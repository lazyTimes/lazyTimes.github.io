<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>爱看书的阿东</title>
  
  <subtitle>赐他一块白色石头，石头上写着新名</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://whitestore.top/"/>
  <updated>2022-06-02T10:17:41.588Z</updated>
  <id>https://whitestore.top/</id>
  
  <author>
    <name>阿东</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《银河铁道之夜》读书笔记-为了谁而活？</title>
    <link href="https://whitestore.top/2022/06/02/bywholive/"/>
    <id>https://whitestore.top/2022/06/02/bywholive/</id>
    <published>2022-06-02T10:16:09.000Z</published>
    <updated>2022-06-02T10:17:41.588Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220601171128.png" alt=""></p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>非常“美丽”的书名，实际上却是一个十分悲伤的故事，大概悲剧更能引起读者的共鸣，本文标题起了一个叫做“为了谁”和这本书的作者身世有关，作者是为妹妹而坚持活着的人，像我这样的绝大多数普通人都难以做到吧。</p><p>这本书总是和《小王子》放到一起比较，因为两者都是源自于一场旅行的成长，我很少去了解作者过去，看书也很少去关注书名，但是因为不是很懂作品说了啥和故事背景，之后开始了解宫泽贤治的身世，不免对他抱持信念以及执着十分钦佩，能为了谁而活的人本身就是伟大的。</p><p>当我看完这本书再看看书中夹着的能通往任何地方的“车票”时候，这场旅行的回忆深深刻在脑海。</p><p><strong>下面的内容涉及剧透，如果对这本书感兴趣建议查看下面的资源了解了解。</strong></p><h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><p>链接：<span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMUVqRHhpMjJvQVpSUkQzX1psZHFkZmc/cHdkPTJramE=" title="https://pan.baidu.com/s/1EjDxi22oAZRRD3_Zldqdfg?pwd=2kja">https://pan.baidu.com/s/1EjDxi22oAZRRD3_Zldqdfg?pwd=2kja<i class="fa fa-external-link"></i></span> 提取码：2kja</p><a id="more"></a><h1 id="书籍简介"><a href="#书籍简介" class="headerlink" title="书籍简介"></a>书籍简介</h1><p>宫泽贤治的代表作《银河铁道之夜》，本作大约写于1927年，1934年被列入<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvdy9pbmRleC5waHA/dGl0bGU9JUU2JTk2JTg3JUU1JTlDJTgzJUU1JUEwJTgyJmFjdGlvbj1lZGl0JnJlZGxpbms9MQ==" title="https://zh.m.wikipedia.org/w/index.php?title=%E6%96%87%E5%9C%83%E5%A0%82&action=edit&redlink=1">文圃堂<i class="fa fa-external-link"></i></span>出版的《宫泽贤治作品集》中第三卷正式发表。其实全书仍在草稿阶段，现存4个版本，以最后一个最为人所熟知，不同版本间差异较大，学者对此众说纷纭。不过作品充满唯美幻想色彩的独特描写，因此仍受到许多人喜爱。</p><p>这本书被定义为儿童作品，却有着很多对成年人有非常多有感触的内容。</p><p>银河列车的轨迹：整个银河列车从北十字到南十字，经过的站点按照顺序排序为：<strong>银河火车站北十字星车站天鹅站普利奥辛海岸阿尔卑列监测站天鹰座停车场高原半人马星村南十字车站煤袋星云</strong>。</p><p>关联作品：</p><ul><li>银河铁道999</li><li>《银河铁道之夜》同名动画电影（B站有）</li><li>《银河铁道之夜》CG动画电影（B站有），虽然2006年但是个人感觉制作的十分精美。</li><li>《永诀の朝》（宫泽贤治所做的诗）</li></ul><p><strong>主角介绍</strong></p><p>一共两位 <strong>乔凡尼</strong> 和 <strong>坎帕内拉</strong>，当然那位落水被救的还会高级黑的小朋友忘记名字了，姑且算上。可以看到主角的人名都比较潮，男主叫乔丹尼，男主最好的朋友以及同学叫做坎培内拉，名字比较拗口但是意外的让人印象深刻。</p><p>这种新潮的起名方式和作者所处的家乡岩手县有关系。作者把岩手县叫 INATOBU，这是自创的词语，个人猜想应该是结合宗教和英语有关，然后我用上神奇的谷歌翻译查了一下，没想到还有意外的惊喜。</p><p><code>岩手 =&gt; no fly</code>，宫泽贤治奇特的想象力确实很有意思。顺带自夸一下我的联想能力。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220601164421.png" alt=""></p><p>书籍年代：太正时代的书籍。也就是从1912年7月30日至1926年12月25日止。</p><blockquote><p><strong>大正</strong>（日语：大正／たいしょう <em>Taishō</em> <span class="exturl" data-url="aHR0cHM6Ly9qYS53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUE0JUE3JUU2JUFEJUEz" title="https://ja.wikipedia.org/wiki/%E5%A4%A7%E6%AD%A3">*<i class="fa fa-external-link"></i></span>/<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS9IZWxwOiVFNiU5NyVBNSVFOCVBQSU5RQ==" title="https://zh.m.wikipedia.org/wiki/Help:%E6%97%A5%E8%AA%9E">?<i class="fa fa-external-link"></i></span>）是<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTYlOTclQTUlRTYlOUMlQUM=" title="https://zh.m.wikipedia.org/wiki/%E6%97%A5%E6%9C%AC">日本<i class="fa fa-external-link"></i></span><span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTUlQTQlQTclRTYlQUQlQTMlRTUlQTQlQTklRTclOUElODc=" title="https://zh.m.wikipedia.org/wiki/%E5%A4%A7%E6%AD%A3%E5%A4%A9%E7%9A%87">大正天皇<i class="fa fa-external-link"></i></span>在位期间使用的<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTYlOTclQTUlRTYlOUMlQUMlRTUlQjklQjQlRTglOTklOUY=" title="https://zh.m.wikipedia.org/wiki/%E6%97%A5%E6%9C%AC%E5%B9%B4%E8%99%9F">年号<i class="fa fa-external-link"></i></span>，使用时间从1912年7月30日至1926年12月25日止。承续年号为<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTYlOTglOEUlRTYlQjIlQkI=" title="https://zh.m.wikipedia.org/wiki/%E6%98%8E%E6%B2%BB">明治<i class="fa fa-external-link"></i></span>，接续年号为<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTYlOTglQUQlRTUlOTIlOEM=" title="https://zh.m.wikipedia.org/wiki/%E6%98%AD%E5%92%8C">昭和<i class="fa fa-external-link"></i></span><span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvemgtaGFucy8lRTUlQTQlQTclRTYlQUQlQTMjY2l0ZV9ub3RlLTowLTE=" title="https://zh.m.wikipedia.org/zh-hans/%E5%A4%A7%E6%AD%A3#cite_note-:0-1">[1]<i class="fa fa-external-link"></i></span>。 大正天皇体弱多病，加上第一次民主化在欧洲的遍地开花，这也促使东亚日本的政治权力从旧的<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTUlQUYlQTElRTUlQTQlQjQ=" title="https://zh.m.wikipedia.org/wiki/%E5%AF%A1%E5%A4%B4">寡头<i class="fa fa-external-link"></i></span>政治集团<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTklOTclQTglRTklOTglODA=" title="https://zh.m.wikipedia.org/wiki/%E9%97%A8%E9%98%80">门阀<i class="fa fa-external-link"></i></span>或<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTUlODYlOUIlRTQlQkElQkE=" title="https://zh.m.wikipedia.org/wiki/%E5%86%9B%E4%BA%BA">军人<i class="fa fa-external-link"></i></span>转移到<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTUlQjglOUQlRTUlOUMlOEIlRTglQUQlQjAlRTYlOUMlODNfKCVFNiU5NyVBNSVFNiU5QyVBQyk=" title="https://zh.m.wikipedia.org/wiki/%E5%B8%9D%E5%9C%8B%E8%AD%B0%E6%9C%83_(%E6%97%A5%E6%9C%AC)">帝国议会<i class="fa fa-external-link"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTYlQjAlOTElRTQlQjglQkIlRTUlODUlOUElRTYlQjQlQkU=" title="https://zh.m.wikipedia.org/wiki/%E6%B0%91%E4%B8%BB%E5%85%9A%E6%B4%BE">民主党派<i class="fa fa-external-link"></i></span>。 因此，这个时代被认为是日本被称为“<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTUlQTQlQTclRTYlQUQlQTMlRTYlQjAlOTElRTQlQjglQkI=" title="https://zh.m.wikipedia.org/wiki/%E5%A4%A7%E6%AD%A3%E6%B0%91%E4%B8%BB">大正民主<i class="fa fa-external-link"></i></span>”的<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTglODclQUElRTclOTQlQjElRTQlQjglQkIlRTQlQjklODk=" title="https://zh.m.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E4%B8%BB%E4%B9%89">自由主义<i class="fa fa-external-link"></i></span>运动的时代，它通常区别于<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTYlOTglOEUlRTYlQjIlQkI=" title="https://zh.m.wikipedia.org/wiki/%E6%98%8E%E6%B2%BB">明治时代<i class="fa fa-external-link"></i></span>的混乱和随后由<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTUlODYlOUIlRTUlOUIlQkQlRTQlQjglQkIlRTQlQjklODk=" title="https://zh.m.wikipedia.org/wiki/%E5%86%9B%E5%9B%BD%E4%B8%BB%E4%B9%89">军国主义<i class="fa fa-external-link"></i></span>驱动的<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTYlOTglQUQlRTUlOTIlOEM=" title="https://zh.m.wikipedia.org/wiki/%E6%98%AD%E5%92%8C">昭和时代<i class="fa fa-external-link"></i></span>初期<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvemgtaGFucy8lRTUlQTQlQTclRTYlQUQlQTMjY2l0ZV9ub3RlLTowLTE=" title="https://zh.m.wikipedia.org/zh-hans/%E5%A4%A7%E6%AD%A3#cite_note-:0-1">[1]<i class="fa fa-external-link"></i></span>。大正纪元与<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTYlQjAlOTElRTUlOUMlOEIlRTclQjQlODAlRTUlODUlODM=" title="https://zh.m.wikipedia.org/wiki/%E6%B0%91%E5%9C%8B%E7%B4%80%E5%85%83">民国纪元<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTQlQjglQkIlRTQlQkQlOTMlRTclQkElQUElRTUlODUlODM=" title="https://zh.m.wikipedia.org/wiki/%E4%B8%BB%E4%BD%93%E7%BA%AA%E5%85%83">主体纪元<i class="fa fa-external-link"></i></span>共享相同的元年。</p></blockquote><p>可能让人看不下去的原因有：</p><ul><li>开头比较黑暗，因为美丽的书名，会让人以为一开始就觉得</li><li>新潮的名字，特别是人名会让人退却。</li></ul><p>这两点可能会觉得莫名其妙，但是换位并且结合日本人排外的思想想象一下相信不是很难理解。</p><p><strong>几点重要的暗示：</strong></p><ol><li>叙事基调：在黑暗之后，是无比美丽和光明的生活。</li><li>无论何时都要对未来抱有期望。</li><li>乔丹尼的母亲叮嘱乔丹可以去看灯会，但是不要到水里去成为贯穿整个故事的伏笔。</li><li>乔丹尼所在的城镇每一年又一次叫做“银河祭”的盛会，成为引出整个故事的基础。</li><li><strong>今晚是银河祭，请大家外出观看银河</strong>，盛大的节日和悲剧形成强烈对比。</li></ol><h1 id="为什么要写这样的故事？"><a href="#为什么要写这样的故事？" class="headerlink" title="为什么要写这样的故事？"></a>为什么要写这样的故事？</h1><p>作者写这本书的目的似乎可以从他过去写的一首诗中可以体现，这首诗叫做永诀の朝。为什么要聊到这首诗呢？因为这和宫泽贤治的妹妹有关系，这是他为了缅怀早早逝去的妹妹写的一首诗。</p><p>下面找来了两个版本的翻译：</p><p>第一个版本</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">就在今天  </span><br><span class="line"></span><br><span class="line">我的妹妹啊要去远方  </span><br><span class="line"></span><br><span class="line">雨雪交加，前门异常明亮  </span><br><span class="line"></span><br><span class="line">　　（请给我些雨雪）  </span><br><span class="line">　　</span><br><span class="line">从暗红的阴惨的云中  </span><br><span class="line"></span><br><span class="line">雨雪凄凄地落下来  </span><br><span class="line"></span><br><span class="line">　　（请给我些雨雪）  </span><br><span class="line">　　</span><br><span class="line">拿着有两棵蓝色菜图案的陶碗 </span><br><span class="line"></span><br><span class="line">给你去盛雨雪  </span><br><span class="line"></span><br><span class="line">我像出了膛的子弹  </span><br><span class="line"></span><br><span class="line">冲向那暗淡的雨雪之中  </span><br><span class="line"></span><br><span class="line">　　（请给我些雨雪）  </span><br><span class="line">　　</span><br><span class="line">从铅灰色的暗淡云中  </span><br><span class="line"></span><br><span class="line">雨雪凄凄地沉落下来  </span><br><span class="line"></span><br><span class="line">啊，敏子  </span><br><span class="line"></span><br><span class="line">在这死亡的时刻  </span><br><span class="line"></span><br><span class="line">为了使我一生光明  </span><br><span class="line"></span><br><span class="line">你让我拿给你  </span><br><span class="line"></span><br><span class="line">一碗清凉的雪  </span><br><span class="line"></span><br><span class="line">谢谢你，我的勇敢的妹妹  </span><br><span class="line"></span><br><span class="line">我一定勇往直前  </span><br><span class="line"></span><br><span class="line">　　（请给我些雨雪） </span><br><span class="line">　　 </span><br><span class="line">你是在高烧和喘息之中  </span><br><span class="line"></span><br><span class="line">让我</span><br><span class="line"></span><br><span class="line">从那称为银河，太阳，大气层的  </span><br><span class="line"></span><br><span class="line">大宇宙落下来的雪中取来最后一碗  </span><br><span class="line"></span><br><span class="line">在两块花岗岩石上  </span><br><span class="line"></span><br><span class="line">雨雪寂寞地存留着  </span><br><span class="line"></span><br><span class="line">我小心地站在上面  </span><br><span class="line"></span><br><span class="line">雪和水，纯白的雪和水  </span><br><span class="line"></span><br><span class="line">从挂满透明冰冷水珠的  </span><br><span class="line"></span><br><span class="line">光润美丽的松树枝上  </span><br><span class="line"></span><br><span class="line">给心爱的妹妹取来最后的一餐  </span><br><span class="line"></span><br><span class="line">在我们一块长大的日子里  </span><br><span class="line"></span><br><span class="line">看惯了的茶碗的蓝色图案  </span><br><span class="line"></span><br><span class="line">今天你也要与它告别  </span><br><span class="line"></span><br><span class="line">　　（我一个人死去）  </span><br><span class="line">　　</span><br><span class="line">你今天真的要告别  </span><br><span class="line"></span><br><span class="line">啊，那封锁了的病室里  </span><br><span class="line"></span><br><span class="line">在那黑暗的屏风和帐子里  </span><br><span class="line"></span><br><span class="line">我的勇敢的妹妹啊  </span><br><span class="line"></span><br><span class="line">优美地苍白地燃尽她最后的生命  </span><br><span class="line"></span><br><span class="line">不管从哪里挑选这雪  </span><br><span class="line"></span><br><span class="line">都是那么洁白  </span><br><span class="line"></span><br><span class="line">从那可怕的混乱的天空  </span><br><span class="line"></span><br><span class="line">落下这美丽的雪  </span><br><span class="line"></span><br><span class="line">　　（假如再次托生  </span><br><span class="line">　　</span><br><span class="line">　　不单为自己  </span><br><span class="line">　　</span><br><span class="line">　　也要为别人把苦来尝）</span><br><span class="line">　　  </span><br><span class="line">我对着你吃的两碗雪  </span><br><span class="line"></span><br><span class="line">内心祈祷  </span><br><span class="line"></span><br><span class="line">愿它变为上天的赐予  </span><br><span class="line"></span><br><span class="line">为你和大家  </span><br><span class="line"></span><br><span class="line">得到圣粮  </span><br><span class="line"></span><br><span class="line">我宁愿舍弃一切的幸福</span><br></pre></td></tr></table></figure><p>第二个版本（个人认为第二版翻译略好一些，更有诗词的律动感）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">《永诀之朝》</span><br><span class="line"></span><br><span class="line">今昔你就要远去了，</span><br><span class="line"></span><br><span class="line">我的妹妹。</span><br><span class="line"></span><br><span class="line">门外的世界风雨交叠，</span><br><span class="line"></span><br><span class="line">却异常的明媚。</span><br><span class="line"></span><br><span class="line">从隐隐泛红却又愈发阴沉的天空，</span><br><span class="line"></span><br><span class="line">迅疾地飘飞着雨雪。</span><br><span class="line"></span><br><span class="line">那两个缺口的陶瓷碗。</span><br><span class="line"></span><br><span class="line">绘着那熟悉的蓝色莼菜花纹。</span><br><span class="line"></span><br><span class="line">为了让碗里盛满你所渴求着的雪，</span><br><span class="line"></span><br><span class="line">我像破了膛的弧线的子弹一般，</span><br><span class="line"></span><br><span class="line">冲向外面黯淡交加的雨雪。</span><br><span class="line"></span><br><span class="line">那铅灰色沉寂的天空中，</span><br><span class="line"></span><br><span class="line">雨雪一阵又一阵的紧紧催促着。</span><br><span class="line"></span><br><span class="line">啊，妹妹。</span><br><span class="line"></span><br><span class="line">你为了让我释怀乐观起来，</span><br><span class="line"></span><br><span class="line">求我接一碗那圣洁冰凉的雪。</span><br><span class="line"></span><br><span class="line">尽管你已生命垂危。</span><br><span class="line"></span><br><span class="line">谢谢你啊，</span><br><span class="line"></span><br><span class="line">我勇敢可敬的妹妹。</span><br><span class="line"></span><br><span class="line">我也一定会勇敢向前，无畏风雪。</span><br><span class="line"></span><br><span class="line">随着激烈又炽热的喘息，</span><br><span class="line"></span><br><span class="line">你拜托我。</span><br><span class="line"></span><br><span class="line">为你捧来从被称为银河、太阳、大气层的世界的天空中，</span><br><span class="line"></span><br><span class="line">飘落下的最后一轮雪。</span><br><span class="line"></span><br><span class="line">在两块光滑的花岗岩上，</span><br><span class="line"></span><br><span class="line">雨雪静静地沉寂着。</span><br><span class="line"></span><br><span class="line">我小心翼翼地站在那上面，</span><br><span class="line"></span><br><span class="line">保持着雪与水那纯洁的联系，</span><br><span class="line"></span><br><span class="line">满载着透明的冰冷安静的雪水，</span><br><span class="line"></span><br><span class="line">从这闪烁着残微光亮的脆嫩松枝上，</span><br><span class="line"></span><br><span class="line">为我那心爱的善良美好的妹妹取下那最后的渴求。</span><br><span class="line"></span><br><span class="line">在伴随着我们一起长大的岁月里，</span><br><span class="line"></span><br><span class="line">早已熟悉了这陶瓷碗上的蓝色花纹。</span><br><span class="line"></span><br><span class="line">如是今朝却也要与你永诀，</span><br><span class="line"></span><br><span class="line">（我将独自前行）</span><br><span class="line"></span><br><span class="line">在那封闭了的病房里，</span><br><span class="line"></span><br><span class="line">在那昏暗的屏风和帐子里，</span><br><span class="line"></span><br><span class="line">你正面色苍白温情脉脉地燃尽着生命啊</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">我亲爱的妹妹，</span><br><span class="line"></span><br><span class="line">无论是抉择着哪里的雪，</span><br><span class="line"></span><br><span class="line">它都是那么的洁白。</span><br><span class="line"></span><br><span class="line">从那昏暗的雨雪交加的可怕天空中，</span><br><span class="line"></span><br><span class="line">竟落下如此美丽动人的雪。</span><br><span class="line"></span><br><span class="line">（假如获得重生，这次要活的轻松，不再遭受苦难）</span><br><span class="line"></span><br><span class="line">面对你所渴求的那两碗雪，</span><br><span class="line"></span><br><span class="line">我衷心的祈祷着。</span><br><span class="line"></span><br><span class="line">愿它变成上天的赐予，</span><br><span class="line"></span><br><span class="line">为你和大家，</span><br><span class="line"></span><br><span class="line">得到神圣的粮食</span><br><span class="line"></span><br><span class="line">我宁愿舍弃这一切的幸福</span><br><span class="line"></span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>十分优美并且让人看完有种想哭的冲动的诗，因为包含了作者真挚的情感。</p><p>上面的故事是宫泽贤治和他妹妹的真实的故事，宫泽贤治的妹妹在生命的最后一刻让哥哥给他带点雪尝尝，宫泽贤治焦急的跑到屋外找雪的身影，最后却回家却发现妹妹已经永远闭上双眼。</p><p>令我最感动的是”你拜托我。为你捧来从被称为银河、太阳、大气层的世界的天空中，飘落下的最后一轮雪。”这句话。</p><p>妹妹的死直接影响了宫泽贤治对人生和世界的看法，也让他写出印象深刻的作品。也引导出《银河铁道之夜》中十分启发人的一句话：</p><p><strong>如果能为了某人而活着，我想大概是一件幸福的事情吧。</strong></p><p>宫泽贤治确实是十分温柔并且也确实是诚恳真实的人，最好的体现是他在生前所有畅销世界的巨作其实都是<strong>写给自己</strong>的，很多十分优秀的作品并没有发表（包括这本影响力最大的书），所以从这一些细节可以看到宫泽贤治确实一直贯彻自己的理念，为自己的妹妹而活并且很少考虑自己，是十分值得欣赏的人。</p><p>那么为什么要写出《银河铁道之夜》呢？这里就必须要探究作者妹妹死后的故事，当然个人也是从日本人的书评讲解里面才明白的。在宫泽贤治的妹妹死后宫泽贤治和家人闹掰了，因为家人要用传统的方式让妹妹下葬，而宫泽贤治则更希望用自己的方式向妹妹告别，最终结果就是导致妹妹一直无法安然入土魂归天灵。</p><p>经过很长时间的争吵，宫泽贤治最终选择离开家庭独自营生，这也导致宫泽贤治没有和自己的妹妹好好告别，所以<strong>《银河铁道之夜》实际上是宫泽贤治为了给自己妹妹告别所写的一本书</strong>，正如书中的角色一般，他用银河列车和绝美的风景送走了妹妹化身的坎培内拉，最后再将一切回忆随着牛奶瓶一般带在他的身上。</p><h1 id="个人评价"><a href="#个人评价" class="headerlink" title="个人评价"></a>个人评价</h1><p>蕴含了宗教，科学，信仰，以及自己的真挚祝愿，融合在一个小孩子也看得懂的书中，宫泽贤治确实是一个厉害的人，看这本书甚至让我有些理解宗教的魅力是什么，而信仰究竟有什么样的力量。</p><p>实际上个人在读完第一遍之后其实并不是很了解上面这些内容的，故事很吸引人但是很多地方十分奇怪作者为什么要写这样的故事，虽然故事看到一半在各种暗示中透露了各种信息可以明显看出是一个悲伤的故事，但是依然摸不着头脑写本书的用意是什么，所以我果断找了个日本的书评靠着字幕翻译大概看懂了这本书讲了什么，另外看了下油管500多万粉丝，确实是一个大佬。</p><p>整本书开头两章从主角乔丹尼悲惨的命运，到视角一转却有些莫名其妙的坐上了开往银河的列车，当下的痛苦与黑暗和壮阔的银河列车鲜明对比，乔丹尼是作者的化身，在艰苦过后是幸福的邂逅，先抑后扬也让后面列车上的故事回忆更为深刻。</p><p>然而这一段奇幻的旅行却终究是悲伤的故事，故事最后突然急转直下，这是作者对于现实和理想的刻意安排，个人认为这也是暗指得与失的哲学。</p><p>其中让我印象最为深刻的是关于蝎子的故事，蝎子本身是有毒的，它一辈子都在伤害别人，但是到了死前的那一刻却决定要献出自己的生命，“反正我都要死了，不如就为你而死吧”，所以蝎子的本性似乎并不坏？我们是否愿意为了谁做出牺牲？</p><p>大概伟大的作家都会伴随着悲惨的命运，有时候只能感叹上天的不公，宫泽贤治只活了37年也因病匆匆离开了人世。</p><h1 id="佳句摘录"><a href="#佳句摘录" class="headerlink" title="佳句摘录"></a>佳句摘录</h1><ul><li>我不知道什么是真正的幸福，但我知道即使遭遇再大的痛苦，只要我们走在正确的道路上，那么无论顺境或逆境，都会距离真正的幸福越来越近。</li><li>如果能为了某人而活着，我想大概是一件幸福的事情吧。</li><li>人生的幸福在于每一个小小瞬间。</li></ul><h1 id="内容分析"><a href="#内容分析" class="headerlink" title="内容分析"></a>内容分析</h1><p>下面是个人看书过程中的一些疑问和看法，有些内容是个人看完之后查资料明白是什么意思的，属于意外之喜，顺便涨了一些知识。</p><h2 id="捡铅字"><a href="#捡铅字" class="headerlink" title="捡铅字"></a>捡铅字</h2><p>捡铅字是第二章乔丹尼给印刷厂打工的工作内容，这一段个人第一次看的时候完全不知道主角在干什么，所以这里有必要补充解释一下，在作者的那个年代，印刷是需要在铅块和板上面放上假名和汉字的，使用的是活版印刷术，印刷一本书需要把“字”捡到一个个的板上面才能印刷，然后下一页再用同样的方式捡到一起印刷下一章，是非常辛苦单调但是需要很强注意力的工作。所以不难理解为什么拿到报酬的乔丹尼会如此开心了。</p><p>另外这里再次回忆这一章的内容，又要被人嘲笑“小放大镜”，又要急急忙忙的捡铅字，实在是有够憋屈，难怪前面两章比较劝退人。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220601153653.png" alt=""></p><h2 id="海獭皮"><a href="#海獭皮" class="headerlink" title="海獭皮"></a>海獭皮</h2><p>乔丹尼的父亲是渔民，需要外出捕鱼，在出海之前答应给乔丹尼一件海獭皮的衣服，然而迟迟未归的父亲却也这件事成为了同学嘲笑乔丹尼的笑点。</p><p>拿不到海獭皮的外套而被同学嘲笑是为什么呢？其实是由于当时海獭都是当地人偷猎，后面因为大肆杀害野生动物而被政府禁止，嘲笑乔丹尼拿不到海獭皮是暗指的他爸被抓去坐牢了，属于不骂人的“高级黑”，看书过程不免想要吐槽小学生都已经这么强了么。</p><p>当然只有坎佩内拉不会嘲笑他，并且主角的父亲和坎佩内拉的父亲在读书的时候是朋友，所以他们之间也是能互相理解的朋友。</p><h2 id="四维空间"><a href="#四维空间" class="headerlink" title="四维空间"></a>四维空间</h2><p>在天鹅站，主人公一行人遇到了考古的学者，随后的火车行驶过程中遇到了红胡子老头，红胡子老头是一个捕鸟人，之后是乔丹尼和坎佩内拉与捕鸟人的一些互动。</p><p>捕鸟人的剧情不长，但是看到捕鸟人能闪现到白鹭的旁边，并且在主角询问之后回答这是轻而易举的事情，不知道为什么让我想起来《三体》中那个“徒手”摘心脏的故事，很明显作者在这里提出了自己对于四维空间的一种遐想，实在是难以想象100年前就有这生动的想象力，并且在书中用简单明了的方式体现，虽然没有过多深入但是可以看出作者的知识渊博。</p><h2 id="得与失"><a href="#得与失" class="headerlink" title="得与失"></a>得与失</h2><p>在故事的最后是乔丹尼在现实世界得知了坎佩内拉为了救同学自己淹死的消息，乔丹尼带着装满了回忆的牛奶瓶赶回家中却意外得知父亲归来的消息，大概作者在暗示<strong>当你失去某样东西的时候，有新的事物在向你走来</strong>，所以作者的温柔总是藏在这种看不见的地方。</p><p>转念一想，牛奶瓶和雪一样都是白色的，为了让母亲喝上牛奶而捧着牛奶瓶的乔丹尼映射了为了妹妹捧着雪的宫泽贤治，这大概也是宫泽贤治激励自己哪怕过去无法挽回，却依然可以为了某种事物而活的心态吧。</p><p>这大概也是作者自己不愿意把《银河铁道之夜》公开于世，只愿让他督促和勉励自己的一份记录。</p><h1 id="写到最后"><a href="#写到最后" class="headerlink" title="写到最后"></a>写到最后</h1><p>书里书外都有着看似悲伤的故事，作者是为了为了妹妹坚持活下去，我们又是为了谁而活呢？</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      非常“美丽”的书名，实际上却是一个十分悲伤的故事
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://whitestore.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="书籍" scheme="https://whitestore.top/tags/%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>谷歌三件套 - Bigtable</title>
    <link href="https://whitestore.top/2022/05/21/google-bigtable/"/>
    <id>https://whitestore.top/2022/05/21/google-bigtable/</id>
    <published>2022-05-21T11:16:54.000Z</published>
    <updated>2022-06-02T10:09:44.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="谷歌三件套-Bigtable"><a href="#谷歌三件套-Bigtable" class="headerlink" title="谷歌三件套 - Bigtable"></a>谷歌三件套 - Bigtable</h1><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>如标题所言，这一篇文章简单介绍BigTable，其实个人更建议看LevelDB这款开源数据库，因为这数据库也是Bigtable的作者 <strong>JeffreyDean</strong> 设计的，很多内容不能说像简直就是一模一样。</p><p>值得注意的是，看Bigtable的内容<strong>千万不要带着关系型数据库的思维</strong>，建议看之前看看《数据密集型应用系统设计》的第三章，里面提到了LSM-Tree以及大数据系统设计思想，或者看看个人之前写的文章 [[《数据密集型型系统设计》LSM-Tree VS BTree]]</p><h1 id="三件套论文资料"><a href="#三件套论文资料" class="headerlink" title="三件套论文资料"></a>三件套论文资料</h1><p>Bigtable 原始在线论文： <strong><span class="exturl" data-url="aHR0cHM6Ly9zdGF0aWMuZ29vZ2xldXNlcmNvbnRlbnQuY29tL21lZGlhL3Jlc2VhcmNoLmdvb2dsZS5jb20vemgtQ04vL2FyY2hpdmUvYmlndGFibGUtb3NkaTA2LnBkZg==" title="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/bigtable-osdi06.pdf">Bigtable: A Distributed Storage System for Structured Data<i class="fa fa-external-link"></i></span></strong></p><p>MapReduct 原始在线论文：<span class="exturl" data-url="aHR0cHM6Ly9zdGF0aWMuZ29vZ2xldXNlcmNvbnRlbnQuY29tL21lZGlhL3Jlc2VhcmNoLmdvb2dsZS5jb20vemgtQ04vL2FyY2hpdmUvbWFwcmVkdWNlLW9zZGkwNC5wZGY=" title="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf">MapReduce: Simplified Data Processing on Large Clusters<i class="fa fa-external-link"></i></span></p><p>GFS 原始在线论文：<span class="exturl" data-url="aHR0cHM6Ly9zdGF0aWMuZ29vZ2xldXNlcmNvbnRlbnQuY29tL21lZGlhL3Jlc2VhcmNoLmdvb2dsZS5jb20vemgtQ04vL2FyY2hpdmUvZ2ZzLXNvc3AyMDAzLnBkZg==" title="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/gfs-sosp2003.pdf">The Google File System<i class="fa fa-external-link"></i></span></p><p>如果看不懂英文或者想要线下阅读，个人从某全是广告的技术网站买了一份中文翻译以及原始英文论文PDF，合并到一起免费分享给大家（虽然掏钱买也没几个钱）：</p><p>链接: <span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMTVaMjRhcTYydTI1WV9MckhTYU5DQ3c=" title="https://pan.baidu.com/s/15Z24aq62u25Y_LrHSaNCCw">Google-GFS,Bigtable,Mapreduce三大论文英文原版+中文翻译<i class="fa fa-external-link"></i></span> 提取码: 82ok </p><blockquote><p>（如果链接失效可以关注公众号“懒时小窝” 回复“谷歌三件套”或者“谷歌”获取这些内容）</p></blockquote><a id="more"></a><h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>下面Bigtable介绍内容可以跳过，论文巴拉巴拉吹了一大堆，其实关键也就是关注这几个点：</p><ul><li>大数据、分布式存储、异地多活容灾（侧面反应）。</li><li>GFS和BigTable的关系。</li><li>Chubby。</li><li>LSM-Tree 数据结构。</li><li>SSTable（LSM-Tree）。</li></ul><p>Bigtable 是一个<strong>分布式存储系统</strong>，用于管理旨在扩展到非常大的结构化数据<br>大小：数千种商品的 PB 级数据服务器。 Google 的许多项目都将数据存储在 Bigtable 中，包括网络索引、谷歌地球和谷歌财经。 这些应用提出了非常不同的要求</p><p>在 Bigtable 上，无论是在数据大小方面（从 URL 到网页到卫星图像）和延迟要求<br>（从后端批量处理到实时数据服务）。尽管有这些不同的需求，Bigtable 还是成功地为所有用户提供了灵活、高性能的解决方案这些 Google 产品。 在本文中，我们描述了 Bigtable 提供的简单数据模型，它为客户提供对数据布局和格式的动态控制，我们描述了 Bigtable 的设计和实现。</p><p>Bigtable看起来像一个数据库，采用了很多数据库的实现策略。但是Bigtable并不支持完整的关系型数据模型；而是为客户端提供了一种简单的数据模型，客户端可以动态地控制数据的布局和格式，并且利用底层数据存储的局部性特征。Bigtable将数据统统看成无意义的字节串，客户端需要将结构化和非结构化数据串行化再存入Bigtable。</p><p>前面提到相当多的google应用使用了BigTable，比如Google Earth和Google Analytics，这里建议有条件高级上网的同学推荐看一下<strong>Google Earth</strong> 找找你家位置，你会发现在这个世界上你没有啥秘密可言（地理位置上），也能最直观的明白现代导弹为什么可以精准无误的打击，挺恐怖的事情。</p><p>题外话就扯到这，由于网上有很多介绍的文章，这里也同样结合原始论文和理解摘录自己感兴趣的部分，因为个人是看完一整个LevelDB的源代码之后再回来看的，很多东西都省略了，没看过的更多内容可以参考下面这篇文章：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L09wZW5OYWl2ZS9hcnRpY2xlL2RldGFpbHMvNzUzMjU4OQ==" title="https://blog.csdn.net/OpenNaive/article/details/7532589">BigTable解读<i class="fa fa-external-link"></i></span></p><p>我们不需要关注谷歌吹逼自己的高性能，高负载介绍，毕竟都会这么对外宣传，我们只要了解Bigtable干了啥和怎么实现即可。</p><h1 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h1><p>首先介绍最为重要的数据组织结构也就是数据模型，论文第二节开头对于SSTable做了定义：</p><p> A Bigtable is a sparse（稀疏）, distributed（分布式）, persistent（持久化） multidimensional（多维度） sorted map（排序哈希表）。</p><p>简单的数据模型意味着灵活和很强的扩展性，SSTable 使用 <code>row</code>、<code>column</code> 和 <code>timestamp</code> 三个字段作为这个哈希的键，值是字节数组，其实也就是字符串。</p><p>一条数据最小单位可以抽象理解为这样的存储形式：</p><p><code>(row:string, column:string, time:int64) → string</code></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205201448701.png" alt=""></p><p>再次强调这里的数据格式<strong>不能按照关系型数据库理解</strong>，原因是他本质上是<strong>Key/Value</strong>的存储格式，这三个值不能按照单纯行或者列存储格式理解，而是使用<strong>混合存储</strong>+多维数据的存储方式，所以这三个值抽象理解为<strong>行键（row）、列键（column）、时间戳（timestamp）</strong>，最终由这三个参数构成三维参数。</p><p><strong>行键（row）</strong></p><p>行键是原子操作，行数据可以是任意的字符串，最大可以扩展到64个KB，当然多数情况为10 - 100个字节，每一个读和写操作都是一个独立原子性的。</p><p>行的范围是可以动态划分的，行的数据切分称为切片，通过切片用户只需要和更加少量的数据通信，通过分片也可以更好的获取更加准确和可控的数据范围。</p><p>切片在行键中被称为 tablet，切片支持负载均衡，随着表的扩展片也会自动进行分裂，最终一个分片控制在100 MB - 200MB 当中。</p><p><strong>列键（column）</strong></p><p>列的存储格式涉及到一个被称之为 <strong>列族</strong> 的概念，通过列族的方式把相似的值组合到一起，一个列族里的列一般存储相同类型的数据，所以通常情况下列族的数据变动比较小，但是列族是可以随意添加和删除的，并且通过谷歌特定的格式进行命名，列族</p><p>这里补充列族的概念，指的是<strong>把一行中的所有列和行主键保存到一起</strong>，并且不使用列压缩的形式存储。其实这种用行转列基本就可以实现，所以列族严格意义上依然是行存储的变体，和真正的列存储还是存在差异的。</p><p>由于列族的存在，使得SSTable实现一个key的多维度映射，所以多维的概念就是在列族上出现的，同时可以把列族看做是二级索引。</p><p><strong>时间戳</strong></p><p>时间戳负责标记每一个行列索引的版本号，每个单元格可以包含多个版本，版本通过时间戳管理，BigTable的时间戳是64位整数，通常情况为微秒级别的单位，可以使用客户端进行指定单位。</p><p>时间戳显然就是三级别索引了，读取的时候通过最新的时间戳可以认为是数据的最新版本。另外在查询时如果 只给出行列，那么返回的是<strong>最新版本的数据</strong>；如果给出了行列时间戳，那么返回的是时间<strong>小于或等于时间戳的数据</strong>。</p><blockquote><p>这也是现在大数据框架的存储格式特点，比如目前前景不错的<strong>Tidb</strong>，支持OLTP也支持OLAP。</p></blockquote><h1 id="支撑组件"><a href="#支撑组件" class="headerlink" title="支撑组件"></a>支撑组件</h1><p>BigTable除开SSTable之外，还存在其他的支持组件：</p><ul><li>用GFS来存储日志和数据文件.</li><li>按SSTable文件格式存储数据.</li><li>用Chubby管理元数据.</li></ul><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205201416964.png" alt=""></p><p><strong>GFS（Google File System）</strong></p><p>从上面的内容可以看到，GFS先于memtable操作，显然充当了整个系统的日志部分，这一部分牵扯到谷歌三件套的另一个系统设计GFS，不是本文讨论的重点，这里只需要知道它干了所有和Log和数据存储位置有关的事情即可。</p><p>既然是日志和数据的存储，那么GFS自然也知道数据的具体位置，因为属于SSTable的前置组件，所以 SSTable 的具体位置需要GFS提前记录。</p><p>另外memtable相当于SSTable的缓存，当memtable成长到一定规模会被冻结，Bigtable随之创建一个新的memtable，并且将冻结的memtable转换为SSTable格式写入GFS，这个操作称为<code>minor compaction</code>。</p><blockquote><p>在 LevelDB中体现的是Level0的SSTable 压缩合并。</p></blockquote><p><strong>Chubby</strong></p><p>Bigtable 依赖于一个高可用和持久的分布式锁服务称为 <strong>Chubby</strong>，它由五个活动副本组成，其中一个是选举为主节点的Master，节点正常的时候可以进行互相通信，Chubby 使用Paxos算法保持一致。</p><p>Chubby提供了命名空间，内部通过小文件和目录组成，目录或者文件可以配置单独的锁，使得读和写操作都是原子性的，Chubby 客户端提供一致性的文件缓存，每一个Chubby 都必须和另一个 Chubby 保持会话，如果客户端会话过期会丢失全部的锁。</p><p><strong>SSTable</strong></p><p>终于要进入重点部分了，可惜的是原始论文并没有详细的介绍SSTable的内部数据结构，仅仅在论文第六个小节中介绍了SSTable的作用。</p><p>首先看看BigTable和GFS 是什么关系呢？在论文中我们可以看到一个类似树的结构，其中根节点为主服务器，主服务器负责接受请求，通过管理分片服务器将请求分片到不同的片服务器中，所以从外层看最终干活的是<strong>片服务器</strong>。</p><p>然而片服务器实际上本身也只是负责管理自己分片的SSTable，它也通过特殊索引知道数据在那个SSTable分片中，然后从GFS中读取SSTable文件的数据，而GFS则可能要从多个Chuncker server里面搜索数据。</p><p>而图中的metatable原数据表可以看作是和SSTable绑定的类似<strong>索引</strong>的关系，元数据表的数据是<strong>不能被外界访问</strong>的，外界访问的是元数据对应的SSTable分片。</p><h1 id="Bigtable集群"><a href="#Bigtable集群" class="headerlink" title="Bigtable集群"></a>Bigtable集群</h1><p>BigTable集群通过三个层级配套组件完成工作。</p><p>第一层是<strong>主服务器（master server</strong>）也就是我们上面提到的Chubby，本身也通过集群的方式保证root tablet正常访问，也可以直接看作我们广为使用的中间件节点集群。</p><p>第二层是<strong>分片服务器</strong>，也称 tablet，其中root tablet是元数据表（METADATA table）的第一个分片，</p><p>第三层是<strong>元数据</strong>的部分，和 root tablet 组成元数据映射表，元数据包含很多的用户数据分片。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205211600915.png" alt=""></p><p>关于三个层级内部的组成这里不用过多猜测到底长啥样，还是那句话去看LevelDB吧。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章简单介绍了一下BigTable 中一些核心部分，有很大部分内容都被忽略了，对于大数据方向的同学来说这三篇论文基本是必看的资料，因为说白了这三驾马车放到现在基本也可以通用，提到的很多理念对现在的中间件有很深的影响。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>关于<strong>Bigtable</strong>部分就介绍到这里了，虽然论文还要很多理论的部分，但是个人看下来之后基本在LevelDB都有体现，所以想要了解使用的直接看LevelDB源代码理解起来更快。</p><h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDA0MTY1MjAwMw==" title="https://segmentfault.com/a/1190000041652003">[《数据密集型型系统设计》LSM-Tree VS BTree]<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDA0MTcyMDIwNQ==" title="https://segmentfault.com/a/1190000041720205">[LSM-Tree - LevelDb了解和实现]<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDA0MTg2NDU3OQ==" title="https://segmentfault.com/a/1190000041864579">[LSM-Tree - LevelDb 源码解析]<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDA0MTg2OTU4Ng==" title="https://segmentfault.com/a/1190000041869586">[LSM-Tree - LevelDb Skiplist跳表]<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDA0MTg3MzQwMA==" title="https://segmentfault.com/a/1190000041873400">[LSM-Tree - LevelDb 布隆过滤器]<i class="fa fa-external-link"></i></span></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      bigtable数据结构解析
    
    </summary>
    
    
      <category term="谷歌三件套" scheme="https://whitestore.top/categories/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97/"/>
    
    
      <category term="LevelDB" scheme="https://whitestore.top/tags/LevelDB/"/>
    
      <category term="谷歌" scheme="https://whitestore.top/tags/%E8%B0%B7%E6%AD%8C/"/>
    
  </entry>
  
  <entry>
    <title>《生之欲》观影感悟</title>
    <link href="https://whitestore.top/2022/05/21/szygw/"/>
    <id>https://whitestore.top/2022/05/21/szygw/</id>
    <published>2022-05-21T11:15:11.000Z</published>
    <updated>2022-06-02T10:09:44.787Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>乘着假期的尾巴看了这一部电影，不得不说虽然豆瓣的高分不一定是好电影，但是这一部上世纪五十年代的电影还是值得观看。</p><p>本文内容<strong>包含剧透</strong>。</p><blockquote><p>兑现前两天立得看电影的Flag，个人认为不管是好的电影还是书籍都是值得记录和回忆的， 为了让自己不忘记电影留下点东西也为不白白浪费两个小时的 宝贵人生。</p></blockquote><h1 id="故事内容"><a href="#故事内容" class="headerlink" title="故事内容"></a><strong>故事内容</strong></h1><p>一句话概括：《生之欲》讲述了一位官僚在发现自己患了晚期癌症后，试图在他的生活中找到意义。</p><blockquote><p>A bureaucrat tries to find a meaning in his life after he discovers he has terminal cancer.</p></blockquote><p>《<strong>生之欲</strong>》（日语：生きる）在<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JUE2JTk5JUU2JUI4JUFG" title="https://zh.wikipedia.org/wiki/%E9%A6%99%E6%B8%AF">香港<i class="fa fa-external-link"></i></span>译作《<strong>流芳颂</strong>》，乃是1952年由<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTk3JUE1JUU2JTlDJUFD" title="https://zh.wikipedia.org/wiki/%E6%97%A5%E6%9C%AC">日本<i class="fa fa-external-link"></i></span>知名<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUIwJThFJUU2JUJDJTk0" title="https://zh.wikipedia.org/wiki/%E5%B0%8E%E6%BC%94">导演<i class="fa fa-external-link"></i></span><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JUJCJTkxJUU2JUJFJUE0JUU2JTk4JThF" title="https://zh.wikipedia.org/wiki/%E9%BB%91%E6%BE%A4%E6%98%8E">黑泽明<i class="fa fa-external-link"></i></span>执导的<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTlCJUJCJUU1JUJEJUIx" title="https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%BD%B1">电影<i class="fa fa-external-link"></i></span>，曾获得日本<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JUFGJThGJUU2JTk3JUE1JUU5JTlCJUJCJUU1JUJEJUIxJUU3JThEJThF" title="https://zh.wikipedia.org/wiki/%E6%AF%8F%E6%97%A5%E9%9B%BB%E5%BD%B1%E7%8D%8E">每日电影最佳影片奖<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTlCJUJCJUU1JUJEJUIxJUU2JTk3JUFDJUU1JUEwJUIx" title="https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%BD%B1%E6%97%AC%E5%A0%B1">电影旬报<i class="fa fa-external-link"></i></span>年度最佳影片奖、<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTlGJThGJUU2JTlFJTk3JUU1JUJEJUIxJUU1JUIxJTk1" title="https://zh.wikipedia.org/wiki/%E6%9F%8F%E6%9E%97%E5%BD%B1%E5%B1%95">柏林影展<i class="fa fa-external-link"></i></span>特别奖等奖项。</p><p>在市公所工作30年的市民课课长渡边勘治每天过着盖章、签公文的乏味生活，某日因身体不适前往<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTg2JUFCJUU5JTk5JUEy" title="https://zh.wikipedia.org/wiki/%E9%86%AB%E9%99%A2">医院<i class="fa fa-external-link"></i></span>检查，结果竟被告知罹患<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JTgzJTgzJUU3JTk5JThD" title="https://zh.wikipedia.org/wiki/%E8%83%83%E7%99%8C">胃癌<i class="fa fa-external-link"></i></span>末期，只剩下约半年的生命。回到家中，<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTg1JTkyJUU1JUFEJTkw" title="https://zh.wikipedia.org/wiki/%E5%85%92%E5%AD%90">儿子<i class="fa fa-external-link"></i></span>与<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUFBJUIzJUU1JUE5JUE2" title="https://zh.wikipedia.org/wiki/%E5%AA%B3%E5%A9%A6">媳妇<i class="fa fa-external-link"></i></span>对他并不友善，甚至可谓不孝。感到悲伤的渡边，带了毕生积蓄离家出走，也不去上班了。他在外头遇见一位<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUIwJThGJUU4JUFBJUFB" title="https://zh.wikipedia.org/wiki/%E5%B0%8F%E8%AA%AA">小说<i class="fa fa-external-link"></i></span><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU0JUJEJTlDJUU1JUFFJUI2" title="https://zh.wikipedia.org/wiki/%E4%BD%9C%E5%AE%B6">作家<i class="fa fa-external-link"></i></span>，告之自己将不久于人世，他认为从未替自己好好活过。小说家同情其遭遇，带他去打<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUJEJTg4JUU3JThGJUEwJUU2JUE5JTlG" title="https://zh.wikipedia.org/wiki/%E5%BD%88%E7%8F%A0%E6%A9%9F">小钢珠<i class="fa fa-external-link"></i></span>，甚至去<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUE2JTkzJUU5JTk5JUEy" title="https://zh.wikipedia.org/wiki/%E5%A6%93%E9%99%A2">声色场所<i class="fa fa-external-link"></i></span>。对渡边来说，虽然这些事很新鲜，但到头来却觉得空虚落寞。第二天他就告别了小说家，一个人孤独的走在街上。</p><p>他遇见了市公所的一位年轻女职员小田切丰，后者表示她厌倦公务员无聊的工作，已觅得新职，却因课长没来上班，没人批准<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUJFJUFEJUU4JTgxJUI3" title="https://zh.wikipedia.org/wiki/%E8%BE%AD%E8%81%B7">辞呈<i class="fa fa-external-link"></i></span>。渡边便将小田切带回家中，为她盖离职同意书；见她丝袜破掉，想为她买双新的。这天他要求小田切带他去玩，两人也度过快乐的一天。但回家后却遭到儿子辱骂，认为他之前带走的存款算是家用的一部分；儿子同时误会小田切是他的年轻<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTg0JTlCJUU0JUJBJUJB" title="https://zh.wikipedia.org/wiki/%E6%84%9B%E4%BA%BA">情人<i class="fa fa-external-link"></i></span>，要求父亲自重。</p><p>过了几天后，渡边前往小田切新任职的<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JThFJUE5JUU1JTg1JUI3" title="https://zh.wikipedia.org/wiki/%E7%8E%A9%E5%85%B7">玩具<i class="fa fa-external-link"></i></span>工厂，希望她再陪着出去玩。小田切原本不想答应，但渡边苦苦哀求，她只好同意。晚上来到一家<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUE1JUJGJUU5JUE0JTkwJUU1JUJCJUIz" title="https://zh.wikipedia.org/wiki/%E8%A5%BF%E9%A4%90%E5%BB%B3">西餐厅<i class="fa fa-external-link"></i></span>，渡边的举动让小田切以为他要对她不轨，十分害怕。没想到渡边告诉她自己得了不治之症，来日无多，但是见到小田切如此年轻有活力，希望小田切告诉他究竟活着是为了什么。小田切只好战战兢兢的拿出一只玩具<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTg1JTk0" title="https://zh.wikipedia.org/wiki/%E5%85%94">兔<i class="fa fa-external-link"></i></span>子告诉他，她平常在工厂工作就是做这种东西；只要想到自己做出的东西是为别人带来欢乐，自己也就很开心。渡边突然想到自己想要什么了，向小田切道谢后便离开餐厅。此时碰巧有群年轻人替一位少女庆生，众人唱起<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUE1JTlEJUU0JUJEJUEwJUU3JTk0JTlGJUU2JTk3JUE1JUU1JUJGJUFCJUU0JUI5JTkw" title="https://zh.wikipedia.org/wiki/%E7%A5%9D%E4%BD%A0%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90">生日快乐歌<i class="fa fa-external-link"></i></span>，仿佛在庆祝渡边的重生。</p><p>翌日渡边再度回到市公所上班，将他请假这些日子的公文全数拿出来，发觉有件案子是许多妇女前来陈情，希望将某条臭水沟改建为<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTg1JUFDJUU1JTlDJTky" title="https://zh.wikipedia.org/wiki/%E5%85%AC%E5%9C%92">公园<i class="fa fa-external-link"></i></span>，却屡屡遭到各单位互踢皮球不愿处理。他决定要处理这件事，带着下属开始各处奔走。5个月后，渡边过世，在灵堂上大家开始回忆他生命最后5个月的过程，发觉他非常努力奔走以建立公园，最后甚至选择在大<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTlCJUFB" title="https://zh.wikipedia.org/wiki/%E9%9B%AA">雪<i class="fa fa-external-link"></i></span>的夜里独自快乐的唱着歌，死于自己亲手建立的公园里。虽然在守灵的酒会上，大家如此怀念渡边所做的一切，但等到第二天上班时市公所 依就弥漫着官僚之气。尽管有职员看不过去，心中认为应该要继承渡边的精神，但也仅止于缅怀而已。</p><a id="more"></a><h1 id="个人评价"><a href="#个人评价" class="headerlink" title="个人评价"></a>个人评价</h1><p>十分推荐所有人去看的一部电影，虽然剧情大致的走向都能猜到，但是在看完之后绝对不会后悔的电影，顺带一提如果难以忍受电影时长可以多倍速观看，不过看着看着就会自然减速。</p><p>志村乔的演技也确实入木三分，不仅演绎出不知人生目的的活着，在醒悟之后眼神的那种光，以及和儿子的关系疏远，所谓好的演员是电影成功的另一半。</p><p>另外感叹上世纪50年代的电影质量和现在真的没法比，虽然是一部黑白电影，但是这部电影在个人心目中地位不亚于《肖申克的救赎》。</p><h1 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h1><p>黑白片加上2小时的电影时长估计没有多少读者可以坚持下来。</p><p>虽然人物的表情略显夸张，表情也有点用力过度的样子，但是看到主角眼睛都要瞪出来的那种孤独依然为之动容。</p><p>令人讽刺是最后葬礼上小职员虽然高歌要做出改变，然而最后却都按部就班的在体制内做着无用的零件，这样的事情像极了每天都在打鸡血的普通人。</p><p>然而更令人讽刺的是在葬礼上最关系最为紧密的儿子以及陪伴一旁的儿媳却一直沉默，最为亲近的人却成为了距离最遥远的陌生人，只在最后寥寥数语中知道父亲死前竟然为自己处理后事并且把身价财产传给儿子，直到这时才后悔一切无法挽回，然而现今这样的人似乎越来越多，这样的场面也越来越多……</p><p><strong>真切的活着最好的办法是培养利他之心，为他人和社会做出贡献</strong>，这也是为什么主角在听到小田切的感受之后能涅槃重生的根本原因。</p><h1 id="影评摘录"><a href="#影评摘录" class="headerlink" title="影评摘录"></a>影评摘录</h1><p>下面是摘自豆瓣的影评，在个人看来是对这部电影比较中肯的评价了。</p><p>个人心目中黑泽明最杰出的电影，同行朋友评价说“后劲太大”。这种电影，看一部少一部，看到就是赚到。世界没有进步，电影也没有进步，我无法相信一部讲故事的电影，能做的比《生之欲》更好。 说理蕴含在叙事中，因此显得格外通透。每个人都能从电影里看到自己，思考如何抵抗庸俗的生活。</p><p>当你的生命只剩半年，你会怎么做？——这是每个人都听过但无法给出确凿回答的问题。黑泽明不仅提出问题，他还给出了答案，这答案不仅领先于观众（叙事技巧），而且每一层次的回答都是对之前的超越（主题）。 </p><p>从后悔到享乐再到认真生活，最后落在对政府及个人辛辣无情的批判。</p><p>每个人酒后都振臂高呼继承遗志却无一改变，而真正觉醒的人无非也是独木难支、黯然神伤。不是理想主义，而是现实主义。人生的真相就这样向我摊开，印证了心中所想后也难免要陷入深深的失落。</p><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><p>电影原片：<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL2Jhbmd1bWkvcGxheS9lcDMxMTYxNT90aGVtZT1tb3ZpZSZzcG1faWRfZnJvbT0zMzMuNzg4LnJlY29tbWVuZF9tb3JlX3ZpZGVvLjE=" title="https://www.bilibili.com/bangumi/play/ep311615?theme=movie&spm_id_from=333.788.recommend_more_video.1">生之欲正片-电影-高清在线观看<i class="fa fa-external-link"></i></span></p><p>最为感动的部分是 ゴンドラの唄 这首歌。</p><p>个人认为最好的一个剪辑：<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVFzNDExVjdIbi8/c3BtX2lkX2Zyb209MzMzLjc4OC5yZWNvbW1lbmRfbW9yZV92aWRlby4y" title="https://www.bilibili.com/video/BV1Qs411V7Hn/?spm_id_from=333.788.recommend_more_video.2">ゴンドラの唄 - 船歌 - The Gondola Song -志村乔（《生之欲》黑泽明1952）_哔哩哔哩_bilibili<i class="fa fa-external-link"></i></span></p><p>光是曲子都非常好听：<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMUR0NDExRzdtTS8/c3BtX2lkX2Zyb209MzMzLjc4OC5yZWNvbW1lbmRfbW9yZV92aWRlby4x" title="https://www.bilibili.com/video/BV1Dt411G7mM/?spm_id_from=333.788.recommend_more_video.1">【手风琴】《凤尾船之歌》2011 ゴンドラの唄_哔哩哔哩_bilibili<i class="fa fa-external-link"></i></span></p><p>下面是对应的歌词：</p><blockquote><p>生命苦短 恋爱吧！少女！<br>    在朱唇褪色之前，<br>    在热血冷却之前，<br>    明天就没有这样的好时光了。<br>    生命苦短 恋爱吧！少女！<br>    来吧！彼此手牵手 登上他的船，<br>    让他滚烫的面颊贴在你的面庞上，<br>    在这里有谁也追求不到的东西。<br>    生命苦短 恋爱吧！少女！<br>    在你黑发染上白霜之前，<br>    在你心灵的火焰还未熄灭之前，<br>    因为今日是不会再来临的。</p></blockquote><h1 id="剧情摘录"><a href="#剧情摘录" class="headerlink" title="剧情摘录"></a>剧情摘录</h1><p>下面是边看电影边做的一些细节笔记，简单看看即可。</p><ol><li>市民科长不知道为什么而活。</li><li>政府踢皮球，造公园的事情跑了不下十几个部门，市民科长如同木乃伊一般的处理公务。</li><li>被下级戏谑30年不请假记录打破。</li><li>医院的旁人讲述胃癌反应，科长胃癌的反应被旁人看出来惊慌躲避，</li><li>医生说只是轻型胃溃疡，实际上只有不到半年的命。</li><li>儿子想要动用父亲的养老金，父亲听到之后却只是想着活着的意义。</li><li>看着死去妻子的照片，回忆妻子过去。儿子的过去回忆：棒球，割盲肠，儿子被征兵，然而长久的分割父子之间关系疏远。（镜头语言和场景切换都是神来之笔）</li><li>遇到小说家，诉说自己的苦衷。</li><li>小说家带领主角享受人生。</li><li>被人拿了戴了几十年的帽子而换新帽子。（意味着抛弃过去）。</li><li>后悔人生，歌唱：ゴンドラの唄。</li><li>儿子不理解父亲认为父亲的不配合令人失望，父亲也因儿子之间天堑般的隔阂痛苦。</li><li>遇到离职的下属小田切，追随并追问存在的意义。</li><li>陌生人的生日歌为庆祝主角的涅槃重生。</li><li>主角想要解决公园问题，生命却戛然而止。</li><li>利用各种职员的对话，阐述主角光辉事迹。</li><li>振臂高呼改变现状，第二天却又沦入体制，真正觉醒之人看清世界的面貌，然而想要反抗却是独木难支。</li><li>最后公园的一幕，是主角曾经存在最好的证明。</li><li>批判一个人要在一个人死去之后。<br>电影结束。</li></ol><h2 id="时间轴"><a href="#时间轴" class="headerlink" title="时间轴"></a>时间轴</h2><p>26:32 镜头切换，主角后悔这几张画面很有镜头语言的感觉，父亲和儿子之间某种看不见的隔阂。</p><p>38:30 无可奈何的接受现实<br><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205042157854.png" alt=""></p><p>41:56秒 和小说家倾诉自己想要知道如何体验人生，甚至连自己存了大半辈子的钱也不知道怎么花，于是小说家带他尽情享受人生。</p><p>49:24 第一次唱<strong>ゴンドラの唄</strong>，后悔自己如同行尸走肉的活了30年。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041928283.png" alt=""></p><p>忍受胃癌的痛苦却没有目的空洞活着的表情。另外这个动作莫名像是拿破仑。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041948309.png" alt=""></p><p>1小时24分<br>请求小田切告诉主角为什么会如此年轻活力，请教人生的存在意义。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041954734.png" alt=""></p><p>1小时28分<br>饭店陌生人庆祝友人的生日歌代表了主角的涅槃重生。</p><p>1小时32分<br>然而主角涅槃重生的之时，主角生命戛然而止。个人最为惊讶的地方。</p><p>02:05:48 几句名台词：</p><ul><li>我不能憎恨别人，我没有这种时间。</li><li>30年以来我从没见过黄昏，它太美丽了，但是我已经没有这种时间。</li></ul><p>02:16:30 荡秋千，第二次唱<strong>ゴンドラの唄</strong>，和第一次唱不同，这一次主角是认真而活的尽情歌唱，以至于巡逻警官也为止动容。</p><p>最后一幕：<br>真正觉醒的人看着主角建成的公园而感叹，然而现实却依旧如此的残酷。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>人一旦有了目的，大抵只会感叹人生的短暂，就如电影的主角一般，拼尽全力，人的伟大也只活在别人眼中，珍惜现在的每一刻，就是为自己而活。</p><p>19年电影院刷了2，30部电影，然后几乎没怎么看过电影了，感叹曾经美好年代，也感叹时间易逝。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      乘着假期的尾巴看了这一部电影
    
    </summary>
    
    
      <category term="其他" scheme="https://whitestore.top/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="其他" scheme="https://whitestore.top/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>LSM-Tree - LevelDb 源码解析</title>
    <link href="https://whitestore.top/2022/05/21/leveldb-source/"/>
    <id>https://whitestore.top/2022/05/21/leveldb-source/</id>
    <published>2022-05-21T11:13:33.000Z</published>
    <updated>2022-06-02T10:09:44.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LSM-Tree-LevelDb-源码解析"><a href="#LSM-Tree-LevelDb-源码解析" class="headerlink" title="LSM-Tree - LevelDb 源码解析"></a>LSM-Tree - LevelDb 源码解析</h1><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在上一篇文章[[LSM-Tree - LevelDb了解和实现]]中介绍了LevelDb相关的数据结构和核心组件，LevelDB的核心读写部分，以及为什么在这个数据库中写入的速度要比读取的速度快上好几倍。 </p><p>LevelDB的源代码还是比较好懂的，好懂到我只学过学JAVA只有定点基础C语言入门知识的人也能看懂，另一方面作者在关键的地方都给了注释，甚至告诉你为什么要这么设计<s>（写的很好很棒让人落泪为什么自己没这样的同事）</s>。</p><p>如果还是看不懂，作者也写了很多数据结构介绍的md文档（在doc目录中）告诉你核心组件的作用。</p><p>总之，不要惧怕这个数据库，无论是作为优秀代码和设计模式还是各种主流数据结构算法应用都非常值得学习和参考。</p><blockquote><p>Tip：这一节代码内容非常多，所以不建议在手机或者移动设备阅读，更适合在PC上观看。</p></blockquote><a id="more"></a><h2 id="源码运行"><a href="#源码运行" class="headerlink" title="源码运行"></a>源码运行</h2><p>LevelDB的编译是比较简单的，可以从官网直接克隆代码。</p><p>地址：<span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzJTNBLy9naXRodWIuY29tL2dvb2dsZS9sZXZlbGRi" title="https://link.zhihu.com/?target=https%3A//github.com/google/leveldb">https://github.com/google/leveldb<i class="fa fa-external-link"></i></span></p><p>具体操作步骤如下(也可以参考仓库中的<code>README</code>)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone --recurse-submodules https://github.com/google/leveldb.git</span><br><span class="line">mkdir -p build &amp;&amp; cd build</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Release .. &amp;&amp; cmake --build .</span><br></pre></td></tr></table></figure><p>完成整个编译动作之后，我们可以新增一个动态库，一个静态库和test目录，接着就可以编写单元测试了，同时官方的源代码中有很多的单元测试可以提供自己编写的测试程序进行调试使用，当然这里跳过这些内容，直接从源码开始。</p><h2 id="底层存储存储结构"><a href="#底层存储存储结构" class="headerlink" title="底层存储存储结构"></a>底层存储存储结构</h2><p>关联：[[SSTable]]</p><p>在LevelDB中<strong>SSTable</strong>是整个数据库最重要的结构，所有的SSTable文件本身的内容是<strong>不可修改</strong>的，虽然通常数据在内存中操作，但是数据不可能无限存储，当数据到达一定量之后就需要持久化到磁盘中，而压缩合并的处理就十分考验系统性能了，为此LevelDb使用分层的结构进行存储，下面我们从外部的使用结构开始来了解内部的设计。</p><p>整个外部的黑盒就是数据库本身了，以事务性数据库为例，通常的操作无非就是ACID四种，但是放到LSM-Tree的数据结构有点不一样，因为更新和删除其实都会通过“新增”与“合并”的方式完成新数据对旧数据的覆盖。</p><p>扯远了，我们从简单的概念开始，首先是整个DB的源代码，DB源代码可以通过以下路径访问：</p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9sZXZlbGRiL2Jsb2IvbWFpbi9pbmNsdWRlL2xldmVsZGIvZGIuaA==" title="https://github.com/google/leveldb/blob/main/include/leveldb/db.h">https://github.com/google/leveldb/blob/main/include/leveldb/db.h<i class="fa fa-external-link"></i></span></p><p>首先我们需要了解DB存储结构，可以看到存储引擎的对外提供的接口十分简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LEVELDB_EXPORT</span> <span class="title">DB</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置数据库的key-value结构，如果没有返回OK则视为操作失败，</span></span><br><span class="line"><span class="comment">// 备注：考虑默认打开sync=true操作，`Put` 方法在内部最终会调用 `Write` 方法，只是在上层为调用者提供了两个不同的选择。</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Status <span class="title">Put</span><span class="params">(<span class="keyword">const</span> WriteOptions&amp; options, <span class="keyword">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> Slice&amp; value)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功返回OK，如果异常则不返回OK，如果什么都返回，说明被删除的Key不存在，</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Status <span class="title">Delete</span><span class="params">(<span class="keyword">const</span> WriteOptions&amp; options, <span class="keyword">const</span> Slice&amp; key)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入操作</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Status <span class="title">Write</span><span class="params">(<span class="keyword">const</span> WriteOptions&amp; options, WriteBatch* updates)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据key获取数据</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Status <span class="title">Get</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options, <span class="keyword">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="built_in">std</span>::<span class="built_in">string</span>* value)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Get</code> 和 <code>Put</code> 是 LevelDB 为上层提供的用于读写的接口，注意这个接口的<code>Update</code>和<code>Delele</code>操作 实际上是通过<code>Put</code>完成的，实现方式是内部做了类型判断，十分有意思，这里可以先留意一下。</p><h2 id="write部分"><a href="#write部分" class="headerlink" title="write部分"></a>write部分</h2><p>下面先从写入操作开始，看看数据是如何进入到LevelDb，以及内部是如何管理的。</p><p>Write的内部逻辑算是比较复杂的，所以这里画了下基本流程图：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204171601989.png" alt=""></p><p>我们从DB的<code>Write()</code>接口方法切入，简化代码之后大致的流程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  为写入构建足够的空间，此时可以不需要加锁。</span></span><br><span class="line">Status status = MakeRoomForWrite(updates == <span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">//  通过 `AddRecord` 方法向日志中追加一条写操作的记录；</span></span><br><span class="line">status = log_-&gt;AddRecord(WriteBatchInternal::Contents(write_batch));</span><br><span class="line"><span class="comment">//  如果日志记录成功，则将数据进行写入</span></span><br><span class="line"><span class="keyword">if</span> (status.ok()) &#123;</span><br><span class="line">status = WriteBatchInternal::InsertInto(write_batch, mem_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个执行流程如下：</p><ul><li>首先调用 <code>MakeRoomForWrite</code> 方法为即将进行的写入提供足够的空间。<ul><li>如果当前空间不足需要冻结当前的<code>memtable</code>，此时发生<code>Minor Compaction</code>并创建一个新的 <code>MemTable</code> 对象。</li><li>如果满足触发<code>Major Compaction</code>需要对数据进行压缩并且对于SSTable进行合并。</li></ul></li><li>通过<code>AddRecord</code>方法向日志中追加一条写操作记录。</li><li>最终调用<strong>memtable</strong>往内存结构中添加<strong>key/value</strong>，完成最终写入操作。</li></ul><p>将写入操作的源代码逻辑简化之后最终如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DBImpl::Write</span><span class="params">(<span class="keyword">const</span> WriteOptions&amp; options, WriteBatch* my_batch)</span> </span>&#123;</span><br><span class="line">  <span class="function">Writer <span class="title">w</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  w.batch = my_batch;</span><br><span class="line"></span><br><span class="line">  MakeRoomForWrite(my_batch == <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">uint64_t</span> last_sequence = versions_-&gt;LastSequence();</span><br><span class="line">  Writer* last_writer = &amp;w;</span><br><span class="line">  WriteBatch* updates = BuildBatchGroup(&amp;last_writer);</span><br><span class="line">  WriteBatchInternal::SetSequence(updates, last_sequence + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 记录最终的操作记录点</span></span><br><span class="line">  last_sequence += WriteBatchInternal::Count(updates);</span><br><span class="line"><span class="comment">// 日志编写</span></span><br><span class="line">  log_-&gt;AddRecord(WriteBatchInternal::Contents(updates));</span><br><span class="line"><span class="comment">// 将数据写入memtable</span></span><br><span class="line">  WriteBatchInternal::InsertInto(updates, mem_);</span><br><span class="line"></span><br><span class="line">  versions_-&gt;SetLastSequence(last_sequence);</span><br><span class="line">  <span class="keyword">return</span> Status::OK();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码有较多的方法封装，这里我们一个个来看。</p><p><code>MaybeScheduleCompaction()</code>压缩合并（如果觉得这里突兀可以请参阅上文的流程图）在源码中系统会定时检查是否可以进行压缩合并，if/else用于多线程并发写入的时候进行合并写入的操作，当发现有不同线程在操作就会等待结果或者等到拿到锁之后接管合并写入的操作。</p><blockquote><p>如果对于下面的代码有疑问可以阅读[[LSM-Tree - LevelDb了解和实现]]中关于“合并写入”的部分，为了节省时间，可以在网页中直接输入关键字“<strong>合并写入</strong>”快速定位，这里假设读者已经了解基本的工作流程，就不再赘述了。</p></blockquote><p>#LevelDb合并写入操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::MaybeScheduleCompaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">mutex_.AssertHeld();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (background_compaction_scheduled_) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Already scheduled</span></span><br><span class="line"><span class="comment">// 正在压缩</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DB is being deleted; no more background compactions</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DB正在被删除；不再有后台压缩</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!bg_error_.ok()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Already got an error; no more changes</span></span><br><span class="line"><span class="comment">// 已经发生异常，不能做更多改动。</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm_ == <span class="literal">nullptr</span> &amp;&amp; manual_compaction_ == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line"></span><br><span class="line">!versions_-&gt;NeedsCompaction()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不需要合并则不工作</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 设置当前正常进行压缩合并</span></span><br><span class="line"></span><br><span class="line">background_compaction_scheduled_ = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 开始压缩合并</span></span><br><span class="line"></span><br><span class="line">env_-&gt;Schedule(&amp;DBImpl::BGWork, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>不可变memtable</strong>：</p><p>在write的函数内部有这样一串代码，此时会暂停解锁等待写入，这个写入又是干嘛的？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Status status = MakeRoomForWrite(updates == <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><p>进入方法内部会发现通过一个<code>while</code>循环判断当前的 <code>memtable</code>状态，一旦发现memtable写入已经写满整个<code>mem</code>，则需要停止写入并且将当前的<code>memtable</code>转为<strong>imutiablememtable</strong>，并且创建新的<code>mem</code>切换写入，此时还会同时根据一些条件判断是否可以进行压缩 <code>mem</code>。</p><p>这里额外解释源码中<strong>GUARDED_BY</strong>含义：</p><p>GUARDED_BY是数据成员的属性，该属性声明数据成员受给定功能保护。对数据的读操作需要<strong>共享</strong>访问，而写操作则需要<strong>互斥</strong>访问。</p><p>该 GUARDED_BY属性声明线程必须先锁定<strong>listener_list_mutex</strong>才能对其进行读写listener_list，从而确保增量和减量操作是原子的。</p><p><strong>总结：其实就是一个典型的互斥共享锁，至于实现不是本文的重点。</strong></p><p>mem可以看作是当前的系统备忘录或者说临时的记账板，和大多数的日志或者关系型数据库类似，都是先写入日志在进行后续的所有“事务”操作，也就是<strong>日志优先于记录操作</strong> 原则，根据日志写入操作加锁来完成并发操作的正常运行。</p><p><code>MakeRoomForWrite</code> 方法中比较关键的部分都加了注释，很多操作作者都有介绍意图，代码逻辑都比较简单，多看几遍基本了解大致思路即可。（C++语法看不懂不必过多纠结，明白他要做什么就行，主要是我也看不懂，哈哈）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!bg_error_.ok()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Yield previous error</span></span><br><span class="line"></span><br><span class="line">s = bg_error_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (allow_delay &amp;&amp; versions_-&gt;NumLevelFiles(<span class="number">0</span>) &gt;=</span><br><span class="line"></span><br><span class="line">config::kL0_SlowdownWritesTrigger) &#123;</span><br><span class="line"><span class="comment">// 我们正接近于达到对L0文件数量的硬性限制。L0文件的数量。当我们遇到硬性限制时，与其将单个写操作延迟数而是在我们达到硬限制时，开始将每个mem单独写1ms以减少延迟变化。另外。这个延迟将一些CPU移交给压缩线程，因为 如果它与写入者共享同一个核心的话。</span></span><br><span class="line"></span><br><span class="line">mutex_.Unlock();</span><br><span class="line"></span><br><span class="line">env_-&gt;SleepForMicroseconds(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 不要将一个单一的写入延迟超过一次</span></span><br><span class="line">allow_delay = <span class="literal">false</span>; </span><br><span class="line">mutex_.Lock();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!force &amp;&amp;</span><br><span class="line"></span><br><span class="line">(mem_-&gt;ApproximateMemoryUsage() &lt;= options_.write_buffer_size)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在当前的mem中还有空间</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们已经填满了当前的memtable，但之前的的mem还在写入，所以需要等待</span></span><br><span class="line"></span><br><span class="line">background_work_finished_signal_.Wait();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (versions_-&gt;NumLevelFiles(<span class="number">0</span>) &gt;= </span><br><span class="line">config::kL0_StopWritesTrigger) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">background_work_finished_signal_.Wait();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A试图切换到一个新的memtable并触发对旧memtable的压缩</span></span><br><span class="line">assert(versions_-&gt;PrevLogNumber() == <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 新建文件号</span></span><br><span class="line"><span class="keyword">uint64_t</span> new_log_number = versions_-&gt;NewFileNumber(); <span class="comment">//return next_file_number_++;</span></span><br><span class="line"></span><br><span class="line">WritableFile* lfile = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">// 新建可写入文件, 内部通过一个map构建一个文件：文件状态的简易文件系统</span></span><br><span class="line"><span class="comment">// typedef std::map&lt;std::string, FileState*&gt; FileSystem;</span></span><br><span class="line">s = env_-&gt;NewWritableFile(LogFileName(dbname_, new_log_number), &amp;lfile);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line"><span class="comment">// 避免死循环重复新增文件号</span></span><br><span class="line">versions_-&gt;ReuseFileNumber(new_log_number);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> log_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> logfile_;</span><br><span class="line"></span><br><span class="line">logfile_ = lfile;</span><br><span class="line"></span><br><span class="line">logfile_number_ = new_log_number;</span><br><span class="line"><span class="comment">// 写入日志</span></span><br><span class="line">log_ = <span class="keyword">new</span> <span class="built_in">log</span>::Writer(lfile);</span><br><span class="line"><span class="comment">// **重点：imm_ 就是immutable 他将引用指向当前已经写满的mem，其实和mem对象没什么区别，就是加了一个互斥共享锁而已（写互斥，读共享）**</span></span><br><span class="line">imm_ = mem_;</span><br><span class="line"></span><br><span class="line">has_imm_.store(<span class="literal">true</span>, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line"><span class="comment">// 新建新的memtable</span></span><br><span class="line">mem_ = <span class="keyword">new</span> MemTable(internal_comparator_);</span><br><span class="line"><span class="comment">// 引用至新块</span></span><br><span class="line">mem_-&gt;Ref();</span><br><span class="line"></span><br><span class="line">force = <span class="literal">false</span>; <span class="comment">// Do not force another compaction if have room</span></span><br><span class="line"><span class="comment">// 尝试对于已满mem压缩合并 ，此处承接上文</span></span><br><span class="line">MaybeScheduleCompaction();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面用一个简单的示意图了解上面的大致流程：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204181000328.png" alt=""></p><p>注意这对于[[SSTable]]的原始理论的实现结构显然是有一定出入，当然这是很正常的理论和实践的差别。</p><p>在通常情况下<code>memtable</code>可以通过短暂的延迟读写请求等待压缩完成，但是一旦发现mem占用的内存过大，此时就需要给<strong>当前的mem加锁变为_imu状态</strong>，然后创建一个新的 MemTable 实例并且把<strong>新进来的请求转到新的mem中</strong>，这样就可以继续接受外界的写操作，不再需要等待 <code>Minor Compaction</code> 的结束了。</p><blockquote><p>再次注意此处会通过函数 <strong>MaybeScheduleCompaction</strong> 是否进行压缩合并的操作判断。</p></blockquote><p>这种无等待的设计思路来自于：[[Dynamic-sized NonBlocking Hash table]]，可以自己下下论文来看看，当然也可以等我后面的文章。</p><h2 id="log部分"><a href="#log部分" class="headerlink" title="log部分"></a>log部分</h2><p>写入的大致操作流程了解之后，下面来看看LevelDb的日志管理也就是<code>AddRecord()</code>函数的操作：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204172014056.png" alt=""></p><p>注意日志的核心部分并不在<code>AddRecord()</code>内部，因为内部只有一些简单的字符串拼接操作，这里将核心放到了<code>RecordType</code>的部分，可以看到这里通过当前日志字符长度判断不同的类型，<code>RecordType</code>标识当前记录在块里面的位置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//....</span></span><br><span class="line"><span class="keyword">enum</span> RecordType &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Zero is reserved for preallocated files</span></span><br><span class="line"></span><br><span class="line">kZeroType = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">kFullType = <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// For fragments</span></span><br><span class="line"></span><br><span class="line">kFirstType = <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">kMiddleType = <span class="number">3</span>,</span><br><span class="line"></span><br><span class="line">kLastType = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//....</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RecordType type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">bool</span> <span class="built_in">end</span> = (left == fragment_length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">begin</span> &amp;&amp; <span class="built_in">end</span>) &#123;</span><br><span class="line"></span><br><span class="line">type = kFullType;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">begin</span>) &#123;</span><br><span class="line"></span><br><span class="line">type = kFirstType;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">end</span>) &#123;</span><br><span class="line"></span><br><span class="line">type = kLastType;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">type = kMiddleType;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>First：是用户记录第一个片段的类型，<br>Last：是用户记录的最后一个片段的类型。<br>   Middle：是一个用户记录的所有内部片段的类型。</p></blockquote><p>如果看不懂源代码，可以根据作者的md文档介绍也可以大致了解日志文件结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">record :=</span><br><span class="line">     checksum: uint32     <span class="comment">// crc32c of type and data[] ; little-endian</span></span><br><span class="line">     length: uint16       <span class="comment">// little-endian</span></span><br><span class="line">     type: uint8          <span class="comment">// One of FULL, FIRST, MIDDLE, LAST</span></span><br><span class="line">     data: uint8[length]</span><br></pre></td></tr></table></figure><p>我们可以根据描述简单画一个图：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204171749969.png" alt=""></p><p>从<code>RecordType</code>内部的定义可以看到日志固定为<strong>32KB</strong>大小，在日志文件中将分为多部分，但是一个日志只包含在一个单一的文件块。</p><p>RecordType 存储的内容如下：</p><ul><li>前面4个字节用于CRC校验</li><li>接着两个字节是块数据长度</li><li>接着是一个字节的类型标识（标识当前日志记录在块中位置）</li><li>最后是数据payload部分</li></ul><p><strong>32kb</strong>大小选择是考虑到日志记录行的磁盘对齐和日志读写，针对日志写的速度也非常快，写入的日志先写入内存的文件表，然后通过<code>fdatasync(...)</code>方法将缓冲区<code>fflush</code>到磁盘中并且持久化，最后通过日志完成故障恢复的操作。</p><p>需要注意如果日志记录较大可能存在于多个block块中。</p><p>一个记录永远不会在一个块的最后六个字节内开始，理由是一个记录前面需要一些其他部分占用空间（也就是记录行的校验和数据长度标识信息等）。</p><p>为了防止单个日志块被拆分到多个文件以及压缩考虑，这种“浪费”是可以被接受。</p><p>如果读者非要清楚最后几个字节存储的是什么，想满足自己的好奇心，可以看下面的代码：</p><p><code>dest_-&gt;Append(Slice(&quot;\x00\x00\x00\x00\x00\x00&quot;, leftover));</code></p><p><strong>日志写流程图</strong>：</p><p>日志写的流程比较简单，主要分歧点是当前块剩余空间是否够写入一个header，并且最后6个字节将会填充空格进行补齐。</p><p>在日志写入的过程中通过一个<code>while(ture)</code>不断判断<code>buffer</code>大小，如果大小超过<strong>32KB</strong>-最后6个字节，则需要停止写入并且把开始写入到现在位置为一个数据块。</p><p>下面是日志写流程图：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204171802290.png" alt="日志写流程图"></p><p>下面是日志读流程图：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204171802000.png" alt="日志读流程图"></p><p>既然日志大小为32kb，那么日志的读写单位也应该是32kb，接着便是扫描数据块，在扫描chunk的时候如果发现CRC校验不通过则返回错误信息，如果数据破损则丢弃当前chunk。</p><p>翻了一下代码，简单来说就是读取通过<code>while(true)</code>循环<code>read</code>，直到读取到类型为<code>Last</code>的<code>chunk</code>，日志记录读取完成。</p><p><code>memtable</code>比较有意思的特点是无论插入还是删除都是通过“新增”的方式实现的（你没有看错），内部通过<code>Mainfest</code>维护状态，同时根据版本号和序列号维护一条记录是新增还是删除并且保证读取到的内容是最新值，具体介绍同样在上一节[[LSM-Tree - LevelDb了解和实现]]中。</p><p>注意<strong>写入日志之后记录是不能查询</strong>的（因为中间有可能存在断电故障导致真实记录没有写入），日志仅作为故障恢复，只有<strong>数据写入到mem之后才被访问到</strong>。</p><p>关于mem新增和删除的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemTableInserter</span> :</span> <span class="keyword">public</span> WriteBatch::Handler &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">SequenceNumber sequence_;</span><br><span class="line"></span><br><span class="line">MemTable* mem_;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Put</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">mem_-&gt;Add(sequence_, kTypeValue, key, value);</span><br><span class="line"></span><br><span class="line">sequence_++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">mem_-&gt;Add(sequence_, kTypeDeletion, key, Slice());</span><br><span class="line"></span><br><span class="line">sequence_++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace</span></span><br></pre></td></tr></table></figure><p>在<code>Add()</code>函数的内部通过一个[[LSM-Tree - LevelDb Skiplist跳表]]完成数据的插入，在数据的node中包含了记录键值，为了保证读取的数据永远是最新的，记录需要在<code>skiplist</code>内部进行排序，节点排序使用的是比较常见的比较器<code>Compare</code>，如果用户想要自定义排序（例如处理不同的字符编码等）可以编写自己的比较器实现。</p><p>对于一条记录的结构我们也可以从 <code>Add()</code> 函数中看到作者的注释：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Format of an entry is concatenation of:</span></span><br><span class="line">  <span class="comment">//  key_size     : varint32 of internal_key.size()</span></span><br><span class="line">  <span class="comment">//  key bytes    : char[internal_key.size()]</span></span><br><span class="line">  <span class="comment">//  tag          : uint64((sequence &lt;&lt; 8) | type)</span></span><br><span class="line">  <span class="comment">//  value_size   : varint32 of value.size()</span></span><br><span class="line">  <span class="comment">//  value bytes  : char[value.size()]</span></span><br></pre></td></tr></table></figure><blockquote><p>[[VarInt32编码]]：在这里虽然是变长整型类型但是实际使用4个字节表示。<br><code>uint64((sequence &lt;&lt; 8) | type</code>：位运算之后实际为7个字节的sequence长度<br>注意在tag和value_size中间有一个ValueType标记来标记记录是新增还是删除。</p></blockquote><p>VarInt32 (vary int 32)，即：长度可变的 32 为整型类型。一般来说，int 类型的长度固定为 32 字节。但 VarInt32 类型的数据长度是不固定的，VarInt32 中每个字节的最高位有特殊的含义。如果最高位为 1 代表下一个字节也是该数字的一部分。</p><p>因此，表示一个整型数字最少用 1 个字节，最多用 5 个字节表示。如果某个系统中大部分数字需要 &gt;= 4 字节才能表示，那其实并不适合用 VarInt32 来编码。</p><p>根据<code>get()</code>代码内部通过<code>valueType</code>进行区分，<code>valueType</code>占用一个字节的空间进行判断新增还是删除记录，默认比较器判断新增或者删除记录逻辑如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (comparator_.comparator.user_comparator()-&gt;Compare(</span><br><span class="line"></span><br><span class="line">Slice(key_ptr, key_length - <span class="number">8</span>), key.user_key()) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Correct user key</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint64_t</span> tag = DecodeFixed64(key_ptr + key_length - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (<span class="keyword">static_cast</span>&lt;ValueType&gt;(tag &amp; <span class="number">0xff</span>)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> kTypeValue: &#123;</span><br><span class="line"></span><br><span class="line">Slice v = GetLengthPrefixedSlice(key_ptr + key_length);</span><br><span class="line"></span><br><span class="line">value-&gt;assign(v.data(), v.size());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> kTypeDeletion:</span><br><span class="line"></span><br><span class="line">*s = Status::NotFound(Slice());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据代码定义和上面的描述画出下面的结构图：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204171916505.png" alt=""></p><p><strong>Compare键排序</strong></p><p>LevelDb的memtable通过跳表维护了键，内部默认情况下通过<code>InternalKeyComparator</code>对于键进行比较，下面是比较内部逻辑：</p><p>比较器通过 <code>user_key</code> 和 <code>sequence_number</code> 进行排序，同时按照user_key进行升序排序，<strong>序列号通过插入的时间递增</strong>，以此来保证无论是增加还是删除都是获取到最新的信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 一个用于内部键的比较器，它使用一个指定的比较器用于用户键部分比较，并通过递减序列号来打破平衡。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InternalKeyComparator::Compare</span><span class="params">(<span class="keyword">const</span> Slice&amp; akey, <span class="keyword">const</span> Slice&amp; bkey)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Order by:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加用户密钥（根据用户提供的比较器）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递减序列号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递减类型（尽管序列号应该足以消除歧义）。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> r = user_comparator_-&gt;Compare(ExtractUserKey(akey), ExtractUserKey(bkey));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint64_t</span> anum = DecodeFixed64(akey.data() + akey.size() - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint64_t</span> bnum = DecodeFixed64(bkey.data() + bkey.size() - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (anum &gt; bnum) &#123;</span><br><span class="line"></span><br><span class="line">r = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (anum &lt; bnum) &#123;</span><br><span class="line"></span><br><span class="line">r = +<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意被比较key<strong>可能包含完全不同的内容</strong>，这里读者肯定会有疑问对于key获取值进行提取信息是否会有影响，然而从get的逻辑来看它可以通过键长度，和序列号等信息进行获取Key，并且获取是<strong>header的头部信息</strong>，所以key是任何类型都是没有影响的。</p><p><strong>记录查询</strong></p><p>现在我们再回过头来看一下<code>memtable</code>是如何读取的，从<code>memtable</code>和<code>imumemble</code>的关系可以看出有点类似<strong>缓存</strong>，当<code>memtable</code>写满之后转为<code>imumem</code>并且等待同步至磁盘。</p><p>key读取和查找的顺序如下：</p><ul><li>在memtable中获取指定Key，如果数据符合条件则结束查找。</li><li>在Imumemtable中查找指定Key，如果数据符合条件则结束查找。</li><li>按低层至高层的顺序在level i层的sstable文件中查找指定的key，若搜索到符合条件的数据项就会结束查找，否则返回Not Found错误，表示数据库中不存在指定的数据。</li></ul><p>记录按照层级关系进行搜索，首先是从当前内存中正在写入<code>memtable</code>搜索，接着是<code>imumemtable</code>，再接着是存在于磁盘不同层级的<code>SSTable</code>，SSTable通过<code>*.ldb</code>的形式进行标记，可以快速找到。</p><p>最终我们可以把LevelDb的查询看作下面的形式：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204172111973.png" alt=""></p><p><strong>小结</strong>：</p><p>这一部分我们了解了LevelDB源代码部分等基础结构DB，介绍了LevelDB的基础对外接口，LevelDB和map的接口看起来十分类似，这一部分重点讲述了读写操作等源代码，以及内部合并压缩的一些细节。</p><p>另外记录查询等动作和之前介绍LevelDB等读写流程大致类似，当然代码简化了很多的内容，读者可以根据自己感兴趣的内容研究。</p><h2 id="SSTable操作"><a href="#SSTable操作" class="headerlink" title="SSTable操作"></a>SSTable操作</h2><p>前面我们提到了记录的增删改查底层查询，和日志的读写细节，下面则针对谷歌发明的特殊数据结构<code>SSTable</code>进行介绍。</p><p><strong>SSTable如何工作？</strong></p><p><code>SSTable</code>在初始的论文中可以总结出下面的特点：</p><ul><li>写入的时候不写入磁盘而是先写入内存表的数据结构。</li><li>当数据结构内存占用超过一定的阈值就可以直接写入到磁盘文件由于已经是排好序的状态，所以可以直接对旧结构覆盖，写入效率比较高。并且写入和数据结构改动可以同时进行。</li><li>读写顺序按照 内存 - 磁盘 - 上一次写入文件 - 未找到。</li><li>后台定时线程定时合并和压缩排序分段，将废弃值给覆盖或者丢弃。</li></ul><p>[[SSTable]] 最早出现在谷歌2006年的论文当中，LevelDB的SSTable设计也有部分特性体现这个数据结构，当然并不是完全一致的，LevelDB利用SSTable在磁盘中维护多层级的数据节点。</p><p>可以认为了解SSTable结构就相当于了解了LevelDb的核心数据结构设计。</p><p><strong>多层级SSTable</strong></p><p>我们重点看看多层级的SSTable部分，levelDB在磁盘中扫描SSTable的时候LevelDB并不会跳过层级，这里肯定会有疑问每个层级都扫一遍的效率问题，针对这个问题作者在db中设计了下面的数据结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FileMetaData</span> &#123;</span></span><br><span class="line"></span><br><span class="line">FileMetaData() : refs(<span class="number">0</span>), allowed_seeks(<span class="number">1</span> &lt;&lt; <span class="number">30</span>), file_size(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">int</span> refs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> allowed_seeks; <span class="comment">// 允许压缩搜索</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> number;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> file_size; <span class="comment">// 文件大小</span></span><br><span class="line"></span><br><span class="line">InternalKey smallest; <span class="comment">// 表提供的最小内部密钥</span></span><br><span class="line"></span><br><span class="line">InternalKey largest; <span class="comment">// 表提供最大内部密钥</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上面的结构体声明中定义了压缩SSTable文件的全部信息，包括最大值和最小值，运行查找次数，文件引用次数和文件号，SSTable会按照固定的形式存储到同一个目录下面，所以可以通过文件号进行快速搜索。</p><p>查找和记录key顺序类似，都是按照<strong>从小到大</strong>的顺序进行读取的，以Level0为例，里面通常包含<strong>4个固定的SSTable</strong>，并且内部通常存在key交叉，所以会按照从SSTable1-4的顺序进行读取，而更高层次的层级则通过查找上面结构体的最大值和最小值的信息（smallest和largest）。</p><p>具体的文件搜索细节可以通过<code>TableCache::FindTable</code>查找 ，由于篇幅有限这里就不贴代码了，简要逻辑是配合缓存和<code>RandomAccessFile</code>对于文件进行读写，然后把读到的文件信息写入到内存中方便下次获取。</p><blockquote><p>如果了解Mysql Btree设计会发现文件搜索有些类似页目录的查找。不同的是Btree页目录通过页目录等稀疏搜索。</p></blockquote><p><strong>SSTable合并</strong></p><p>我们再来看看SSTable是如何合并的，之前提到过SSTable通过<strong>MaybeScheduleCompaction</strong>尝试合并，需要注意这个合并压缩和Bigtable的形式类似，都是根据不同的条件判断是否进行合并，一旦可以合并便执行<code>BackgroundCompaction</code>操作。</p><p>合并分为两种情况，一种是<strong>Minor Compaction</strong>，另一种是将<strong>Memtable</strong>数据写满转为不可变对象（实际就是加锁），执行<code>CompactMemtable</code>进行压缩。</p><p>合并操作简化版源代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::CompactMemTable</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">VersionEdit edit;</span><br><span class="line">Version* base = versions_-&gt;current();</span><br><span class="line">WriteLevel0Table(imm_, &amp;edit, base);</span><br><span class="line">versions_-&gt;LogAndApply(&amp;edit, &amp;mutex_);</span><br><span class="line">RemoveObsoleteFiles();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CompactMemTable方法会先构建当前的修改版本号，然后调用<code>WriteLevel0Table()</code>方法尝试把当前的Imumtable写入到Level0的层级。<br>如果发现Level0的层级SSTable过多，则进一步进行<strong>Major Compaction</strong>，同时根据<code>BackgroudCompcation()</code>选择合适的压缩层级和压缩方式。</p><p>下面是<code>writeLevel0</code>的简化代码：</p><p>简化代码的最后几行代码会获取文件信息的最大值和最小值以此判断是否在当前SSTable搜索还是跳转到下一个。</p><p>数据如果是写入Level0我们可以看作是<strong>Major Compaction</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::WriteLevel0Table</span><span class="params">(MemTable* mem, VersionEdit* edit,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">Version* base)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SSTable文件信息</span></span><br><span class="line">FileMetaData meta;</span><br><span class="line"></span><br><span class="line">meta.number = versions_-&gt;NewFileNumber();</span><br><span class="line"></span><br><span class="line">pending_outputs_.insert(meta.number);</span><br><span class="line"></span><br><span class="line">Iterator* iter = mem-&gt;NewIterator();</span><br><span class="line"><span class="comment">// 构建SSTable文件</span></span><br><span class="line">BuildTable(dbname_, env_, options_, table_cache_, iter, &amp;meta);</span><br><span class="line"></span><br><span class="line">pending_outputs_.erase(meta.number);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，如果 file_size 为零，则该文件已被删除，并且不应被添加到清单中。</span></span><br><span class="line"><span class="comment">// 获取文件信息的最大值和最小值</span></span><br><span class="line"><span class="keyword">const</span> Slice min_user_key = meta.smallest.user_key();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Slice max_user_key = meta.largest.user_key();</span><br><span class="line"><span class="comment">// level层级扫描</span></span><br><span class="line">base-&gt;PickLevelForMemTableOutput(min_user_key, max_user_key);</span><br><span class="line"><span class="comment">// 写入文件</span></span><br><span class="line">edit-&gt;AddFile(level, meta.number, meta.file_size, meta.smallest,</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Status::ok();</span><br></pre></td></tr></table></figure><p>结合上下两段源码可以发现文件管理最终是通过<code>VersionEdit</code>来完成的，如果写入成功了则返回当前的SSTable的<code>FileMetaData</code>，在<code>VersionEdit</code>内部通过<code>logAndApply</code>的方式记录文件内部的变化，也就是前文介绍的日志管理功能了，完成之后通过<code>RemoveObsoleteFiles()</code>方法进行数据的清理操作。</p><p>如果<code>Level0</code>写满了此时就需要进行<strong>Major Compaction</strong>，这个压缩会比前面的要复杂一些因为涉及低层级到高层级的压缩。</p><p>这里需要再回看<code>BackgroundCompaction</code>的代码，具体代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::BackgroundCompaction</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"><span class="comment">// 如果存在不可变imumem,进行压缩合并</span></span><br><span class="line">CompactMemTable();</span><br><span class="line">  </span><br><span class="line">versions_-&gt;PickCompaction();</span><br><span class="line"></span><br><span class="line">VersionSet::LevelSummaryStorage tmp;</span><br><span class="line"></span><br><span class="line">CompactionState* compact = <span class="keyword">new</span> CompactionState(c);</span><br><span class="line"></span><br><span class="line">DoCompactionWork(compact);</span><br><span class="line"></span><br><span class="line">CleanupCompaction(compact);</span><br><span class="line"></span><br><span class="line">c-&gt;ReleaseInputs();</span><br><span class="line"></span><br><span class="line">RemoveObsoleteFiles();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先根据<code>VersionSet</code> 查找需要压缩的信息，并且打包加入到 <strong>Compaction</strong> 对象，这个对象根据查询次数和大小限制来选择需要压缩的<strong>两个层级</strong>，因为level0中包含很多重叠键，则会在更高层级找到有重叠的键的SSTable，再通过<code>FileMetaData</code>找到需要压缩的文件，另外查询频繁的SSTable将会“升级”到更高层级进行压缩存储，并且更新文件信息方便下一次查找。</p><p><strong>合并的触发条件</strong></p><p>每个 SSTable 在创建之后的 <code>allowed_seeks</code> 都为 100 次，当 <code>allowed_seeks &lt; 0</code> 时就会触发该文件的与更高层级和合并，因为频繁查询的数据通常会降低系统性能。</p><p>这样的设计理由是<strong>在高层级搜索键说明在上一层肯定是相同的键查找</strong>，同时也是为了减少每次都覆盖扫描多层级扫描寻找数据。最终这种设计方式核心是以更新<strong>FileMetaData</strong> 来减少下一次查询的性能开销。</p><p>另外这种处理可以简单理解为我们在操作系统中进行深层次文件夹搜索的时候，如果频繁查询某个深层次的数据很麻烦，解决此问题的第一种方式是建立一个“快捷方式”的文件夹，另一种是直接做标签直接指向这个目录，其实两者都是差不多的，所以压缩设计也是同理。</p><p>LevelDB 中的 <code>DoCompactionWork</code> 方法会对所有传入的 SSTable 中的键值使用<strong>归并排序</strong>进行合并，最后会在更高层级中生成一个新的 SSTable。</p><blockquote><p>归并排序主要是对于key进行归并，使得迭代的时候key就是有序的可以直接合并到指定的高高层级。关键代码存在于下面的代码<br><code>Iterator* input = versions_-&gt;MakeInputIterator(compact-&gt;compaction);</code></p></blockquote><p><strong>归并排序</strong></p><p><strong>DoCompactionWork</strong> 归并排序 的源代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::DoCompactionWork</span><span class="params">(CompactionState* compact)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int64_t</span> imm_micros = <span class="number">0</span>; <span class="comment">// Micros spent doing imm_ compactions</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (snapshots_.empty()) &#123;</span><br><span class="line"><span class="comment">// 快照为空，找到直接采用记录信息的最后序列号</span></span><br><span class="line"></span><br><span class="line">compact-&gt;smallest_snapshot = versions_-&gt;LastSequence();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 快照存在，则抛弃之前所有的序列</span></span><br><span class="line">compact-&gt;smallest_snapshot = snapshots_.oldest()-&gt;sequence_number();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 对于待压缩数据进行，内部生成一个MergingIterator，当构建迭代器之后键内部就是有序的状态了，也就是前面说的归并排序的部分</span></span><br><span class="line">Iterator* input = versions_-&gt;MakeInputIterator(compact-&gt;compaction);</span><br><span class="line"></span><br><span class="line">input-&gt;SeekToFirst();</span><br><span class="line"></span><br><span class="line">Status status;</span><br><span class="line"></span><br><span class="line">ParsedInternalKey ikey;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> current_user_key;</span><br><span class="line"><span class="comment">//当前记录user key</span></span><br><span class="line"><span class="keyword">bool</span> has_current_user_key = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">SequenceNumber last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (input-&gt;Valid() &amp;&amp; !shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优先考虑imumemtable的压缩工作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (has_imm_.load(<span class="built_in">std</span>::memory_order_relaxed)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint64_t</span> imm_start = env_-&gt;NowMicros();</span><br><span class="line"></span><br><span class="line">imm_micros += (env_-&gt;NowMicros() - imm_start);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Slice key = input-&gt;key();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (compact-&gt;compaction-&gt;ShouldStopBefore(key) &amp;&amp;</span><br><span class="line"></span><br><span class="line">compact-&gt;builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line"></span><br><span class="line">status = FinishCompactionOutputFile(compact, input);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理键/值，添加到状态等。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> drop = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ParseInternalKey(key, &amp;ikey)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除和隐藏呗删除key</span></span><br><span class="line"></span><br><span class="line">current_user_key.clear();</span><br><span class="line"></span><br><span class="line">has_current_user_key = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 更新序列号</span></span><br><span class="line">last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!has_current_user_key ||</span><br><span class="line"></span><br><span class="line">user_comparator()-&gt;Compare(ikey.user_key, Slice(current_user_key)) !=</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户key第一次出现</span></span><br><span class="line"></span><br><span class="line">current_user_key.assign(ikey.user_key.data(), ikey.user_key.size());</span><br><span class="line"></span><br><span class="line">has_current_user_key = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (last_sequence_for_key &lt;= compact-&gt;smallest_snapshot) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩以后旧key边界的被新的覆盖</span></span><br><span class="line"></span><br><span class="line">drop = <span class="literal">true</span>; <span class="comment">// (A)</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ikey.type == kTypeDeletion &amp;&amp;</span><br><span class="line"></span><br><span class="line">ikey.sequence &lt;= compact-&gt;smallest_snapshot &amp;&amp;</span><br><span class="line"></span><br><span class="line">compact-&gt;compaction-&gt;IsBaseLevelForKey(ikey.user_key)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于这个用户密钥：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (1) 高层没有数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (2) 较低层的数据会有较大的序列号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (3) 层中的数据在此处被压缩并具有</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 较小的序列号将在下一个被丢弃</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个循环的几次迭代（根据上面的规则（A））。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因此，此删除标记已过时，可以删除。</span></span><br><span class="line"></span><br><span class="line">drop = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">last_sequence_for_key = ikey.sequence;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>归并排序并且处理完键值信息完成跨层级压缩，之后便是是一些收尾工作，收尾工作需要对于压缩之后的信息统计。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">CompactionStats stats;</span><br><span class="line"></span><br><span class="line">stats.micros = env_-&gt;NowMicros() - start_micros - imm_micros;</span><br><span class="line"><span class="comment">//选择两个层级的SSTable</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> which = <span class="number">0</span>; which &lt; <span class="number">2</span>; which++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; compact-&gt;compaction-&gt;num_input_files(which); i++) &#123;</span><br><span class="line"></span><br><span class="line">stats.bytes_read += compact-&gt;compaction-&gt;input(which, i)-&gt;file_size;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; compact-&gt;outputs.size(); i++) &#123;</span><br><span class="line"></span><br><span class="line">stats.bytes_written += compact-&gt;outputs[i].file_size;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 压缩到更高的层级</span></span><br><span class="line">stats_[compact-&gt;compaction-&gt;level() + <span class="number">1</span>].Add(stats);</span><br><span class="line"><span class="comment">// 注册压缩结果</span></span><br><span class="line">InstallCompactionResults(compact);</span><br><span class="line"><span class="comment">// 压缩信息存储</span></span><br><span class="line">VersionSet::LevelSummaryStorage tmp;</span><br><span class="line">Log(options_.info_log, <span class="string">"compacted to: %s"</span>, versions_-&gt;LevelSummary(&amp;tmp));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> status;</span><br></pre></td></tr></table></figure><p>最后层级压缩的默认层级为<strong>7个层级</strong>，在源代码中有如下定义：</p><p><code>static const int kNumLevels = 7;</code></p><p><strong>小结</strong></p><p>这里我们小结一下合并压缩的两个操作：<code>Minor Compaction</code>和<code>Major Compaction</code>：</p><p><code>Minor Compaction</code>：这个GC主要是Level0层级的一些压缩操作，由于Level0层级被较为频繁使用，类似一级缓存，键值不会强制要求进行排序，所以重叠的键会比较多，整个压缩的过程比较好理解，关键部分是skiplist（跳表）中构建一个新的SSTable并且插入到指定层级。</p><p>注：<code>Minor Compaction</code>进行的时候会暂停<code>Major Compaction</code>操作。</p><p><strong>Minor Compaction</strong>：这个比Minor Compaction复杂不少，不仅包含跨层级压缩，还包括键范围确定和迭代器归并排序和最终的统计信息操作，其中最最关键的部分是归并排序压缩列表，之后将旧文件和新文件合并生产新的<code>VersionSet</code>信息，另外这里除开全局的压缩进度和管理操作之外。</p><p>另外Minor Compaction完成之后还会再尝试一次Minor Compaction，因为Minor Compaction可能带来更多的重复键，所以再进行一次压缩可以进一步提高查找效率。</p><p><strong>Major Compaction</strong>：这个操作需要暂停整个LevelDB的读写，因为此时需要对于整个LevelDb的多层级进行跨层级合并，跨层级压缩要复杂很多，具体的细节会在后面介绍。</p><blockquote><p>这里可以认为是作者在测试的过程发现一种情况并且做的优化。</p></blockquote><p><strong>存储状态 - VersionSet</strong></p><p>从这个对象名称来看直接理解为“版本集合”，在内部通过一个Version的结构体对于键值信息进行“版本控制”，毫无疑问这是由于多线程压缩所带来的特性，所以最终是一个双向链表+历史版本的形式串联，但是永远只有一个版本是当前版本。<br>VersionSet最为频繁也是比较关键的一个操作函数<code>LogAndApply</code>，下面是简化之后的<code>VersionSet::LogAndApply</code>代码：</p><blockquote><p>这里可以对照关系型数据库Mysql的Mvcc中的undo log类比进行理解</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">VersionSet::LogAndApply</span><span class="params">(VersionEdit* edit, port::Mutex* mu)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 更新版本链表信息</span></span><br><span class="line"><span class="keyword">if</span> (!edit-&gt;has_prev_log_number_) &#123;</span><br><span class="line"></span><br><span class="line">edit-&gt;SetPrevLogNumber(prev_log_number_);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">edit-&gt;SetNextFile(next_file_number_);</span><br><span class="line"></span><br><span class="line">edit-&gt;SetLastSequence(last_sequence_);</span><br><span class="line"></span><br><span class="line">Version* v = <span class="keyword">new</span> Version(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">// 构建当前的版本version，委托给建造器进行构建</span></span><br><span class="line"><span class="function">Builder <span class="title">builder</span><span class="params">(<span class="keyword">this</span>, current_)</span></span>;</span><br><span class="line"></span><br><span class="line">builder.Apply(edit);</span><br><span class="line"></span><br><span class="line">builder.SaveTo(v);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键方法：内部通过打分机制确定文件所在的层级，值得注意的是level0的层级确定在源代码中有较多描述</span></span><br><span class="line">Finalize(v);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如有必要，通过创建包含当前版本快照的临时文件来初始化新的描述符日志文件。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> new_manifest_file;</span><br><span class="line"><span class="comment">//  没有理由在这里解锁*mu，因为我们只在第一次调用LogAndApply时（打开数据库时）碰到这个路径。</span></span><br><span class="line">new_manifest_file = DescriptorFileName(dbname_, manifest_file_number_);</span><br><span class="line"><span class="comment">// 写入mainfest文件</span></span><br><span class="line">env_-&gt;NewWritableFile(new_manifest_file, &amp;descriptor_file_);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入版本信息快照</span></span><br><span class="line">WriteSnapshot(descriptor_log_);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把记录写到 MANIFEST中</span></span><br><span class="line"></span><br><span class="line">descriptor_log_-&gt;AddRecord(record);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果创建了新的文件，则将当前版本指向这个文件</span></span><br><span class="line"></span><br><span class="line">SetCurrentFile(env_, dbname_, manifest_file_number_);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册新版本</span></span><br><span class="line"></span><br><span class="line">AppendVersion(v);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Status::OK();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键部分注释已给出，这里的<strong>Mainfest</strong>细节在之前没有提到过，在作者提供的<code>impl.md</code>是这样介绍mainfest的：</p><blockquote><p>MANIFEST 文件列出了组成每个级别的排序表集、相应的键范围和其他重要的元数据。 每当重新打开数据库时，都会创建一个新的 MANIFEST 文件（文件名中嵌入了一个新编号）。 MANIFEST 文件被格式化为日志，并且对服务状态所做的更改（随着文件的添加或删除）被附加到此日志中。</p></blockquote><p>从个人的角度来看，这个文件有点类似BigTable中的元数据<code>Meta</code>。</p><p><strong>SSTable文件格式</strong></p><p>理解这部分不需要急着看源代码，在仓库中的<code>table_format.md</code>的文件中同样有相关描述，这里就直接照搬官方文档翻译了：</p><blockquote><p>leveldb 文件格式<br><beginning_of_file><br>[数据块 1]<br>[数据块 2]<br>…<br>[数据块N]<br>[元块 1]<br>…<br>[元块K]<br>[元索引块]<br>[索引块]<br>[页脚]（固定大小；从 file_size - sizeof(Footer) 开始）<br><end_of_file></p></blockquote><p>我们可以根据描述画一个对应的结构图：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204172242656.png" alt=""></p><p>上面的结构图从上至下的介绍如下：</p><ul><li>数据块：按照LSM-Tree的数据存储规范，按照key/value的顺序形式进行排序，数据块根据<code>block.builder.cc</code>的内部逻辑进行格式化，并且可以选择是否压缩存储。</li><li>元数据块：元数据块和数据块类似也使用<code>block.builder.cc</code>进行格式化，同时可选是否压缩，元数据块后续扩展更多的类型（主要用作数据类型记录）</li><li>“元索引”块：为每个其他元数据块索引，键为元块的名称，值为指向该元块的 BlockHandle。</li><li>“索引块”：包含数据块的索引，键是对应<strong>字符串&gt;=数据块的最后一个键</strong>，并且在连续的数据块的第一个键之前，值是 数据块的 BlockHandle。</li><li>文件的最后是一个固定长度的页脚，其中包含元索引和索引块的 BlockHandle 以及一个<strong>幻数</strong>。</li></ul><blockquote><p>幻数又被称为魔数，比如JAVA的字节码第一个字节8位是<code>CAFEBABE</code>，数值和字节大小没什么意义，更多是作者的兴趣。</p></blockquote><p>注意Footer页脚固定48个字节的大小，我们能在其中拿到 <strong>元索引块</strong> 和 <strong>索引块</strong>的位置，然后通过这两个索引寻找其他值对应的位置。</p><p>更详细的内容可以继续参考<code>table_format.md</code>介绍，这里就不再赘述了。</p><p><strong>TableBuilder</strong>：</p><p>SSTable接口定义于一个<code>TableBuilder</code>构建器当中，<strong>TableBuilder</strong> 提供了用于构建 Table 的接口，关于此接口的定义如下：</p><p>TableBuilder提供了用于建立表的接口  (一个从键到值的不可变和排序的映射)。</p><p>多个线程可以在一个TableBuilder上调用const方法而不需要外部同步。但如果任何一个线程可能调用一个非常量方法，所有访问同一个TableBuilder的线程必须使用外部同步。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TableBuilder 提供了用于构建 Table 的接口</span></span><br><span class="line"><span class="comment">//（从键到值的不可变且排序的映射）。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 多个线程可以在 TableBuilder 上调用 const 方法，而无需</span></span><br><span class="line"><span class="comment">// 外部同步，但如果任何线程可能调用</span></span><br><span class="line"><span class="comment">// 非常量方法，所有访问同一个 TableBuilder 的线程都必须使用</span></span><br><span class="line"><span class="comment">// 外部同步。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LEVELDB_EXPORT</span> <span class="title">TableBuilder</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">TableBuilder(<span class="keyword">const</span> Options&amp; options, WritableFile* file);</span><br><span class="line"></span><br><span class="line">TableBuilder(<span class="keyword">const</span> TableBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">TableBuilder&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> TableBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">改变该构建器所使用的选项。注意：只有部分的</span></span><br><span class="line"><span class="comment">选项字段可以在构建后改变。如果一个字段是</span></span><br><span class="line"><span class="comment">不允许动态变化，并且其在结构中的值</span></span><br><span class="line"><span class="comment">中的值与传递给本方法的结构中的值不同。</span></span><br><span class="line"><span class="comment">结构中的值不同，该方法将返回一个错误</span></span><br><span class="line"><span class="comment">而不改变任何字段。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Status <span class="title">ChangeOptions</span><span class="params">(<span class="keyword">const</span> Options&amp; options)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Flush</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">status</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Finish</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">表示应该放弃这个建设者的内容。停止</span></span><br><span class="line"><span class="comment">在此函数返回后停止使用传递给构造函数的文件。</span></span><br><span class="line"><span class="comment">如果调用者不打算调用Finish()，它必须在销毁此构建器之前调用Abandon()</span></span><br><span class="line"><span class="comment">之前调用Abandon()。</span></span><br><span class="line"><span class="comment">需要。Finish()、Abandon()未被调用。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Abandon</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">NumEntries</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">FileSize</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ok</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> status().ok(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WriteBlock</span><span class="params">(BlockBuilder* block, BlockHandle* handle)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WriteRawBlock</span><span class="params">(<span class="keyword">const</span> Slice&amp; data, CompressionType, BlockHandle* handle)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rep</span>;</span></span><br><span class="line"></span><br><span class="line">Rep* rep_;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>小结</strong>：</p><p>SSTable 相关的设计在整个LevelDB中有着重要的地位和作用，我们介绍了SSTable的多层级合并和压缩的细节，以及两种不同的压缩形式，第一种是针对Level0的简单压缩，简单压缩只需要把存在于内存中的SSTable也就是将Imumemtable压缩到磁盘中存储，特别注意的是这个动作在第一次完成之后通常还会再执行一次，目的是为了防止合并之后产生的。</p><p>另一种是针对频繁Key查询进行的多层级压缩，多层级压缩要比简单压缩复杂许多，但是多层级压缩是提高整个LevelDB写入性能和查询性能到关键。</p><p>最后，从LevelDB中也可以看到很多经典数据结构和算法的实现，比键管理利用了跳表+归并排序的方式提高管理效率，排序的内容不仅利于查询，在存储的时候也有利于数据的顺序扫描。</p><h2 id="Skiplist跳表"><a href="#Skiplist跳表" class="headerlink" title="Skiplist跳表"></a>Skiplist跳表</h2><p>跳表不仅在LevelDb中使用，还在许多其他的中间件中存在实现，这一部分内容将会放到下一篇文章单独介绍。</p><p>压缩文件使用了归并排序的方式进行键合并，而内部的数据库除了归并排序之外还使用了比较关键的[[LSM-Tree - LevelDb Skiplist跳表]]来进行有序键值管理，在了解LevelDB跳表的细节之前，需要先了解跳表这个数据结构的基本概念。</p><p>[[LevelDb跳表实现]]</p><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>Bloom Filter是一种空间效率很高的随机数据结构，它利用位数组很简洁地表示一个集合，并能判断一个元素是否属于这个集合。Bloom Filter的这种高效是有一定代价的：在判断一个元素是否属于某个集合时，有可能会把不属于这个集合的元素误认为属于这个集合（false positive）。因此，Bloom Filter不适合那些“零错误”的应用场合。而在能容忍低错误率的应用场合下，Bloom Filter通过极少的错误换取了存储空间的极大节省。</p><p>leveldb中利用布隆过滤器判断指定的key值是否存在于sstable中，若过滤器表示不存在，则该key一定不存在，由此加快了查找的效率。</p><p>布隆过滤器在不同的开源组件中用的也比较多，所以这里同样放到了一篇单独文章讲解。</p><p>[[LSM-Tree - LevelDb布隆过滤器]]</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>LevelDB的设计还是很有意思的，关键是大部分的代码都有解释和介绍。</p><p>源代码内容很多，但是仔细分析的话不难分析，感谢看到最后。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sZXZlbGRiLWhhbmRib29rLnJlYWR0aGVkb2NzLmlvL3poL2xhdGVzdC9pbmRleC5odG1s" title="https://leveldb-handbook.readthedocs.io/zh/latest/index.html">leveldb-handbook<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kcmF2ZW5lc3MubWUvYmlndGFibGUtbGV2ZWxkYi8=" title="https://draveness.me/bigtable-leveldb/">bigtable-leveldb<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC85ZDgyOTY1NjI4MDY=" title="https://www.jianshu.com/p/9d8296562806">Skip List–跳表（全网最详细的跳表文章没有之一） - 简书 (jianshu.com)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppYW9tZW5nL2FydGljbGUvZGV0YWlscy8xNDk1NTAw" title="https://blog.csdn.net/jiaomeng/article/details/1495500"># Bloom Filter概念和原理<i class="fa fa-external-link"></i></span></li></ul><h1 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h1><ul><li><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDA0MTcyMDIwNQ==" title="https://segmentfault.com/a/1190000041720205">LSM-Tree - LevelDb了解和实现<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDA0MTY1MjAwMw==" title="https://segmentfault.com/a/1190000041652003">《数据密集型型系统设计》LSM-Tree VS BTree<i class="fa fa-external-link"></i></span></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      源码解析
    
    </summary>
    
    
      <category term="数据库-LevelDB" scheme="https://whitestore.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-LevelDB/"/>
    
    
      <category term="数据库" scheme="https://whitestore.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>LSM-Tree - LevelDb 布隆过滤器</title>
    <link href="https://whitestore.top/2022/05/21/leveled-bloom/"/>
    <id>https://whitestore.top/2022/05/21/leveled-bloom/</id>
    <published>2022-05-21T11:07:44.000Z</published>
    <updated>2022-06-02T10:09:44.638Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LSM-Tree-LevelDb布隆过滤器"><a href="#LSM-Tree-LevelDb布隆过滤器" class="headerlink" title="LSM-Tree - LevelDb布隆过滤器"></a>LSM-Tree - LevelDb布隆过滤器</h1><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>布隆过滤器有点类似哈希表，但是比哈希表的效率要更高，因为使用了位来判断Key是否存在，布隆过滤器在完成高效搜索key是否存在的同时带来一定的副作用– <strong>不保证Key一定存在</strong>，所以它只适用于允许一定容错率的系统。</p><p>一句话概括：<code>Bloom Filter</code> 是一个<strong>基于概率的数据结构</strong>，它只能告诉我们一个元素绝对不在集合内或<strong>可能</strong>在集合内。</p><p>布隆过滤器比较悬浮的东西是它不保证元素百分百在一个集合内，所以适用于具备一定容错的业务，关于它的理论和实践很多内容都是参考或者直接摘自网上的资料加上自己的理解，如有错误欢迎指正。</p><a id="more"></a><h1 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h1><p>理论基础相关文章都大同小异，这里归纳自这一篇大神写的文章：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppYW9tZW5nL2FydGljbGUvZGV0YWlscy8xNDk1NTAw" title="https://blog.csdn.net/jiaomeng/article/details/1495500">Bloom Filter概念和原理_jiaomeng的博客-CSDN博客_bloomfilter<i class="fa fa-external-link"></i></span>，简洁易懂，另外建议多参考原始论文，这里很多内容其实也是归纳自老外早已写出来的论文。</p><p>在这个网址中可以通过JS代码查看实际的运行效果：<br><span class="exturl" data-url="aHR0cHM6Ly9sbGltbGxpYi5naXRodWIuaW8vYmxvb21maWx0ZXItdHV0b3JpYWwvemhfQ04v" title="https://llimllib.github.io/bloomfilter-tutorial/zh_CN/">Bloom Filters by Example (llimllib.github.io)<i class="fa fa-external-link"></i></span></p><blockquote><p>注意在案例中使用了<code>Fnv</code>和 <code>Murmur</code> 这两个简单的哈希函数。</p></blockquote><p>对于一个布隆过滤器，通常有如下定义：</p><ol><li>n 个 key。</li><li>m bits 的空间 v，全部初始化为0。</li></ol><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205031233283.png" alt=""></p><ol start="3"><li><p>Bloom Filter 理论建议使用k个相互独立的哈希函数（Hash Function），用于表示<code>S={x1, x2,…,xn}</code>的n个元素的集合，对任意一个元素x，第 i 个哈希函数映射的位置hi(x) 就会被置为1（1≤i≤k）。</p><p> 如果有多个哈希函数位置都为1，那么只有 <strong>第一个哈希结果被使用</strong>。比如下面的图中从左往右数第二个“1”所在的位置就是最终哈希函数选中位置。</p></li></ol><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205031235855.png" alt=""></p><ol start="4"><li><p>为了判断当前的元素是否在集合当中，需要对于当前的元素y进行k次的哈希函数，如果所有的hi(y)次数是1（i &lt;= i &lt;= k中的次数都是1）就认为当前的元素y<strong>可能</strong>在集合中，否则就绝对不存在。</p><p> 以下面的内容y1因为存在hash为0的结果，所以认为不存在于集合，而y2所有的hash都落在1上，可以认为<strong>可能</strong>存在集合。</p></li></ol><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205031927973.png" alt=""></p><p>布隆过滤器的理论内容相对简单，关键部分是哈希函数的选择和错误率的平衡。</p><p><strong>错误率计算</strong></p><p>首先布隆过滤器需要注意bit位长度，也就是数组长度。通常一个大的布隆过滤器会比小的布隆过滤器有更小的错误率。</p><p>误判率的计算公式为：<code>(1-e^(-kn/m))^k</code>。</p><p>推导过程如下，过程不是特别重要，了解最终公式即可：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205032059650.png" alt=""></p><blockquote><p>n为key的个数，m为bits的位数（也就是数组大小）</p></blockquote><p>根据这个公式可以发现，需要先确定可能插入的数据集的容量大小 <em>n</em>, 然后再调整 k 和 <em>m</em> 来为你的应用配置过滤器，m 越大，k 越大， n 越小，那么误判率越小。</p><p>考虑到 p 为设置为0的概率，因此可以认为 m 有一半设置为1，一半设置为0时，误判率最低，注意这句话在最后的推导部分会详细介绍。</p><p><strong>多少个哈希函数？</strong></p><p>根据错误率计算结论，这里又有一个问题，就是究竟应该选择多少个哈希函数，哈希函数的过多容易导致计算效率降低影响性能，太少又会让误判率升高。</p><p>高兴的是，这个公式也有人推导出来了：</p><p><strong>hash 函数 k 的最优个数为 ln2 * (m/n)</strong>。</p><p>可以通过以下的步骤来确定 Bloom filter 的大小:</p><ol><li>确定 <em>n</em> 的变动范围</li><li>选定 <em>m</em> 的值</li><li>计算 <em>k</em> 的最优值</li><li>对于给定的n, <em>m</em>,  k计算错误率。如果这个错误率不能接受，那么回到第二步，否则结束</li></ol><p><strong>Bloom filter 的时间复杂度和空间复杂度?</strong></p><p>插入和测试操作的时间复杂度都是 O(k)，这是因为如果想要插入或者查询一个元素，只需要对于元素进行k次数的函数运算。</p><p>空间复杂度就比较难以估算了，因为误差率的存在，大小是难以确定的，如果难以估算一个过滤器的大小，最好选择一个哈希表或者一个可拓展的 Bloom filter。</p><blockquote><p>注意⚠️：LevelDB的过滤器大小是不能少于64位的bit数组。</p></blockquote><p><strong>m中多少位数为1合适</strong></p><p>直接记住结论：<strong>可以认为 m 有一半设置为1，一半设置为0时，误判率最低</strong>。</p><h1 id="levelDB实现"><a href="#levelDB实现" class="headerlink" title="levelDB实现"></a>levelDB实现</h1><p>LevelDB的布隆过滤器精髓在哈希函数上，它通过一个哈希达到多个哈希的性能，同时保证误判率在一定的限制。</p><p>具体的代码实现可以阅读<strong>bloom.cc</strong>：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9sZXZlbGRiL2Jsb2IvbWFpbi91dGlsL2Jsb29tX3Rlc3QuY2M=" title="https://github.com/google/leveldb/blob/main/util/bloom_test.cc">leveldb/bloom_test.cc at main · google/leveldb · GitHub<i class="fa fa-external-link"></i></span></p><h2 id="index-md介绍"><a href="#index-md介绍" class="headerlink" title="index.md介绍"></a>index.md介绍</h2><p>这里先不深入源代码，先看看作者在<code>index.md</code>是如何解释的：<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9sZXZlbGRiL2Jsb2IvbWFpbi9kb2MvaW5kZXgubWQjZmlsdGVycw==" title="https://github.com/google/leveldb/blob/main/doc/index.md#filters">leveldb/index.md at main · google/leveldb · GitHub<i class="fa fa-external-link"></i></span></p><p>由于leveldb数据在磁盘上的组织方式，一个<code>Get()</code>的调用可能涉及到从磁盘上多次读取，所以可选的<code>FilterPolicy</code>机制可以被用来可以用来大大减少磁盘读取的次数，其实这里就是指的使用布隆过滤器提高过滤效率。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">leveldb::Options options;</span><br><span class="line"></span><br><span class="line">options.filter_policy = NewBloomFilterPolicy(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">leveldb::DB* db;</span><br><span class="line"></span><br><span class="line">leveldb::DB::Open(options, <span class="string">"/tmp/testdb"</span>, &amp;db);</span><br><span class="line"></span><br><span class="line">... use the database ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> db;</span><br><span class="line"><span class="comment">// 注意，关闭leveldb的时候需要手动释放过滤器所占用内存空间</span></span><br><span class="line"><span class="keyword">delete</span> options.filter_policy;</span><br></pre></td></tr></table></figure><p>前面的代码将基于布隆过滤器的过滤策略与数据库联系起来。 </p><p>基于布隆过滤器的过滤依赖于在内存中为每个密钥保留一定数量的数据（本例中每个密钥为10bits，因为这是我们传递给<code>NewBloomFilterPolicy</code>的参数）。</p><p>这个过滤器将减少<code>Get()</code>调用所需的不必要的磁盘IO次数，提升效率大约是<strong>100倍</strong>。增加每一个key的位数将导致更大的减少，但<strong>代价占用是更多的内存</strong>。我们建议那些工作集不适合放在内存中的应用程序不适合在内存中使用，并且进行大量随机读取的应用程序设置一个过滤策略。</p><h2 id="FilterPolicy"><a href="#FilterPolicy" class="headerlink" title="FilterPolicy"></a>FilterPolicy</h2><p>整个过滤器通过对外的接口<code>FilterPolicy</code>，目的是减少<code>DB::Get()</code>函数调用时间，通常内部默认使用布隆过滤器。</p><p>下面是接口定义的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Slice</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LEVELDB_EXPORT</span> <span class="title">FilterPolicy</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> ~FilterPolicy();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return the name of this policy. Note that if the filter encoding</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// changes in an incompatible way, the name returned by this method</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// must be changed. Otherwise, old incompatible filters may be</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// passed to methods of this type.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回该策略的名称。注意如果过滤器的编码变化，此方法返回的名称必须被改变。否则不兼容旧的过滤器可能被传递给这种类型的方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">Name</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// keys[0,n-1] contains a list of keys (potentially with duplicates)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// that are ordered according to the user supplied comparator.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Append a filter that summarizes keys[0,n-1] to *dst.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Warning: do not change the initial contents of *dst. Instead,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// append the newly constructed filter to *dst.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* keys[0,n-1] 包含一个键的列表（可能有重复的）。根据用户提供的比较器进行排序。将一个总结keys[0,n-1]的过滤器追加到*dst。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 警告：不要改变*dst的初始内容。 相反将新构建的过滤器追加到*dst中。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">CreateFilter</span><span class="params">(<span class="keyword">const</span> Slice* keys, <span class="keyword">int</span> n,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="built_in">std</span>::<span class="built_in">string</span>* dst)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// "filter" contains the data appended by a preceding call to</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CreateFilter() on this class. This method must return true if</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the key was in the list of keys passed to CreateFilter().</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This method may return true or false if the key was not on the</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// list, but it should aim to return false with a high probability.</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> "filter "包含了前面对这个类的CreateFilter()的调用所附加的数据。如果键在传递给CreateFilter()的键列表中，该方法必须返回true。如果键不在列表中，该方法可能会返回true或false，但它应该以返回false的概率大为目标。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">KeyMayMatch</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; filter)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这一部分注释较多，放到后文介绍</span></span><br><span class="line"></span><br><span class="line"><span class="function">LEVELDB_EXPORT <span class="keyword">const</span> FilterPolicy* <span class="title">NewBloomFilterPolicy</span><span class="params">(<span class="keyword">int</span> bits_per_key)</span></span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace leveldb</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// STORAGE_LEVELDB_INCLUDE_FILTER_POLICY_H_</span></span></span><br></pre></td></tr></table></figure><h2 id="bloom-cc"><a href="#bloom-cc" class="headerlink" title="bloom.cc"></a>bloom.cc</h2><p>关于具体的代码解释放在了注释当中，比较值得关注的是创建过滤器的部分以及哈希函数的部分，这部分介绍的是过滤器本身的源代码，关键的哈希函数放到了下面的小节。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright (c) 2012 The LevelDB Authors. All rights reserved.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style license that can be</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// found in the LICENSE file. See the AUTHORS file for names of contributors.</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"leveldb/filter_policy.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"leveldb/Slice.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"util/hash.h"</span></span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint32_t</span> <span class="title">BloomHash</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 注意 0xbc9f1d34</span></span><br><span class="line"><span class="keyword">return</span> Hash(key.data(), key.size(), <span class="number">0xbc9f1d34</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BloomFilterPolicy</span> :</span> <span class="keyword">public</span> FilterPolicy &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">BloomFilterPolicy</span><span class="params">(<span class="keyword">int</span> bits_per_key)</span> : <span class="title">bits_per_key_</span><span class="params">(bits_per_key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We intentionally round down to reduce probing cost a little bit</span></span><br><span class="line"><span class="comment">// 我们有意四舍五入，以减少一点探测成本</span></span><br><span class="line">k_ = <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(bits_per_key * <span class="number">0.69</span>); <span class="comment">// 0.69 =~ ln(2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (k_ &lt; <span class="number">1</span>) k_ = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (k_ &gt; <span class="number">30</span>) k_ = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">Name</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">"leveldb.BuiltinBloomFilter2"</span>; &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateFilter</span><span class="params">(<span class="keyword">const</span> Slice* keys, <span class="keyword">int</span> n, <span class="built_in">std</span>::<span class="built_in">string</span>* dst)</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compute bloom filter size (in both bits and bytes)</span></span><br><span class="line"><span class="comment">// 计算布过滤器的大小（包括比特和字节）。</span></span><br><span class="line"><span class="keyword">size_t</span> bits = n * bits_per_key_;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// For small n, we can see a very high false positive rate. Fix it</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// by enforcing a minimum bloom filter length.</span></span><br><span class="line"><span class="comment">// 对于小的n，我们可以看到一个非常高的误判率。通过强制执行最小Bloom filter长度来解决这个问题。</span></span><br><span class="line"><span class="comment">// tip: 这里就是之前说的如果bit位数过小会增加误判率</span></span><br><span class="line"><span class="keyword">if</span> (bits &lt; <span class="number">64</span>) bits = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> bytes = (bits + <span class="number">7</span>) / <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 至少有64个bits</span></span><br><span class="line">bits = bytes * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> init_size = dst-&gt;size();</span><br><span class="line"><span class="comment">// 调整容器的大小，使其包含_n个_元素。</span></span><br><span class="line">dst-&gt;resize(init_size + bytes, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">dst-&gt;push_back(<span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(k_)); <span class="comment">// Remember # of probes in filter</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* <span class="built_in">array</span> = &amp;(*dst)[init_size];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use double-hashing to generate a sequence of hash values.</span></span><br><span class="line"><span class="comment">// See analysis in [Kirsch,Mitzenmacher 2006].</span></span><br><span class="line"><span class="comment">// 使用双重哈希法生成一连串的哈希值。见[Kirsch,Mitzenmacher 2006]中的分析。</span></span><br><span class="line"><span class="comment">// tips: 原始论文请看参考资料 -&gt; LNCS 4168 - Less Hashing, Same Performance: Building a Better Bloom Filter (harvard.edu)</span></span><br><span class="line"><span class="keyword">uint32_t</span> h = BloomHash(keys[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> delta = (h &gt;&gt; <span class="number">17</span>) | (h &lt;&lt; <span class="number">15</span>); <span class="comment">// // 向右旋转17位</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; k_; j++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> bitpos = h % bits;</span><br><span class="line"></span><br><span class="line"><span class="built_in">array</span>[bitpos / <span class="number">8</span>] |= (<span class="number">1</span> &lt;&lt; (bitpos % <span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">h += delta;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">关键函数：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">KeyMayMatch</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; bloom_filter)</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> len = bloom_filter.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有1位的过滤器无意义</span></span><br><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="built_in">array</span> = bloom_filter.data();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> bits = (len - <span class="number">1</span>) * <span class="number">8</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// Use the encoded k so that we can read filters generated by</span></span><br><span class="line"><span class="comment">// bloom filters created using different parameters.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用编码的k，这样我们就可以读取由 使用不同参数创建的bloom过滤器。</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> k = <span class="built_in">array</span>[len - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (k &gt; <span class="number">30</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 超过我们设定 k 个数，直接返回 true，不滤掉该 SSTable.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Reserved for potentially new encodings for short bloom filters.</span></span><br><span class="line"><span class="comment">// Consider it a match.</span></span><br><span class="line"><span class="comment">// 保留给可能出现的新编码的短Bloom过滤器。认为它是一种匹配。</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键：哈希函数</span></span><br><span class="line"><span class="keyword">uint32_t</span> h = BloomHash(key);</span><br><span class="line"><span class="comment">// 右旋17位</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> delta = (h &gt;&gt; <span class="number">17</span>) | (h &lt;&lt; <span class="number">15</span>); <span class="comment">// Rotate right 17 bits</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> bitpos = h % bits;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">array</span>[bitpos / <span class="number">8</span>] &amp; (<span class="number">1</span> &lt;&lt; (bitpos % <span class="number">8</span>))) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">h += delta;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> bits_per_key_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> k_;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 新的布隆过滤器策略（请看下文注释）</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> FilterPolicy* <span class="title">NewBloomFilterPolicy</span><span class="params">(<span class="keyword">int</span> bits_per_key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> BloomFilterPolicy(bits_per_key);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace leveldb</span></span><br></pre></td></tr></table></figure><p><strong>NewBloomFilterPolicy</strong>函数</p><p>为什么叫做新的布隆过滤器策略，可以看作者所给的注释：</p><blockquote><p>返回一个新的过滤策略，该策略使用一个Bloom过滤器，每个密钥大约有指定的每个密钥的比特数。键的比特数是10。<br>最终测试最佳值是10，这将产生一个误报率为1%的过滤器。</p></blockquote><p>注意使用之后必须要<strong>手动</strong>释放掉相关对象内存：</p><blockquote><p>调用者必须在使用该结果的<strong>任何数据库关闭后删除该结果</strong>，数据库被关闭后，调用者必须删除该结果。</p></blockquote><p>如果使用的是自定义的比较器，它忽略了被比较的键的某些部分以及被比较的键的某些部分，这时候不允许使用<code>NewBloomFilterPolicy()</code>，而必须提供自定义的<code>FilterPolicy</code>实现，因为原始的过滤器它也忽略了键的相应部分。</p><p>例如，如果<strong>比较器忽略了尾部的空格</strong>，那么使用一个的<code>FilterPolicy</code>（比如<code>NewBloomFilterPolicy</code>），原始对<code>FilterPolicy（如NewBloomFilterPolicy）</code>行为就会出现失误，因为它<strong>不会忽略键的尾部空格</strong>。</p><h2 id="hash-cc"><a href="#hash-cc" class="headerlink" title="hash.cc"></a>hash.cc</h2><p>之前说过关键的代码其中之一是优质的哈希函数，下面是<code>hash.cc</code>的相关代码：</p><p>注意这里的哈希函数使用的伪随机数种子为<code>0xbc9f1d34</code>，对应的10进制为<code>9134</code>。</p><p>这里也可以看到LevelDB利用自己的优质哈希函数，使得一个函数取代N个函数的效果，这算是对理论的调整，内部也控制levelDB长度最少为64个bit位。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">data：bit 位数</span></span><br><span class="line"><span class="comment">n：n 个 key</span></span><br><span class="line"><span class="comment">seed：种子，实际固定为 0xbc9f1d34</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">Hash</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* data, <span class="keyword">size_t</span> n, <span class="keyword">uint32_t</span> seed)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Similar to murmur hash</span></span><br><span class="line"><span class="comment">// 类似杂音哈希</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> m = <span class="number">0xc6a4a793</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> r = <span class="number">24</span>;</span><br><span class="line"><span class="comment">// limit指向了char*数组的最后一个位置的下一个位置，类似于迭代器end()</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* limit = data + n;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">uint32_t</span> h = seed ^ (n * m);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pick up four bytes at a time</span></span><br><span class="line"><span class="comment">// 以4个字节作为一次解析</span></span><br><span class="line"><span class="keyword">while</span> (data + <span class="number">4</span> &lt;= limit) &#123;</span><br><span class="line"><span class="comment">//  每次解码前4个字节，直到最后剩下小于4个字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DecodeFixed32 低级别的Get...版本，直接从字符缓冲区读取 而不进行任何边界检查，最近的clang和gcc将其优化为一条 mov / ldr 指令。</span></span><br><span class="line"><span class="keyword">uint32_t</span> w = DecodeFixed32(data);</span><br><span class="line"></span><br><span class="line">data += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">h += w;</span><br><span class="line"></span><br><span class="line">h *= m;</span><br><span class="line"></span><br><span class="line">h ^= (h &gt;&gt; <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pick up remaining bytes</span></span><br><span class="line"><span class="comment">// 处理剩余的字节</span></span><br><span class="line"><span class="keyword">switch</span> (limit - data) &#123;</span><br><span class="line"><span class="comment">// 将剩下的字节转化到uint32_t里面</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="comment">// static_cast 表示的是良性转换，含义表示</span></span><br><span class="line">h += <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(data[<span class="number">2</span>]) &lt;&lt; <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FALLTHROUGH_INTENDED宏可以用来注解开关标签之间的隐性落差。真正的定义应该由外部提供。 这个是为不支持的编译器提供的后备版本。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#ifndef FALLTHROUGH_INTENDED</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#define FALLTHROUGH_INTENDED \</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">do &#123; \</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125; while (0)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">FALLTHROUGH_INTENDED;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">h += <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(data[<span class="number">1</span>]) &lt;&lt; <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">FALLTHROUGH_INTENDED;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">h += <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(data[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">h *= m;</span><br><span class="line"></span><br><span class="line">h ^= (h &gt;&gt; r);</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> h;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Slice-h"><a href="#Slice-h" class="headerlink" title="Slice.h"></a>Slice.h</h2><p>可以看作类似Redis的简单字符串sds设计，只不过语言使用的是c++。</p><p>相关解释可以阅读文档：</p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9sZXZlbGRiL2Jsb2IvbWFpbi9kb2MvaW5kZXgubWQjU2xpY2U=" title="https://github.com/google/leveldb/blob/main/doc/index.md#Slice">leveldb/index.md at main · google/leveldb · GitHub<i class="fa fa-external-link"></i></span></p><p>Slice 是一个简单的数据结构，包含一个进入一些外部存储的指针和size。 Slice的用户必须确保在相应的外部存储被取消分配后不使用该Slice（用完必须手动释放内存）。</p><p>多个线程可以在一个Slice上调用<strong>const方法</strong>而不需要外部同步（线程安全对象），但如果任何一个线程可能会调用非const方法，所有访问同一Slice的线程都必须使用外部同步。</p><p>C++ 或者类C的 字符串可以简单的转化为Slice：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">leveldb::Slice s1 = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">"world"</span>)</span></span>;</span><br><span class="line">leveldb::Slice s2 = str;</span><br></pre></td></tr></table></figure><p>反过来也是一样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str = s1.ToString();</span><br><span class="line">assert(str == <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"hello"</span>));</span><br></pre></td></tr></table></figure><p>在使用Slice时要小心因为要由调用者来确保Slice所指向的外部字节数组在Slice使用时保持有效。例如，下面的例子是错误的：</p><p>下面的例子中Slice将可能指向一个外部的引用，同时不保证外部引用存在。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">leveldb::Slice Slice;</span><br><span class="line"><span class="keyword">if</span> (...) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> str = ...;</span><br><span class="line">  Slice = str;</span><br><span class="line">&#125;</span><br><span class="line">Use(Slice);</span><br></pre></td></tr></table></figure><p>当if语句超出范围时，str将被销毁，Slice的存储内容将消失。</p><h1 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h1><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>作者编写的单元测试可以更为直观的看到具体效果，路径为：<code>/leveldb-main/util/bloom_test.cc</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright (c) 2012 The LevelDB Authors. All rights reserved.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style license that can be</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// found in the LICENSE file. See the AUTHORS file for names of contributors.</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"gtest/gtest.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"leveldb/filter_policy.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"util/coding.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"util/logging.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"util/testutil.h"</span></span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kVerbose = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Slice <span class="title">Key</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">char</span>* buffer)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">EncodeFixed32(buffer, i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Slice(buffer, <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BloomTest</span> :</span> <span class="keyword">public</span> testing::Test &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">BloomTest() : policy_(NewBloomFilterPolicy(<span class="number">10</span>)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">~BloomTest() &#123; <span class="keyword">delete</span> policy_; &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">keys_.clear();</span><br><span class="line"></span><br><span class="line">filter_.clear();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">const</span> Slice&amp; s)</span> </span>&#123; keys_.push_back(s.ToString()); &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Build</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Slice&gt; key_Slices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; keys_.size(); i++) &#123;</span><br><span class="line"></span><br><span class="line">key_Slices.push_back(Slice(keys_[i]));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter_.clear();</span><br><span class="line"></span><br><span class="line">policy_-&gt;CreateFilter(&amp;key_Slices[<span class="number">0</span>], <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(key_Slices.size()),</span><br><span class="line"></span><br><span class="line">&amp;filter_);</span><br><span class="line"></span><br><span class="line">keys_.clear();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (kVerbose &gt;= <span class="number">2</span>) DumpFilter();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">FilterSize</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> filter_.size(); &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DumpFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"F("</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; filter_.size(); i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> c = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(filter_[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%c"</span>, (c &amp; (<span class="number">1</span> &lt;&lt; j)) ? <span class="string">'1'</span> : <span class="string">'.'</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">")\n"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 匹配</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Matches</span><span class="params">(<span class="keyword">const</span> Slice&amp; s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!keys_.empty()) &#123;</span><br><span class="line"></span><br><span class="line">Build();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> policy_-&gt;KeyMayMatch(s, filter_);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">FalsePositiveRate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buffer[<span class="keyword">sizeof</span>(<span class="keyword">int</span>)];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Matches(Key(i + <span class="number">1000000000</span>, buffer))) &#123;</span><br><span class="line"></span><br><span class="line">result++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result / <span class="number">10000.0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> FilterPolicy* policy_;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> filter_;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; keys_;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">TEST_F(BloomTest, EmptyFilter) &#123;</span><br><span class="line"></span><br><span class="line">ASSERT_TRUE(!Matches(<span class="string">"hello"</span>));</span><br><span class="line"></span><br><span class="line">ASSERT_TRUE(!Matches(<span class="string">"world"</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">TEST_F(BloomTest, Small) &#123;</span><br><span class="line"></span><br><span class="line">Add(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">Add(<span class="string">"world"</span>);</span><br><span class="line"></span><br><span class="line">ASSERT_TRUE(Matches(<span class="string">"hello"</span>));</span><br><span class="line"></span><br><span class="line">ASSERT_TRUE(Matches(<span class="string">"world"</span>));</span><br><span class="line"></span><br><span class="line">ASSERT_TRUE(!Matches(<span class="string">"x"</span>));</span><br><span class="line"></span><br><span class="line">ASSERT_TRUE(!Matches(<span class="string">"foo"</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">NextLength</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (length &lt; <span class="number">10</span>) &#123;</span><br><span class="line"></span><br><span class="line">length += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (length &lt; <span class="number">100</span>) &#123;</span><br><span class="line"></span><br><span class="line">length += <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (length &lt; <span class="number">1000</span>) &#123;</span><br><span class="line"></span><br><span class="line">length += <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">length += <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> length;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">TEST_F(BloomTest, VaryingLengths) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buffer[<span class="keyword">sizeof</span>(<span class="keyword">int</span>)];</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// Count number of filters that significantly exceed the false positive rate</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mediocre_filters = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> good_filters = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> length = <span class="number">1</span>; length &lt;= <span class="number">10000</span>; length = NextLength(length)) &#123;</span><br><span class="line"></span><br><span class="line">Reset();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line"></span><br><span class="line">Add(Key(i, buffer));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Build();</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">ASSERT_LE(FilterSize(), <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;((length * <span class="number">10</span> / <span class="number">8</span>) + <span class="number">40</span>))</span><br><span class="line"></span><br><span class="line">&lt;&lt; length;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// All added keys must match</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line"></span><br><span class="line">ASSERT_TRUE(Matches(Key(i, buffer)))</span><br><span class="line"></span><br><span class="line">&lt;&lt; <span class="string">"Length "</span> &lt;&lt; length &lt;&lt; <span class="string">"; key "</span> &lt;&lt; i;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// Check false positive rate</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> rate = FalsePositiveRate();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (kVerbose &gt;= <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">"False positives: %5.2f%% @ length = %6d ; bytes = %6d\n"</span>,</span><br><span class="line"></span><br><span class="line">rate * <span class="number">100.0</span>, length, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(FilterSize()));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ASSERT_LE(rate, <span class="number">0.02</span>); <span class="comment">// Must not be over 2%</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rate &gt; <span class="number">0.0125</span>)</span><br><span class="line"></span><br><span class="line">mediocre_filters++; <span class="comment">// Allowed, but not too often</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">good_filters++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (kVerbose &gt;= <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Filters: %d good, %d mediocre\n"</span>, good_filters,</span><br><span class="line"></span><br><span class="line">mediocre_filters);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ASSERT_LE(mediocre_filters, good_filters / <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// Different bits-per-byte</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace leveldb</span></span><br></pre></td></tr></table></figure><h2 id="c-语法"><a href="#c-语法" class="headerlink" title="c++语法"></a>c++语法</h2><p>补充：<br>个人并没有学过C++，所以这部分补充一些不理解的关键字和语法含义。</p><p><strong>explicit</strong></p><p><span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzJTNBLy96aC5jcHByZWZlcmVuY2UuY29tL3cvY3BwL2xhbmd1YWdlL2V4cGxpY2l0" title="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/language/explicit">C++ 参考手册<i class="fa fa-external-link"></i></span>如下解释：</p><ul><li><code>explicit</code>修饰的构造函数不能被隐式调用。</li><li>禁止类对象之间的隐式转换。</li></ul><p>这篇文章我们关注的就是第一点：<strong>构造函数被<code>explicit</code>修饰后, 就不能再被隐式调用了</strong>。</p><p>这里用了网上相关的案例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Explicit</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Explicit(<span class="keyword">int</span> <span class="built_in">size</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" the size is "</span> &lt;&lt; <span class="built_in">size</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Explicit(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> _str = str;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" the str is "</span> &lt;&lt; _str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Explicit(<span class="keyword">const</span> Explicit&amp; ins)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" The Explicit is ins"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Explicit(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" the a is "</span> &lt;&lt; a  &lt;&lt; <span class="string">" the b is "</span> &lt;&lt; b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Explicit <span class="title">test0</span><span class="params">(<span class="number">15</span>)</span></span>;</span><br><span class="line">    Explicit test1 = <span class="number">10</span>;<span class="comment">// 隐式调用Explicit(int size)</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Explicit <span class="title">test2</span><span class="params">(<span class="string">"RIGHTRIGHT"</span>)</span></span>;</span><br><span class="line">    Explicit test3 = <span class="string">"BUGBUGBUG"</span>;<span class="comment">// 隐式调用Explicit(const char* str)</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Explicit <span class="title">test4</span><span class="params">(<span class="number">1</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    Explicit test5 = test1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然程序没有错误，但是把一个<code>int</code>类型或者<code>const char*</code>类型的变量赋值给<code>Explicit</code>类型的变量看起来总归不是很好，并且一旦使用出错很难排查，所以这时候构造函数被<code>explicit</code>修饰后, 就不能再被隐式调用了，添加关键字之后的效果不演示了，加上之后整个程序是无法通过编译的。</p><p>吐槽：很神经病的东西，在过去的版本中使用隐式调用提高编码效率，结果后面发现坑太大挖坑自己填。</p><p><strong>resize函数</strong></p><p>直接看下面的案例更容易理解：</p><ul><li>myvector.resize(5);<br>将原来有10个数的vector数组，调整为5个数的长度，多余的数删掉，释放内存。 <strong>5 &lt; 10 减小数组长度</strong></li><li>myvector.resize(8,100);<br>将5个数长度的vector数组的长度调整为8，不够的数用100来填补，即增加了3个100。 <strong>8 &gt; 5 增大数组长度，指定填充元素</strong></li><li>myvector.resize(12);<br>将8个数长度的vector数组的长度调整为12，用0默认填补，即增加了4个0。 <strong>12 &gt; 8 增大数组长度，未指定填充元素</strong></li></ul><h2 id="数学推导"><a href="#数学推导" class="headerlink" title="数学推导"></a>数学推导</h2><p>推导部分给想要更加深入了解的人，可以直接记住上面的结论，看不懂也没关系。</p><p>下面的大部分内容来自论文根据 <span class="exturl" data-url="aHR0cDovL3d3dy5lZWNzLmhhcnZhcmQuZWR1L35taWNoYWVsbS9wb3N0c2NyaXB0cy9lc2EyMDA2YS5wZGY=" title="http://www.eecs.harvard.edu/~michaelm/postscripts/esa2006a.pdf">LNCS 4168 - Less Hashing, Same Performance: Building a Better Bloom Filter (harvard.edu)<i class="fa fa-external-link"></i></span> 翻译。</p><blockquote><p> <code>false position</code>：误判率，也就是随着哈希和为1的bit位增加导致的误判率上升。</p></blockquote><p>根据 bloom filter 的组成，对一个指定的 bit，其被设置为0、1的概率分别为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P(<span class="number">1</span>) = <span class="number">1</span>/m</span><br><span class="line">P(<span class="number">0</span>) = <span class="number">1</span> - <span class="number">1</span>/m</span><br></pre></td></tr></table></figure><p>k 个 hash 函数，该 bit 设置为 0 的概率为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P<span class="number">'</span>(<span class="number">0</span>) = P(<span class="number">0</span>) ** k = (<span class="number">1</span> - <span class="number">1</span>/m) ** k</span><br></pre></td></tr></table></figure><p>再经过 n 个 key，该 bit 设置为 0 的概率为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P<span class="number">''</span>(<span class="number">0</span>) = P<span class="number">'</span>(<span class="number">0</span>) ** n = (<span class="number">1</span> - <span class="number">1</span>/m) ** kn</span><br></pre></td></tr></table></figure><p>根据自然对数e的公式：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041413726.png" alt=""></p><p>我们可以近似计算前面的<code>P&#39;&#39;(0)</code></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041414674.png" alt=""></p><p>关于自然对数 e 的值，可以看下面的内容:</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041327457.png" alt=""></p><p>当检测某个实际不存在的 key 时，满足条件：</p><p>其对应的 k 个 bit 恰好都设置为了1，此时即 false positive 的场景。</p><p>概率为：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041418134.png" alt=""></p><p>问题是，怎么最小化 false_positive 呢？</p><p>为了简化描述，先定义 p (即<code>P&#39;&#39;(0)</code>：某个 bit 设置为0的概率)：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041423865.png" alt=""></p><p>根据公式推导：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041424497.png" alt=""></p><p>底数是 e，为固定值，那么最小化 false_positive_rate 即为最小化指数</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041424841.png" alt=""></p><p>根据之前的计算结果，我们可以做下面的变形：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041431847.png" alt=""></p><p>最终得到结果 g：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041431129.png" alt=""></p><p>根据对称性，当 <code>p = 1/2</code> 时，f 取得最小值。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041435792.png" alt=""></p><p>此时k、f最小值为：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041436632.png" alt=""></p><p>最终的推导结果：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041441884.png" alt=""></p><p>考虑到 p 为设置为0的概率，因此<strong>可以认为 m 有一半设置为1，一半设置为0时，误判率最低</strong>。</p><p><code>false position</code>和m/n、k 的组合关系表例子可以下面的截图：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041219187.png" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Bloom Filter 通常用于快速判断某个元素是否在集合中。其本质上容忍一定的错误率来换取时空的高效性。</p><p>对于LevelDB的意义：在哈希表的基础上省下了冲突处理部分，LevelDB 在实现时使用了某种优化：<strong>利用一个哈希函数来达到近似 k 个哈希函数的效果</strong>。这样做实现了高效的并发写入同时不会牺牲过多的性能。</p><p>LevelDB除开哈希函数和针对并发写入的优化部分之外，其他部分都非常贴合布隆过滤器的理论基础，也是优秀的学习案例，作为C++版本的过滤器生产案例应用也是一个不错的参考范本。</p><p>最后，有问题找布隆准没错。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>下面的资料绝对能让你吃透布隆过滤器。</p><blockquote><p>公众号请“阅读原文”获取访问链接。</p></blockquote><ul><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppYW9tZW5nL2FydGljbGUvZGV0YWlscy8xNDk1NTAw" title="https://blog.csdn.net/jiaomeng/article/details/1495500">Bloom Filter概念和原理_jiaomeng的博客-CSDN博客_bloomfilter<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sbGltbGxpYi5naXRodWIuaW8vYmxvb21maWx0ZXItdHV0b3JpYWwvemhfQ04v" title="https://llimllib.github.io/bloomfilter-tutorial/zh_CN/">Bloom Filters by Example (llimllib.github.io)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2MuYmlhbmNoZW5nLm5ldC9jcHAvYmlhbmNoZW5nL3ZpZXcvMzI5Ny5odG1s" title="http://c.biancheng.net/cpp/biancheng/view/3297.html">C++四种类型转换运算符：static_cast、dynamic_cast、const_cast和reinterpret_cast_C语言中文网 (biancheng.net)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5lZWNzLmhhcnZhcmQuZWR1L35taWNoYWVsbS9wb3N0c2NyaXB0cy9lc2EyMDA2YS5wZGY=" title="http://www.eecs.harvard.edu/~michaelm/postscripts/esa2006a.pdf">LNCS 4168 - Less Hashing, Same Performance: Building a Better Bloom Filter (harvard.edu)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9sZXZlbGRiL2Jsb2IvbWFpbi9kb2MvaW5kZXgubWQjZmlsdGVycw==" title="https://github.com/google/leveldb/blob/main/doc/index.md#filters">leveldb/index.md at main · google/leveldb · GitHub<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5lZWNzLmhhcnZhcmQuZWR1L35taWNoYWVsbS9wb3N0c2NyaXB0cy9pbTIwMDViLnBkZg==" title="http://www.eecs.harvard.edu/~michaelm/postscripts/im2005b.pdf">im2005b.pdf (harvard.edu)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5lZWNzLmhhcnZhcmQuZWR1L35taWNoYWVsbS9wb3N0c2NyaXB0cy90b24yMDAyLnBkZg==" title="http://www.eecs.harvard.edu/~michaelm/postscripts/ton2002.pdf">Compressed bloom filters - Networking, IEEE/ACM Transactions on (harvard.edu)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9penVhbHpoeS5jbi9sZXZlbGRiLWJsb29tLWZpbHRlcg==" title="https://izualzhy.cn/leveldb-bloom-filter">leveldb笔记之9:bloom filter - Ying’s Blog (izualzhy.cn)<i class="fa fa-external-link"></i></span></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      有问题找布隆
    
    </summary>
    
    
      <category term="数据库-LevelDB" scheme="https://whitestore.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-LevelDB/"/>
    
    
      <category term="数据库" scheme="https://whitestore.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>14岁懂社会-《被你讨厌的昆虫们》读书笔记</title>
    <link href="https://whitestore.top/2022/05/21/bntydkcm/"/>
    <id>https://whitestore.top/2022/05/21/bntydkcm/</id>
    <published>2022-05-21T10:57:38.000Z</published>
    <updated>2022-06-02T10:09:44.584Z</updated>
    
    <content type="html"><![CDATA[<h1 id="14岁懂社会-《被你讨厌的昆虫们》读书笔记"><a href="#14岁懂社会-《被你讨厌的昆虫们》读书笔记" class="headerlink" title="14岁懂社会-《被你讨厌的昆虫们》读书笔记"></a>14岁懂社会-《被你讨厌的昆虫们》读书笔记</h1><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p><strong>曾经为之讨厌的东西，实际接触之后才发现那么多喜爱</strong>，这是看完这本书之后感触最深的一句话。对于作者来说昆虫们因为不被人接受逐渐淡出视野惋惜，真正喜爱的人才能发现昆虫的魅力。个人观察过最多的动物大概是蚂蚁的，不知道为什么特别喜欢蚂蚁搬东西的场景，每次看到这样的画面都会忍不住看上几眼或者放空电脑盯上很久。</p><p>最后作者提到的《生之欲》这部电影倒是意外收获，打算后续无聊打发时间的时候看看。</p><p>《<strong>生之欲</strong>》（日语：生きる）在<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JUE2JTk5JUU2JUI4JUFG" title="https://zh.wikipedia.org/wiki/%E9%A6%99%E6%B8%AF">香港<i class="fa fa-external-link"></i></span>译作《<strong>流芳颂</strong>》，乃是1952年由<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTk3JUE1JUU2JTlDJUFD" title="https://zh.wikipedia.org/wiki/%E6%97%A5%E6%9C%AC">日本<i class="fa fa-external-link"></i></span>知名<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUIwJThFJUU2JUJDJTk0" title="https://zh.wikipedia.org/wiki/%E5%B0%8E%E6%BC%94">导演<i class="fa fa-external-link"></i></span><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JUJCJTkxJUU2JUJFJUE0JUU2JTk4JThF" title="https://zh.wikipedia.org/wiki/%E9%BB%91%E6%BE%A4%E6%98%8E">黑泽明<i class="fa fa-external-link"></i></span>执导的<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTlCJUJCJUU1JUJEJUIx" title="https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%BD%B1">电影<i class="fa fa-external-link"></i></span>，曾获得日本<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JUFGJThGJUU2JTk3JUE1JUU5JTlCJUJCJUU1JUJEJUIxJUU3JThEJThF" title="https://zh.wikipedia.org/wiki/%E6%AF%8F%E6%97%A5%E9%9B%BB%E5%BD%B1%E7%8D%8E">每日电影最佳影片奖<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTlCJUJCJUU1JUJEJUIxJUU2JTk3JUFDJUU1JUEwJUIx" title="https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%BD%B1%E6%97%AC%E5%A0%B1">电影旬报<i class="fa fa-external-link"></i></span>年度最佳影片奖、<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTlGJThGJUU2JTlFJTk3JUU1JUJEJUIxJUU1JUIxJTk1" title="https://zh.wikipedia.org/wiki/%E6%9F%8F%E6%9E%97%E5%BD%B1%E5%B1%95">柏林影展<i class="fa fa-external-link"></i></span>特别奖等奖项。</p><a id="more"></a><h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><p>实体书阅读，可惜这本书个人并没有从网上找到资源。</p><h1 id="佳句摘录"><a href="#佳句摘录" class="headerlink" title="佳句摘录"></a>佳句摘录</h1><p><strong>曾经为之讨厌的东西，实际接触之后才发现那么多喜爱</strong>。</p><blockquote><p>令人回味无穷的一句话，个人阅历越是丰富，对于这句话越是深有感触。</p></blockquote><h1 id="个人评价"><a href="#个人评价" class="headerlink" title="个人评价"></a>个人评价</h1><p>《为什么长大》中提到人的成长会逐渐失去惊奇，渐渐忘记了自己曾经的好奇心，说什么波澜不惊，随遇而安，不过都是用来掩盖自己越长大越无趣的借口。</p><p>对于这本书最大的感受是佩服作者能对于自己喜爱之物变为事业之后依然保持热情，另一方面对于昆虫世界的残酷又纯粹的生存法则十分感慨。</p><p>另外鲁迅《朝花夕拾》中提到的“人禽之辨其实本不必那么严”，发现和这本书倒是比较贴合，人类和昆虫真的有天差地别么？看过这本书之后发现其实人和昆虫只是多了理性和道德而已。</p><p>看这本书总是有一种小时候看动物世界的错觉，内容整体写的比较有趣，对于个人感兴趣的部分都记录到了此次的读书笔记当中。</p><h1 id="昆虫处世之道"><a href="#昆虫处世之道" class="headerlink" title="昆虫处世之道"></a>昆虫处世之道</h1><p>昆虫常见的三种处世之道，昆虫为虫的样子很像是做人为人的样子。</p><ul><li>喜欢就去追求。</li><li>有危险就需要隐蔽和伪装。</li><li>遇到困难互相帮助，共生和共存。</li></ul><h1 id="竞争与共生"><a href="#竞争与共生" class="headerlink" title="竞争与共生"></a>竞争与共生</h1><p>昆虫之间的竞争和共生都是单纯的，然而人的共生和竞争确实十分复杂的，相比昆虫的纯粹不免让人为之吸引。</p><p>当然昆虫之间也不单单只有竞争，昆虫也存在共生共存关系，当然共生共存也分为互惠互利或者一方白嫖，比如书中提到的下面内容：</p><ul><li><strong>蚜虫和瓢虫</strong>：保镖和老板的关系，保镖保护老板不受伤害，老板提供保镖的薪水，也就是蜜汁，供其食用，这种各取所需的关键是一种微妙的平衡。</li><li><strong>黑灰蝶和蚂蚁</strong>：黑灰蝶的幼虫会散发雄性蚂蚁的气味，因为雄性蚂蚁在蚂蚁中是不需要干活的，所以伪装成蚂蚁的黑灰蝶可以躺着分享蜜汁给其他蚂蚁，也就可以一直无所事事。直到化为飞蝶的时候，蚂蚁才会知道被骗了，但是到这时候一切都晚了。这种共生关系其实一切说白了都是蚂蚁自给自足，蜜汁都是蚂蚁辛苦劳动的成果，实在是狡猾。</li></ul><h1 id="人类是基因的载体"><a href="#人类是基因的载体" class="headerlink" title="人类是基因的载体"></a>人类是基因的载体</h1><p>“生命就是传递基因并且进化而来的”这句话怎么理解？性的诞生仅仅是为了传递基因的手段，而人类的道德和理性也是为了获取更加优异的异性，留下更好的后代基因。</p><p>人类和昆虫没有什么本质的差别，为了追求生命和基因的延续，人类会想方设法来培养更优秀的后代，这种为了后代获得更好发展的强烈渴望究竟是生物本能还是基因的本能犹未可知。</p><p>基因载体的另一个思考是关于大刘的书《三体》中提到的“<strong>失去人性，失去很多，失去兽性，失去一切</strong>”，对于这句话的理解个人看法为这里的人性指的是道德法律的约束，其实道德和法律的约束更多的基于<strong>环境</strong> 而不是人类本身，因为人性是经不起考验的，做人的基本底线也是建立在整个生存环境做的“妥协”。如果真的要到了三体那样的情况人类真的会为了基因延续而战么？</p><p>我想外在的敌人不足为虑，但是永远要小心内部的敌人，所谓“攘外必先安内”这一点放在任何场合都适用，很多时候伤害自己的人是自己最熟悉的人。</p><h1 id="喜欢就要大胆追求"><a href="#喜欢就要大胆追求" class="headerlink" title="喜欢就要大胆追求"></a>喜欢就要大胆追求</h1><p>昆虫如果有了喜欢的对象就会大胆追求，想想昆虫为了追求异性不惜粉身碎骨也要留下自己的后代，感叹为了生存和繁衍生物的行为都是十分纯粹的，昆虫的后代存活率非常低更会为获得和异性交配的权利而不择手段。</p><p>抛开动物生存法则这一点不谈，能在自己喜欢的事情尽情的投入（或者说）时间本身就是幸福的事情，因为很多人干着自己根本不喜欢的工作，对于这一点有幸在大学的时候有了认识，所以<strong>心中抱持着强烈的愿望，愿望就会悄悄来到你的身边</strong>。</p><p>兴趣作为事业会逐渐消磨热情这是避免不了的，但是这种无论干多久都不会腻的事情是可遇而不可求的。</p><p>当然这里要排除机械和无思考的劳动，这才是害人之根本，消耗精神的同时还消耗肉体，建议大家不要尽量接触这一类的工作。</p><h1 id="伪装和趋光性"><a href="#伪装和趋光性" class="headerlink" title="伪装和趋光性"></a>伪装和趋光性</h1><p><strong>昆虫之所以令人喜爱是因为他们总是只有一个目标不断的追去</strong>。无论是进行伪装还是“飞蛾扑火”的冲击，对于昆虫来说永远追求最大的存活率。</p><p>伪装是昆虫中的基本有的虫伪装成树枝，有的伪装成树叶，有的直接伪装同类的气味，还有伪装则是为食物伪装做诱饵，这些技巧都是为了生存做的一系列努力。</p><p>为了生存，昆虫会隐蔽自己，萤火虫会通过发光诱骗其他萤火虫吃掉别的属的萤火虫然后发出原本的光，昆虫的狡猾和智慧是赖以生存的资本。</p><p>飞行类动物之所以会趋光性是因为在飞行的时候也需要看清周围环境才能正常飞行，对于夜晚月光和星星的光亮当然不足以和电灯相比了。不只是动物，晚上走漆黑的巷道看到光亮人也会产生安心的感觉，昆虫会如此执着光明也不是不能理解。</p><p>人类也为了光明坚持不懈的努力，电的到来无论如何都是人类历史上最伟大的发明（在我看来没有之一）。</p><h1 id="真正可怕之物"><a href="#真正可怕之物" class="headerlink" title="真正可怕之物"></a>真正可怕之物</h1><p>对于昆虫来说真正应该害怕的是那些会带来生命危险的东西，而不那些看似危险实则无害的生物，很多看似无害的小虫子才是真正的杀手，比如隐翅虫这种呼一巴掌基本手是废了。</p><p>个人过去也遭受过“虫子”的道，现在想想还有些后怕，过去在老家山里劈柴的时候不小心掠过一只小虫不在意，结果晚上通红一片，本以为上点止痒的药就会好的，结果第二天手便肿成了”肉球“，没错真的是肉球，为此当时还拍过照做过纪念。</p><p>虽然手机换了几次之后相片已经没了，但是对于那种胀痛依旧还有深刻的记忆。</p><blockquote><p>后面找长辈问了一下才知道是马蜂，不过好在只有一只。只怪小时候懵懂不懂事，老天保佑算是捡了一条命。另外个人在朋友眼中算是黑历史比较少的，这一次手肿成肉球让朋友也有深刻记忆，每次提起都会吐槽一遍=-=。</p></blockquote><p>所以对于生活中可能碰到的昆虫建议都做一个了解，不明不白当蚊子拍了会有意想不到的后果。</p><h1 id="失去惊奇"><a href="#失去惊奇" class="headerlink" title="失去惊奇"></a>失去惊奇</h1><p>沉重的话就放到最后部分了。</p><p>失去惊奇大概是成年人最大的悲哀了，成长总是伴随着无尽的代价，当我们失去惊奇我们会逐渐原地踏步活在安逸和舒适圈还是寻找新的可能性，大部分都是会选择安逸平凡的生活，这大概是成年人的另一种悲哀 – 放弃追求。</p><p>然而给昆虫的生存环境是没有惊奇，失去惊奇意味着死亡。</p><h1 id="生之欲"><a href="#生之欲" class="headerlink" title="生之欲"></a>生之欲</h1><p>下面的内容都是从网络上拷过来的，可以随便看看。</p><p>书中作者在某一小节的结尾提到了《生之欲 》这部电影，查了下是一部上世纪50年代的电影，观感应该不会太好，但是豆瓣居然有9点几分瞬间来了兴趣，后续抽空看一下说说观后感。</p><p>《生之欲》讲述了一位官僚在发现自己患了晚期癌症后，试图在他的生活中找到意义。</p><p>A bureaucrat tries to find a meaning in his life after he discovers he has terminal cancer.</p><blockquote><p>2007年日本有再编过，这里不要下载错了哦。</p></blockquote><blockquote><p>《生之欲》电影链接：</p></blockquote><p>链接: <span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMVdTWU1zWDZCdkdzeXVGSV9LUGUyb0E=" title="https://pan.baidu.com/s/1WSYMsX6BvGsyuFI_KPe2oA">https://pan.baidu.com/s/1WSYMsX6BvGsyuFI_KPe2oA<i class="fa fa-external-link"></i></span> 提取码: zfqc 复制这段内容后打开百度网盘手机App，操作更方便哦 –来自百度网盘超级会员v7的分享</p><p>另外下面是维基的介绍，这里直接搬过来了：</p><p>《<strong>生之欲</strong>》（日语：生きる）在<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JUE2JTk5JUU2JUI4JUFG" title="https://zh.wikipedia.org/wiki/%E9%A6%99%E6%B8%AF">香港<i class="fa fa-external-link"></i></span>译作《<strong>流芳颂</strong>》，乃是1952年由<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTk3JUE1JUU2JTlDJUFD" title="https://zh.wikipedia.org/wiki/%E6%97%A5%E6%9C%AC">日本<i class="fa fa-external-link"></i></span>知名<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUIwJThFJUU2JUJDJTk0" title="https://zh.wikipedia.org/wiki/%E5%B0%8E%E6%BC%94">导演<i class="fa fa-external-link"></i></span><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JUJCJTkxJUU2JUJFJUE0JUU2JTk4JThF" title="https://zh.wikipedia.org/wiki/%E9%BB%91%E6%BE%A4%E6%98%8E">黑泽明<i class="fa fa-external-link"></i></span>执导的<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTlCJUJCJUU1JUJEJUIx" title="https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%BD%B1">电影<i class="fa fa-external-link"></i></span>，曾获得日本<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JUFGJThGJUU2JTk3JUE1JUU5JTlCJUJCJUU1JUJEJUIxJUU3JThEJThF" title="https://zh.wikipedia.org/wiki/%E6%AF%8F%E6%97%A5%E9%9B%BB%E5%BD%B1%E7%8D%8E">每日电影最佳影片奖<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTlCJUJCJUU1JUJEJUIxJUU2JTk3JUFDJUU1JUEwJUIx" title="https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%BD%B1%E6%97%AC%E5%A0%B1">电影旬报<i class="fa fa-external-link"></i></span>年度最佳影片奖、<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTlGJThGJUU2JTlFJTk3JUU1JUJEJUIxJUU1JUIxJTk1" title="https://zh.wikipedia.org/wiki/%E6%9F%8F%E6%9E%97%E5%BD%B1%E5%B1%95">柏林影展<i class="fa fa-external-link"></i></span>特别奖等奖项。</p><h2 id="故事内容"><a href="#故事内容" class="headerlink" title="故事内容"></a><strong>故事内容</strong></h2><p>在市公所工作30年的市民课课长渡边勘治每天过着盖章、签公文的乏味生活，某日因身体不适前往<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTg2JUFCJUU5JTk5JUEy" title="https://zh.wikipedia.org/wiki/%E9%86%AB%E9%99%A2">医院<i class="fa fa-external-link"></i></span>检查，结果竟被告知罹患<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JTgzJTgzJUU3JTk5JThD" title="https://zh.wikipedia.org/wiki/%E8%83%83%E7%99%8C">胃癌<i class="fa fa-external-link"></i></span>末期，只剩下约半年的生命。回到家中，<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTg1JTkyJUU1JUFEJTkw" title="https://zh.wikipedia.org/wiki/%E5%85%92%E5%AD%90">儿子<i class="fa fa-external-link"></i></span>与<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUFBJUIzJUU1JUE5JUE2" title="https://zh.wikipedia.org/wiki/%E5%AA%B3%E5%A9%A6">媳妇<i class="fa fa-external-link"></i></span>对他并不友善，甚至可谓不孝。感到悲伤的渡边，带了毕生积蓄离家出走，也不去上班了。他在外头遇见一位<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUIwJThGJUU4JUFBJUFB" title="https://zh.wikipedia.org/wiki/%E5%B0%8F%E8%AA%AA">小说<i class="fa fa-external-link"></i></span><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU0JUJEJTlDJUU1JUFFJUI2" title="https://zh.wikipedia.org/wiki/%E4%BD%9C%E5%AE%B6">作家<i class="fa fa-external-link"></i></span>，告之自己将不久于人世，他认为从未替自己好好活过。小说家同情其遭遇，带他去打<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUJEJTg4JUU3JThGJUEwJUU2JUE5JTlG" title="https://zh.wikipedia.org/wiki/%E5%BD%88%E7%8F%A0%E6%A9%9F">小钢珠<i class="fa fa-external-link"></i></span>，甚至去<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUE2JTkzJUU5JTk5JUEy" title="https://zh.wikipedia.org/wiki/%E5%A6%93%E9%99%A2">声色场所<i class="fa fa-external-link"></i></span>。对渡边来说，虽然这些事很新鲜，但到头来却觉得空虚落寞。第二天他就告别了小说家，一个人孤独的走在街上。</p><p>他遇见了市公所的一位年轻女职员小田切丰，后者表示她厌倦公务员无聊的工作，已觅得新职，却因课长没来上班，没人批准<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUJFJUFEJUU4JTgxJUI3" title="https://zh.wikipedia.org/wiki/%E8%BE%AD%E8%81%B7">辞呈<i class="fa fa-external-link"></i></span>。渡边便将小田切带回家中，为她盖离职同意书；见她丝袜破掉，想为她买双新的。这天他要求小田切带他去玩，两人也度过快乐的一天。但回家后却遭到儿子辱骂，认为他之前带走的存款算是家用的一部分；儿子同时误会小田切是他的年轻<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTg0JTlCJUU0JUJBJUJB" title="https://zh.wikipedia.org/wiki/%E6%84%9B%E4%BA%BA">情人<i class="fa fa-external-link"></i></span>，要求父亲自重。</p><p>过了几天后，渡边前往小田切新任职的<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JThFJUE5JUU1JTg1JUI3" title="https://zh.wikipedia.org/wiki/%E7%8E%A9%E5%85%B7">玩具<i class="fa fa-external-link"></i></span>工厂，希望她再陪着出去玩。小田切原本不想答应，但渡边苦苦哀求，她只好同意。晚上来到一家<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUE1JUJGJUU5JUE0JTkwJUU1JUJCJUIz" title="https://zh.wikipedia.org/wiki/%E8%A5%BF%E9%A4%90%E5%BB%B3">西餐厅<i class="fa fa-external-link"></i></span>，渡边的举动让小田切以为他要对她不轨，十分害怕。没想到渡边告诉她自己得了不治之症，来日无多，但是见到小田切如此年轻有活力，希望小田切告诉他究竟活着是为了什么。小田切只好战战兢兢的拿出一只玩具<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTg1JTk0" title="https://zh.wikipedia.org/wiki/%E5%85%94">兔<i class="fa fa-external-link"></i></span>子告诉他，她平常在工厂工作就是做这种东西；只要想到自己做出的东西是为别人带来欢乐，自己也就很开心。渡边突然想到自己想要什么了，向小田切道谢后便离开餐厅。此时碰巧有群年轻人替一位少女庆生，众人唱起<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUE1JTlEJUU0JUJEJUEwJUU3JTk0JTlGJUU2JTk3JUE1JUU1JUJGJUFCJUU0JUI5JTkw" title="https://zh.wikipedia.org/wiki/%E7%A5%9D%E4%BD%A0%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90">生日快乐歌<i class="fa fa-external-link"></i></span>，仿佛在庆祝渡边的重生。</p><p>翌日渡边再度回到市公所上班，将他请假这些日子的公文全数拿出来，发觉有件案子是许多妇女前来陈情，希望将某条臭水沟改建为<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTg1JUFDJUU1JTlDJTky" title="https://zh.wikipedia.org/wiki/%E5%85%AC%E5%9C%92">公园<i class="fa fa-external-link"></i></span>，却屡屡遭到各单位互踢皮球不愿处理。他决定要处理这件事，带着下属开始各处奔走。5个月后，渡边过世，在灵堂上大家开始回忆他生命最后5个月的过程，发觉他非常努力奔走以建立公园，最后甚至选择在大<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTlCJUFB" title="https://zh.wikipedia.org/wiki/%E9%9B%AA">雪<i class="fa fa-external-link"></i></span>的夜里独自快乐的唱着歌，死于自己亲手建立的公园里。虽然在守灵的酒会上，大家如此怀念渡边所做的一切，但等到第二天上班时市公所 依就弥漫着官僚之气。尽管有职员看不过去，心中认为应该要继承渡边的精神，但也仅止于缅怀而已。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>昆虫的生活似乎每天只有成王败寇，其中最大的启发就是“活着就要感谢”。</p><p>开头的那句话换一下词也可以说成：<strong>曾经为之喜爱的东西，实际接触之后才发现那么多讨厌</strong>，相比于昆虫作为人看起来有更多的无可奈何，但是那又怎么样呢？终究是选择的代价罢了。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      曾经为之讨厌的东西，实际接触才发现如此喜欢
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://whitestore.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="书籍" scheme="https://whitestore.top/tags/%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>阿里云OSS图床搭建</title>
    <link href="https://whitestore.top/2022/05/21/abioss/"/>
    <id>https://whitestore.top/2022/05/21/abioss/</id>
    <published>2022-05-21T10:50:06.000Z</published>
    <updated>2022-06-02T10:09:44.958Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阿里云OSS图床搭建"><a href="#阿里云OSS图床搭建" class="headerlink" title="阿里云OSS图床搭建"></a>阿里云OSS图床搭建</h1><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>过去介绍过Gitee的图床搭建，用了一年多都挺稳定了，访问速度尚可，但是2022年开始发现不是很稳定，并且部分网站会发现“图片消失”的情况，F12看一下发现是很多外国网站给直接<strong>302临时重定向</strong>了。</p><p>所以为了保证数据安全，这里无奈只能掏钱买阿里云的 OSS做图床了，查了下价钱也还能接受，标准LRS存储一年也就10块钱。</p><p>本文就根据OSS配置再结合个人常用的几个软件来总结阿里云OSS相关配置和应用。</p><a id="more"></a><h2 id="计费方式"><a href="#计费方式" class="headerlink" title="计费方式"></a>计费方式</h2><p>在了解具体的使用之前，这里简要介绍一下计费的方式。</p><p>阿里云有目前有两种计费方式，如果你不想买资源包等等操作，那么默认开通OSS之后就可以直接拿来用，直接<strong>按量计费</strong>的方式即可，先使用，后付费。</p><ul><li><p>按量收费计费公式：OSS的使用费用每小时结算一次，计算公式为：<strong>费用=实际资源使用量×对应资源每小时单价</strong>。</p></li><li><p>资源包：预先购买针对不同的计费项推出的优惠资源包，在费用结算时，优先从资源包抵扣用量，先购买，后抵扣，适用于业务用量相对稳定的场景。</p></li></ul><blockquote><p>注意：资源包一定要根据自己创建和使用的Bucket进行购买，比如标准存储就买标准存储的，低频存储的就买低频存储的，<strong>千万不要买错了，买错了不能反悔</strong>。当然标准的LRS比较便宜，但是粗略看了一下其他几个Burket选项都挺贵的，购买之前一定要确认清楚自己的需求和使用的Bucket类型。<br>如果对于费用计费有顾虑，可以阅读“资源包管理“中的”购买了资源包为什么还会欠费？“，里面都有相关解释。<br><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202204032203859.png" alt=""></p></blockquote><p>这里假定读者都是给个人学习或者简单使用的情况，所以使用的是购买资源包计费方式。</p><h2 id="存储类型"><a href="#存储类型" class="headerlink" title="存储类型"></a>存储类型</h2><p>官方做了一张表，其实一般使用“标准类型”就够了，可能有的读者还想图便宜会想要买一个“低频访问”来玩玩，但是只要你去看一下低频访问资源包价格就会发现你会被文字游戏给坑了。</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202204032207275.png" alt=""></p><h2 id="新人优惠"><a href="#新人优惠" class="headerlink" title="新人优惠"></a>新人优惠</h2><p>新人优惠很重要，查了一下很多文章不会说这个东西，这里有必要强调一下，阿里云的OSS对于新人来说有送3个月免费100GB流量，基本相当于让你免费用3个月，这一点还是挺香的（<s>到期了薅完阿里薅腾讯云的</s>），所以创建OSS之后先不要急着用，先把免费的资源包领一下：</p><p>地址：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYWxpeXVuLmNvbS9wcm9kdWN0L29zcz9zcG09NTE3Ni4yMTIxMzMwMy5KXzY3MDQ3MzM5MjAuMTEuNDAyNzUzYzk3QVlCODQjSl8zMzMyMjQzMjIw" title="https://www.aliyun.com/product/oss?spm=5176.21213303.J_6704733920.11.402753c97AYB84#J_3332243220">对象存储OSS_云存储服务_企业数据管理_存储-阿里云 (aliyun.com)<i class="fa fa-external-link"></i></span>。</p><p>滚动条下拉选择套餐即可。</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202204032156464.png" alt=""></p><p>地域选择大陆通用即可：</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202204032157443.png" alt=""></p><p>购买之后我们创建相关的Burket然后上传的时候就会从资源包扣费了。<br>注意你创建的Burket一定要和你的资源包匹配！<br>注意你创建的Burket一定要和你的资源包匹配！<br>注意你创建的Burket一定要和你的资源包匹配！</p><p>很重要，否则不明不白的额外扣费让人恼火和后悔。</p><h1 id="阿里云-OSS基础配置"><a href="#阿里云-OSS基础配置" class="headerlink" title="阿里云 OSS基础配置"></a>阿里云 OSS基础配置</h1><p>进入官网：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYWxpeXVuLmNvbS8/c3BtPTUxNzYuMjEyMTMzMDMuSl8zMjA3NTI2MjQwLjEuMjg4MTUzYzlUREdrdHg=" title="https://www.aliyun.com/?spm=5176.21213303.J_3207526240.1.288153c9TDGktx">阿里云-上云就上阿里云 (aliyun.com)<i class="fa fa-external-link"></i></span>，在产品中选择 OSS，如果从来没开通过OSS，阿里云这里会给一份协议确认然后确认用户开通，这里就不截图了。</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202204032023825.png" alt=""></p><p>进入管理页面，刚进去看不知道要干啥，所以直接点击右边的OSS新手入门来了解也是一种方式。<br><span class="exturl" data-url="aHR0cHM6Ly9oZWxwLmFsaXl1bi5jb20vbGVhcm4vbGVhcm5pbmdwYXRoL29zcy5odG1sP3NwbT01MTc2Ljg0NjU5ODAuZ3VpZGUuMS40MTIzMTQ1MG1oNUxsNw==" title="https://help.aliyun.com/learn/learningpath/oss.html?spm=5176.8465980.guide.1.41231450mh5Ll7">OSS阿里云_ OSS是什么意思_对象储存OSS_阿里云OSS学习路径图_OSS Learning Path - 阿里云 (aliyun.com)<i class="fa fa-external-link"></i></span></p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202204032036671.png" alt=""></p><p>我们切换到B<strong>ucket</strong>列表，选择“创建Bucket”。</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202204032105135.png" alt=""></p><p>进入页面之后，我们填写下面的内容：</p><ul><li>Bucket名称，唯一命名，起个自己喜欢的名字即可</li><li>地域：选择和自己所在城市比较近的城市，国内选择国内的区域和节点即可。</li><li>Endpoint：需要的话可以记录一下，比如我我选择的是：oss-cn-shenzhen.aliyuncs.com</li><li>存储类型：如果仅仅作为备份使用，低频访问比较合适，但是如果是对外使用不管流量多少还是建议用标准的，归档存储一般用于永久存储备份重要数据。</li><li>同城冗余和版本控制没啥必要，不用开</li><li>读写权限：如果我们作为图床，需要用“公共读”允许匿名用户访问数据。（和PicGo配置有关）</li><li>实时日志和定期备份个人认为如果是自己用也是没有必要，骗钱玩意。</li></ul><h2 id="购买资源包"><a href="#购买资源包" class="headerlink" title="购买资源包"></a>购买资源包</h2><p>创建完成之后，我们先不急着操作，我们先买个资源包，这里个人使用了“新人优惠”不给买了，这里就不演示购买操作了。</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202204032215220.png" alt=""></p><h2 id="AccessKey管理"><a href="#AccessKey管理" class="headerlink" title="AccessKey管理"></a>AccessKey管理</h2><p>接着是用户配置部分，我们需要在OSS中配置允许对外访问的AccessKey，这里我们点击右上角“头像”的”AccessKey管理“，这里其实用户体验不是很好。<br><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202204032249369.png" alt=""></p><p>由于图床会对外访问，所以建议不要使用主账户的AccessToken进行操作，而是使用子账户方式进行操作处理，这里进入之后可以看到RAM用户管理，点击“创建用户”。</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202204032253953.png" alt=""></p><p>“创建用户”其他都可以自由操作，但是一定要选择“Open API”，这里需要进行安全验证。创建完整之后，我们便拥有了<strong>AccessKey ID，AccessKey Secret</strong>这两个关键配置，注意这两个配置只能查看一次，建议复制到自己本地存储后面需要使用到。</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202204032254752.png" alt=""></p><p><strong>Burke授权</strong><br>创建用户之后，我们需要给创建的子用户授权，在管理页面选择新建子商户之后选择给商户添加权限。</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202204041251396.png" alt=""></p><p>然后回到刚刚创建的bucket，在文件管理内给新建的用户授权。</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202204041300935.png" alt=""></p><h2 id="配置PicGo"><a href="#配置PicGo" class="headerlink" title="配置PicGo"></a>配置PicGo</h2><p>PicGo是什么这里就略过了，我们直接来看PicGo的配置</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202204041303779.png" alt=""></p><p>关键部分：在软件中我们选择“阿里云OSS配置”然后根据参数填写下面的内容：</p><ul><li>keyId：这里用之前新建的<strong>子用户</strong>的 <strong>AccessKey</strong>。</li><li>KeySecret：这里使用新建<strong>子用户</strong>的 <strong>AcessSecret</strong>。</li><li>存储空间名称：这里按照下图填写<strong>Bucket域名</strong>，注意这里只需要<code>.aliyuncs.com</code>需要删除。</li><li>默认存储区域：这里按照下图填写<strong>Endpoint</strong>，注意这里只需要<code>.aliyuncs.com</code>需要删除。</li></ul><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202204041306584.png" alt=""></p><p>最后个人的配置如下：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204041315333.png" alt=""></p><h2 id="配置Typera"><a href="#配置Typera" class="headerlink" title="配置Typera"></a>配置Typera</h2><p>安装Typera这里就跳过了，我们打开软件之后选择“图像”，然后切换到PicGo，验证一把之后会提示成功信息，之后我们修改上面“插入图片时….”的操作改为“上传图片”，以后图片都会往PicGo进行上传，不会出现在本地的一个临时路径了。</p><blockquote><p>这里不是很建议直接执行上传操作，更建议先放到一个指定文件夹然后确认无误之后进行复制粘贴的上传替换，当然OSS流量基本够用。</p></blockquote><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204041345412.png" alt=""></p><h2 id="obsidian配置"><a href="#obsidian配置" class="headerlink" title="obsidian配置"></a>obsidian配置</h2><p>具体可以看作者的文章，基本上安装一个插件之后“Enable”即可直接使用，直接往Obsidian进行粘贴就会直接委托PicGo上传，然后出翔相关路径。<br><span class="exturl" data-url="aHR0cHM6Ly9mb3J1bS16aC5vYnNpZGlhbi5tZC90L3RvcGljLzM4OA==" title="https://forum-zh.obsidian.md/t/topic/388">在Obsidian中使用图床实现“一次上传、多次搬运”省心又省力 - 经验分享 - Obsidian 中文论坛<i class="fa fa-external-link"></i></span></p><p>最后，我们截图粘贴查看是否触发PicGo上传，最终截图的路径如下：</p><p><span class="exturl" data-url="aHR0cHM6Ly9hZG9uZy1waWN0dXJlLm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vYWRvbmcvMjAyMjA0MDQxMzMzMzgzLnBuZw==" title="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204041333383.png">https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204041333383.png<i class="fa fa-external-link"></i></span></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204041333383.png" alt=""></p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>gitee的图床个人目前已经不再进行上传，后续都将会改用OSS，另外个人建议定期给图床做一下本地备份，虽然可能并没有特别大的意义。</p><p>另外如果对于图片的重要性不大，可以直接使用免费的图床。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      图床处理
    
    </summary>
    
    
      <category term="其他" scheme="https://whitestore.top/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="其他" scheme="https://whitestore.top/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>14岁懂社会-《给想要成为医生的你》读书笔记</title>
    <link href="https://whitestore.top/2022/05/05/gxycwysdn/"/>
    <id>https://whitestore.top/2022/05/05/gxycwysdn/</id>
    <published>2022-05-05T06:36:15.000Z</published>
    <updated>2022-06-02T10:09:44.582Z</updated>
    
    <content type="html"><![CDATA[<h1 id="14岁懂社会-《给想要成为医生的你》读书笔记"><a href="#14岁懂社会-《给想要成为医生的你》读书笔记" class="headerlink" title="14岁懂社会-《给想要成为医生的你》读书笔记"></a>14岁懂社会-《给想要成为医生的你》读书笔记</h1><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204232131277.png" alt=""></p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>看到这样的书名难免让人止步，但是即使是不想成为医生我看完之后依然认为十分有收获的一本书，而对于渴望成为医生的人来说这本书大概是在“浇冷水”，因为挽救生命的职业既是天使也有可能是魔鬼。</p><p>这本书也是比较著名的医生写的，也确实看得出是医生写的出来的书，但是行文却和医生严肃的面容大相径庭。</p><blockquote><p>不过日本人给作者取了一个“上帝之手”的称号属实没绷住</p></blockquote><a id="more"></a><h1 id="个人评价"><a href="#个人评价" class="headerlink" title="个人评价"></a>个人评价</h1><p>虽然我对于医生行业一窍不通但是看这本书的时候还是被作者的文字所吸引，看到作者是世界上第一例胃网膜右动脉搭桥手术还是心生佩服。</p><p>寻常职业大概可以把自己的职业成果当作鼓励和夸奖，而每天都有可能见证死亡的外科医生却是时刻在和死神搏斗，这种济世救人的成就对于他们来说都是日常工作应该做到的事情罢了，所以“<strong>应该做到的事情</strong>”上医生毫无疑问承受了最大的压力。</p><p>现代人似乎丢失了耐心和责任对自己的工作负责心越来越轻，以个人从事的 IT 行业为例有时候出一些小BUG在用户没有发现的时候无伤大雅，或许也不会有任何的金钱损失最多遭受一顿骂然后及时改正即可，然而医生一旦犯错不仅会丢了饭碗甚至有可能葬送一个家庭，大概没有哪一个行业需要比医生更多责任心，丰富的学识以及想象力了，<strong>医生是上帝的同时也是恶魔</strong>。</p><p>最后看完这本书之后不仅少了几分对于医生的讨厌，更多的是更多了几分对于医生的尊敬。</p><h1 id="佳句收藏"><a href="#佳句收藏" class="headerlink" title="佳句收藏"></a>佳句收藏</h1><ul><li>人拥有无限的潜力，成长之所以停止是因为人失去的进取之心，人的可能性其实没有界限。</li><li><strong>想象成功的愿景和强烈的愿望是医生不会犯错的前提，套用在任何事情上也是通用的</strong></li><li>与其畏惧死亡不如充分享受生命才会更加幸福。</li><li>你的人生就像是坐着最快列车在最前面车厢的最前列向前方驶去，周围是什么景色你从来没有看过吧？当人生飘过死亡气息与充满生机的时候感受是完全不同的。</li><li><strong>一旦意识到生命的短暂，人生观就会改变</strong>。</li><li><strong>不如预想并且期待和欢喜的时候，未知世界的大门正在打开。</strong></li><li>世界上有四种人：创造者、挑剔者、破坏者、使用者，只要不是挑剔者大概都不会活在这个世上产生烦恼吧。</li><li>遗憾的是生命并不平等，虽然大家都拥有一条生命，但是大家生命的长度、死亡的痛苦程度各不相同。</li></ul><h1 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h1><p>拥有实体书可以看看目录中对应正文的<strong>如何发展能力</strong>部分，相信任何人看完都能有所收获，如果时间有限不想看后面的内容也可以看看下面部分几点总结，也是我认为这本书能带给我一些价值和深入思考的地方：</p><ul><li><strong>绝对自信</strong>：没有人天生就是绝对自信的，也没有人能在生死攸关的场景保持绝对冷静，外科医生这种走钢丝的职业不能有丝毫差错，需要在经验和成功中不断证明自己“我能行”，站上手术台之前无数次的预演成功，从相信自己不可能犯错到肯定自己不会犯错便是成熟和实现绝对自信的过程。</li><li><strong>进取之心</strong>：根据自己的位置设置合理的进取目标，人才不会安于现状毫无进取之心。哪怕没有成熟的本领和技术每天进步一点点，也是微小成长的过程，也好过安于现状。</li><li><strong>想象成功</strong>：如果医生不想象从进入手术室到家属高高兴兴出院的场景，那么成为一名合格的“运动员”。</li><li><strong>拼尽全力的成功和拼尽全力的失败</strong>：如果把失败是成功之母放在医生这个职业上，这和鼓励杀人犯去杀人是没有区别的，正如作者所说如果没有4950的成功治愈的病例而只有50例没能挽回的生命，医生和刽子手是没有区别的，他也绝对无法达成现在的成就，即使如此，哪怕拯救了上千的人没有挽回的每一例生命都会医生无尽的心里创伤和痛苦。</li><li><strong>榜样是最好的教育</strong>：十分认可作者对于给孩子的教育不需要传授知识，只需要给孩子树立一个正确并且值得模仿和学习的榜样的理念，同时我也认为很多熊孩子的问题归根结底是家庭教育的问题，“管不了”和“管不住”这种借口是无法抵赖的。</li><li><strong>拥抱挑战就是拥抱机遇</strong>：如果作者没有成为主刀医生的欲望那么可能成为一个教授，作者到了40多岁依然在寻找新的手术方案，不断在寻找新的可能性，纵观现在35岁就好像要退休要被社会断绝生路的年代毫无疑问是值得反思的。</li><li><strong>学习榜样和模仿是最好的学习方式</strong>：就像这本书一样，作者看似一些有感而发的肺腑之言和经验之谈才是真正学不到的经验，所谓经验、预判和直觉才是比知识更重要的东西。</li><li><strong>生命并不平等</strong>：现实是每一个人的生命长度各不相同，所以活在当下是对自己最好的祝福。</li></ul><blockquote><p>可以思考医生能在你没有具体描述病情的情况下能预判你的病根，这种经验和直觉是知识无法带来的。</p></blockquote><h1 id="每天都将面对死亡"><a href="#每天都将面对死亡" class="headerlink" title="每天都将面对死亡"></a>每天都将面对死亡</h1><p>医生是见到生死画面最多的职业，既要承担外界的家属压力，同时还要接受自己的压力，对于每一位医生来说无论何时都不能失去自己的冷静判断。</p><p>和殡仪馆的面对死亡不同，医生面对的是生命陨落的过程，在医院中隐藏着生命最本质的样子，就如《活着》核心活着的本质就是为了活着一样，人生在世尝尽酸甜苦辣咸方得圆满。</p><h1 id="心脏是可爱的脏器"><a href="#心脏是可爱的脏器" class="headerlink" title="心脏是可爱的脏器"></a>心脏是可爱的脏器</h1><p>心脏在我们左胸肋骨和肺部的交界处，每天要跳动十几万次都不会疲劳，心脏的重量在130到200克左右。</p><p>心脏任务是输送向脏器输送氧气，通常被称为动脉血，而消耗完氧气的血是静脉血。&#x20;</p><p>心脏可能会因为下面的原因逐渐衰竭：一个是冠状动脉堵塞，另一个是心脏瓣膜受损，这两个问题都是容易导致心脏肌肉衰弱的问题。</p><p>心脏有四个腔，左心房右心房，左心室右心室，血液从左心室通过强大的压力送往心房和肺动脉流向全身，最后通过肺静脉回到右心房，右心房在肺部送往右心室通过肺动脉接受氧气之后回流到左心房和左心室，接着完成下一个循环。</p><blockquote><p>文科生直接按照书上摘抄的，如果有错误欢迎指正。</p></blockquote><p>为了保证回流的时候不会逆流，在心脏中会存在瓣膜保证血液只能单向流动。</p><p>心脏的运作有点儿类似发动机的工作方式，只不过带来的价值完全不同。</p><p>换成是我会怎么做？从第三者眼光虽然觉得自己会理智感性，然而真正身处那样的环境通常情况下行动和言行都会不一致。所谓知行合一，大概才是最难做到的。</p><p>虽然手术是需要多个人配合的过程，但是实际上手术更多情况下是主刀医生一个人的责任，因为责任重大主刀医生压力也很大，因为患者和家属只会把希望寄托在主刀医生身上。</p><p>心脏停止才是真正的死亡？是否心脏停止才是真正的停止不得而知，但是脑死亡的人确实像是活在地狱当中，心脏无疑是身体中和大脑同样重要的脏器，一个控制精神，一个控制生命。</p><p>作者认为心脏十分的美丽，为了让心脏病患者重新回到生活正轨</p><h1 id="医生是运动员-x20"><a href="#医生是运动员-x20" class="headerlink" title="医生是运动员&#x20;"></a>医生是运动员&#x20;</h1><p>比较有趣的是外科医生起源于<strong>理发店的理发师</strong>，其实仔细想想也可以理解理发店的理发师给人理发如果不小心刮伤了那么需要会各种止血和包扎，慢慢的逐渐发展出专门处理伤口的人员，最后转变为医生，我想很多职业的起源都是十分有趣并且让人意外的。</p><blockquote><p>就好像程序C语言的诞生最开始只不过是作者为了帮助老婆看菜谱炒菜以及想打游戏的心情逐渐发展成构建编程语言的。</p></blockquote><p>那么为什么说医生是运动员呢？因为都和运动员一样需要三个最为重要的特征：<strong>想象力，技术和判断力</strong>。如果没有这三样是无法成为一名合格的医生的。</p><p>虽然外科手术是一项群体项目，但是没有人会认为责任会分担给其他的助手，家属也不会对着主刀医生以外的人说希望可以手术顺利等等话语，主刀医生是没有上台了再想办法这种情况的，换句话说手术其实早在进入手术室之前就已经开始，也就是之前提到的在脑海中不断构建成功的画面，才绝无失败的可能。</p><h2 id="想象力"><a href="#想象力" class="headerlink" title="想象力"></a>想象力</h2><p>为什么说需要想象力，因为作为医生没有见到急救病人之前无法判断病人的情况，这时候需要思考家属的心情，思考从进入手术室到医好病人，最终病人安全回家整个流程，在脑海中需要不断的进行预演。如果不能想象成功的画面，就无法在紧张的手术中预想通往成功的方案。</p><p>另一方面想象力需要反复的预演形成下意识才能完成，这也是专家和普通人的区别，专家的想象力来自于能在执行某些专业的流程同时腾出思考空间对于结果反复的排练和预演，同样脑海中需要不断的决策。</p><p><strong>预读是可以训练的才能，不是身高这种没有办法训练的天赋。</strong></p><h2 id="判断力"><a href="#判断力" class="headerlink" title="判断力"></a>判断力</h2><p>学习的时候还有明天继续的说法，但是手术是没有明天继续的说法的，任何判断和决定都应该在几秒内完成，这就牵扯到作为医生最为重要的准则，那就是时刻保持镇静，哪怕内心已经失去冷静也绝对不能把慌张写在脸上。</p><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><p>书中让我比较难以想象是冠状动脉手术的血管移植，血管移植在表面上看像是嫁接，但是难度之大令人咋舌，首先需要在血管开一个2毫米的孔，之后需要用比发丝远远小的线把血管进行<strong>缝合</strong>，没错就是和缝衣服一样缝血管上，所以需要的惊人的判断和专注力。</p><p>让我想到过去看日本外科医生的考试画面，需要用镊子折出比指甲盖还要小很多的千纸鹤，很难想象日常生活中要下多大的功夫和时间才能完成。</p><p>另外像是医生这样的职业让我想到了律师，律师在个人看来也是学的越多越容易失去感性的。</p><blockquote><p>冠状动脉移植难点：需要找到粗细适中并且不会影响其他脏器的血管，在人体中仅仅有几条可供使用并且很难发现。</p></blockquote><h1 id="第一次手术"><a href="#第一次手术" class="headerlink" title="第一次手术"></a>第一次手术</h1><p>和其他绝大多数的第一次不同，第一次手术是关乎性命的事情并且绝对不能失败，对于书中患者家属听说医生第一次主刀，很难想象作者究竟有多大的压力，仅仅是想象一下就可以让心跳加速，身历其境可想而知。</p><p>医生不允许失败，<strong>失败意味着死亡。</strong></p><p>唯一可以感同身受的大概是紧张的心情了，一场手术之后忘记自己干了啥和考试的之后不知道自己干了啥的心情有些许类似吧，不过紧张程度当然完全无法比较。</p><h1 id="想象成功"><a href="#想象成功" class="headerlink" title="想象成功"></a>想象成功</h1><p>医生大概是最需要想象成功的人，同时需要不断预演成功的人，因为保持着绝对不能失败的心情。</p><p>对于医生团队来说无外乎需要三点：</p><ul><li><p>目标：要有具体的目标，包括步骤，愿景</p></li><li><p>到达目标：确定目标之后便是用尽全力完成目标。</p></li><li><p>做出榜样：只有做出榜样才能带领团队实现目标，只有自己能拥有绝对的自信才能够带领团队纠正错误和到达正确的目标</p></li></ul><h1 id="绝对自信"><a href="#绝对自信" class="headerlink" title="绝对自信"></a>绝对自信</h1><p>绝对自信是医生走向成熟的标志，哪怕经验再成熟的人站上手术台的时候依然会紧张，所以想象完美的结果很重要，作者在不断想象病人和家属高高兴兴走出医院的画面，提升自己的自信同时让自己不断成熟。当从渴望成功到肯定自己不会失败不再畏惧死亡的时候，大概是医生成熟的标志。</p><p>也就是因为绝对的自信，作者在36岁完成了世界上第一例胃网膜右动脉搭桥手术，并且在40岁归国之后收到全国的关注，并且被越来越多的患者拜托拯救。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这本书最大的受众大概还是医学生吧，我认为拥有学医治病救人的这样崇高理想的人所应该仔细研读的一本书。</p><p>看完这本书的另一个感受是：啊！原来医生也是普通人。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      医生,护士，未来
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://whitestore.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="书籍" scheme="https://whitestore.top/tags/%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>LSM-Tree - LevelDb了解和实现</title>
    <link href="https://whitestore.top/2022/05/05/leveldblj/"/>
    <id>https://whitestore.top/2022/05/05/leveldblj/</id>
    <published>2022-05-05T06:31:32.000Z</published>
    <updated>2022-06-02T10:09:44.642Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LSM-Tree-LevelDb了解和实现"><a href="#LSM-Tree-LevelDb了解和实现" class="headerlink" title="LSM-Tree - LevelDb了解和实现"></a>LSM-Tree - LevelDb了解和实现</h1><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>自从[[《数据密集型型系统设计》LSM-Tree VS BTree]]这篇文章完成之后，对于LSM-Tree这种结构非常感兴趣，于是趁热打铁在之后的几天静下心来研究了一下LevelDB的具体实现，最终阅读了一下源代码。</p><p>本文涉及了LevelDB的基础功能和相关数据结构的介绍，最后讲述LevelDB中至关重要的读写操作，通过设计数据结构和读写操作的讲解，相信读者可以自行解答为什么LevelDB可以做到极为高效的读写操作，并且比查询操作要远远优秀。</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Levledb是Google的两位Fellow （Jeaf Dean和Sanjay Ghemawat）设计和开发的嵌入式K-V系统，读写性能非常彪悍，官方网站报道其写性能40万/s，读性能达到6万/s，写操作要远快于读操作。</p><blockquote><p>如果对于这个数据结构感兴趣，可以访问下面的github:<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9sZXZlbGRi" title="https://github.com/google/leveldb">https://github.com/google/leveldb<i class="fa fa-external-link"></i></span></p></blockquote><h1 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h1><p>需要注意的是Level-DB不仅是LSM-Tree日志存储结构的代表作品，同时也是对于Bigtable中SSTable的实践和扩展。</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>首先底层的基础数据结构是LSM-Tree，同时存储结构为Key-Value形式，但是在此基础上进行了一些调整，比如让数据存储在磁盘并且保证数据的<strong>顺序读写</strong>，为了高效读取设计了大小树结构，也就是将LSM- Tree一分为二，大的存磁盘，小的常驻内存，两者共同维护同一个。</p><p>当数据不断写入导致树不断的膨胀，此时为了频繁的磁盘写入对于数据肯定会有很大的影响，索引LevelDb将树在此基础上又拆分了多层，当一层的数据到达一定量的时候就往下一层归并，最终形成一颗自上而下的增长树。LevelDb的Level就是这么来的。</p><p>下面是这种特殊结构的设计图：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204162304929.png" alt=""></p><h2 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h2><ul><li>键和值是任意字节数组。</li><li>数据按key排序存储。</li><li>调用者可以提供自定义比较函数来覆盖排序顺序。</li><li>基本运算是<code>Put(key,value)</code>, <code>Get(key)</code>, <code>Delete(key)</code>.</li><li>可以在一个原子批处理中进行多项更改。</li><li>用户可以创建临时快照以获得一致的数据视图。</li><li>支持对数据进行前向和后向迭代。</li><li><span class="exturl" data-url="aHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL3NuYXBweS8=" title="https://google.github.io/snappy/">使用Snappy 压缩库<i class="fa fa-external-link"></i></span>自动压缩数据。</li><li>外部活动（文件系统操作等）通过虚拟接口中继，因此用户可以自定义操作系统交互。</li><li>系统可移植性很强，因为底层使用了C++编写。</li></ul><h2 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h2><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204162304981.png" alt=""></p><p>下面是各个组件介绍：</p><ul><li><p><strong>Memtable</strong>：LevelDB在写入数据的时候并不会直接写入磁盘，而是和多数的数据库工具一样先写入到内存的数据结构，内存数据结构通过跳表实现，新的数据会首先写入这里，<strong>Memtable</strong>负责管理所有的Key数据，这种数据结构效率可以比拟二叉查找树，绝大多数操作的时间复杂度为O(log n)。</p></li><li><p><strong>Log</strong>：Level-DB是典型的日志存储结构形式，在写入<strong>Memtable</strong>之前首先写入日志文件，对于写入日志以单纯的<strong>追加</strong>形式进行写入，这一点相比Btree相关的注重事务的复杂日志维护要简单不少，Level-DB和多数的LSM-Tree没有太大区别，日志的主要作用是数据库崩溃之后进行数据恢复，比如当程序出现下面的问题之后可以通过Log进行数据恢复：</p></li></ul><ol><li>写log期间进程异常。</li><li>写log完成，写内存未完成。</li><li>write动作完成（即log、内存写入都完成）后，进程异常。</li><li>Immutable memtable持久化过程中进程异常。</li><li>其他压缩异常（较为复杂，首先不在这里介绍）。</li></ol><ul><li><strong>Immutable Memtable</strong>：顾名思义不可变的内存数据结构，当内存数据结构数据满了之后就需要触发数据合并的操作，此时需要停掉数据读写并且对数据进行压缩。</li></ul><blockquote><p>不可变的数据结构其实是通过简单的C++ 锁机制实现的，不需要额外的维护锁对象控制。</p></blockquote><ul><li><p><strong>SST文件：</strong>：磁盘数据存储文件，分为Level 0到Level N多层，每一层包含多个SST文件；单层SST文件总量随层次增加成倍增长。SST文件本身是不可被修改的，这是Level-DB 设计哲学的一环，通过追加的和定期合并文件的方式实现了“删除”的操作，同时在读取的时候通过特殊的标记来判断更新还是删除操作，借此保证获取到最新的数据，这些内容在源代码中都能很好的发现，在后续的文章中会详细的解释，这里只需要有个大概的概念即可。</p></li><li><p><strong>Manifest文件</strong>： Level-Db存在版本控制的概念，版本信息的差别主要来自于每一层维护的元信息的差别。Manifest文件在整个系统中十分关键，不仅维护了最大key和最小key，Manifest文件中还记录SST文件在不同Level的分布，同时MainFest主要管理SST文件的层级，在进行<strong>合并</strong>操作的时候需要依赖Mainfest文件中的元信息完成合并的关键步骤。</p></li></ul><blockquote><p>元信息包括：(1)最大Key值，(2)最小Key值，(3)文件大小。</p></blockquote><ul><li><strong>Current文件</strong>：LevelDB启动时的首要任务就是找到当前的Manifest，而Manifest可能有多个，Current文件记录了<strong>Manifest文件</strong>相关的文件名。</li></ul><h1 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h1><p>在了解源代码之前我们从数据库的读写操作进行分析。如果了解Btree和事务型数据库的生态就会发现两者的差别是非常大的，Level-DB 的最大优点是读写速度要优秀于查询动作，由于不需要事务所以他的性能要比Btree的高非常多。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204162028858.png" alt=""></p><p>可以看到整个Level-DB分为两次写操作，头一次是写入log，接着才是写入记录数据，但是写入记录的数据并不会立刻写到磁盘，而是通过一些触发机制完成。</p><p>由于记录日志的方式够简单直接，所以Level-DB可以拥有很好的写入性能，如果在用户写入完成但是数据没入盘的时候突然发生系统宕机没有影响，因为数据压根没有写入硬盘，只要再次读日志还原相关操作即可。</p><h2 id="写操作实现"><a href="#写操作实现" class="headerlink" title="写操作实现"></a>写操作实现</h2><p>LevelDb对外提供了1）Put2）Delete两种接口，但是更新的操作和删除的操作可以看作是同一个操作，一个Delete操作会被转换成一个value为空的Put操作。</p><p>另外LevelDB 专门提供了批量操作的工具Batch完成批量操作的动作，为了保证数据的完整性，内部会通过加锁的方式实现原子操作。</p><p>Batch的整体结构大致如下：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204162042324.png" alt=""></p><blockquote><p>注意：这个结构图并不完整，在源代码里面还有其他的信息，这里简化了部分数据</p></blockquote><p>批量操作的每一个操作项都是通过类似上面的结构组成，通过type来标记整个记录的数据项类型，在记录key的内容之前，会记录key的长度，同样记录value的值之前会记录整个value的长度。</p><p>另外batch中还会维护一个size值表示key+value长度的总和，以及每条数据项额外的8个字节表示，这8个字节标识用于存储一条数据项额外的一些信息。</p><p><strong>原子性</strong>操作：</p><p>写操作的原子性体现日志记录操作上，一条日志记录的所有内容代表了一次写操作，这也是日志的写入最小单位。</p><p>既然是日志写入就会出现下面两种情况：</p><ul><li>未开始写入或者日志写一半断电。</li><li>日志写入完成真实数据没有变动。</li></ul><p><strong>合并写入</strong>操作：<br>#LevelDb合并写入操作<br>合并写入是对于日志问题的最大挑战， 为了保证操作原子性，并发写入的时候只有一个线程允许操作日志和追加数据，但是这样显然会影响写入的性能并且导致多线程阻塞等待，为了提高写入的性能，对于多线程频繁的写入的操作进行“合并”，将单一线程对于同一个日志的多次操作进行合并。</p><p>整个合并写入的流程如下：<br><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204162252652.png" alt=""></p><ul><li>第一次写入获取写入锁。</li><li>写操作没有达到出发合并写入的阈值，并且存在其他写入线程等待的情况下，将会“帮忙”把其他线程的写操作和自己进行合并。</li><li>如果到达了合并写入的阈值，并且没有其他线程等待的时候，把所有的内容合并写入到日志文件，然后再存储到数据库当中。</li><li>通知其他“被帮忙”的线程我已经帮你们把活干完了并且把操作结果告诉你们，同时释放写锁给下一个访问线程。</li></ul><p>对于其他的线程来说合并写入的操作类似下面的情况：</p><ul><li>等待上一个锁的持有者完成合并写入操作，如果操作成功接受结果并且返回。</li><li>如果上一个线程操作失败或者没有进行表明当前的锁可以进行合并写入了，则自动接任务继续尝试合并写入的操作。</li><li>如果还是没有合并完成继续等待锁和合并结果。</li></ul><p>通过这样的处理可以发现无论那个线程进来都可以尝试帮其他线程工作，但是仅限于和自己的操作相关的内容可以尝试合并。</p><h2 id="读操作实现"><a href="#读操作实现" class="headerlink" title="读操作实现"></a>读操作实现</h2><p>读操作的实现通过下面两种方式完成：</p><ul><li>通过<code>get</code>接口完成数据的获取。</li><li>为了提高读取的效率，会通过快照对于当前读到的数据进行缓存，最终通过快照的<code>get</code>接口完成数据获取。</li></ul><blockquote><p>从这里来看，快照即是缓存也是代理。</p></blockquote><p>其实两个操作类似，只不过一次读操作之前加入了快照，但是快照读到的数据不会因为后续的记录操作出现改动。</p><p>快照类似数据库某一个时刻状态的一个拷贝，对于大量的读操作来说可以减轻数据查找的压力。<br><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204162251954.png" alt=""></p><p>这里可能会存在疑问，读取的快照出现更新的时候会出现什么情况？<br>这里就必须要简单描述一下快照的实现了，快照的实现是通过 <strong>乐观锁</strong> 的方式实现的，内部通过维护一个 <strong>版本号</strong>的方式记录同一个Key的操作结果，同时一条记录有唯一的序列号，序列号在每次记录变动的时候不断+1，意味着序列号越大记录的值越新。</p><p>也就是说通过<strong>序列号</strong>和<strong>版本号</strong>这两个值可以模拟整个数据项的变更状态，同时为了保证快照的有效性，可以通过版本号和序列号检查是否对应，反过来说，如果当前序列号超过快照的序列号，则直接“掩盖”保证快照不会读到最新的数据。</p><blockquote><p>如果你了解Mysql的InnoDB中的MVCC机制，那么相信更好理解。</p></blockquote><p><strong>读取</strong>的步骤：</p><ul><li>在memtable中获取指定Key，如果数据符合条件则结束查找。</li><li>在Imumemtable中查找指定Key，如果数据符合条件则结束查找。</li><li>按低层至高层的顺序在level i层的sstable文件中查找指定的key，若搜索到符合条件的数据项就会结束查找，否则返回Not Found错误，表示数据库中不存在指定的数据。<br><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204162252669.png" alt=""></li></ul><blockquote><p>在LevelDB的每一层扫描SSTable 是按照顺序扫描的方式进行查找的（中间不会跳过）。<br>Level0层最为特殊，因为SSTable之间的Key会出现重合的情况，所以这时候会根据文件编号更大的作为查找参考<br>PS：为什么要文件编号更大的数据作为参考，因为序列号是递增的，所以更大的文件编号会存在更新的数据。<br>Level N层的数据，Key之间不会存在重合，并且由于每一层通过Mainfest的元数据找到最大key和最小key进行快速的定位操作，最终每一层只需要扫描一个SSTable就可以往下查找。</p></blockquote><p>在memory db或者sstable的查找过程中，需要根据指定的序列号拼接一个<strong>internalKey</strong>，如果查找用户key一致且seq号<strong>不大于</strong>指定seq的数据。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本节内容简单介绍了LevelDB，并且介绍了内部几个重要的数据结构内容，之后介绍了有关Level读写操作的细节，这些内容的理解对于后续介绍源代码是一个前提和铺垫。</p><p>在介绍完数据结构和读写操作的大致流程之后，下一节将会深入具体的源代码进行拓展介绍。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      关于LevelDB的拓展
    
    </summary>
    
    
      <category term="数据库-LevelDB" scheme="https://whitestore.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-LevelDB/"/>
    
    
      <category term="LevelDB" scheme="https://whitestore.top/tags/LevelDB/"/>
    
  </entry>
  
  <entry>
    <title>三高Mysql - Mysql索引和查询优化（偏实战部分）</title>
    <link href="https://whitestore.top/2022/04/06/suoyinshizhan/"/>
    <id>https://whitestore.top/2022/04/06/suoyinshizhan/</id>
    <published>2022-04-06T06:08:47.000Z</published>
    <updated>2022-06-02T10:09:44.828Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三高Mysql-Mysql索引和查询优化（偏实战部分）"><a href="#三高Mysql-Mysql索引和查询优化（偏实战部分）" class="headerlink" title="三高Mysql - Mysql索引和查询优化（偏实战部分）"></a>三高Mysql - Mysql索引和查询优化（偏实战部分）</h1><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>​    实战部分挑选一些比较常见的情况，事先强调个人使用的是<strong>mysql 8.0.26</strong>，所以不同版本如果出现不同测试结果也不要惊讶，新版本会对于过去一些不会优化的查询进行优化。</p><p>​    实战部分承接上一篇文章：<span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDA0MTY2MTQwMw==" title="https://segmentfault.com/a/1190000041661403">三高 Mysql - Mysql 索引和查询优化（偏理论部分）<i class="fa fa-external-link"></i></span></p><a id="more"></a><h1 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h1><p>​    这里还是要再啰嗦一遍，所有的数据库和表均来自官方的<strong>sakila-db</strong>，作为学习和熟悉mysql数据库操作非常好。</p><h2 id="sakila-db"><a href="#sakila-db" class="headerlink" title="sakila-db"></a>sakila-db</h2><p>​    sakila-db是什么？国外很火的一个概念，指的是国外电影租赁市场外国人使用租赁的方式进行电影的观看，过去十分受外国人的喜欢，这里拿出来介绍是因为后续的内容都用到了这个案例，所以我们需要提前把相关的环境准备好，从如下地址进行下载：</p><p>​    下载地址：<span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy9pbmRleC1vdGhlci5odG1s" title="https://dev.mysql.com/doc/index-other.html">https://dev.mysql.com/doc/index-other.html<i class="fa fa-external-link"></i></span></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204061302118.png" alt=""></p><h2 id="work-bench"><a href="#work-bench" class="headerlink" title="work-bench"></a>work-bench</h2><p>​    work-bench是官方开发的数据库关系图的可视化工具，使用官方案例的具体关系图展示效果如下，通过这些图可以看到Sakila-db之间的大致关系：</p><blockquote><p>work-bench 是免费软件，下载地址如下：</p><p><span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2Rvd25sb2Fkcy93b3JrYmVuY2gv" title="https://dev.mysql.com/downloads/workbench/">https://dev.mysql.com/downloads/workbench/<i class="fa fa-external-link"></i></span></p></blockquote><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204061302376.png" alt=""></p><p>​    </p><p>​    安装<code>workbench</code>和下载<code>sakila-db</code>的过程这里不做记录，在运行的时候需要注意先建立一个数据库运行<code>Sheme</code>文件，然后执行data的sql文件，最终借助navicat中查看数据和表结构关系：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204061302205.png" alt=""></p><p>​    </p><h1 id="正文部分"><a href="#正文部分" class="headerlink" title="正文部分"></a>正文部分</h1><h2 id="where查询太慢怎么办？"><a href="#where查询太慢怎么办？" class="headerlink" title="where查询太慢怎么办？"></a>where查询太慢怎么办？</h2><p>​    遇到where查询太慢，我们第一步是需要分析数据类型的组成以及数据表的设置是否合理，其次我们可以使用<code>explain</code>对于查询语句进行分析，使用方式十分简单在需要优化的查询语句前面添加<code>explain</code>语句，对于所有的查询来说，覆盖索引的查找方式是最优解，因为覆盖索引不需要回表查数据。</p><p>​    覆盖索引：覆盖索引是查询方式，他不是一个索引，指的是在查询返回结果的时候和使用的索引是同一个，这时候可以发现他压根不需要回表，直接查辅助索引树就可以得到数据，所以覆盖索引的查询效率比较高。</p><blockquote><p>如何使用sql语句查看某一个表的建表语句：</p><p>回答：使用<code>show create table 表名称</code>即可。 </p></blockquote><p>​    </p><p>​    那么什么情况下会使用覆盖索引：</p><ol><li>查询字段为辅助索引的字段或者聚簇索引的字段。</li><li>符合<strong>最左匹配原则</strong>，如果不是最左匹配则不能走索引。</li></ol><p>​    我们使用上面提到的<code>sakila-db</code>进行实验，这里可以使用<code>inventory</code>表作为实验，但是这个表需要进行一些调整，下面请看具体的sql：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`inventory_test`</span> (</span><br><span class="line">  <span class="string">`inventory_id`</span> mediumint <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`film_id`</span> <span class="built_in">smallint</span> <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`store_id`</span> <span class="built_in">tinyint</span> <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`last_update`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`inventory_id`</span>),</span><br><span class="line">  <span class="comment">-- KEY `idx_fk_film_id` (`film_id`),</span></span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_store_id_film_id`</span> (<span class="string">`store_id`</span>,<span class="string">`film_id`</span>)</span><br><span class="line">  <span class="comment">-- CONSTRAINT `fk_inventory_film` FOREIGN KEY (`film_id`) REFERENCES `film` (`film_id`) ON DELETE RESTRICT ON UPDATE CASCADE,</span></span><br><span class="line">  <span class="comment">-- CONSTRAINT `fk_inventory_store` FOREIGN KEY (`store_id`) REFERENCES `store` (`store_id`) ON DELETE RESTRICT ON UPDATE CASCADE</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">4582</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COLLATE</span>=utf8mb4_0900_ai_ci;</span><br></pre></td></tr></table></figure><p>​    我们将原始的sql建表语句只保留一个辅助索引，比如在上面的语句中删除了<code>idx_fk_film_id</code>索引，下面删除这个索引之后的实验效果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> inventory_test <span class="keyword">where</span> film_id = <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 案例1. 不符合最左原则不走索引 </span></span><br><span class="line"><span class="comment">-- 1  SIMPLE  inventory_test    ALL          1  100.00  Using where</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> inventory_test <span class="keyword">where</span> store_id = <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 案例2: 使用了辅助索引（联合索引）：</span></span><br><span class="line"><span class="comment">-- 1  SIMPLE  inventory_test    ref  idx_store_id_film_id  idx_store_id_film_id  1  const  1  100.00  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> inventory_id,film_id,store_id <span class="keyword">from</span> inventory_test <span class="keyword">where</span> store_id = <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 案例3:  正常使用索引 </span></span><br><span class="line"><span class="comment">-- 1 SIMPLE  inventory_test    ref  idx_store_id_film_id  idx_store_id_film_id  1  const  1  100.00  Using index</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> film_id,store_id <span class="keyword">from</span> inventory_test <span class="keyword">where</span> store_id = <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 案例4:  覆盖索引 </span></span><br><span class="line"><span class="comment">-- 1  SIMPLE  inventory_test    ref  idx_store_id_film_id  idx_store_id_film_id  1  const  1  100.00  Using index</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> film_id,store_id <span class="keyword">from</span> inventory_test <span class="keyword">where</span> film_id = <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 案例5: 正常使用索引，但是type存在区别 </span></span><br><span class="line"><span class="comment">-- 1  SIMPLE  inventory_test    index  idx_store_id_film_id  idx_store_id_film_id  3    1  100.00  Using where; Using index</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> inventory_id,film_id,store_id <span class="keyword">from</span> inventory_test <span class="keyword">where</span> film_id = <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 案例6: 使用索引返回结果，但是type存在区别 </span></span><br><span class="line"><span class="comment">-- 1  SIMPLE  inventory_test    index  idx_store_id_film_id  idx_store_id_film_id  3    1  100.00  Using where; Using index</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> inventory_id,film_id,store_id <span class="keyword">from</span> inventory_test <span class="keyword">where</span> store_id = <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 案例7: 覆盖索引 </span></span><br><span class="line"><span class="comment">-- 1  SIMPLE  inventory_test    ref  idx_store_id_film_id  idx_store_id_film_id  1  const  1  100.00  Using index</span></span><br></pre></td></tr></table></figure><p>​    案例1和案例2是较为典型的<strong>索引最左匹配原则</strong>的错误使用反面教材，也是很多新手建立索引但是可能用错的陷阱之一，最左匹配原则指的是where条件需要从建立索引的最左列开始进行搜索，可以看到这里的星号和建表的时候字段的顺序是一样的，也就是<code>inventory_id</code>，<code>film_id,store_id</code>，<code>last_update</code>，所以是虽然是<code>select *</code>但是是正常走索引的。</p><p>（实际干活时候千万不要这么做，这里是为了演示偷懒而已）</p><blockquote><p>不用星号我使用<strong>乱序</strong>的列查询会怎么样，其实这时候如果你把查询列的数据换一下会…..没啥影响，<strong>随意调换查询列顺序依然可以走索引</strong>。</p></blockquote><p>​    接下来是案例3 - 案例7的几个查询，这几个查询意图解释的是针对覆盖索引使用的细节问题，在上面的测试案例语句当中可以看到案例4由于查询的结果和where条件都是使用了索引的，所以最终mysql使用了完整的覆盖索引，同时符合联合索引的最左匹配原则，所以查询的效率达到了<code>ref</code>级别（这个级别暂时简单理解就是非常快就行）。</p><p>​    接着案例5又把where条件换了一下，可以看到虽然还是走了索引，但是效率一下子就低了下来，因为他不符合最左匹配原则，另外这个案例5的查询级别可以理解为它需要把整个辅助索引也就是联合索引的树扫完再去进行where筛选，效率自然就不如直接检索排序索引值快了，但是index这个级别还是比ALL这个龟速快不少。</p><p>​    理解了上面的这一层意思，再来理解案例6和7就很简单了，可以看到只多了一个主键列查询。</p><p>​    这里读者可能会觉得你这上面不是说返回结果全是索引列才会覆盖么，怎么加入了主键列还是奏效呢？主键不是在聚簇索引上嘛不是需要回表么？其实这两个问题很好回答，因为辅助索引当中key存储的确实是索引列的值，但是他的索引值放的是主键ID，当mysql在搜索索引列的时候发现这里多了一个列，但是又发现这个列是主键，所以最后发现可以直接通过联合索引直接返回结果不需要回表，所以这样覆盖索引的条件同样是成立的。</p><p>​    如果读者不清楚查询<code>explain</code>结果列代表的含义，可以参考下面的内容对比：</p><ul><li>id: 首先，一个select就会出现一个id, 通常在复杂的查询里面会包含多张表的查询，比如join, in等等</li><li>select_type：这个表示的是查询的类型</li><li>table：表名称</li><li>partitions：这个表示表空间，分区的概念</li><li><strong>type</strong> : 比如查询的优化等级,  const, index, all，分别代表了聚簇索引，二级索引(辅助索引)，全表扫描的查询搜索方式</li><li>Possiblekeys：和type一样确定访问方式，确定有哪些索引可以选择，</li><li>key：确定有哪些可以提供选择，同时提供索引的对应长度</li><li>key_len： 表示的是索引的长度</li><li>ref： 等值匹配的时候出现的一些匹配的相关信息</li><li>Rows： 预估通过所索引或者别的方式读取多少条数据</li><li>filtered：经过搜索条件过滤之后的剩余数据百分比。</li><li>extra：额外的信息不重要，主要用于用户判定查询走了什么索引。</li></ul><p>总结</p><p>通过上面的案例我们可以从下面的角度思考来如何提升索引查询速度：</p><ul><li>使用<strong>覆盖索引</strong>查询方式提高效率，再次强调覆盖索引不是索引是优化索引查询一种方式。</li><li>如果数据不只使用索引列那么就构不成覆盖索引。</li><li>可以优化sql语句或者优化联合索引的方式提高覆盖索引的命中率。</li></ul><h2 id="如何确认选择用什么索引？"><a href="#如何确认选择用什么索引？" class="headerlink" title="如何确认选择用什么索引？"></a>如何确认选择用什么索引？</h2><p>​    这里涉及一个索引基数（cardinality）的问题，索引基数是什么，其实就是利用算法和概率学统计的方式确定最优化的索引方案，这个值可以通过<code>show index from 表名</code>的方式进行获取，比如下面的200和121就是<strong>索引基数（cardinality）</strong>。</p><blockquote><p>因为索引基数的存在如果索引不符合我们到使用预期可以尝试强制使用某索引。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; show index from actor;</span><br><span class="line">actor  <span class="number">0</span>  PRIMARY  <span class="number">1</span>  actor_id  A  <span class="number">200</span>        BTREE      YES  </span><br><span class="line">actor  <span class="number">1</span>  idx_actor_last_name  <span class="number">1</span>  last_name  A  <span class="number">121</span>        BTREE      YES</span><br></pre></td></tr></table></figure><p>​    索引基数的定义官方文档的介绍：</p><p>​    下面一坨东西简单来说就是mysql会根据基数的数值根据一定的算法选择使用索引，但是有时候如果查询不能符合预期要求就需要强制使用索引了。</p><blockquote><p>表列中不同值的数量。当查询引用具有关联索引的列时，每列的基数会影响最有效的访问方法。<br />例如，对于具有唯一约束的列，不同值的数量等于表中的行数。如果一个表有一百万行，但特定列只有 10 个不同的值，<br />则每个值（平均）出现 100,000 次。 SELECT c1 FROM t1 WHERE c1 = 50 等查询因此可能会返回 1 行或大量行，<br />并且数据库服务器可能会根据 c1 的基数以不同方式处理查询。<br /><br />如果列中的值分布非常不均匀，则基数可能不是确定最佳查询计划的好方法。例如，SELECT c1 FROM t1 WHERE c1 = x;<br />当 x=50 时可能返回 1 行，当 x=30 时可能返回一百万行。在这种情况下，您可能需要使用索引提示来传递有关哪种<br />查找方法对特定查询更有效的建议。<br /><br />基数也可以应用于多个列中存在的不同值的数量，例如在复合索引中。<br />参考：<strong>列、复合索引、索引、索引提示、持久统计、随机潜水、选择性、唯一约束</strong>。</p></blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">原文：</span><br><span class="line">The number of different values in a table column. When queries refer to columns that have an </span><br><span class="line">associated index, the cardinality of each column influences which access method is most </span><br><span class="line">efficient. For example, for a column with a unique constraint, the number of different </span><br><span class="line">values is equal to the number of rows in the table. If a table has a million rows but </span><br><span class="line">only 10 different values for a particular column, each value occurs (on average) 100,000 times.</span><br><span class="line"> A query such as SELECT c1 FROM t1 WHERE c1 = 50; thus might return 1 row or a huge number of </span><br><span class="line"> rows, and the database server might process the query differently depending on the cardinality </span><br><span class="line"> of c1.</span><br><span class="line"></span><br><span class="line">If the values in a column have a very uneven distribution, the cardinality might not be </span><br><span class="line">a good way to determine the best query plan. For example, SELECT c1 FROM t1 WHERE c1 = x;</span><br><span class="line"> might return 1 row when x=50 and a million rows when x=30. In such a case, you might need </span><br><span class="line"> to use index hints to pass along advice about which lookup method is more efficient for a </span><br><span class="line"> particular query.</span><br><span class="line"></span><br><span class="line">Cardinality can also apply to the number of distinct values present in multiple columns, </span><br><span class="line">as in a composite index.</span><br><span class="line"></span><br><span class="line">See Also column, composite index, index, index hint, persistent statistics, random dive,</span><br><span class="line"> selectivity, unique constraint.</span><br></pre></td></tr></table></figure><p>​    </p><p>​    如何让sql强制使用索引</p><p>​    可以使用from表之后接条件语句：<code>force index(索引)</code> 的方式进行处理，使用强制索引的情况比较少，除非优化器真的选择了不符合预期的优化规则并且严重影响查询性能，使用强制索引的案例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> actor <span class="keyword">force</span> <span class="keyword">index</span>(idx_actor_last_name);</span><br></pre></td></tr></table></figure><h2 id="count-慢的原因是什么？"><a href="#count-慢的原因是什么？" class="headerlink" title="count()慢的原因是什么？"></a>count()慢的原因是什么？</h2><p>count函数不用多介绍，作用是查询结果的行数，但是需要注意优化器在处理过程中会<strong>比对并且排除掉结果为null的值</strong>的数据，这意味着在行数很大的时候如果使用不正确count会因为比对数据操作进而降低查询效率。</p><p>所以这里我们只要记住一个特定的规则，那就是只要是涉及行数的查询，那就使用<code>select(*)</code>，原因仅仅是mysql官方针对这个做了专门的优化，也不需要去纠结为什么官方要给<code>select(*)</code>做优化，只能说<strong>约定大于配置</strong>，下面是常见的查询性能之间的对比：</p><ul><li>count(非索引字段)：理论上是最慢的，因为对于每一行结果都要判断是否为null。</li><li>count(索引字段)：虽然走了索引，但是依然需要对每一行结果判断是否为null。</li><li>count(1)：虽然不涉及字段了，但是这种方式依然需要对1进行判断是否为null。</li><li><strong>count(*)：Mysql官方进行优化，查询效率最快，只需要记住这种方式即可</strong>。</li></ul><h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><p>索引下推实现版本为Mysql5.6以上。</p><p>作用：本质上是为了减少辅助索引（或者说二级索引）<strong>回表次数</strong>的一种优化手段。</p><p>案例：请看下面的建表语句，这里比较关键的是建立了<code>store_id</code>和<code>film_id</code>的联合索引 。</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202203211327993.png" alt=""></p><p>​    以下面的SQL语句为例，如果是5.6之前的版本虽然他是覆盖索引的查询方式但却是<strong>不能使用索引</strong>的，数据进过索引查找之后虽然store_id是顺序排序的但是film_id是乱序的，在索引检索的时候由于没有办法顺序扫描（如果不清楚索引组织结构可以多看几遍B+树索引构造） 它需要一行行使用主键回表进行查询，查询实际需要使用每一行的<code>inentory_id</code>回表4次去匹配film_id是否为3。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> inventory_3 <span class="keyword">where</span> store_id <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>) <span class="keyword">and</span> film_id = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204061303013.png" alt=""></p><p>​    按照人的思维看起来是很不合理的，因为我们可以发现按照正常的逻辑有一种搜索的方法是通过“跳跃“索引的方式进行扫描，当扫描到索引列如果不符合条件，则直接跳跃索引到下一个索引列，有点类似我们小时候”跳房子“方式来寻找自己需要的沙袋（索引数据）。</p><p>​    <strong>那么索引下推是如何处理上面这种情况的呢</strong>？虽然film_id是没有办法顺序扫描的也不符合索引的排列规则，但是发现可以根据遍历film_id汇总索引之后再回表查呀！比如根据查询条件搜索遍历找到film=3之后再根据二级索引列对应的主键去查主索引，这时候只需要一次回表就可以查到数据，此时原本应该根据每个二级索引的主键值进行回表变为遍历索引并找到索引值之后再回表，最终达到减少回表次数的效果，这也是前面为什么说索引下推是为了减少了回表的次数的答案。</p><p>​    索引下推的开启和关闭可以参考如下命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 索引下推变量值：</span></span><br><span class="line">mysql&gt; select @@optimizer_switch\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@optimizer_switch: index_merge=on,index_merge_union=on,index_merge_sort_union=on,index_merge_intersection=on,engine_condition_pushdown=on,index_condition_pushdown=on,mrr=on,mrr_cost_based=on,block_nested_loop=on,batched_key_access=off,materialization=on,semijoin=on,loosescan=on,firstmatch=on,duplicateweedout=on,subquery_materialization_cost_based=on,use_index_extensions=on,condition_fanout_filter=on,derived_merge=on</span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 关闭索引下推</span></span><br><span class="line"><span class="keyword">set</span> optimizer_switch=<span class="string">'index_condition_pushdown=off'</span>;</span><br><span class="line"><span class="comment">-- 开启索引下推</span></span><br><span class="line"><span class="keyword">set</span> optimizer_switch=<span class="string">'index_condition_pushdown=on'</span>;</span><br></pre></td></tr></table></figure><h2 id="松散索引和紧凑索引"><a href="#松散索引和紧凑索引" class="headerlink" title="松散索引和紧凑索引"></a><strong>松散索引和紧凑索引</strong></h2><p>​    关于松散索引和紧凑索引可以看下面两个文档对比参考阅读：</p><p>​    <span class="exturl" data-url="aHR0cHM6Ly93d3cuZG9jczRkZXYuY29tL2RvY3MvemgvbXlzcWwvNS43L3JlZmVyZW5jZS9ncm91cC1ieS1vcHRpbWl6YXRpb24uaHRtbA==" title="https://www.docs4dev.com/docs/zh/mysql/5.7/reference/group-by-optimization.html">MySql 中文文档 - 8.2.1.15 GROUP BY 最佳化 | Docs4dev<i class="fa fa-external-link"></i></span></p><p>​    <span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy9yZWZtYW4vOC4wL2VuL2dyb3VwLWJ5LW9wdGltaXphdGlvbi5odG1s" title="https://dev.mysql.com/doc/refman/8.0/en/group-by-optimization.html">MySQL :: MySQL 8.0 Reference Manual :: 8.2.1.17 GROUP BY Optimization<i class="fa fa-external-link"></i></span></p><p>​    松散索引和紧凑索引的概念不是特别好理解，松散索引和紧凑索引实际上就是当MySQL 利用索引扫描来实现<code>GROUP BY</code>的时候，<strong>并不需要扫描所有满足条件的索引键即可完成操作得出结果</strong>，仅仅处理的情况细节不同。</p><p>​    过去Mysql对于<code>group by</code>操作是构建临时表并且在临时表上操作，在使用索引的情况下，分组查询是可以走索引的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> last_name <span class="keyword">from</span> actor  <span class="keyword">GROUP</span> <span class="keyword">BY</span> last_name</span><br><span class="line"><span class="comment">-- 1SIMPLEactorindexidx_actor_last_nameidx_actor_last_name182200100.00Using index</span></span><br></pre></td></tr></table></figure><p>​    由于<code>group by</code> 操作和<code>order by</code>操作不走索引的时候可能会产生临时表，同时<code>group by</code> 操作拥有和<code>order by</code> 类似的排序操作，有时候我们分组查询不止一个字段，所以可能会出现多列索引情况，所以此时mysql对于多列联合索引分组查询进一步优化，提供了松散索引和紧凑索引多概念，</p><p>​    松散索引在官方有下面的定义：</p><ol><li>当彻底使用索引扫描实现<code>group by</code>操作的时候，只需要使用部分的索引列就可以完成操作</li><li>虽然Btree的二级索引内部是排序并且要求索引是顺序访问的，但是对于group by最大的优化是扫描这种顺序索引的时候<strong>where条件没必要完全贴合所有索引key</strong>，</li></ol><p>​    上面定义有两个个关键词：<strong>彻底</strong>和<strong>不完全</strong>，where条件没必要完全贴合索引键。为了更好理解我们这里使用了官方给的例子，假设在 table<code>t1(c1,c2,c3,c4)</code>上有一个索引<code>idx(c1,c2,c3)</code>。松散索引扫描访问方法可用于以下查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 可以不使用所有索引字段，可以走联合索引</span></span><br><span class="line"><span class="keyword">SELECT</span> c1, c2 <span class="keyword">FROM</span> t1 <span class="keyword">GROUP</span> <span class="keyword">BY</span> c1, c2;</span><br><span class="line"><span class="comment">-- 去重操作内部也会进行隐式的分组行为</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> c1, c2 <span class="keyword">FROM</span> t1;</span><br><span class="line"><span class="comment">-- 分组的极值查询可以使用松散索引，因为c2和c1依然有序</span></span><br><span class="line"><span class="keyword">SELECT</span> c1, <span class="keyword">MIN</span>(c2) <span class="keyword">FROM</span> t1 <span class="keyword">GROUP</span> <span class="keyword">BY</span> c1;</span><br><span class="line"><span class="comment">-- 分组前的where 条件</span></span><br><span class="line"><span class="keyword">SELECT</span> c1, c2 <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c1 &lt; const <span class="keyword">GROUP</span> <span class="keyword">BY</span> c1, c2;</span><br><span class="line"><span class="comment">-- 对于c3的极值操作依然和c1,c2构成索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(c3), <span class="keyword">MIN</span>(c3), c1, c2 <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c2 &gt; const <span class="keyword">GROUP</span> <span class="keyword">BY</span> c1, c2;</span><br><span class="line"><span class="comment">-- 支持范围查询的同时走松散索引</span></span><br><span class="line"><span class="keyword">SELECT</span> c2 <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c1 &lt; const <span class="keyword">GROUP</span> <span class="keyword">BY</span> c1, c2;</span><br><span class="line"><span class="comment">-- 最后一列等值查询依然可以视为松散索引</span></span><br><span class="line"><span class="keyword">SELECT</span> c1, c2 <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c3 = const <span class="keyword">GROUP</span> <span class="keyword">BY</span> c1, c2;</span><br><span class="line"><span class="comment">-- 松散索引可以作用于下面的查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> c1), <span class="keyword">SUM</span>(<span class="keyword">DISTINCT</span> c1) <span class="keyword">FROM</span> t1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> c1, c2), <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> c2, c1) <span class="keyword">FROM</span> t1;</span><br></pre></td></tr></table></figure><p>​    松散索引需要满足下面的条件：</p><ul><li>分组查询是单表查询</li><li><code>group by</code>的条件必须同一个索引顺序索引的连续位置。</li><li><code>group by</code>的同时只能使用max或者min两个聚合函数（但是在5.5之后，新增了更多函数支持）。</li><li>如果应用<code>group by</code>以外字段条件必须用<strong>常量形式</strong>存在。</li><li>必须使用完整的索引值，也就意味着like这样的前缀索引是不适用的。</li></ul><p>​    如果想要判定查询是否使用松散索引可以根据<code>explain</code>的<code>extra</code>内容是否为<code>Using index for group-by</code>确认。</p><p>​    下面我们用更实际SQL来介绍，假设在 table<code>t1(c1,c2,c3,c4)</code>上有一个索引<code>idx(c1,c2,c3)</code>。松散索引扫描访问方法可用于以下查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 自我实验：松散索引</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> film_id, store_id), <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> store_id, film_id) <span class="keyword">FROM</span> inventory_test;</span><br><span class="line"><span class="comment">-- 1  SIMPLE  inventory_test    range  idx_store_id_film_id  idx_store_id_film_id  3    4  100.00  Using index for group-by (scanning)</span></span><br><span class="line"><span class="comment">-- 自我实验：松散索引</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> store_id), <span class="keyword">SUM</span>(<span class="keyword">DISTINCT</span> store_id) <span class="keyword">FROM</span> inventory_test;</span><br><span class="line"><span class="comment">-- 1  SIMPLE  inventory_test    range  idx_store_id_film_id  idx_store_id_film_id  1    4  100.00  Using index for group-by (scanning)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 但是如果查询的不是同一个索引，不满足最左原则是不走松散索引的，而是走更快的索引扫描：</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> store_id), <span class="keyword">SUM</span>(<span class="keyword">DISTINCT</span> store_id) <span class="keyword">FROM</span> inventory_test;</span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> film_id), <span class="keyword">SUM</span>(<span class="keyword">DISTINCT</span> film_id) <span class="keyword">FROM</span> inventory_test;</span><br><span class="line"><span class="comment">-- 1SIMPLEinventory_testrangeidx_store_id_film_ididx_store_id_film_id14100.00Using index for group-by (scanning)</span></span><br><span class="line"><span class="comment">-- 1SIMPLEinventory_testindexidx_store_id_film_ididx_store_id_film_id33100.00Using index</span></span><br></pre></td></tr></table></figure><p><strong>紧凑索引</strong></p><p>​    和松散索引区别的是紧凑索引使用前提是必须是<strong>全索引扫描</strong>或者<strong>范围索引扫描</strong>，当松散索引没有生效时使得<code>group by</code> 依然有可能避免创建临时表，紧凑索引需要读取所有满足条件的索引键才会工作，然后根据读取的数据完成<code>group by</code> 操作。</p><p>​    为了使紧凑索引查询这种方法奏效在查询中的所有列都要有<strong>恒定的相等条件</strong>，比如必须<code>GROUP BY</code>键之前或之间的部分键。</p><p>​    在紧凑索引扫描方式下，先对索引执行<strong>范围扫描（range scan）</strong>，再对结果元组进行分组。为了更好的理解，可以看一下相关的案例：</p><p>​    在<code>GROUP BY</code>中存在一个缺口，但是它被条件<code>c2=&#39;a&#39;</code>所覆盖。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c1, c2, c3 <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c2 = <span class="string">'a'</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> c1, c3;</span><br></pre></td></tr></table></figure><p>​    <code>GROUP BY</code>没有以键的第一部分开始，但是有一个条件为这部分提供了一个常数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c1, c2, c3 <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c1 = <span class="string">'a'</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> c2, c3;</span><br></pre></td></tr></table></figure><p>​    我们按照官方给的案例实验一下，首先是表结构，我们在下面表中建立联合索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`inventory_test`</span> (</span><br><span class="line">  <span class="string">`inventory_id`</span> mediumint <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`film_id`</span> <span class="built_in">smallint</span> <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`store_id`</span> <span class="built_in">tinyint</span> <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`last_update`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`inventory_id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_store_id_film_id`</span> (<span class="string">`store_id`</span>,<span class="string">`film_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">4582</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COLLATE</span>=utf8mb4_0900_ai_ci;</span><br></pre></td></tr></table></figure><p>​    下面是个人使用紧凑索引的案例，当where条件是常量值并且是针对索引的常量值的时候，<code>group by</code>就可以走索引，但是如果where条件是非索引字段依然需要全表扫描，注意这里group的字段并不是按照联合索引的最左前缀处理的依然可以走索引，这就是mysql对于分组操作的一系列优化了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 紧凑索引</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> <span class="keyword">count</span>(*),<span class="keyword">max</span>(film_id),<span class="keyword">sum</span>(film_id), <span class="keyword">avg</span>(film_id) <span class="keyword">from</span> inventory_test <span class="keyword">where</span> store_id = <span class="number">1</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> film_id;</span><br><span class="line"><span class="comment">-- 1  SIMPLE  inventory_test    ref  idx_store_id_film_id  idx_store_id_film_id  1  const  1  100.00  Using index</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> <span class="keyword">count</span>(*),<span class="keyword">max</span>(film_id),<span class="keyword">sum</span>(film_id), <span class="keyword">avg</span>(film_id) <span class="keyword">from</span> inventory_test <span class="keyword">where</span> last_update &gt; <span class="string">'2022-02-02 23:20:45'</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> film_id;</span><br><span class="line"><span class="comment">-- 1  SIMPLE  inventory_test    ALL  idx_store_id_film_id        3  33.33  Using where; Using temporary</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> <span class="keyword">count</span>(*),<span class="keyword">max</span>(film_id),<span class="keyword">sum</span>(film_id), <span class="keyword">avg</span>(film_id) <span class="keyword">from</span> inventory_test <span class="keyword">where</span> last_update = <span class="string">'2022-02-02 23:20:45'</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> film_id;</span><br><span class="line"><span class="comment">-- 1  SIMPLE  inventory_test    ALL  idx_store_id_film_id        3  33.33  Using where; Using temporary</span></span><br></pre></td></tr></table></figure><p>​    建议读者多读一读官方文档加深这两个概念理解。</p><h2 id="order-by如何优化？"><a href="#order-by如何优化？" class="headerlink" title="order by如何优化？"></a>order by如何优化？</h2><p>什么是中间结果集？</p><p>​    对于常规的sort语句，由于需要对于搜索的结果按照某一字段进行大小排序，而为了让这个操作顺利完成，mysql会把这个操作放到硬盘或者内存完成。</p><p>排序的基本步骤和原理 </p><p>​    对于涉及排序的语句，它的大致工作原理如下：</p><ol><li>选取查询字段，根据<code>where</code>进行条件查询。</li><li>查询结果集生成<code>sort_buffer</code>，如果内存不够，需要在硬盘建立中间表进行排序。</li><li>将中间表根据<code>Order</code> 字段进行排序。</li><li>回表生成完整结果集，组装返回结果。</li></ol><p>中间结果集特点</p><p>​    如果中间表比较小则放到内存中，判定什么时候会存在于内存中Mysql提供了<code>sort_buffer_size</code>的参数，它负责控制中间结果集的大小，如果优化内存需要调整降低这个参数值，但是如果想要优化查询的时间，则需要调大这个参数。</p><p>回表生成完整结果集</p><p>​    回表生成完整结果集这个操作其实也不是总是执行的，会根据会话参数<code>max_length_for_sort_data</code>进行判断，如果当前查询小于这个数值，会生成一个<strong>全字段中间表</strong>结果可以直接从全字段中间表获取，但是如果大于这个数值那么就只会生成<strong>排序字段+主键中间表</strong>（类似二级索引），所以这时候显然查找一遍是无法找到的，需要回表才能完成操作。</p><blockquote><p>需要注意<strong>排序字段+主键中间表</strong>看起来像是二级索引但是实际上和二级索引完全没有关系，只是一个简单列表需要反复去主表获取数据。</p></blockquote><p>​    总结：全字段中间表&gt;<code>max_length_for_sort_data</code>&gt;排序字段+主键中间表，数值并不是越大越好越大越影响查询效率。</p><p>排序查询优化点</p><p>​    根本问题在于排序的结果是中间结果集，虽然结果集可以在内存中处理，但是他有最为本质的问题那就是<strong>中间表不存在索引</strong>并且导致索引失效，所以为了让中间表可以走索引我们可以使用<strong>索引覆盖</strong>的方式。</p><blockquote><p>优化手段：索引覆盖，也是最高效的处理方式。索引覆盖可以跳过生成生成中间结果集，直接输出查询结果。</p></blockquote><ol><li>order by的字段为索引（或者联合索引的最左边）。</li><li>其他字段（条件、输出）均在上述索引中。</li><li>索引覆盖可以跳过中间结果集，直接输出查询结果。 </li></ol><blockquote><p>什么是索引覆盖？</p><p>覆盖索引：覆盖索引是<strong>查询方式</strong>而不是一个索引，指的是一个sql语句中包括查询条件和返回结果均符合索引使用条件，当然在Mysql5.6之后增加索引下推，满足下推条件的也可以走覆盖索引。</p></blockquote><p>​    比如下面的语句并不会生成中间结果集并且可以有效利用索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> film_id, title <span class="keyword">from</span> film <span class="keyword">order</span> <span class="keyword">by</span> title;</span><br><span class="line"><span class="comment">-- 1SIMPLEfilmindexidx_title5141000100.00Using index</span></span><br></pre></td></tr></table></figure><p>总结：提升排序查询速度</p><ol><li>给<code>order by</code>字段增加索引，或者<code>where</code>字段使用索引，让查询可以走覆盖索引的方式。</li><li>调整<code>sort_buffer_size</code>大小，或者调整<code>max_length_for_sort_data</code>的大小，让排序尽量在内存完成。</li></ol><h2 id="函数操作索引失效的问题"><a href="#函数操作索引失效的问题" class="headerlink" title="函数操作索引失效的问题"></a>函数操作索引失效的问题</h2><p>通过下面的案例可以得知，如果我们对于索引的字段进行了类似函数的操作那么mysql会放弃使用索引，另外一种情况是日期函数比如month()函数也会使得索引失效。</p><blockquote><p>小贴士：很多人以为函数操作是那些sum()，count()函数，实际上对于字段的<strong>加减乘除</strong>操作都可以认为是函数操作，因为底层需要调用计算机的寄存器完成相关指令操作。另外这里需要和签名的索引下推和松散紧凑索引做区分，松散和紧凑索引针对分组操作索引优化，索引下推到了5.6才被正式引入。大多数旧版本的mysql系统是没法享受使用函数操作同时还能走索引的。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- sql1：对于索引字段进行函数操作</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span></span><br><span class="line">  title </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  film   </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  title + <span class="string">'22'</span> = <span class="string">'ACADEMY DINOSAUR'</span> </span><br><span class="line">  <span class="keyword">AND</span> <span class="keyword">length</span> + <span class="number">11</span> = <span class="number">86</span>;</span><br><span class="line">  <span class="comment">-- 1  SIMPLE  film    ALL          1000  100.00  Using where</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">-- sql2：如果对于其他字段使用函数操作，但是索引字段不进行 函数操作依然可以走索引</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span></span><br><span class="line">  title </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  film </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  title  = <span class="string">'ACADEMY DINOSAUR'</span> </span><br><span class="line">  <span class="keyword">AND</span> <span class="keyword">length</span> + <span class="number">11</span> = <span class="number">86</span>;</span><br><span class="line">  <span class="comment">-- 1  SIMPLE  film    ref  idx_title  idx_title  514  const  1  100.00  Using where</span></span><br></pre></td></tr></table></figure><p>时间函数如何优化：</p><p>​    我们要如何优化时间函数呢？有一种比较笨的方式是使用 <strong>between and 替代，</strong>比如要搜索5月份，就使用5月的第一天到5月的最后一天，具体的优化案例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> last_update <span class="keyword">from</span> payment <span class="keyword">where</span> <span class="keyword">month</span>(last_update) =<span class="number">2</span>;</span><br><span class="line"><span class="comment">-- last_update需要手动创建索引</span></span><br><span class="line"><span class="comment">-- 1  SIMPLE  payment    ALL          16086  100.00  Using where</span></span><br></pre></td></tr></table></figure><p>​    如果需要优化上面的结果，我们可以使用其他的方式替换写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain select * from payment where last_update between <span class="string">'2006-02-01'</span> and <span class="string">'2006-02-28'</span>;</span><br><span class="line">-- <span class="number">1</span>  SIMPLE  payment    ALL  idx_payment_lastupdate        <span class="number">16086</span>  <span class="number">50.00</span>  Using where</span><br></pre></td></tr></table></figure><p>​    这里很奇怪，咋和上面说的不一样呢？其实是因为<code>last_update</code>这个字段使用的数据类型是<strong>t</strong>imestamp，而timestamp在进行搜索的时候由于优化器的判断会放弃使用索引！所以解决办法也比较简单：<strong>使用force inde</strong>x 让SQL 强制使用索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span>  * <span class="keyword">from</span> payment <span class="keyword">force</span> <span class="keyword">index</span>(idx_payment_lastupdate) <span class="keyword">where</span> last_update <span class="keyword">between</span> <span class="string">'2006-02-01'</span> <span class="keyword">and</span> <span class="string">'2006-02-28'</span> ;</span><br><span class="line"><span class="comment">-- 1  SIMPLE  payment    range  idx_payment_lastupdate  idx_payment_lastupdate  5    8043  100.00  Using index condition</span></span><br></pre></td></tr></table></figure><blockquote><p>这里经过实验发现如果字段是datetime，就可以直接用Between and索引，对于时间戳类型并没有实验，仅从现有的表设计来看结果如下：</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 优化后</span></span><br><span class="line"><span class="comment">-- 1  SIMPLE  rental    range  rental_date  rental_date  5    182  100.00  Using index condition</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> rental <span class="keyword">where</span> rental_date <span class="keyword">between</span> <span class="string">'2006-02-01'</span> <span class="keyword">and</span> <span class="string">'2006-02-28'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1  SIMPLE  rental    ALL          16008  100.00  Using where</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> rental <span class="keyword">where</span>  <span class="keyword">month</span>(rental_date) =<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>字符和数字比较：</p><p>​    字符和数字比较也是会出现函数转化的同样会导致索引失效，所以在等式匹配的时候需要确保被比较的类型左右两边一致，另外如果无法修改查询可以使用cast函数进行补救，比如像下面这样处理。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> city <span class="keyword">where</span> <span class="keyword">cast</span>(city_id <span class="keyword">as</span> SIGNED <span class="built_in">int</span>) = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>隐式字符编码转化：</p><p>​    如果两个表字段的编码不一样，也会出现索引失效的问题，因为底层需要对于编码进行转化，解决方式也比较简单，在比较的时候， 同时<strong>尽量</strong>比较字符串保证编码一致。那么假设两张表比较的时候，那个表的字段需要转化呢，比如A表的utf8和B表utf8mb4，A表中字段需要和B表字段进行比较的时候，需要将<strong>A表的字段转为和 B表的字段一致</strong>。</p><blockquote><p>这个就偷懒不实验了，绝大多数情况下表的字符集编码格式只要跟随表级别基本不会出现不一致的问题……</p></blockquote><h2 id="order-by-rand-原理"><a href="#order-by-rand-原理" class="headerlink" title="order by rand()原理"></a>order by rand()原理</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> tilte, desciption <span class="keyword">from</span> film <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">rand</span>() <span class="keyword">limit</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- EXPLAIN select title, description from film order by rand() limit 1;</span></span><br><span class="line"><span class="comment">-- 1  SIMPLE  film    ALL          1000  100.00  Using temporary; Using filesort</span></span><br></pre></td></tr></table></figure><p>​    <code>rand()</code>函数是十分耗费数据库性能的函数，在日常使用过程中我们可能遇到需要临时获取一条数据的情况，这时候就有可能会使用<code>rand()</code>函数，下面是<code>rand()</code>函数的执行原理：</p><ul><li>创建一个临时表，临时表字段为<code>rand、title、description</code>。</li><li>从临时表中获取一行，调用rand()，把结果和数据放入临时表，以此类推。</li><li>针对临时表，把rand字段+行位置（主键）放入到<code>sort_buffer</code>。</li></ul><p>​    可以看到这里最大的问题是出现了<strong>两次中间结果集</strong>。</p><p>​    针对此问题可以使用下面的临时方案进行处理，这个临时方案可以看作是把rand()内部的工作拆开来进行处理，也是在不改动业务的情况下一种比较“笨”的解决方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(film_id),<span class="keyword">min</span>(film_id) <span class="keyword">into</span> @M,@N <span class="keyword">from</span> film;</span><br><span class="line"><span class="keyword">set</span> @x=<span class="keyword">FLOOR</span>((@M-@N+<span class="number">1</span>) * <span class="keyword">rand</span>() + @N);</span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> title,description <span class="keyword">from</span> film <span class="keyword">where</span> film_id &gt;= @X <span class="keyword">limit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>​    其他处理方式是使用业务和逻辑代码替代sql的内部处理，比如使用下面的方式进行处理：</p><ol><li>查询数据表总数 total。</li><li>total范围内，随机选取一个数字r。</li><li>执行下列的SQL：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> title,description <span class="keyword">from</span> film <span class="keyword">limit</span> r,<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>​    小结：</p><ol><li><p><code>order by rand() limit</code> 这个查询的效率极其低下，因为他需要生成两次中间表才能获取结果，谨慎使用此函数。</p></li><li><p>解决方案有两种：</p><ul><li><p>临时解决方案：在主键的最大值和最小值中选取一个。</p></li><li><p>好理解的方式处理：业务代码加limit处理</p></li></ul><p>优点：在不改变业务的情况下直接通过调整SQL                                                                                                                       </p><p>缺点：模板代码比较难以记忆，并且并不是万能的，因为可能不给你相关权限</p></li><li><p>建议使用业务逻辑代码处理不使用rand()函数。</p></li></ol><h2 id="分页查询慢怎么办？"><a href="#分页查询慢怎么办？" class="headerlink" title="分页查询慢怎么办？"></a>分页查询慢怎么办？</h2><p>​    再次注意这里实验的时候使用的数据库版本为<strong>8.0.26</strong>。</p><p>​    我们首先来看一下《高性能Mysql 第三版》 241-242页怎么说的，作者使用的也是sakila表，推荐的方式是使用<strong>延迟关联</strong>的方法，比如把下面的sql进行优化：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 优化前</span></span><br><span class="line"><span class="keyword">select</span> film_id,description <span class="keyword">from</span> film <span class="keyword">order</span> <span class="keyword">by</span> title <span class="keyword">limit</span> <span class="number">50</span>,<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 优化后</span></span><br><span class="line"><span class="keyword">select</span> film_id,description <span class="keyword">from</span> film <span class="keyword">inner</span> <span class="keyword">join</span> (<span class="keyword">select</span> film_id <span class="keyword">from</span> film <span class="keyword">order</span> <span class="keyword">by</span> title <span class="keyword">limit</span> <span class="number">50</span>, <span class="number">5</span>) <span class="keyword">as</span> lim <span class="keyword">using</span>(film_id)</span><br></pre></td></tr></table></figure><p>​    第二种方式是当id符合某种排序规则并且业务刚好符合的时候可以使用<code>between ...and</code>替代</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> film <span class="keyword">where</span> film_id <span class="keyword">between</span> <span class="number">46</span> <span class="keyword">and</span> <span class="number">50</span> <span class="keyword">order</span> <span class="keyword">position</span>;</span><br></pre></td></tr></table></figure><p>​    最后还有一种方式是利用排序的特性将数据排序之后获取前面的行即可：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> film <span class="keyword">where</span> film_id <span class="keyword">order</span> <span class="keyword">position</span> <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>​    以上是关于《高性能Mysql 第三版》 部分的介绍。下面来看下我们是否还有其他的办法？</p><p>​    深分页问题不管是面试还是日常开发中经常会遇到的问题，这和limit的语法特性有关，可以看下面的内容：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> film <span class="keyword">limit</span> x,y;</span><br></pre></td></tr></table></figure><p>​    limit的语句的执行顺序如下：</p><ol><li>先按照列查找出所有的语句，如果有where语句则根据where查找出数据</li><li>查找数据并且加入结果集直到查找到（x+y）条数据为止。</li><li>丢弃掉前面的x条，保留y条。</li><li>返回剩下的y条数据。</li></ol><p>​    针对limit我们有下面的优化和处理方案：</p><p>​    1. <strong>简单优化</strong>：</p><p>​    如果主键是int自增并且主键是逻辑符合业务自增的，那么我们可以使用下面的语句进行优化：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> film <span class="keyword">where</span> <span class="keyword">id</span> &gt;= <span class="number">10000</span> <span class="keyword">limit</span> y;</span><br></pre></td></tr></table></figure><p>​    </p><p>​    2. <strong>子查询优化</strong>：</p><p>​    自查询的优化方式是减少回表次数的一种方式，我们可以使用自查询的方式，由于不同业务之间存在不同的处理方式，这里给一个大致的处理模板：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> film <span class="keyword">where</span> <span class="keyword">ID</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> film <span class="keyword">where</span> title = <span class="string">'BANG KWAI'</span>) <span class="keyword">limit</span> <span class="number">10000</span>,<span class="number">10</span></span><br></pre></td></tr></table></figure><p>​    这样处理过后有两个优点：</p><ul><li>查询转为搜索索引列，并且不需要磁盘IO。</li><li>虽然使用的是子查询，但是因为搜索的是索引列，所以效率还是比较高的。</li></ul><p>​    3. <strong>延迟关联</strong></p><p>​    和《高性能Mysql》的方式一样，其实就是子查询方式的一种优化版本，优化的思路也是把过滤数据变为走索引之后在进行排除，由于上文已经介绍过这里就不再赘述了。</p><p>总结：</p><p>​    对于深分页的问题我们一般有下面的优化思路：</p><ul><li>如果主键符合自增或者符合业务排序，可以直接通过<code>id&gt;xxx</code> 然后limit搜索数据。</li><li>如果通过排序可以正确搜索相关数据，则可以直接排序之后取条数即可。</li><li>延迟关联，延迟关联有两种方式，第一种是使用in的子查询，第二种是使用inner join，本质都是通过索引列的方式避免大数据的查找，同时转变为查索引的方式。</li><li>如果可以确认范围，使用between and 替代。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​    本节内容针对了一些实战过程中可能经常遇到的一些问题处理进行阐述，其中稍微有些难度的部分在索引下推和紧凑索引部分，这些特性</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>​    <span class="exturl" data-url="aHR0cHM6Ly93d3cuZG9jczRkZXYuY29tL2RvY3MvemgvbXlzcWwvNS43L3JlZmVyZW5jZS9ncm91cC1ieS1vcHRpbWl6YXRpb24uaHRtbA==" title="https://www.docs4dev.com/docs/zh/mysql/5.7/reference/group-by-optimization.html">MySql 中文文档 - 8.2.1.15 GROUP BY 最佳化 | Docs4dev<i class="fa fa-external-link"></i></span></p><p>​    [MySQL :: MySQL 8.0 Reference Manual :: 8.2.1.17 GROUP BY Optimization](</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      Mysql索引和查询优化
    
    </summary>
    
    
      <category term="数据库-mysql" scheme="https://whitestore.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-mysql/"/>
    
    
      <category term="数据库" scheme="https://whitestore.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Mysql" scheme="https://whitestore.top/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>三高Mysql - Mysql索引和查询优化（偏理论部分）</title>
    <link href="https://whitestore.top/2022/04/06/suoyinlilun/"/>
    <id>https://whitestore.top/2022/04/06/suoyinlilun/</id>
    <published>2022-04-06T06:05:30.000Z</published>
    <updated>2022-06-02T10:09:44.829Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三高Mysql-Mysql索引和查询优化（偏理论部分）"><a href="#三高Mysql-Mysql索引和查询优化（偏理论部分）" class="headerlink" title="三高Mysql - Mysql索引和查询优化（偏理论部分）"></a>三高Mysql - Mysql索引和查询优化（偏理论部分）</h1><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>​    内容为慕课网的”高并发 高性能 高可用 MySQL 实战”视频的学习笔记内容和个人整理扩展之后的笔记，本节内容讲述的索引优化的内容，另外本部分内容涉及很多优化的内容，所以学习的时候建议翻开《高性能Mysql》第六章进行回顾和了解，对于Mysql数据的开发同学来说大致了解内部工作机制是有必要的。</p><p>​    由于文章内容过长，所以这里拆分为两部分，上下部分的内容均使用<strong>sakila-db</strong>，也就是mysql的官方案例。第一部分讲述优化的理论和Mysql过去的优化器设计的缺陷，同时会介绍更高的版本中如何修复完善这些问题的（但是从个人看来新版本那些优化根本算不上优化，甚至有的优化还是照抄的Mysql原作者的实现的，发展了这么多年才这么一点成绩还是要归功于Oracle这种极致商业化公司的功劳）。</p><blockquote><p>如果内容比较难，可以跟随《Mysql是怎么样运行》个人读书笔记专栏补补课，个人也在学习和同步更新中。</p><p>地址如下：<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vY29sdW1uLzcwMjQzNjM0NzY2NjM3MzAyMDfjgII=" title="https://juejin.cn/column/7024363476663730207。">https://juejin.cn/column/7024363476663730207。<i class="fa fa-external-link"></i></span></p></blockquote><a id="more"></a><h1 id="【知识点】"><a href="#【知识点】" class="headerlink" title="【知识点】"></a>【知识点】</h1><ul><li>Mysql索引内容的介绍</li><li>索引的使用策略和使用规则</li><li>查询优化排查，简单了解Mysql各个组件的职责</li></ul><h1 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h1><h2 id="sakila-db"><a href="#sakila-db" class="headerlink" title="sakila-db"></a>sakila-db</h2><p>​    sakila-db是什么？国外很火的一个概念，指的是国外的电影租赁市场使用租赁的方式进行电影的观看十分受外国的喜欢。这里介绍是因为后续的内容都用到了这个案例。所以我们需要提前把相关的环境准备好，从如下地址进行下载：</p><p>​    下载地址：<span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy9pbmRleC1vdGhlci5odG1s" title="https://dev.mysql.com/doc/index-other.html">https://dev.mysql.com/doc/index-other.html<i class="fa fa-external-link"></i></span></p><blockquote><p>《高性能Mysql》的SQL 案例也是使用官方的example</p></blockquote><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202203201510470.png" alt=""></p><h2 id="work-bench"><a href="#work-bench" class="headerlink" title="work-bench"></a>work-bench</h2><p>​    work-bench是官方开发的数据库关系图的可视化工具，使用官方案例的具体关系图展示效果如下，通过这些图可以看到Sakila-db之间的大致关系：</p><blockquote><p>work-bench也是开源免费软件，下载地址如下：</p><p><span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2Rvd25sb2Fkcy93b3JrYmVuY2gv" title="https://dev.mysql.com/downloads/workbench/">https://dev.mysql.com/downloads/workbench/<i class="fa fa-external-link"></i></span></p></blockquote><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202203201508589.png" alt="sakila-db示意图"></p><p>​    安装workbench和下载sakila-db的方式这里不做记录，在运行的时候需要注意先建立一个数据库运行sheme文件，然后执行data的sql文件，最终在navicat中查看数据：</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202203201521740.png" alt="数据库关系图"></p><h1 id="正文部分"><a href="#正文部分" class="headerlink" title="正文部分"></a>正文部分</h1><h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><p>​    首先是索引的特点以及作用：</p><ol><li><p>索引的目的是为了提升数据的效率。</p></li><li><p>对于ORM框架来说索引的使用至关重要，但是ORM的优化往往难以顾及所有业务情况，后续被逐渐废弃。</p></li><li><p>不同的索引类型适用于不同的场景。</p></li><li><p>索引关键在于减少数据需要扫描的量，同时避免服务器内部对内容排序和临时表（因为临时表会索引失效），随机IO转顺序IO等特点</p></li></ol><p>​    </p><p>​    下面介绍Mysql相关的索引类型：</p><ul><li>哈希索引：哈希索引适合全值匹配和精确查找，查询的速度非常快 在MySQL中只有memory存储引擎显式支持此索引，memory还支持非唯一哈希索引的，是哈希索引设计里面比较特殊的。</li><li>空间索引：空间索引是myisam表支持，主要用作地理数据存储，这里包含一个叫做GIS的玩意，但是GIS在Postgre中使用比MySQL要出色很多，所以mysql中空间索引是无关紧要的东西。</li><li>全文索引：全文索引也是myisam独有支持的一种索引类型。适合使用的场景为全值匹配的场景和关键字查询，对于大文本的关键字匹配可以有效处理。</li><li>聚簇索引：聚簇索引是innodb存储引擎的默认存储引擎。</li><li>前缀压缩索引：注意这个索引针对的是myisam存储引擎，目的是为了让索引放入内存中排序，，前缀压缩的方法是首先保存索引块的第一个值，然后在保存第二个值，存储第二个值类似（长度,索引值）的形式存放前缀索引。</li></ul><p>其他索引类型注意事项：</p><p>​    Archive 在5.1之后才支持单列自增索引。</p><p>​    MyISAM 支持压缩之后的前缀索引，使得数据结构占用更小。</p><p><strong>哈希索引</strong></p><p>​    在Mysql中唯一显式实现哈希索引的存储引擎为Memory，Memory是存在非唯一哈希索引，同时BTree也支持“自适应哈希索引的方式“兼容哈希索引。</p><p>下面是哈希索引特点：</p><ul><li>键存储的是索引哈希值，注意不是索引值本身，而值存储的是指向行的指针</li><li>注意此哈希索引无法避免行扫描，但是在内存中指针非常快通常可以忽略不计</li><li>注意只有哈希值按照顺序排序，但是行指针不是按照顺序排序</li><li>哈希不支持：部分索引覆盖，只支持全索引覆盖，因为使用全部的索引列计算哈希值</li><li>哈希索引支持等值匹配操作不支持范围查询，比如等于，in子查询，不全等。</li><li>如果出现哈希冲突，哈希索引将退化为链表顺序查询，同时维护索引的开销也会变大</li></ul><p><strong>聚簇索引</strong></p><p>​    聚簇表示数据行的值紧凑存储在一起。而innodb聚簇的值就是主键的值，所以通常使用都是主键上的索引，针对主键索引的选择十分重要。由于本部分着重索引优化，聚簇索引这里就不再讲述了。</p><p>​    MyISam和Innodb的主键索引区别是MyISam的索引很简单，因为数据行只包含行号，所以索引<strong>直接存储列值和行号</strong>，数据单独存放另一处，类似于一个唯一非空索引，索引和数据不在一处，MyISam的索引设计比InnoDB简单很多，这和MyIsam不需要支持事务也有直接关系，而innodb将索引和行数据放入一个数据结构，将列进行紧凑的存储。</p><p>​    </p><p>聚簇索引有下面优点</p><ul><li>紧凑存储数据行，所以可以只扫描少量磁盘就可以获取到数据</li><li>数据访问的速度非常快，索引和数据放在同一颗BTree中，比非聚簇索引查询快很多</li><li>覆盖索引可以直接<strong>减少回表</strong></li></ul><p>当然索引也有下面的缺点：</p><ul><li>对于非IO密集型应用，聚簇索引的优化无意义。</li><li>插入速度依赖于插入顺序，但是如果不是自增插入则需要optimize table重新组织表。</li><li>更新代价非常高，因为BTree要保证顺序排序需要挪动数据页位置和指针。</li><li>主键数据插入过满数据页存在页分裂问题，行溢出会导致存储压力加大。</li><li>聚簇索引导致全表扫描变慢，页分裂导致数据问题等。</li><li>二级索引需要回表查询聚簇索引才能查询数据。</li><li>二级索引由于需要存储主键开销会更大，至少在InnoDb中维护一个二级索引的开销是挺大的。</li></ul><p>压缩索引</p><p>​    压缩索引的特点是使用更少的空间存放尽可能多的内容，但是这样的处理方式仅仅适用于IO密集型的系统，压缩前缀存储形式最大的缺陷是无法使用二分法进行查找，同时如果使用的倒序索引的方式比如order by desc 的方式可能会因为压缩索引的问题存在卡顿的情况。</p><p>Bree索引的特点</p><ul><li><p>叶子结点存在逻辑页和索引页两种，通常非最底层叶子结点都是索引页，最底层索引页由链表串联。</p></li><li><p>Btree索引会根据<strong>建表顺序</strong>对于索引值进行排序，索引建表时候建议将经常查询的字段往前挪。</p></li><li><p>Btree索引适合的查询类型：<strong>前缀查询，范围查询，键值查询（哈希索引）</strong>。</p></li></ul><p>自适应哈希索引</p><p>​    当innodb发现某些索引列和值使用频繁的时候，BTree会在此基础上自动创建哈希索引辅助优化，但是这个行为是不受外部控制的，完全是内部的优化行为，如果不需要可以考虑关闭。</p><p>Btree查询类型</p><p>​    针对Innodb的Btree索引，有下面几种常见的查询方式：</p><ul><li>全值匹配：等值匹配的方式，全值匹配适合哈希索引进行查询</li><li>最左匹配原则：二级索引的查询条件放在where最左边</li><li>前缀匹配：只使用索引的第一列，并且like ‘xxx%’</li><li>范围匹配：范围匹配索引列到另一列之间的值</li><li>范围查询和精确匹配结合，一个全值匹配，一个范围匹配</li><li>覆盖索引查询：覆盖索引也是一种查询方式，</li></ul><h2 id="索引策略"><a href="#索引策略" class="headerlink" title="索引策略"></a>索引策略</h2><p>​    下面是关于建立索引的一些常见策略：</p><ol><li>第一件事情需要考虑的是预测那些数据为热点数据或者热点列，按照《高性能Mysql》介绍，对于热点列来说有时候要违背最大选择性的原则，通过建立时常搜索的索引作为最左前缀的默认的设置。同时优化查询需要考虑所有的列，如果一个查询的优化会破坏另一个查询，那么就需要优化索引的结构。</li><li>第二件事情是考虑where的条件组合，通过组合多种where条件，需要考虑的是尽可能让查询重用索引而不是大规模的建立新索引。</li><li>避免多个范围进行扫描，一方面是范围查询会导致，但是对于多个等值的条件查询，最好的办法是尽量控制搜索范围。</li></ol><p>​    </p><p>​    对于索引的策略我们还需要了解下面的细节</p><ul><li>单行访问很慢，特别是随机访问要比顺序访问要慢更多，一次性加载很多数据页会造成性能的浪费。</li><li>顺序访问范围数据很快，顺序IO的速度不需要多磁道查找，比随机的访问IO块很多，顺序访问也可以使用group by进行聚合计算。</li><li>索引覆盖速度很快，如果查询字段包含了索引列，就不需要回表。</li></ul><p>索引碎片优化</p><p>​    Innodb的数据结构和特性会导致索引存在数据碎片，对于任何存储结构来说顺序的存储结构是最合适的，并且索引顺序访问要比随机访问快更多，数据存储的碎片比索引本身复杂很多，索引碎片通常包含下面的情况：</p><ul><li>行碎片：数据行的数据被存储在多个数据页当中，碎片可能会导致性能的下降。</li><li>行间碎片：逻辑顺序上的页，行在磁盘上不顺序存储，行间数据碎片会导致全表扫描。</li><li>剩余空间碎片：数据页的间隙有大量的垃圾数据导致的浪费。</li></ul><p>​    对于上面几点，对于myisam 都有可能出现，但是innodb的行碎片不会出现，内部会移动碎片重写到一个片段。</p><p>​    索引碎片的处理方式：在Mysql中可以通过<code>optimize table</code>导入和导出的方式重新整理数据，防止数据碎片问题。</p><p>​    </p><p>索引规则</p><ul><li>索引必须按照索引顺序从左到右匹配</li><li>如果在查询中间出现范围，则范围查询之后的索引失效</li><li>不能跳过索引列的方式查询（和B+tree索引数据结构设计有关系）</li></ul><p>​    接着是索引顺序问题，由于BTree的结构特性，索引都是按照建立顺序进行查找的，通常不包含排序和分组的情况下，把选择性最高的索引放在最左列是一个普遍正确策略。</p><p>​    如何查看索引基数：<code>show index from sakila.actor</code>，还有一种方式是通过<code>information_schema.statistics</code> 表查询这些信息，可以编写为一个查询给出选择性较低的索引。</p><p>​    当innodb打开某些表的时候会触发索引信息的统计，比如打开<code>information_schema</code>表或者使用<code>show table status</code>和<code>show index</code>的时候，所以如果在系统要运行压力较大的业务时期尽量避开这些操作。</p><p><strong>冗余重复索引</strong></p><p>​    Mysql允许同一个列上创建多种类型的索引，有时候会因为建表的特性问题给字段重复建索引造成不必要的性能浪费。冗余索引和重复索引有什么区别？</p><p>​    冗余索引：是符合最左匹配法则的情况下重复对相同列建立索引。</p><p>​    重复索引：是对于不最做的方式创建的索引就有可能是重复创建索引。</p><p>​    比如联合索引：(A,B) 如果在创建 （A）或者（A，B）都是重复索引，但是创建（B）就不是重复索引而是冗余索引。另外某些十分特殊的情况下可能用到冗余索引，但是这会极大的增加索引维护的开销，最为直观的感受是插入、更新、删除的开销变得很大。</p><p><strong>多列索引</strong></p><p>​    首先多列索引不是意味着<code>where</code>字段出现的地方就需要加入，其次多列索引虽然在现在主流使用版本中（5.1版本之后）实现了索引内部合并，也就是使用<code>and or</code>或者<code>and</code>和<code>or</code>合并的方式相交使用索引，但是他存在下面几个缺点</p><ul><li>内部优化器的合并和计算十分耗费CPU的性能，索引反而增加数据查询复杂度，效率也不好</li><li>往往会存在优化过度的情况，导致运行效果还不如全表扫描</li><li>出现多列索引合并通常意味着建立索引的方式不对，存在反向优化的嫌疑</li></ul><p><strong>文件排序</strong></p><p>​    文件排序遵循Innodb的Btree索引的最基本原则：<strong>最左前缀原则</strong>，如果索引列的顺序和order by排序一致，并且查询列都和排序列都一样才会用索引替代排序，对于多表查询则排序字段<strong>全为第一个表</strong>才能进行索引排序。但是有一个特例那就是排序字段的前导列为<strong>常量</strong>的时候依然可以使用索引排序。</p><p>​    案例：rental 表的联合索引列进行排序</p><blockquote><p>Backward index scan 是 MySQL-8.0.x 针对上面场景的一个专用优化项，它可以从索引的后面往前面读，性能上比加索引提示要好的多</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> rental_id,staff_id <span class="keyword">from</span> rental <span class="keyword">where</span> rental_date = <span class="string">'2005-05-25'</span> <span class="keyword">order</span> <span class="keyword">by</span> inventory_id <span class="keyword">desc</span>, customer_id <span class="keyword">asc</span>;</span><br><span class="line"><span class="comment">-- 1 SIMPLE rental ref rental_date rental_date 5 const 1 100.00 Using filesort</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> rental_id,staff_id <span class="keyword">from</span> rental <span class="keyword">where</span> rental_date = <span class="string">'2005-05-25'</span> <span class="keyword">order</span> <span class="keyword">by</span> inventory_id <span class="keyword">desc</span>;</span><br><span class="line"><span class="comment">-- Backward-index-scan</span></span><br><span class="line"><span class="comment">-- Backward index scan 是 MySQL-8.0.x 针对上面场景的一个专用优化项，它可以从索引的后面往前面读，性能上比加索引提示要好的多</span></span><br><span class="line"><span class="comment">-- 1 SIMPLE rental ref rental_date rental_date 5 const 1 100.00 Backward index scan</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> rental_id,staff_id <span class="keyword">from</span> rental <span class="keyword">where</span> rental_date = <span class="string">'2005-05-25'</span> <span class="keyword">order</span> <span class="keyword">by</span> inventory_id, staff_id;</span><br><span class="line"><span class="comment">-- 1 SIMPLE rental ref rental_date rental_date 5 const 1 100.00 Using filesort</span></span><br><span class="line"><span class="comment">-- 无法使用索引</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> rental_id,staff_id <span class="keyword">from</span> rental <span class="keyword">where</span> rental_date &gt; <span class="string">'2005-05-25'</span> <span class="keyword">order</span> <span class="keyword">by</span> inventory_id, customer_id;</span><br><span class="line"><span class="comment">-- 1 SIMPLE rental ALL rental_date 16008 50.00 Using where; Using filesort</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> rental_id,staff_id <span class="keyword">from</span> rental <span class="keyword">where</span> rental_date = <span class="string">'2005-05-25'</span> <span class="keyword">and</span> inventory_id <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>) <span class="keyword">order</span> <span class="keyword">by</span> customer_id;</span><br><span class="line"><span class="comment">-- 1 SIMPLE rental range rental_date,idx_fk_inventory_id rental_date 8 2 100.00 Using index condition; Using filesort</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> actor_id, title <span class="keyword">from</span> film_actor <span class="keyword">inner</span> <span class="keyword">join</span> film <span class="keyword">using</span>(film_id) <span class="keyword">order</span> <span class="keyword">by</span> actor_id;</span><br><span class="line"><span class="comment">-- 1 SIMPLE film index PRIMARY idx_title 514 1000 100.00 Using index; Using temporary; Using filesort</span></span><br><span class="line"><span class="comment">-- 1 SIMPLE film_actor ref idx_fk_film_id idx_fk_film_id 2 sakila.film.film_id 5 100.00 Using index</span></span><br></pre></td></tr></table></figure><h2 id="查询优化排查"><a href="#查询优化排查" class="headerlink" title="查询优化排查"></a>查询优化排查</h2><p>​    查询优化的排查意味着我们需要先了解Mysql的各个组件在各步骤中做了哪些事情，下面这张图来自于《高性能Mysql》，对于一次客户端的请求，大致分为下面的流程：</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202203212336431.png" alt=""></p><ol><li><p>客户端发送请求</p></li><li><p>服务器查询执行缓存</p><ul><li>不重要，8.0之后已经删除</li></ul></li><li><p>服务端进行SQL解析和预处理</p><ul><li>权限检查</li><li>词法解析</li><li>语法树</li></ul></li><li><p><strong>优化器生成执行计划</strong></p><ul><li><p>优化器存在的问题？</p></li><li><p>优化器如何工作？</p></li></ul></li><li><p>根据执行计划调用存储引擎的APi接口执行查询</p></li><li><p>结果返回客户端</p></li></ol><p>​    对于关系型的数据库来说，核心部分在于查询优化器和执行计划的部分，因为不管我们如何编写SQL语句，如果没有强大的优化器和执行计划那么一切都是空谈，所以本部分的重点也会围绕优化器进行讲解，在此之前我们先看看其他组件的工作：</p><p>​    首先查询缓存不需要过多解释，他的作用是当用户重复执行一个查询的时候会内部对于结果进行缓存，但是一旦用户修改查询条件，缓存就失效了，在早期的互联网环境中这种处理很不错，可以减少磁盘IO和CPU的压力，但是到了现在的环境下显然不适合，所以8.0删除也是可以理解的。</p><p>​    接着是解析器，解析器这部分主要工作是通过解析语法形成解析树对于语句进行预处理，预处理可以类看作我们编译器把我们写的编程语句“翻译”为机器代码的过程，让下一步的优化器可以认识这颗解析树去进行解析，</p><p>​    如果想要了解SQL解析优化的底层过程，可以从这篇文章入手：</p><p>​    <span class="exturl" data-url="aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMTgvMDUvMjAvc3FsLXBhcnNlci11c2VkLWluLW10ZHAuaHRtbA==" title="https://tech.meituan.com/2018/05/20/sql-parser-used-in-mtdp.html">SQL解析在美团的应用 - 美团技术团队 (meituan.com)<i class="fa fa-external-link"></i></span></p><p>​    在上面的博客中提到了一个DBA必须掌握的工具<strong>pt-query-digest</strong>，分析慢查询日志，下面这个文章中提供了一个实际的案例来排查和优化，案例较为简单适合刚接触这个工具的人进行学习和思考，这里一并列出来了。</p><p>​    <span class="exturl" data-url="aHR0cHM6Ly9hd3MuYW1hem9uLmNvbS9jbi9ibG9ncy9jaGluYS9wdC1xdWVyeS1kaWdlc3QtcmRzLW15c3FsLXNsb3ctc2VhcmNobmV3Lw==" title="https://aws.amazon.com/cn/blogs/china/pt-query-digest-rds-mysql-slow-searchnew/">使用 pt-query-digest 分析 RDS MySQL 慢查询日志 | 亚马逊AWS官方博客 (amazon.com)<i class="fa fa-external-link"></i></span></p><blockquote><p>SQL解析部分笔记：</p><p>词法分析：核心代码在sql/sql_lex.c文件中的，<code>MySQLLex→lex_one_Token</code></p><p><strong>MySQL语法分析树生成过程</strong>：全部的源码在<code>sql/sql_yacc.yy</code>中，在MySQL5.6中有17K行左右代码</p><p>最核心的结构是SELECT_LEX，其定义在<code>sql/sql_lex.h</code>中</p></blockquote><p>​    下面我们来深入看看优化器的部分工作内容以及Mysql优化历史：</p><p>​    由于讲述优化器的内容较少，这里直接总结《高性能Mysql》的内容，优化器也不需要研究和记忆，因为随着版本的迭代不断更新优化器会不断调整，一切要以真实实验为准：</p><p><strong>1. 子查询关联</strong>：</p><p>​    下面的查询在通常情况下我们会认为先进行子查询，然后通过for循环扫描film表进行匹配操作，然后从explain的结果中可以看到这里的查询线进行了全表扫描，然后通过关联索引进行第二层的for循环查询，这样的写法类似<code>exists</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> sakila.film <span class="keyword">where</span> film_id <span class="keyword">in</span> (<span class="keyword">select</span> film_id <span class="keyword">from</span> film_actor <span class="keyword">where</span> actor_id)</span><br><span class="line"><span class="comment">-- 1SIMPLEfilmALLPRIMARY1000100.00</span></span><br><span class="line"><span class="comment">-- 1SIMPLEfilm_actorrefidx_fk_film_ididx_fk_film_id2sakila.film.film_id590.00Using where; Using index; FirstMatch(film)</span></span><br></pre></td></tr></table></figure><p>​    优化这个子查询的方式使用关联查询替代子查询，但是需要注意这里存在where条件才会走索引，否则和上面的结果没有区别：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> film.* <span class="keyword">from</span> sakila.film film  <span class="keyword">join</span> film_actor actor <span class="keyword">using</span> (film_id) <span class="keyword">where</span> actor.actor_id = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>​    另一种是使用exists的方式进行关联匹配。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> film <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> * <span class="keyword">from</span> film_actor actor <span class="keyword">where</span> actor.film_id =  film.film_id <span class="keyword">and</span> actor.actor_id = <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>​    可以看到哪怕到了5.8的版本，Mysql的子查询优化既然没有特别大的改进，所以通常情况下如果不确定in查询的内容大小，建议用exists或者join进行查询，另外也不要相信什么in查询就一定慢点说法，在不同的mysql优化器版本中可能会有不同的效果。</p><p><strong>2. union查询</strong></p><p>​    虽然多数情况下我们会用union替换or，但是更多的情况是应该尽量避免使用union，因为union查询会产生临时表和中间结果集容易导致优化索引失效，需要注意的是 <strong>union</strong>会触发内部的排序动作，也就是说union会等价于<code>order by</code>的排序，如果数据不是强烈要求不能重复，那么更建议使用union all，对于优化器来说这样工作更加简单，直接把两个结果集凑在一起就行，也不会进行排序。</p><p>​    union查询能不用就不用，除非是用来代替or查询的时候酌情考虑是否有必要使用。</p><p>​    最后注意union的产生排序不受控制的，可能会出现意料之外的结果。</p><p><strong>3. 并行查询优化</strong></p><p>​    并行查询优化在8.0中终于有了实现，可以根据参数：<code>innodb_parallel_read_threads =并行数</code>来验证。</p><p>​    由于个人是M1的CPU，读者可以根据自己的实际情况进行实验。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">local</span> innodb_parallel_read_threads = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> payment;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">local</span> innodb_parallel_read_threads = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> payment;</span><br></pre></td></tr></table></figure><p>从执行结果可以看到仅仅是1万多条数据的count(*)查询就有明显直观的差距：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204051714387.png" alt=""></p><p><strong>4. 哈希关联</strong></p><p>​    官方文档的介绍地址：<span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy9yZWZtYW4vOC4wL2VuL2hhc2gtam9pbnMuaHRtbA==" title="https://dev.mysql.com/doc/refman/8.0/en/hash-joins.html">Mysql官方文档哈希关联<i class="fa fa-external-link"></i></span></p><p>​    在MySQL 8.0.18中Mysql终于增加了哈希关联的功能。在此之前的版本中，Mysql的优化器通常只支持for循环嵌套关联，曲线救国的方法是建立一个哈希索引或者使用Memory存储引擎，而新版本提供的哈希关联则提供了一种新的对关联方式，哈希关联的方式如下：</p><p>​    把一张小表数据存储到<strong>内存</strong>中的哈希表里，通过匹配大表中的数据计算<strong>哈希值</strong>，并把符合条件的数据从内存中返回客户端。    </p><p>​    对于Mysql的哈希关联，我们直接使用官方的例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (c1 <span class="built_in">INT</span>, c2 <span class="built_in">INT</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t2 (c1 <span class="built_in">INT</span>, c2 <span class="built_in">INT</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t3 (c1 <span class="built_in">INT</span>, c2 <span class="built_in">INT</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPLAIN</span></span><br><span class="line">     <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1</span><br><span class="line">         <span class="keyword">JOIN</span> t2 <span class="keyword">ON</span> t1.c1=t2.c1;</span><br><span class="line"><span class="comment">-- Using where; Using join buffer (hash join)</span></span><br></pre></td></tr></table></figure><p>​    除开等值查询以外，Mysql的8.0.20之后提供了更多的支持，比如在 MySQL 8.0.20 及更高版本中，连接不再需要包含至少一个等连接条件才能使用哈希连接，除此之外它还包括下面的内容：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 8.0.20 支持范围查询哈希关联</span></span><br><span class="line"><span class="keyword">EXPLAIN</span>  <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1 <span class="keyword">JOIN</span> t2 <span class="keyword">ON</span> t1.c1 &lt; t2.c1;</span><br><span class="line"><span class="comment">-- 8.0.20 支持 in关联</span></span><br><span class="line"><span class="keyword">EXPLAIN</span>  <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1 </span><br><span class="line">        <span class="keyword">WHERE</span> t1.c1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> t2.c2 <span class="keyword">FROM</span> t2);</span><br><span class="line"><span class="comment">-- 8.0.20 支持 not exists 关联</span></span><br><span class="line"><span class="keyword">EXPLAIN</span>  <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t2 </span><br><span class="line">         <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> t1.c1 = t2.c2);</span><br><span class="line"><span class="comment">-- 8.0.20 支持 左右外部连接</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> t2 <span class="keyword">ON</span> t1.c1 = t2.c1;</span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1 <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> t2 <span class="keyword">ON</span> t1.c1 = t2.c1;</span><br></pre></td></tr></table></figure><blockquote><p>注意8.0.18版本的哈希关联<strong>仅仅支持join查询</strong>，对于可能会带来笛卡尔积的左连和右连接查询是不支持的。但是在后续的版本中提供了更多查询条件支持</p><p>另外，8.0.20版本之前想要查看是否使用hash join，需要结合 <code>format=tree</code> 选项。</p></blockquote><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204051721828.png" alt="哈希关联"></p><p>​    最终Mysql在8.0.18版本中曾经提供过开关哈希索引和设置优化器提示<code>optimizer_switch</code>等参数来判定是否给予hash join的提示，真是闲的蛋疼（官方自己也这么认为）所以在8.0.19立马就把这些参数给废弃。</p><p>​    注意哈希连接不是没有限制的，了解哈希关联的流程就会发现如果哈希表过大，会导致整个哈希关联过程在磁盘中完成其速度可想而知，所以官方提供了下面的建议：</p><ul><li>增加<code>join_buffer_size</code>，也就是增加哈希关联的哈希表缓存大小，防止进入磁盘关联。</li><li>增加<code>open_files_limit</code>数量，这个参数什么意思这里就不介绍了，意义是增加这个参数可以增加关联的时候关联次数。</li></ul><blockquote><p>吐槽：说句心里话自Mysql被Oracle收购之后，越来越商业化的同时进步也越来越小，in查询优化这一点其实在很多开源库甚至Mysql的原作者给解决了，但是Mysql到了8.0依然和多年前的《高性能Mysql》结果没有差别。哎。。。。。</p><p>Mysql数据库的发展也告诉我们时刻保持开放的心态，吸取教训正视不足和改进，才不会被时代逐渐淘汰。</p></blockquote><p><strong>5. 松散索引</strong></p><p>​    松散索引在Mysql5.6之后已经支持，松散索引简单理解就是在进行多列索引扫描的时候，即使次索引不是有序的，但是跳过索引是有序的，也可以走索引来快速匹配数据。</p><pre><code>松散索引的优化细节放到了下半部分的文章，这里简单讲述一下大致的工作原理。</code></pre><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204051830883.png" alt=""></p><ol start="6"><li><strong>查询同时更新数据</strong></li></ol><p>​    在Postgresql中，支持下面的语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> tbl_info</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">name</span> = tmp.name</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> tbl_user <span class="keyword">where</span> <span class="keyword">name</span> =<span class="string">'xxx'</span>)</span><br><span class="line">tmp</span><br><span class="line">[<span class="keyword">where</span> ....]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 比如下面的写法：</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="string">`sakila`</span>.<span class="string">`actor`</span> <span class="keyword">SET</span> <span class="string">`first_name`</span> = <span class="string">'PENELOPE'</span></span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">(<span class="keyword">select</span> address,address_id <span class="keyword">from</span> address <span class="keyword">where</span> address_id = <span class="number">1</span>) tmp</span><br><span class="line"> <span class="keyword">WHERE</span> <span class="string">`actor_id`</span> = <span class="number">1</span> <span class="keyword">and</span> actor.actor_id = tmp.address_id;</span><br></pre></td></tr></table></figure><p>​    但是很可惜这种语法在Mysql是没有办法实现也是不支持的，哪怕到了8.0.26依然没有支持，这和Mysql的优化器设计有着本质的关系。</p><ol start="7"><li><strong>优化器提示设置</strong></li></ol><p>优化器提示没有多少意义，这里直接略过了。</p><ol start="8"><li><strong>最大值和最小值优化</strong></li></ol><p>​    从实际的情况来看Mysql最大值和最小值这两个函数使用并不是很多所以不再进行介绍了，另外无论什么样的数据库都不是很建议频繁使用函数，而是改用业务+简单SQL实现高效索引优化。</p><p>其他慢查询优化</p><p>​    对于慢查询的优化我们需要清楚优化是分为几种类别的，在Mysql中优化策略分为<strong>动态优化</strong>和<strong>静态优化</strong>：静态优化主要为优化更好的写法，比如常数的排序和一些固定的优化策略等，这些动作通常在一次优化过程中就可以完成。而动态优化策略要复杂很多，可能会在执行的过程中优化，有可能在执行过后重新评估执行计划。</p><p>​    静态优化是受优化器影响的，不同版本有不同情况，所以这里讲述动态优化的情况，而动态优化主要包含下面的内容：</p><ul><li>关联表顺序，有时候关联表顺序和查询顺序不一定相同。</li><li>重写外连接为内连接：如果一个外连接关联是没有必要的就优化掉外连接关联。</li><li>等价替换，比如 a&gt;5 and a= 5被优化为a &gt;= 5 ，类似数学的逻辑公式简化</li><li>优化count()、max()、min()等函数：有时候找最大和最小值只需要找最大和最小的索引记录，这时候由于不需要遍历，可以认为直接为哈希的获取记录的方式，所以在查询分析的 extra 里面进行体现（Select tables optimized away），比如：explain select max(actor_id) from actor;</li><li>预估和转化常数：以连接查询为例，如果在查询条件中可以实现预估关联的记录条数，那么对于一个关联查询来说就有可能被优化器作为常数进行优化，因为事先取出记录的条数被优化器知晓。所以优化起来十分简单。</li><li>子查询优化：子查询虽然有可能被索引优化但是需要尽量避免使用。</li><li>覆盖索引扫描：让索引和查询列一致，是非常高效的优化和执行方式</li><li>提前终止查询：提前终止查询指的是当遇到一些查询条件会让查询提前完成，优化器会提前判断加快数据的匹配和搜索速度</li><li>等值传递，如果范围查询可以根据关联表查询优化，那么无需 显式的提示则可以直接搜索数据。</li></ul><p>​    </p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>这里汇总了文章中出现的一些参考资料：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy9yZWZtYW4vOC4wL2VuL2hhc2gtam9pbnMuaHRtbA==" title="https://dev.mysql.com/doc/refman/8.0/en/hash-joins.html">Mysql官方文档哈希关联<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMTgvMDUvMjAvc3FsLXBhcnNlci11c2VkLWluLW10ZHAuaHRtbA==" title="https://tech.meituan.com/2018/05/20/sql-parser-used-in-mtdp.html">SQL解析在美团的应用 - 美团技术团队 (meituan.com)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9hd3MuYW1hem9uLmNvbS9jbi9ibG9ncy9jaGluYS9wdC1xdWVyeS1kaWdlc3QtcmRzLW15c3FsLXNsb3ctc2VhcmNobmV3Lw==" title="https://aws.amazon.com/cn/blogs/china/pt-query-digest-rds-mysql-slow-searchnew/">使用 pt-query-digest 分析 RDS MySQL 慢查询日志 | 亚马逊AWS官方博客 (amazon.com)<i class="fa fa-external-link"></i></span></li></ul><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>​    上半部分以理论为主，下半部分将会着重实战内容进行介绍。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      Mysql索引和查询优化
    
    </summary>
    
    
      <category term="数据库-mysql" scheme="https://whitestore.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-mysql/"/>
    
    
      <category term="数据库" scheme="https://whitestore.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Mysql" scheme="https://whitestore.top/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>《投资中最简单的事》读书笔记 - 寻找不变性</title>
    <link href="https://whitestore.top/2022/04/03/touzibubian/"/>
    <id>https://whitestore.top/2022/04/03/touzibubian/</id>
    <published>2022-04-03T04:47:59.000Z</published>
    <updated>2022-06-02T10:09:44.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《投资中最简单的事》读书笔记-寻找不变性"><a href="#《投资中最简单的事》读书笔记-寻找不变性" class="headerlink" title="《投资中最简单的事》读书笔记 - 寻找不变性"></a>《投资中最简单的事》读书笔记 - 寻找不变性</h1><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20220317220808.png" alt=""></p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>真正的价值投资应该乘着是越早用钱换经验，用尽可能少的钱换来“前瞻性”，而不是锻炼自己后视镜的眼光，用历史套用现在终究会血本无归，人人都可以事后诸葛亮，但是真正想要价值投资需要是<strong>培养向后看的眼光</strong>，培养寻找不变性的眼光。</p><h1 id="资源地址"><a href="#资源地址" class="headerlink" title="资源地址"></a>资源地址</h1><p>  《投资中最简单的事》pdf和mobi资源</p><p>链接: <span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMUhBVUQxTEFqckZQeHQ1cTNSUk9OSXc=" title="https://pan.baidu.com/s/1HAUD1LAjrFPxt5q3RRONIw">https://pan.baidu.com/s/1HAUD1LAjrFPxt5q3RRONIw<i class="fa fa-external-link"></i></span> 提取码: 2oii</p><h2 id="个人评价"><a href="#个人评价" class="headerlink" title="个人评价"></a>个人评价</h2><p>投资是不可能简单的，这本书的争议也十分大，原因是这本书非常散，很像是东拼西凑的书不成体系，不过确实如果股市有规律可循那么早就被资本周转运作消耗完了，所以投资最终学习的是学习<strong>不变性</strong>，而不是去分析市场的规律，规律是不可寻的，新冠和金融危机都是很好的启示，但是<strong>不变性</strong>是可寻的，比如<strong>瘦死的骆驼比马大</strong>，比如<strong>拥有定价权拥有一切</strong>，比如做“中间商”是一门好生意，因为现在所有的行业基本都离不开B2B，B2C，C2C这三个概念，再比如没有人除了战争可以炒的动黄金，所以在战争的前夕买黄金是稳赚不赔的生意，因为人类总是会在灾难的时候寻找最能保值的东西，再比如……等等。</p><p>寻找投资中的不变性是我读这本书的最大意义，所以我把这本书拆分为了三个部分：<strong>选赛道，选骑手（如果买的是基金）</strong>，<strong>稳心态</strong>。</p><a id="more"></a><h1 id="为什么我要看这本书"><a href="#为什么我要看这本书" class="headerlink" title="为什么我要看这本书"></a>为什么我要看这本书</h1><p>为什么我要看这本书呢？一方面作者作为重金投注基金的个人来说选对好的“骑师”是至关重要的，因为会发现在同样的赛道上如果骑师无法指挥好马是无法带来切实收益的，作为同一个行业的专业人士却有着天差地别的表现，这是很明显的圈子理论和效应，如果你投注一个烂圈子的懒经理，最好的方式是赶紧把钱取出来，你是什么样的人身边就会有什么样的人。另外坚持看完这本书的原因还有下面的几点，这几点包含了作者书中提到的前瞻性：</p><ul><li>预见了制造业往东南亚迁移。</li><li>汽车是一个好产业但是由于竞争压力过大很难有好的收益。</li><li>手游行业的爆发，并且和股市行情难以捉摸。</li></ul><p>·试想一下如果时间倒退十年能看到多少前瞻性的东西，有多少人能预测出这三个点？看到这些内容的时候第一反应并不是说自己能不能想到，而是发现自己从来就不会往后看或者往后猜，总是用历史去证明现在做的事情是对的，实际看来只有深入的了解国情才有可能在A股从券商手里偷钱。</p><h1 id="选赛道"><a href="#选赛道" class="headerlink" title="选赛道"></a>选赛道</h1><h2 id="投资依靠什么？"><a href="#投资依靠什么？" class="headerlink" title="投资依靠什么？"></a>投资依靠什么？</h2><p>如果我们不清楚自己所购买的企业是依靠什么赖以生存的那么是很难选对赛道的，选好赛道是价值投资的第一个步骤，下面是行之有效的几个参考点：</p><ul><li><p><strong>护城河</strong>是基石：如果总是需要深挖的护城河，那么这个行业就不能算是拥有护城河，在这样的行业里面求变是真理，所以高门槛和高标准是护城河，平台是护城河。 举例：手游市场竞争激烈，虽然因为缺乏理智被炒热，但是实际上真正的钱被平台赚走。但是后来实际证明手游这一块并不会被完全垄断，而是依然有很多其他力量介入。</p></li><li><p><strong>现金流</strong>决定抗风险能力，如果现金流受到各种条件制约，那么抗风险能力大幅度减弱，也难成大器，掌握现金流意味着定价权的掌握，谁拥有定价权就拥有先机。</p></li><li><p>行情：在熊市不要投资，行情不好的情况下几乎所有的赛道都不好走，行情和实际情况在不同国家有不同的反应，有的策略在这个国家有效，到了其他国家就不行了。这也是为什么我们看所有投资的好书却依然感觉学不到东西。</p><p>  举例：消费股总是周期往复，在美国消费股却常见杀猪盘，所以在低点买入是关键。</p></li><li><p>垄断：垄断行业总归是稳定增长的，但是垄断并不意味着稳定。在任何赛道里面买人人知道的股票是一件风险和代价很高的买卖。</p></li></ul><p>举例：电影为什么难以成为独立平台或者出现独立平台，因为电影总是没有平台或者大资本流入，拍电影不是一门好生意，但是当电影演员有可能是好生意。</p><h1 id="逆向投资"><a href="#逆向投资" class="headerlink" title="逆向投资"></a>逆向投资</h1><p>什么样的行业或人适合逆向投资？</p><ul><li>虽然可能容易受到时局影响但是本质不会变的行业。比如白酒虽然总是唱衰，但是实际上到了特定的时间段就是会上涨，因为消费是我国的生命线和安全线。</li><li>耐着住性子，只有耐心的人才能笑到最后，逆向投资是一种面向未来的投资方式，然而股市更多的是投机倒把者。</li><li>A股容易过度情绪化所以需要小心处理，因为逃的太快容易被踩死，跑的太前容易被挤死。</li><li>逆向投资并不是总是在暴跌的时候买入是对的，有可能出现更低的点，所以在大幅度下跌的时候不要轻易买入</li></ul><p>总结：不去人多地方并且不擅长在合适点出手的人适合逆向投资，人总是赚到大部分认知时候的钱，但是能接受可能部分收益不存在的人适合逆向投资，如果你没有及时止盈的能力或者投资的天赋，逆向投资和长期持有适合大部分普通人。</p><h2 id="投资的三个问题"><a href="#投资的三个问题" class="headerlink" title="投资的三个问题"></a>投资的三个问题</h2><p>做逆向投资，需要把控好三个问题：品质、估值、</p><ul><li>品质是否好？何谓品质，品质包含差异性，是不是一个好行业，同时需要小心是否是政策所管理的行业，最后胜而后求战才是值得购买的股票，而不是战而后求胜，因为拥有定价权或者垄断的公司才有东山再起的机会。</li><li>估值是否可以跑赢市场：其实也指上升空间，一年上升第二年疲软的股票不是好股票，很多人可能更加希望寻找一个平稳上涨的股票或者基金，但是平稳实际上意味着没有收益，今天上去明天下来。有一个特例是稳定增长的长期股票，这样的股票等到被发掘出来的时候往往上涨完成了。</li><li>时机，选股时机可能比选股本身更为重要，预见上涨的股票如果选择错误，很可能出现高点高仓位，低点低仓位。</li></ul><h2 id="何谓品质？"><a href="#何谓品质？" class="headerlink" title="何谓品质？"></a>何谓品质？</h2><p>如果用赌马的思路去思考投资，那么赛马最重要的是什么呢？是骑手还是马？我们总是想找到一匹好马，或者找一个好的骑手，但是我们忘了，找一个好的赛道才是关键，再好的马和骑手都不能在崎岖不堪的道路上跑出好成绩。</p><p>同样如果一个赛道上全是马或者骑手，我们很难分辨哪一匹马跑的快或者哪个骑手指挥的好，很多时候等我们看到跑完大半圈之后才看出端倪，但是这时候下注往往处于终点决赛阶段。</p><p>最后国家扶持的赛道其实需要特别小心的，为什么？因为市场会很容易有过激的反应，政策的加入会让各种投机取巧的分子进入抢占先机，最后赛道上全是马在跑，全是骑手在指挥，机构都不敢进入，更何况散户呢？另外国内政策对于行业的打击性也是毁灭的，因为我们的国家是公有制经济，经济的大头在国家手里，一旦想要打击某个小弟，所有人肯定只能避而远之。</p><h2 id="风险定义"><a href="#风险定义" class="headerlink" title="风险定义"></a>风险定义</h2><p>风险分为两种，一种是<strong>永久性丧失风险</strong>，这种风险是高风险低回报，一种是<strong>波动风险</strong>，这种风险是高风险高回报高收益，涨跌只是一时的表现，倒在黎明之前的人是大多数：</p><p>那么我们应该如何面对投资风险？</p><ul><li>投资风险分为价值投资和趋势投资，价值投资者的弱点是倒在黎明前，趋势投资者的弱点是没来得及卖出去，两者其实同样惨。</li><li>A股往往存在过激反应，常常会有超高估值的无价值公司爆发增长，于是追涨杀跌就会出现。</li><li>成长股不一定是稳妥的，经历过成长股之后的公司往往会出现疲软的局势。</li><li><strong>政策周期优于市场周期，市场周期优于经济周期</strong>。意味着经济周期往往在人们最不关注的地方以及最不关注的时候出现。</li><li>如果大街小巷都在讨论某个行业股票行情的时候，往往是最危险的时候，这时候需要做的事情是找准时机卖出高估值股票和重新寻找低估值股票。</li></ul><h2 id="市场与政策和估值的关系"><a href="#市场与政策和估值的关系" class="headerlink" title="市场与政策和估值的关系"></a>市场与政策和估值的关系</h2><p>我们可能认为政策会快速带动市场，然而政策干预的地方往往是最具有风险的，政策扶持可能会越管越乱，越管越破产。但是a股和政策对着干往往是死路一条，政策打压的行业需要小心，政策扶持的行业容易追涨杀跌。</p><p>股价永远是越低越好，高仓位高估值如同一叶扁舟，不仅容易被割韭菜，还容易追涨。</p><h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><p>上面的这几个问题的基本分析可以确定一支股票或者行业的好坏，其实选股和选马是一样的，首先需要找一条好的跑道，其次如果是基金选对骑师很重要，对于选股则选马和时机很重要，对于现在时代而言行业新赛道已经很难挖掘，更多需要对于选时机进行更多分析，研究周期性股票也是选股的关键。</p><p>最终我们会发现失败者往往是投机者，而成功者往往是选择价值投资和逆向投资的人，选择趋势投资还是长期投资取决于你有多少耐性。</p><h1 id="稳心态"><a href="#稳心态" class="headerlink" title="稳心态"></a>稳心态</h1><h2 id="投资心理学"><a href="#投资心理学" class="headerlink" title="投资心理学"></a>投资心理学</h2><p>投资是一种心理的博弈，了解自己的投资目的和建立自己的投资原则很重要，可能很多人认为投资心理学应该是自己选股或者选基之后出现下面的心理问题:</p><ul><li>关注其他行业，却永远不看自己股票价值。</li><li>总是在不到预期的时候追涨杀跌。</li><li>后视镜现象严重，总是把历史搬到今年来进行验证，总是在事后诸葛亮。</li><li>买股之后却不进行分析，无法坚定自己的判断。</li><li>短期趋势长期化，这样的做法可能就是被钓上来的鱼。</li><li><strong>赚了一块钱总想赚更多，亏一分钱都受不了</strong>，其实股价和你买了多少成本多少无关，不买照样无法影响股票估值上涨和下跌。</li></ul><h2 id="如何面对亏损？"><a href="#如何面对亏损？" class="headerlink" title="如何面对亏损？"></a>如何面对亏损？</h2><ul><li>忘记成本，你投入多少和股票的涨跌无关，所以不要在意你的亏损，投资需要的是比较，选对赛道和及时止损很重要。买的股票是在波动风险范围内。</li><li>你能撑多久：想象一下你的极限，比如是立马掉20个点也不打算买，那就是真的错误投资了，</li></ul><h2 id="不能触碰的赛道"><a href="#不能触碰的赛道" class="headerlink" title="不能触碰的赛道"></a>不能触碰的赛道</h2><ul><li>分散无定价权的夕阳产业，比如钢铁，基建。热度马上消退。</li><li>无显著竞争力的小公司，赢家通吃，依赖于平台吃饭。</li><li>技术进步淘汰的公司，比如传统线下被线上取代，物流是一个特点，地方物流最终被全国物流取代。</li></ul><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>说到容易做到难，投资需要的是时间和“价值”磨炼。</p><blockquote><p>高礼价值投资研究院推荐书单，感兴趣看看，《鞋狗》这本书还不错哦。 <span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC85ODkzMTg1Mw==" title="https://zhuanlan.zhihu.com/p/98931853">https://zhuanlan.zhihu.com/p/98931853<i class="fa fa-external-link"></i></span></p></blockquote><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      请输入描述信息
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://whitestore.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="书籍" scheme="https://whitestore.top/tags/%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>Obsidian使用初体验</title>
    <link href="https://whitestore.top/2022/04/03/obsidian/"/>
    <id>https://whitestore.top/2022/04/03/obsidian/</id>
    <published>2022-04-03T04:46:17.000Z</published>
    <updated>2022-06-02T10:09:44.656Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Obsidian使用初体验"><a href="#Obsidian使用初体验" class="headerlink" title="Obsidian使用初体验"></a>Obsidian使用初体验</h1><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>这篇文章算是半个安利但是绝不是广告，个人也很少针对一款软件或者单独写一篇文章讨论某一款软件，但是在公众号私信的推荐下，个人使用了一周之后来好好说说这款软件。</p><blockquote><p>软件目前还是免费软件，当然不清楚是否以后做大了是否会商业化，但是个人认为免费软件商业化如果价钱不是太离谱只要软件好用支持支持未尝不可。</p></blockquote><a id="more"></a><h1 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h1><p>这款软件对于个人来说相当于是被安利到了，具体的安利来自于个人公众号的私信，话不多说先上手体验一番：</p><p>官网地址：<span class="exturl" data-url="aHR0cHM6Ly9vYnNpZGlhbi5tZC8=" title="https://obsidian.md/">https://obsidian.md/<i class="fa fa-external-link"></i></span></p><p>这个域名的后缀有点意思，作者应该很喜欢markdown格式，如果你对markdown语法滚瓜烂熟，那么这个软件的学习成本会少一半。</p><blockquote><p>markdown是啥？可以看做是一个低代码的写作格式，也是近几年编写博客和文章比较主流的一种形式，特色是可以通过简单的符号快速实现类似word的目录式排版。当然你所看到的大多数文章也是通过markdown编写而成。</p></blockquote><h1 id="胡乱使用"><a href="#胡乱使用" class="headerlink" title="胡乱使用"></a>胡乱使用</h1><p>下载之后进来看到一堆英文看不懂要干啥，不过看到第一个看上去是要打开文件夹的样子尝试打开一个文件夹试一下：</p><blockquote><p>注意下面有一个语言切换的功能，目前最新版已经有官方中文支持。</p></blockquote><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202203311932835.png" alt=""></p><blockquote><p>这个Vault是什么意思？在中文的解释含义里面有“金库”的意思，打开一个文件夹就好像打开你知识的金库？</p></blockquote><p>在左边随意点击一个文件之后，发现打开的文件之后出现markdown的内容，于是大致了解到这款软件以markdown为主要的文件集成形式。Markdown这我熟，可以配合“Typera”软件进行更快的编写。</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202203311932248.png" alt=""></p><p>学习过程中了解到这款软件可以对于知识进行拆分和[[文献链接]] ，如果你没有这个知识块可以使用双括号的形式[[扩展新模块]]，这样你就得到了一新的模块，同时知识导图会显示你的链接内容。<br>这个功能确实比较吸引人，因为我们传统的记忆形式是通过线性思维和仓库的内容，然而实际上整齐和规范虽然让我们视觉舒服，但是对于我们思考却不是很友好，具体可以想象以前的“华西村”一个板子套出来的房子，走错进入到别人的家门都是有可能的。</p><h1 id="使用体验"><a href="#使用体验" class="headerlink" title="使用体验"></a>使用体验</h1><ol><li>这个软件令我最满意的点是使用<strong>双向链接</strong>把知识进行切割，可以让我摆脱细节而从大局思考。也就是所谓的把不重要的东西交给“外脑”消化。</li><li>如果能把typera的快捷键功能融入相信我会完全抛弃typera转obsidian，但是很遗憾他没有typera那样的快捷键方式。</li><li>个人崇尚低学习成本和一切从简，对于obsidian除了换一个喜欢的主题之外，没有安装其他任何插件。</li></ol><h1 id="软件适合的用户群体"><a href="#软件适合的用户群体" class="headerlink" title="软件适合的用户群体"></a>软件适合的用户群体</h1><p>个人认为下面这些用户群体可能会喜欢上这款软件：</p><ul><li>喜欢《卡片笔记法写作法》的笔记思考和整理方式的（知识网络和知识链接）</li><li>不喜欢在线笔记依赖平台的写作方式，喜欢离线笔记写作方式的用户</li><li>单纯喜欢软件，我认为有的人会单纯的因为喜欢一款软件的风格和设计选择一款软件，并且可以没有任何理由。</li></ul><h1 id="软件特色和缺陷"><a href="#软件特色和缺陷" class="headerlink" title="软件特色和缺陷"></a>软件特色和缺陷</h1><p>毫无疑问这款软件十分契合<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MDYwNDg2Njc1NDY1OTk0Mjcw" title="https://juejin.cn/post/7060486675465994270">《卡片笔记写作法》<i class="fa fa-external-link"></i></span>的理念。在经过一周多的粗略使用和了解之后仅个人的感受之后，我认为这款软件有下面几个特色：</p><p>首先是知识图谱，说实话在看到第一眼知识图谱的时候，立马让我想到过去曾经用Neo4j做项目模块功能的时候，看到这种网状知识结构的时候立马被吸引了，还是挺有意思的，或者说看到下面的截图相信读者可能有想要尝试一下的心情了。</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202203311900873.png" alt=""></p><p>这款软件的另外一个优点是双向链接了，关于这一点的使用体验要优于知识图谱，对于个人来说知识链接比较“花里胡哨”</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202203311903723.png" alt=""></p><p>最后是这款软件的tag标签功能，用户可以自定义。<br>以上是我对于原始软件的相关使用体验，其他各种插件个人一个也没有状态，最多是切换了一个好用的主题罢了。。。。。</p><p><strong>缺陷</strong><br>单说优点读者可能觉得这款软件很神，然而下面我要来说说这个软件的缺点。</p><p>首先<strong>软件的强依赖性</strong>和<strong>离线</strong>特征对于这点是个人有些不能接受的，因为人一旦离开机器，你会发现这个软件相当“鸡肋”，同时因为离线的缘故你还必须把笔记随身带着，所以通常把笔记放在你经常使用电脑上使用比较方便，另一个建议是使用U盘随身带走笔记。</p><p>缺陷是个人比较倾向“Typera”这款软件的快捷键，现在切换到原生的markdown语法反倒有点不习惯了。</p><blockquote><p>从这里就可以看出，云笔记和离线笔记互有优势。但是无论笔记在线还是离线很多人有不同的看法。但是个人实在是不提倡抄在本子上。如果一定有纸质笔记的习惯个人更加建议存盘到电子或者使用电子笔记打印。</p></blockquote><h1 id="学习与掌握"><a href="#学习与掌握" class="headerlink" title="学习与掌握"></a>学习与掌握</h1><p>经过上面一大堆的介绍，如果说对于这个软件产生了兴趣并且想要学习一下使用，那么这里要推荐某破站上面的视频了，但是这里要对读者说一声抱歉因为我推荐的是一个老外的视频，对于英语不好的人可能比较劝退，其实这类视频看着操作听他说话大致也能“意会”。</p><blockquote><p>关于推荐英文教材另一个理由是很多国人的视频会上来先叽里呱啦的说一大堆安利这个软件的话，我个人感觉没有必要，既然搜索学习怎么用那肯定是对软件感兴趣想要学习怎么用，像老外一样上来什么话不说直接从安装软件开始我觉得看着更舒服。</p></blockquote><ol><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMWl2NDExeDdVaC8=" title="https://www.bilibili.com/video/BV1iv411x7Uh/">Obsidian 入门 6-1 || 如何用Obsidian记笔记<i class="fa fa-external-link"></i></span>  </li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMTF2NDExeDdMby8=" title="https://www.bilibili.com/video/BV11v411x7Lo/">Obsidian 入门 6-2 || Markdown 关键语法<i class="fa fa-external-link"></i></span>  </li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVBLNHkxVzdVYy8=" title="https://www.bilibili.com/video/BV1PK4y1W7Uc/">Obsidian 入门 6-3 || 软件关键配置<i class="fa fa-external-link"></i></span>   </li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMUh6NHkxNjd2Vy8=" title="https://www.bilibili.com/video/BV1Hz4y167vW/">Obsidian 入门 6-4 || 定制主题<i class="fa fa-external-link"></i></span>  </li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMUp6NHkxNjdCdS8=" title="https://www.bilibili.com/video/BV1Jz4y167Bu/">Obsidian 入门 6-5 || 重要的快捷键<i class="fa fa-external-link"></i></span>  </li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVJwNHkxczdSby8=" title="https://www.bilibili.com/video/BV1Rp4y1s7Ro/">Obsidian 入门 6-6 || 链接你的笔记, 开始使用吧!<i class="fa fa-external-link"></i></span><br><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202203311934314.png" alt=""></li></ol><p>如果你的时间有限下面是视频对应的学习内容：</p><ul><li>Obsidian 入门 6-1 || 如何用Obsidian记笔记<br>  学习内容：<ul><li>如何构建知识链接“双括号”</li><li>双向链接和知识 图谱如何使用</li><li>为什么要使用双向连接，obsidian的核心</li><li>如何使用#标签语法 通过标签语法我们可以如何进行关联关键字。</li><li>为什么需要使用双线链接和标签语法？（闲聊）</li></ul></li><li>Obsidian 入门 6-2 || Markdown 关键语法（个人已了解故跳过）<ul><li>学习如何使用Markdown</li><li>Markdown的基本了解</li></ul></li><li>软件关键配置（可跳过）<ul><li>注意视频的版本比较老，所以里面的一些设置在新版本已经不适用了。</li></ul></li><li>软件关键配置（新版本不适用，可跳过）<ul><li>建议打开关联连接和思维导图的相关视图。</li></ul></li><li>定制主题<ul><li>可以拉进度条寻找一个自己喜欢的主题</li><li>可以在设置的“theme”里面选择自己喜欢的主题</li></ul></li><li>重要的快捷键<ul><li><code>Ctrl+E</code>实现编辑模式和阅读模式的切换</li><li>个人只学习了上面这一个比较实用的快捷键</li><li>[[测试]]通过这样的方式</li></ul></li><li>链接笔记，开始使用</li></ul><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>希望这篇文章能让读者对于这款软件有个更深的认识，个人比较希望以后有更多这种有特色的软件。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      思想革命性的一款软件
    
    </summary>
    
    
      <category term="其他" scheme="https://whitestore.top/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="其他" scheme="https://whitestore.top/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>《数据密集型型系统设计》LSM-Tree VS BTree</title>
    <link href="https://whitestore.top/2022/04/03/lsmtreebtree/"/>
    <id>https://whitestore.top/2022/04/03/lsmtreebtree/</id>
    <published>2022-04-03T04:41:31.000Z</published>
    <updated>2022-06-02T10:09:44.768Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>本文为《数据密集型应用系统设计》的读书笔记第一部分第三章的笔记整理，也是个人认为的这本书第一部分最重要的内容。本文将会针对目前数据库系统两个主要阵营进行展开，分别是采用日志型存储结构高速读写的LSM-Tree和面向OLTP的事务数据库BTree两种数据结构对比。</p><h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h1><p>本文的主要内容介绍如下：</p><ul><li>最简单key/value数据库考量和拓展，从零开始了解日志型存储结构。</li><li>索引对于数据库的重要性，哈希索引如何优化key/value数据库。</li><li>Btree 数据结构的简单介绍，数据结构和特点等。</li><li>LSM-Tree日志存储结构 VS Btree存储引擎，两大阵营的优劣对比。</li><li>OLTP到OLAP的对比，行存储到列式存储结构演进，以及数据仓库出现和数据分析的演进。</li></ul><h1 id="数据库底层设计考量"><a href="#数据库底层设计考量" class="headerlink" title="数据库底层设计考量"></a>数据库底层设计考量</h1><ul><li>底层存储形式：记录存储的基本设计格式，虽然格式会有不同的设计，但是最终都是以文件的形式存储。</li><li>查询/新增/读取/修改方式：在外部来看也就是在数据库概念中的DML操作，这种操作面对的是客户端，属于对外接口的部分。而从内部来看则是存储数据结构，操作数据结构和并发性能的考量。</li><li>操作日志：出于持久性的考量，操作日志是不可或缺的因素，也是意外之后数据修复的保证。</li><li>数据类型：比如Key/value存储还是针对行列的存储结构。</li></ul><h2 id="key-value存储结构和哈希索引"><a href="#key-value存储结构和哈希索引" class="headerlink" title="key/value存储结构和哈希索引"></a>key/value存储结构和哈希索引</h2><p>关键：#key/value存储结构处理 #哈希索引优化</p><p>从零开始设计一个数据库的存储形式，可以从下面的几个点考虑，从存储结构出发我们看日志存储结构数据库是如何出现的。</p><p>首先是key/value数据库数据结构设计第一版，从最简单的k/v存储数据库开始了解由此引申出哈希索引的结构：</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202204021750438.png" alt=""></p><p>上面结构有如下的特点：</p><p> <strong>存储形式</strong>：主要以key/value存储形式，key/value可以是任何内容。底层使用<strong>纯文本</strong>的形式存储，使用追加方式更新数据，相同key使用最后一次读到的key为基准。</p><p> <strong>读写方式</strong>：<code>db_set xx</code>设置数据，<code>db_get xx</code>读取数据，修改一个key通过最后一行追加形式，意味着更新和删除操作没有任何的开销，无需关注并发的问题。</p><p> <strong>查询性能</strong>：查找数据的开销为O(n)，新增和修改的性能都是O(1)。</p><blockquote><p>追加式处理优点</p><ul><li>顺序写比随机写好很多</li><li>段文件是追加不可变的，意味着并发访问和崩溃恢复比较容易</li><li>压缩和合并分段可以防止数据文件碎片化问题</li></ul></blockquote><p>最简单的k/v形式的数据库形成有哪些缺点？</p><ul><li>追加对于存储空间的浪费，虽然追加对于更新和新增十分方面并且维护成本较低，但是有个明显的问题是存储空间的浪费，同时我们发现其实并不需要存储原始文本的形式，同时数据本身可以通过压缩更加紧凑。</li><li>查询效率随着数据的膨胀而降低，所以需要对于查询速度进行优化，对于查询最简单的方式是引入索引，而对于key/value存储形式设计索引最为常见的是哈希索引</li></ul><p>对于Key/value存储引擎来说哈希是常用的索引类型，哈希索引使用内存中的哈希表进行实现，键值对的键存储数据需要索引的数值，而值存储偏移量，偏移量通过计算获取存储位置，在原始数据中直接找到相关位置的数据直接读取。</p><p>下面是哈希索引对于key/value结构数据进行索引优化。</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202204022257014.png" alt="哈希索引结构"></p><p>纯文本存储数据膨胀如何防止性能变差？</p><ul><li><p>分段数据：当追加到一定程度之后则写入一个新的文件。 </p></li><li><p>压缩段：将最新的数据进行压缩存储，由于使用追加新增方式，可以直接丢弃旧数据。</p></li><li><p>段压缩和多段合并：压缩与合并的过程没有特定规划，取决于数据结构和存储结构的抉择。</p></li></ul><p>如何防止性能变差：</p><p>哈希表和段进行绑定，一个段对应一个哈希表，同时执行段压缩和多端合并，保证脏数据及时清理，最后一定在内存中引入哈希表进行维护。</p><p>了解了大致思路之后，如何进行具体优化？</p><ol><li>压缩合并存储：为了让存储数据更加紧凑同时没有浪费，定期对于追加数据进行合并压缩是必要的，同时数据分段也可以提高线程并发读写性能。</li><li>数据分段：注意数据分段是结合压缩合并一同处理的，当压缩合并存储的数据到达一定量的时候需要对于数据进行分段处理，目的是防止单文件过大同时可以提高索引的搜索效率。</li><li>哈希表：引入哈希表结构，在数据行上加一层索引目录，可以加快查询性能，索引的key存储的是键需要保证唯一，而value则存储了<strong>行记录的指针</strong>，这适用于分段的数据结构找到数据存储的位置，通过一次遍历分段直接通过偏移指针查指定数据是否符合要求即可。</li></ol><p>上面讨论的存储结构其实存在实际的实现方式，此数据库存储引擎便是：<strong>Bitcast</strong>。</p><p><strong>哈希索引</strong>：</p><p>哈希索引设计特点</p><ul><li>文件格式：并没有使用纯文本存储而是使用二进制，使用字节来记录字符串长度，后面存储真实数据。（二进制也有利于压缩）<ul><li>崩溃恢复：最大的问题是重启之后<strong>哈希表会被释放</strong>，如果需要重新建立哈希表需要重新读取段，所以最大的性能开销在扫描段上，有一种优化方式是将哈希表的快照存储磁盘上直接读取。</li><li>部分写入记录：使用SHA盐值和操作日志对于部分写入记录进行恢复，操作日志相对于数据存储日志更为简单，只需要做增量操作，因为目的仅仅用于存储引擎崩溃之后可以保证数据的持久性。</li><li>并发控制：Bitcast实际上是一个写线程和多个读线程，数据使用追加方式可以保证多个线程读取，但是只能保证一个线程写入，但是由于数据分段，可以多线程同时改写不同数据段。</li></ul></li></ul><p>通过上面哈希结构的介绍，我们可以总结出<strong>哈希索引</strong>的几个特点：</p><ul><li>哈希索引适用于<strong>查询多，增删少</strong>的情况，虽然压缩和分段合并可以解决数据存储效率低的问题，但是对于频繁的增删需要额外的开销重新维护改动哈希表。</li><li>哈希表<strong>需要在内存</strong>中进行使用，所以受限于内存的大小，当然并不是说磁盘无法存储哈希表，而是哈希表在磁盘中难以维护和存储。</li></ul><p>哈希的索引形式也存在<strong>局限性</strong>：</p><ul><li>虽然哈希表不一定必须放入内存，理论可以在磁盘上维护哈希表，但是这样做需要大量的IO，同时哈希冲突需要更复杂的处理逻辑。</li><li>区间查询效率不高，对于范围查询的处理能力较弱，此时时间复杂度会退化为O(n)。</li></ul><p>以上是哈希结构对于key/value存储的结构的优化。</p><p>哈希索引通常的适用场景：</p><ul><li>点击数：对于数据的准确性要求并不是十分高，但是对于效率要求十分高</li><li>少量数据的唯一记录查找，注意是少量数据，因为哈希表空间有限。</li></ul><p><strong>小结：</strong></p><p>我们可以看到，从一个最简单的k/v数据库到哈希索引的结构引入，数据的存储和读取结构逐渐变复杂，可以看到哈希索引非常适合key/value的存储引擎，但是显然它存在比较明显的缺陷，比如只能维护哈希表到内存，并且频繁的更新插入key/value对于索引的维护开销也不小，最后最为致命的是范围查询对于哈希索引是硬伤。</p><blockquote><p>总结：索引特点</p><ul><li>加快原始数据的查询速度</li><li>空间换时间，需要更多的存储空间以及更长写数据时间</li><li>索引很多时候被视为和原始数据分开的结构</li></ul></blockquote><p>通过上面的设计有缺点，针对哈希索引有了第一层进化，那就是 SSTable和LSM-Tree。</p><h1 id="SSTable和LSM-Tree结构"><a href="#SSTable和LSM-Tree结构" class="headerlink" title="SSTable和LSM-Tree结构"></a>SSTable和LSM-Tree结构</h1><p>#SSTable #LSM-Tree</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在具体的内容介绍之前，我们需要弄清楚SSTable和LSM-Tree有什么区别，简单来说LSM-Tree是对SSTable概念和思想的一个继承。另外需要注意这个结构特点正好解决了<strong>哈希索引局限性</strong>问题，同时SSTable并没有抛弃key/value这样的存储结构，而是在索引结构上进一步升级。</p><h2 id="SSTable概念"><a href="#SSTable概念" class="headerlink" title="SSTable概念"></a>SSTable概念</h2><p>SSTable起源自谷歌在2006年发布的一篇轰动世界的论文，里面的BigTable就是SSTable和LSM-Tree的前身：<strong>Bigtable: A Distributed Storage System for Structured Data</strong>。如果觉得论文难以理解，可以参考这篇文章理解：</p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L09wZW5OYWl2ZS9hcnRpY2xlL2RldGFpbHMvNzUzMjU4OQ==" title="https://blog.csdn.net/OpenNaive/article/details/7532589">https://blog.csdn.net/OpenNaive/article/details/7532589<i class="fa fa-external-link"></i></span></p><p>这里挑了其中一些和SSTable有关的内容，可惜的是这篇论文并没有详细的介绍SSTable的内部数据结构，在论文第六个小节中介绍了SSTable的作用：</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202204010930848.png" alt=""></p><p>BigTable和GFS 是什么关系呢？在论文中我们可以看到一个类似树的结构，其中根节点为主服务器，主服务器负责接受请求，通过管理分片服务器将请求分片到不同的片服务器中，所以从外层看最终干活的是片服务器，实际上片服务器本身只是负责管理自己分片SSTable，通过特殊索引知道数据在那个SSTable分片中，然后从GFS中读取SSTable文件的数据，而GFS则可能要从多个chuncker server里面搜索数据。</p><p>而图中的metatable原数据表可以看作是和SSTable绑定的类似索引的关系，元数据表的数据是不能被外界访问的，外界访问的是元数据对应的SSTable分片，这和后面介绍的LSM-Tree有着十分熟悉的契合关系。</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202204010931615.png" alt=""></p><h2 id="改进与对比"><a href="#改进与对比" class="headerlink" title="改进与对比"></a>改进与对比</h2><p>关键点： 数据存储方式，索引查找方式改进</p><h3 id="SSTable通常如何工作？"><a href="#SSTable通常如何工作？" class="headerlink" title="SSTable通常如何工作？"></a>SSTable通常如何工作？</h3><ul><li>写入的时候不写入磁盘而是先写入内存表的数据结构，同时在内存将数据进行排序。</li><li>当数据结构内存占用超过一定的阈值就可以直接写入到磁盘文件由于已经是排好序的状态，所以可以对于旧结构覆盖，写入效率比较高。并且写入和数据结构改动可以同时进行。</li><li>读写顺序按照 内存 -&gt; 磁盘 -&gt; 上一次写入文件 -&gt; 未找到这样的顺序进行查找和搜索。</li><li>后台定时线程定时合并和压缩排序分段，将废弃值给覆盖或者丢弃。</li></ul><h3 id="SStable的改进点"><a href="#SStable的改进点" class="headerlink" title="SStable的改进点"></a>SStable的改进点</h3><p>下面是SSTable相对于哈希结构的特点：</p><ul><li>高效合并：合并段的过程更加高效，每一个段都是按照特定顺序排序，当出现多个重复数值的时候可以合并到最新的段，对于旧数据则可以直接舍弃前面的内容。</li><li><strong>范围索引优化</strong>：内存中哈希表也是有序存储，可以将多个kv对应的数据条目一同压缩存储，这样索引条目只需要开头部分的键值即可，因为后续所有的记录都是有序的。</li><li>索引优化：比起哈希较为松散随意的结构，这样的处理牺牲一定的读写开销换来更加高效的存储和索引结构，并且可以支持范围索引扫描。</li><li><strong>顺序读写</strong>：数据顺序存储的好处是可以顺序读写，避免磁盘的随机读写可以大幅度提升读写性能</li></ul><p>下面是改进过后的压缩过程图：</p><p>最大的改动点：压缩合并的基础上对于SSTable基础内容进行合并操作。</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202204022247935.png" alt=""></p><blockquote><p>如何维护sstable?<br>首先是数据如何在内存中排序，可以使用红黑树和AVL树的结构也可以是任意结构，重点是在内存中完成数据压缩合并和排序的操作。</p><p>为什么数据集远远大于内存依然可以高效？<br>因为使用排序以及分段合并压缩分段的数据，所以一次加在到内存的数据不需要太多，其实只需要把内存索引表查找某个区间段的数据，然后进行顺序查找，由于是按照排序的方式顺序存储的，在段上查找数据集通常可以根据键直接偏移或者按照特定规则二分查找的方式搜索。</p></blockquote><h3 id="SSTable和哈希索引的对比："><a href="#SSTable和哈希索引的对比：" class="headerlink" title="SSTable和哈希索引的对比："></a>SSTable和哈希索引的对比：</h3><p>可以看到SSTable在哈希索引的基础上进行优化，使用排序的手段虽然会损耗一定的写入消耗，但是换来的是更高效率的范围查询以及更高效率的压缩存储形式。</p><p>哈希索引：</p><ul><li>索引查询效率十分高</li><li>内存中维护，磁盘IO开销很小</li><li>非常适用于Key频繁更新的场景</li></ul><p>SSTable：</p><ul><li>利于磁盘维护索引和顺序读写，</li><li>优化范围查询。</li><li>将范围搜索的查询效率优化至O(logN)的水平</li></ul><h2 id="实际案例和应用"><a href="#实际案例和应用" class="headerlink" title="实际案例和应用"></a>实际案例和应用</h2><p>全文索引：</p><p>全文索引虽然比key/value复杂很多，但是本质都是类似的，某些数据维护依然基于key/value方式存储，比如词条的映射关系使用的SS Table进行存储，在内存中排好序存储，并且需要的时候进行合并。</p><p>LevelDB和RockDB：</p><p>LevelDB和RockDB是最为典型的LSM-Tree实践案例，尤其是LSM-Tree作者刚好又是谷歌的工程师，深入了解这两款经典LSM-Tree实现案例可以对于SSTable的设计和应用有更深的了解。</p><blockquote><p>LSM-Tree 的代码非常简单易懂，难懂的地方作者也给了注释，对于我这种JAVA开发者也能了解大概。</p></blockquote><h2 id="SSTable的弊端"><a href="#SSTable的弊端" class="headerlink" title="SSTable的弊端"></a>SSTable的弊端</h2><ul><li>最大的隐患是在压缩合并分段的时候不能进行数据的读写，否则数据一致性会存在问题，这对于吞吐量要求高的系统很难接受。</li><li>压缩另一个问题是对于带宽的占用非常高，压缩数据量越大，带宽消耗越高，容易阻塞大量的读写请求。</li><li>如果压缩速度跟不上写入数据，那么就会出现大量未压缩数据堆积情况，长期累计容易造成磁盘空间不足，但是sstable的数据结构决定了追加写入是不受控制的，需要外部力量监控。</li></ul><h1 id="Btree存储结构"><a href="#Btree存储结构" class="headerlink" title="Btree存储结构"></a>Btree存储结构</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Btree数据结构自1970年被提出之后，被广大的数据库使用者接受BTree目前不太可能被新技术淘汰，而日志索引结构的Lsm-Tree未来前景十分可观。</p><h2 id="Btree特点"><a href="#Btree特点" class="headerlink" title="Btree特点"></a>Btree特点</h2><p>和SSTable仅仅只有一点类似：B-tree保留按键排序的 key/value对，这样可以实现高效的 key-value查找和区间查询，除此之外没有其他的相似点。</p><p>下面是Btree的特点：</p><ul><li>和日志存储结构不同的是，Btree将数据分为固定的数据页，每一个数据页固定大小，通常为4KB，InnoDB一个数据页固定设置为16KB。</li><li>更新数据在原结构上进行更新，也就是使用新数据页覆盖旧的数据页，所以更新的代价相对于日志结构要大很多的。</li><li>数据页存在和磁盘对应的唯一标识，同时数据页之间通过链表指针串联，但是指针存储的不是内存上的地址，而是磁盘的地址，</li><li>新增数据如果数据页内容不足需要进行页分裂，同时父节点需要包含新分裂的页，而页分裂很容易造成磁盘碎片和数据的排序，同时因为内部需要维持数据排序开销不小。</li></ul><blockquote><p>为什么数据页要固定大小？<br>这和磁盘的读写有关，传统机械硬盘为512b最小单位，而SSD通常为4KB最小单位读写，所以数据页设计为和磁盘兼容的形式存储有利于<strong>顺序读写</strong>，同时可以最大化利用磁盘空间。</p></blockquote><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202204022303218.png" alt=""></p><h2 id="Btree优化和可改进点"><a href="#Btree优化和可改进点" class="headerlink" title="Btree优化和可改进点"></a>Btree优化和可改进点</h2><ul><li>压缩存储：使用缩略的键信息，因为对于树中间一个数据行来说只要提供开始和结束的位置即可，这样可以在有限的数据页存储更多的数据。</li><li>数据页排序：虽然数据页可以存储在不同的磁盘空间，但是对于某些需要范围查询的情况下需要对于磁盘进行顺序查找，而此时数据页的随机查询就会出现问题</li><li>BTree到B+树的优化，优化的方式也十分简单易懂，在各层都加链表加快索引查找，这种甚至不能叫优化只能说是改进。</li><li>使用<strong>写时复制</strong>替代覆盖页的方式，在修改页的时候不对原数据改动，将写入新的父页并且更新旧引用。</li></ul><h2 id="Btree和LSM-Tree对比"><a href="#Btree和LSM-Tree对比" class="headerlink" title="Btree和LSM-Tree对比"></a>Btree和LSM-Tree对比</h2><p>Btree的读写速度快于LSM-Tree，因为一次IO读写可以索引到大量的数据页，而LSM-Tree需要跨越多个压缩段才可能找到数据。但是LSM-Tree的读写速度要快于Btree，同时存储效率要比Btree要高，因为压缩和合并分段之后数据间隙之间基本不存在数据间隙碎片。</p><p>所以LSM-Tree适用于读写多的场景，而Btree因为需要高效查询设计上要复杂非常多所以为了服务查询性能可以容忍写入和删除的额外开销。</p><p>单纯对比数据结构可能比较枯燥，这里从老外的网站上找了一份<strong>Mysql</strong>和<strong>LevelDB</strong>的对比，这两款基本可以代言Btree和LSM-Tree这两种数据结构了。可以看到LevelDB要比Mysql的出现晚上不少，这和BigTable有着密切关系，也和网络时代的发展和互联网的用户量指数上升有关系。</p><table><thead><tr><th>Name</th><th>LevelDB <span class="exturl" data-url="aHR0cHM6Ly9kYi1lbmdpbmVzLmNvbS9lbi9zeXN0ZW0vTXlTUUw=" title="https://db-engines.com/en/system/MySQL">X<i class="fa fa-external-link"></i></span></th><th>MySQL <span class="exturl" data-url="aHR0cHM6Ly9kYi1lbmdpbmVzLmNvbS9lbi9zeXN0ZW0vTGV2ZWxEQg==" title="https://db-engines.com/en/system/LevelDB">X<i class="fa fa-external-link"></i></span></th></tr></thead><tbody><tr><td>Description</td><td>Embeddable fast <span class="exturl" data-url="aHR0cHM6Ly9kYi1lbmdpbmVzLmNvbS9lbi9hcnRpY2xlL0tleS12YWx1ZStTdG9yZXM=" title="https://db-engines.com/en/article/Key-value+Stores">key-value storage<i class="fa fa-external-link"></i></span> library that provides an ordered mapping from string keys to string values</td><td>Widely used open source <span class="exturl" data-url="aHR0cHM6Ly9kYi1lbmdpbmVzLmNvbS9lbi9hcnRpY2xlL1JEQk1T" title="https://db-engines.com/en/article/RDBMS">RDBMS<i class="fa fa-external-link"></i></span></td></tr><tr><td>Primary database model</td><td><span class="exturl" data-url="aHR0cHM6Ly9kYi1lbmdpbmVzLmNvbS9lbi9hcnRpY2xlL0tleS12YWx1ZStTdG9yZXM=" title="https://db-engines.com/en/article/Key-value+Stores">Key-value store<i class="fa fa-external-link"></i></span></td><td><span class="exturl" data-url="aHR0cHM6Ly9kYi1lbmdpbmVzLmNvbS9lbi9hcnRpY2xlL1JEQk1T" title="https://db-engines.com/en/article/RDBMS">Relational DBMS<i class="fa fa-external-link"></i></span> <img src="https://db-engines.com/info.png" alt="info"></td></tr><tr><td>Secondary database models</td><td></td><td><span class="exturl" data-url="aHR0cHM6Ly9kYi1lbmdpbmVzLmNvbS9lbi9hcnRpY2xlL0RvY3VtZW50K1N0b3Jlcw==" title="https://db-engines.com/en/article/Document+Stores">Document store<i class="fa fa-external-link"></i></span> <span class="exturl" data-url="aHR0cHM6Ly9kYi1lbmdpbmVzLmNvbS9lbi9hcnRpY2xlL1NwYXRpYWwrREJNUw==" title="https://db-engines.com/en/article/Spatial+DBMS">Spatial DBMS<i class="fa fa-external-link"></i></span></td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly9kYi1lbmdpbmVzLmNvbS9lbi9yYW5raW5n" title="https://db-engines.com/en/ranking">DB-Engines Ranking<i class="fa fa-external-link"></i></span> <img src="https://db-engines.com/info.png" alt="info"><a href="https://db-engines.com/en/ranking_trend/system/LevelDB%3BMySQL" target="_blank" rel="noopener"><img src="https://db-engines.com/ranking_trend_s.png" alt="ranking trend"></a><span class="exturl" data-url="aHR0cHM6Ly9kYi1lbmdpbmVzLmNvbS9lbi9yYW5raW5nX3RyZW5kL3N5c3RlbS9MZXZlbERCJTNCTXlTUUw=" title="https://db-engines.com/en/ranking_trend/system/LevelDB%3BMySQL">Trend Chart<i class="fa fa-external-link"></i></span></td><td>Score3.19Rank#97 <span class="exturl" data-url="aHR0cHM6Ly9kYi1lbmdpbmVzLmNvbS9lbi9yYW5raW5n" title="https://db-engines.com/en/ranking">Overall<i class="fa fa-external-link"></i></span>#18 <span class="exturl" data-url="aHR0cHM6Ly9kYi1lbmdpbmVzLmNvbS9lbi9yYW5raW5nL2tleS12YWx1ZStzdG9yZQ==" title="https://db-engines.com/en/ranking/key-value+store">Key-value stores<i class="fa fa-external-link"></i></span></td><td>Score1204.16Rank#2 <span class="exturl" data-url="aHR0cHM6Ly9kYi1lbmdpbmVzLmNvbS9lbi9yYW5raW5n" title="https://db-engines.com/en/ranking">Overall<i class="fa fa-external-link"></i></span>#2 <span class="exturl" data-url="aHR0cHM6Ly9kYi1lbmdpbmVzLmNvbS9lbi9yYW5raW5nL3JlbGF0aW9uYWwrZGJtcw==" title="https://db-engines.com/en/ranking/relational+dbms">Relational DBMS<i class="fa fa-external-link"></i></span></td></tr><tr><td>Website</td><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9sZXZlbGRi" title="https://github.com/google/leveldb">github.com/­google/­leveldb<i class="fa fa-external-link"></i></span></td><td><span class="exturl" data-url="aHR0cHM6Ly93d3cubXlzcWwuY29tLw==" title="https://www.mysql.com/">www.mysql.com<i class="fa fa-external-link"></i></span></td></tr><tr><td>Technical documentation</td><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9sZXZlbGRiL2Jsb2IvbWFzdGVyL2RvYy9pbmRleC5tZA==" title="https://github.com/google/leveldb/blob/master/doc/index.md">github.com/­google/­leveldb/­blob/­master/­doc/­index.md<i class="fa fa-external-link"></i></span></td><td><span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy8=" title="https://dev.mysql.com/doc/">dev.mysql.com/­doc<i class="fa fa-external-link"></i></span></td></tr><tr><td>Developer</td><td>Google</td><td>Oracle <img src="https://db-engines.com/info.png" alt="info"></td></tr><tr><td>Initial release</td><td>2011</td><td>1995</td></tr><tr><td>Current release</td><td>1.23, February 2021</td><td>8.0.28, January 2022</td></tr><tr><td>License <img src="https://db-engines.com/info.png" alt="info"></td><td>Open Source <img src="https://db-engines.com/info.png" alt="info"></td><td>Open Source <img src="https://db-engines.com/info.png" alt="info"></td></tr><tr><td>Cloud-based only <img src="https://db-engines.com/info.png" alt="info"></td><td>no</td><td>no</td></tr><tr><td>DBaaS offerings (sponsored links) <img src="https://db-engines.com/info.png" alt="info"></td><td></td><td><span class="exturl" data-url="aHR0cHM6Ly90LnNpZGVraWNrb3Blbjc5LmNvbS9zMXQvYy81L2YxOGRRaGIwU2RZajhiR2NoMFcybjB4NmwyQjluTUpXN3Q2OXY2OHBUYkI0VzYzQmMxZDE2Z0dDTWYzREpwMTkwMT90ZT1XM1I1aEZqNGNtMnp3VzRjSGJydjNLNGROWlczR0dacmsxTEJmMzVGNDdQTmNZUzZUVzEmc2k9MzcwODg1MDA3JnBpPWE2ODYzMmUyLWU4NGMtNGNmZi04NTQxLTRhMGZkMjcwMmFiYQ==" title="https://t.sidekickopen79.com/s1t/c/5/f18dQhb0SdYj8bGch0W2n0x6l2B9nMJW7t69v68pTbB4W63Bc1d16gGCMf3DJp1901?te=W3R5hFj4cm2zwW4cHbrv3K4dNZW3GGZrk1LBf35F47PNcYS6TW1&si=370885007&pi=a68632e2-e84c-4cff-8541-4a0fd2702aba">ScaleGrid for MySQL<i class="fa fa-external-link"></i></span>: Fully managed MySQL hosting on AWS, Azure and DigitalOcean with high availability and SSH access on the #1 multi-cloud DBaaS.</td></tr><tr><td>Implementation language</td><td>C++</td><td>C and C++</td></tr><tr><td>Server operating systems</td><td>Illumos Linux OS X Windows</td><td>FreeBSD Linux OS X Solaris Windows</td></tr><tr><td>Data scheme</td><td>schema-free</td><td>yes</td></tr><tr><td>Typing <img src="https://db-engines.com/info.png" alt="info"></td><td>no</td><td>yes</td></tr><tr><td>XML support <img src="https://db-engines.com/info.png" alt="info"></td><td>no</td><td>yes</td></tr><tr><td>Secondary indexes</td><td>no</td><td>yes</td></tr><tr><td>SQL <img src="https://db-engines.com/info.png" alt="info"></td><td>no</td><td>yes <img src="https://db-engines.com/info.png" alt="info"></td></tr><tr><td>APIs and other access methods</td><td></td><td>ADO.NET JDBC ODBC Proprietary native API</td></tr><tr><td>Supported programming languages</td><td>C++ Go Java <img src="https://db-engines.com/info.png" alt="info"> JavaScript (Node.js) <img src="https://db-engines.com/info.png" alt="info"> Python <img src="https://db-engines.com/info.png" alt="info"></td><td>Ada C C# C++ D Delphi Eiffel Erlang Haskell Java JavaScript (Node.js) Objective-C OCaml Perl PHP Python Ruby Scheme Tcl</td></tr><tr><td>Server-side scripts <img src="https://db-engines.com/info.png" alt="info"></td><td>no</td><td>yes <img src="https://db-engines.com/info.png" alt="info"></td></tr><tr><td>Triggers</td><td>no</td><td>yes</td></tr><tr><td>Partitioning methods <img src="https://db-engines.com/info.png" alt="info"></td><td>none</td><td>horizontal partitioning, sharding with MySQL Cluster or MySQL Fabric</td></tr><tr><td>Replication methods <img src="https://db-engines.com/info.png" alt="info"></td><td>none</td><td>Multi-source replication Source-replica replication</td></tr><tr><td>MapReduce <img src="https://db-engines.com/info.png" alt="info"></td><td>no</td><td>no</td></tr><tr><td>Consistency concepts <img src="https://db-engines.com/info.png" alt="info"></td><td>Immediate Consistency</td><td>Immediate Consistency</td></tr><tr><td>Foreign keys <img src="https://db-engines.com/info.png" alt="info"></td><td>no</td><td>yes <img src="https://db-engines.com/info.png" alt="info"></td></tr><tr><td>Transaction concepts <img src="https://db-engines.com/info.png" alt="info"></td><td>no</td><td>ACID <img src="https://db-engines.com/info.png" alt="info"></td></tr><tr><td>Concurrency <img src="https://db-engines.com/info.png" alt="info"></td><td>yes</td><td>yes <img src="https://db-engines.com/info.png" alt="info"></td></tr><tr><td>Durability <img src="https://db-engines.com/info.png" alt="info"></td><td>yes <img src="https://db-engines.com/info.png" alt="info"></td><td>yes</td></tr><tr><td>In-memory capabilities <img src="https://db-engines.com/info.png" alt="info"></td><td></td><td>yes</td></tr><tr><td>User concepts <img src="https://db-engines.com/info.png" alt="info"></td><td>no</td><td>Users with fine-grained authorization concept <img src="https://db-engines.com/info.png" alt="info"></td></tr></tbody></table><h1 id="OLTP和OLAP"><a href="#OLTP和OLAP" class="headerlink" title="OLTP和OLAP"></a>OLTP和OLAP</h1><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><p>单从名字的区分，这两个类型分别针对<strong>事务</strong>和针对<strong>分析</strong>，由此引发了不同的完全不同的数据结构和存储形式，同时侧重点和服务范围不同，注意这两者并不能说谁优势谁劣势，因为OLAP说白了是在OLTP上演化而出现的。</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202204031054303.png" alt=""><br>如果看不清，可以看看甲骨文提供的一个表格：<br><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202204021830049.png" alt=""></p><p>OLTP：在线<strong>事务</strong>处理。用于处理数据量较小的事务为主的业务，要求的是高吞吐高响应，一般为web应用程序，主要面向广大用户群体，适用于解决生活中80%左右的业务和系统问题。</p><p>OLAP：在线<strong>分析</strong>处理。主要基于大数据量的数据搜索和汇总，随着时间变化而进行数据分析进行数据支撑。一般出现在中大型公司的较大型项目中。</p><h1 id="数据仓库"><a href="#数据仓库" class="headerlink" title="数据仓库"></a>数据仓库</h1><p>事务型号数据库这里不再赘述了，相信大家也很熟悉，这里说说数据仓库是什么？</p><p>数据仓库是上世纪90年代被提出的放弃基于传统事务 OLTP结构的数据库分析，转为使用单个数据仓库进行数据分析的方式，简单理解就是讲数据和业务剥离，只保留数据部分进行存储，通常为了方便分析会使用[[《数据密集型系统设计》列式存储]]引擎和前面提到的[[《数据密集型型系统设计》SSTable和LSM-Tree]]数据结构。</p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>数据仓库有下面的优势。</p><ul><li>面向主题：数据仓库可以高效分析关于特定主题或职能领域（例如销售）的数据。</li><li>集成：数据仓库可在不同来源的不同数据类型之间建立一致性。</li><li>相对稳定：进入数据仓库后，数据将保持稳定，不会发生改变。</li><li>反映历史变化：数据仓库分析着眼于反映历史变化。</li></ul><h2 id="存储形式"><a href="#存储形式" class="headerlink" title="存储形式"></a>存储形式</h2><p>数据仓库一般不存在于小公司，因为根本没有那个资金支撑也没有，而是面对较大公司多达10几个系统数据规模的存在形式，所以对于很多人来说可能就是围观看造火箭，看懂了好像也没啥价值。</p><p>结构图</p><p>下面是整个数仓系统的结构</p><h2 id="进化"><a href="#进化" class="headerlink" title="进化"></a>进化</h2><p>数据仓库到了现在又出现了进一步的转变，大数据也被分为了很多个方向，这些都是战未来的东西，这里简单提炼一下概念：</p><ul><li>数据挖掘</li><li>预测和统计</li><li>人工智能和机器学习</li></ul><h2 id="数据湖"><a href="#数据湖" class="headerlink" title="数据湖"></a>数据湖</h2><p>注意数据库并不是指比数据仓库大很多倍的数据仓库或者数据库集群，他是完全不同的概念，数据仓库是已经被整理<br>数据湖主要用于存储大量迥然不同并且没有进行分类筛选的数据，数据湖对于分析人员来说是最为自由的一种，可以形象看作垃圾池掏金子，收益和代价并存，更多时候是把数据湖转为数据仓库。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul><li>数据库 比较流行的有：MySQL, Oracle, SqlServer等。</li><li>数据仓库 比较流行的有：AWS Redshift, Greenplum, Hive等。</li></ul><h2 id="分析模式"><a href="#分析模式" class="headerlink" title="分析模式"></a>分析模式</h2><p>对于数据仓库的分析模型，现今通常有两种方式：星型模型和雪花模型。</p><h3 id="星型模型"><a href="#星型模型" class="headerlink" title="星型模型"></a>星型模型</h3><p>星型模型也别叫做纬度模型，这个模型针对的是非强依赖的数据关系分析，比较典型的如电商系统和购物网站，虽然商品，订单，库存，广告等等看似没有什么关系，然而这些数据就像是星星一样分散，有着千丝万缕的直接依赖或者间接依赖关系。<br>星型模型的数据更像是星星和月亮的关系，核心通常位于中间， 而四周散布关系模型。</p><h3 id="雪花模型"><a href="#雪花模型" class="headerlink" title="雪花模型"></a>雪花模型</h3><p>雪花模型要比星型模型设计上规范很多，也是对于维度模型的进一步拆分，比如对于商品表引入更加细分的品牌和分类进行更进一步的细分，也类似超市的商品分类。</p><p><strong>小结</strong></p><p>这一节点从OLAP讲到数据仓库，再讲到两种主流的分析方式，星型模型和雪花模型。<br>当然这些内容都是简单介绍，读者可以根据自己感兴趣的点进行深入和熟悉。</p><h1 id="列式存储"><a href="#列式存储" class="headerlink" title="列式存储"></a>列式存储</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>对于传统的业务数据库并且用户量较小的公司来说，通常使用关系型数据库，而关系型数据库基本以Btree数据结构作为核心，这些数据库基本都是行存储，行存储比较符合理解思维，然而实际上对于数据分析而言，行数据往往会造成长时间的时间等待，并且如果需要对于数据进行实施分析作为业务决策，使用行存储分析显然系统开销是无法接受的，由此引入了[[OLTP和OLAP]]。</p><p>之前提到的内容都是行式存储，有些情况下列存储更利于数据管理，特别是对于事务关系数据库行存储结构不利于单一列分析，比如我们想要存储某一分类的价格趋势，行存储需要扫描所有行求和，而列存储直接把一整列拿出来求和即可，两者效率自然不用多说。</p><h2 id="列存储结构特点"><a href="#列存储结构特点" class="headerlink" title="列存储结构特点"></a>列存储结构特点</h2><ul><li>所有列值紧凑存储在一起</li><li>通常比行存储更有利于理解</li><li>可用于非关系型数据库，当然也可以用于关系型数据库。（反过来行存储就不适用这条规则了）</li></ul><h2 id="列压缩"><a href="#列压缩" class="headerlink" title="列压缩"></a>列压缩</h2><p>列式存储意味着把同类数据压缩到不同的段，这对于存储结构来说是有利的，通常列压缩在数据仓库使用位图的形式存储。</p><p>因为列存储的都是同一个数据类型的数据，所以可以针对不同的数据类型进行优化存储，这样也意味着比行存储更少的空间压缩更多的数据，比如对于一些整型数据在压缩存储的时候可以使用位模式存储。也就是直接存数字的二进制位编码，列查询的时候进行位操作即可。</p><p>下面是一个典型的列存储和压缩的例子：<br><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202204021858384.png" alt="列存储模型"></p><p>存储位图可能人不是很好理解和计算，但是计算器来说就不一样了，位元算操作远远高于数学运算。</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202204021859002.png" alt="列压缩模型"></p><p>另外除开列压缩以外，列的存储还以一个<strong>列族</strong>的概念，列族存在于Cassandra和HBase这两个数据库，而列族这个概念继承自BigTable。<br>但是我们之前介绍[[《数据密集型型系统设计》SSTable和LSM-Tree]]讲述基本还是行存储方式和实现。</p><p>列族：其实指的是<strong>把一行中的所有列和行主键保存到一起</strong>，并且不使用列压缩的形式存储。其实这种用行转列基本就可以实现，所以列族严格意义上依然是行存储的变体，和真正的列存储还是存在差异的。</p><h2 id="列排序"><a href="#列排序" class="headerlink" title="列排序"></a>列排序</h2><p>相对于行存储，列的排序其实并没有多重要，因为他不关心数据归属而是数据的整理，和[[SSTable]]一样，列排序最好的方式也是通过追加压缩合并的方式，然后利用索引和一些天然的有序数据结构完成存储。</p><p>注意列排序一般不会针对单列进行排序，因为没有多少意义，至于原因这里依然强调单列没有办法知道数据的归属。</p><p>列排序的第一个优势是可以对列的重复值进行压缩，比如性别通常只有男和女，这时候重复的列存储是没有必要的。</p><p>列排序的另一个优点是多列排序可以快速的定位某一列的极值情况和方便快速的分组或者过滤查询。</p><p>C-Store最早引入了 一 种改进想蓓，井被商业数据仓库 Vertica。</p><p>最后，面相列存储通常会具备多个排序顺序，但是多列排序很难维护，所以更常见的情况是引入二级索引维护，和行存储的索引维护不同，行存储的二级索引通常指向数据行（或者像InnoDB一样指向主键，不过这种处理比较特殊），<strong>列存储二级索引通常指向值</strong>。</p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>列存储中一个十分重要的优化特性是引入试图对于临时查询进行加速，数据仓库中的SQL中经常会碰到聚合函数的查询通常会想到使用缓存进行存储。<br>列存储的缓存被叫做标准视图，注意这个视图并不是逻辑临时结构，而是真实物理视图，列存储相比行存储对于物理存储的数据有效和可用性高很多，OLTP系统不适用物理视图主要原因是缓存失效很快并且需要应对低延迟高响应的查询，而数据仓库由于主要做数据分析数据静态情况更多。<br>视图的特殊情况叫做数据立方体，数据立方体的概念类似于列存储的“行聚合”和“列聚合”交叉查询的方式：<br><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202204021939696.png" alt=""></p><p>从上面的图可以看到，数据分为多个维度进行分析和查询，通过多维度角度可以把多个分类模型的数据放到一起进行交叉统计，这对于数据分析人员来说无疑省去大量的准备工作，将这种数据立方物化之后的查询效率也十分高。</p><p>物化数据毫无疑问让数据查询更快，因为数据已经预先准备，但是数据立方的缺点和缓存的缺点一样是不能频繁改动，否则失去其本身意义。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>主要的内容集中在Key/value的数据库发展和哈希索引，以及后续的Btree和LSM-Tree上，可以看到BTree出现最早但是经历了30多年依然长盛不衰，一时半会应该还没有更优秀的数据结构替代，而LSM-Tree则比较符合未来和现代的发展潮流，因为他存储形式更自由，并且非常适合用于列式存储和列压缩以及数据分析，总之这篇笔记更多的是让读者了解更广阔的数据视野。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>这篇除开书本的内容之外，个人对于其他内容做了一些补充，如果有不同的看法欢迎讨论，如果文中有错误欢迎批评指正。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><ul><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L09wZW5OYWl2ZS9hcnRpY2xlL2RldGFpbHMvNzUzMjU4OQ==" title="https://blog.csdn.net/OpenNaive/article/details/7532589">https://blog.csdn.net/OpenNaive/article/details/7532589<i class="fa fa-external-link"></i></span> BigTable翻译和解读，讲的不错</li><li><span class="exturl" data-url="aHR0cHM6Ly9kYi1lbmdpbmVzLmNvbS9lbi9zeXN0ZW0vTGV2ZWxEQiUzQk15U1FM" title="https://db-engines.com/en/system/LevelDB%3BMySQL">https://db-engines.com/en/system/LevelDB%3BMySQL<i class="fa fa-external-link"></i></span> 文中图表来源</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      采用日志型存储结构高速读写的LSM-Tree和面向OLTP的事务数据库BTree两种数据结构对比
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://whitestore.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="书籍" scheme="https://whitestore.top/tags/%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>《也许你该找个人聊聊》读书笔记 - 直面的勇气</title>
    <link href="https://whitestore.top/2022/03/16/yexu/"/>
    <id>https://whitestore.top/2022/03/16/yexu/</id>
    <published>2022-03-16T01:02:34.000Z</published>
    <updated>2022-06-02T10:09:44.722Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《也许你该找个人聊聊》读书笔记-直面的勇气"><a href="#《也许你该找个人聊聊》读书笔记-直面的勇气" class="headerlink" title="《也许你该找个人聊聊》读书笔记 - 直面的勇气"></a>《也许你该找个人聊聊》读书笔记 - 直面的勇气</h1><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>本书的核心是：<strong>拯救我们的不再是任何道理或技巧，只有直面的勇气</strong>。这本书的奇妙之处在于，每一个人或多或少会看到一些自己的影子，每个人都隐藏着难以言说的痛苦，当痛苦无法承受的时候，我们很难也很少去寻找自己熟悉的人进行和解，这时候需要一个客观的镜子来审视自己，这就是心理咨询师的作用。</p><p>然而国内对于心理咨询这一块一直是不温不火的，也很少有人去寻找专业的心理医生，因为或许心理医生甚至可能要比来访者的压力还要大，或许对于中国人疗伤的方式是来源于网络逃避，然而网络虽然可以帮助我们逃避痛苦，但是是无法帮我们解决痛苦，当言语无法传达的时候，就需要用文字传达，或许我们或多或少都需要像书名一样：该找个人聊聊。</p><h1 id="资源地址"><a href="#资源地址" class="headerlink" title="资源地址"></a>资源地址</h1><p>链接: <span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMUFlRVFhdXh3YS1QZlZYc0JQRnFHSmc=" title="https://pan.baidu.com/s/1AeEQauxwa-PfVXsBPFqGJg">https://pan.baidu.com/s/1AeEQauxwa-PfVXsBPFqGJg<i class="fa fa-external-link"></i></span> 提取码: bnol</p><blockquote><p>如果链接失效，可以公众号“懒时小窝”回复“也许你该找个人聊聊”获取链接，感兴趣也可以关注我，不定时发布个人的读书笔记和技术文，希望给各位带来更多好书。 </p></blockquote><a id="more"></a><h1 id="推荐语"><a href="#推荐语" class="headerlink" title="推荐语"></a>推荐语</h1><p>平心而论我不建议线性的读完这本书，你会发现这本书很厚但是故事琐碎并且绵长，因为这本书更像是一本小说却同时穿插了5个故事，越往后面阅读你越会发现这怎么这么像是电视剧呀？这既是巧合又不是巧合，在这本书中真正重要的不是故事，而是在心理咨询这个双面镜的相互映照的过程中我们是如何思考的，他们在对话中如何产生转变和思考的。</p><p>对于这本书的核心毫无疑问是诚实是面对这一切问题的唯一答案，我们的谎言可能可以掩盖事实，但是永远无法掩盖潜意识之中的痛苦，如果想要分清痛和痛苦，这本书能给你指明一个方向。</p><h1 id="个人评价"><a href="#个人评价" class="headerlink" title="个人评价"></a>个人评价</h1><p>开头介绍心理咨询师是如何为咨询者提供建议的，它带你全方位的了解心理咨询师这个行业，然而奇怪是作为心理医疗师的主角却受到了另一位心理咨询师的拯救，这是穿插整本书的一个暗线，心理疾病对于我们每一个人来说的就像牙医无法治好自己的牙齿，我们总是会不自觉让别人或者利用网络给自己答案，看完这本书的一个个故事之后，你会发现心理咨询就像是双面镜一样，治疗的过程就是让一个陌生的“自己”来给自己答案，这种疗伤方式需要双向选择，但是这个世界同样没有圣人，就如身为主角的咨询师被男友抛弃而走向绝望甚至需要其他的心理咨询师开导，所以更让我吸引的是这个暗线故事的关于主角成长的心路历程。</p><h1 id="本书简介"><a href="#本书简介" class="headerlink" title="本书简介"></a>本书简介</h1><p>因为我是跳读的，这里直接拿网络的简介进行介绍了。</p><p>这是一位心理治疗师的回忆录，讲述了发生在诊室中的故事。在这个小小的密闭空间里，人们会展现出最真实、最脆弱的一面；也是在这里，人们获得了陪伴和倾听，也获得了宝贵的觉察、成长与改变。<br>在书中，我们会看到四个来访者的故事，他们是：<br>一个四十多岁、事业成功、自以为是，认为身边所有人都是蠢货的好莱坞制片人；<br>一个三十多岁、刚刚新婚就被诊断出患有绝症，时日不多的大学女教师；<br>一个六十九岁、离过三次婚，感觉孤独绝望，声称生活再不好转就要在七十岁生日当天自杀的老太太；<br>一个二十多岁、有原生家庭创伤和酗酒问题，在爱情中频频受挫的姑娘。<br>同时，书中还有第五个寻求帮助的人，那就是治疗师自己。她是一个单身的职场妈妈，四十多岁时遭遇失恋，几乎崩溃。有朋友对她说“或许你该找个人聊聊”，于是她也给自己找了一位心理治疗师。当她切换到来访者的位置，坐到另一位心理治疗师的沙发上诉说自己内心的脆弱与悲伤，就更能感受到心理治疗为何具有治愈和改变的力量。<br>这本书从治疗师和来访者的双重视角展现了心理治疗的过程，让我们发现：无论身份背景有多相异，人类面对的烦恼其实都相通——爱与被爱、遗憾、选择、控制、不确定、死亡，这些都是我们身而为人必须共同学习面对的议题。我们在现实生活中所遭遇的切肤之痛和生命困境，都能在这本书中得到共鸣、找到希望。</p><h1 id="心理咨询师是什么？"><a href="#心理咨询师是什么？" class="headerlink" title="心理咨询师是什么？"></a>心理咨询师是什么？</h1><p>他是可以让你放心并且诚实面对的人，心理咨询师接受来访者反复无常的举动。这个职业用来提供人们期望的某种标准答案的解答思路，就好像一个作业做不出来的学生找一个家长解答，但是这个家长并不认识并且可能是给很多学生做过解答，但是给每个人的答案相似却又不同。</p><p>另外人真的很难看透自己，心理咨询师更像是一个临时伙伴，是一个镜子来照亮受访者，他们为咨询者提供说出真相的勇气，在一个个案例中你会发现人其实与自己最难相处，我们时常会遇到内心壁垒，并且会逃避伤口转移注意力到不能将我们完全击溃的鸡毛蒜皮的小事上，越是痛苦也是掩盖真实，因为倾诉本身就是一件十分困难的事，我们需要语言和感受来开导自己，而疏导整个过程的角色担当则是心理咨询师。</p><h1 id="关注点"><a href="#关注点" class="headerlink" title="关注点"></a>关注点</h1><p>下面是个人认为本书值得思考的一些关注点：</p><ul><li>心理咨询师也是人，当他们遭遇痛苦的时候和普通人并无区别，每个人都怀揣渴望，不安甚至恐惧进行工作，同时把自己内心的伤痛掩盖，心理咨询师开导他人的同时，似乎也是在开导自己。</li><li>心理咨询师本身甚至需要接受一定时间的心理咨询和治疗才能拿到证书和证明。并且需要比他人更加关注自身心理健康。</li><li>我们很难想到人最难相处的其实是自己，甚至我们自己也会讨厌自己，所谓<strong>自我即地狱</strong>。</li><li>排除人性中的谎言和信息，努力中立的态度去看待受访者是心理咨询师的责任，但是来访者可常常是心理咨询师口中最不靠谱的人。</li></ul><h1 id="痛与痛苦"><a href="#痛与痛苦" class="headerlink" title="痛与痛苦"></a>痛与痛苦</h1><p>痛与痛苦是不一样的，这是普通人难以认清的现实，有时候我们会感觉到痛苦，但是感觉痛苦是我们自己的选择，有时候我们会寻找解药和答案来减轻自己的痛苦，甚至渴望人生存在某种标准答案，虽然他们确实可以帮我们缓解痛苦，但是我们依然需要直面内心的痛，事实是我们没有办法逃避痛苦并且只能承认他，诚实是困难的，因为诚实需要经历痛苦并且留下痛，但是我们的成长必然会付出代价。</p><p>我们是很难让感情保持中立的，所以需要关注的是自己不中立的感情，我们的感受不需要经过我们的自身预判，所以我们的潜意识会选择逃避痛苦，对于每一个人来说，自己或许是最没有办法真实描述真实感受的那个人。</p><h1 id="改变的步骤"><a href="#改变的步骤" class="headerlink" title="改变的步骤"></a>改变的步骤</h1><p>人的改变不是一蹴而就的，在书中提到了改变有五个步骤，他的过程如下：</p><ul><li>未准备阶段：我们有了改变的想法，却没有为改变做出任何切实的行动，这时候我们只是种下了改变的种子却没有发芽，另外未准备阶段最大的敌人是抗拒，我们抗拒走出原有的舒适圈，因为习惯是不需要我们经过思考而轻易实现的 。</li><li>犹豫阶段：受到了关键性的刺激，这个阶段好似在刺激与回应之间的游离阶段，这时候我们通过各种手段为改变或者不改变站队，就像后文提到的父亲的故事一样。</li><li>准备阶段：转变往往存在于刺激和回应之后，但是恐惧和焦虑是无法促使我们转变的，真正促使我们转变的是心态以及持续正向反馈。</li><li>行动阶段：行动是枯燥的，但是行动是能否完成改变的一切，最终我们将反复经历痛苦，留下心中新的“痛”，因为这好像是在过去的自己诀别。</li><li>完成阶段：当你回过头来会发现，<strong>一切的改变都是有迹可循</strong>。</li></ul><p>书中使用了一个因为迷恋渣男酗酒上瘾的女生如何戒酒为案例，当然让他做出决定性改变的不是因为他知道酒精的危害，而是因为受到了渣男的伤害，所以当她认清了酒精对于自己的改变是无济于事的，故事看起来挺老套的，但是很适合理解改变，有时候简单的故事能蕴含深刻的道理，就好像《小王子》一样，但是这需要高超的水平才能讲清。</p><h1 id="现在即未来"><a href="#现在即未来" class="headerlink" title="现在即未来"></a>现在即未来</h1><p>感受无论如何都会存在，同时感受不需要服从我们的预判，所以我们的大脑总是去思考未来的事情，未来和现在的关系十分奇妙，我们总是感叹时间过的太快，并且总是去恐慌未到的未来，实际上现在决定未来，请思考过去的你做了什么样的事情促使了现在的你？那么成就现在的你就是成就未来的你，然而实际情况是我们害怕做出改变，我们好像永远停留在未准备或者犹豫阶段，却很少付出行动去做出实际改变，这并不是我们不愿做出改变，而是我们的情感不愿意接受改变的自己，因为未来总是比现在更让人恐慌，但是一旦我们走在改变的道路，甚至于可能将自己的退路截断的时候才会真正的前进。但是这也大可不必，我们无法扼杀自己的情感做出决定，诚实告诉我们，现在就意味着未来，这是无法改变并且必须接受的现实，我们为何还需要继续选择接受痛苦？</p><p>为什么我们不愿意改变现在？因为我们总是在选择痛苦却忘记了痛。</p><h1 id="父亲"><a href="#父亲" class="headerlink" title="父亲"></a>父亲</h1><p>父亲的故事讲的作者对于父亲老去却不知道如何孝顺父亲，也不知道如何对待父亲的感到十分的纠结，最终在温德尔医生的开导下找到了未来应该如何转变心态。这个短暂的故事并没有什么出彩的地方，但是由一句主角引用的话让我共鸣：<strong>在刺激和回应之间有一个特殊空间，我们用自己的意志回应，我们的选择应该做出的回应包含成长和自由</strong>，这是一段挺抽象的话，其实可以用两个字简单概括：忏悔，用更加通俗的语言来说可以认为是懂事，释怀。</p><h2 id="懂事"><a href="#懂事" class="headerlink" title="懂事"></a>懂事</h2><p>作者对于父亲的依赖心理转变来自于她的回忆，在她记忆最深处是大学过于思念父亲，而父亲千里迢迢来到他宿舍对面长椅听她倾诉，由此随着他的增长十分害怕突然倒下却没有好好孝顺父亲，随着我们年龄的增长或多或少都有类似的感受，致使作者认清自己内心的转变是什么呢？其实是他听到最为刺激他的话：<strong>当你正睁开眼看那一刻，有一双眼睛将要闭上</strong>。</p><h2 id="释怀"><a href="#释怀" class="headerlink" title="释怀"></a>释怀</h2><p>在父亲这个故事的最后当作者澄清自己偷偷调查了温德尔医生的家庭背景并且坦白的时候，他在害怕被医生辱骂和讨厌以及和撒谎的平衡中选择真实面对自己的内心，然而当他将内心的阴暗面坦白的时候，却感觉放轻松了，仿佛放下了一个包袱在，在诚实和谎言的最后他选择了面对真相，但是当一切被和盘托出的时候无论结果如何获得的只有解脱。所以坦白虽然会让很多东西破碎，但是有时候坦白或许是最好的答案，显然作为心理咨询师的温德尔医生对于作者的好奇心尽可能的包容和理解。</p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>我们是否也有这样的时刻？个人印象最深的是在看到父亲弯腰的背影之后突然害怕有一天父亲直不起腰来，再看看书中关于刺激和回应的特殊空间的或许我那时的脑海就处在这样的特殊空间吧，成长和懂事的那一刻来的很突然，直到你去回忆才会发现原来自己转变了很多。</p><h2 id="更多的思考？"><a href="#更多的思考？" class="headerlink" title="更多的思考？"></a>更多的思考？</h2><ul><li>我们能回忆起多少在刺激和回应之间的瞬间，而这一转变好像突然脱胎换骨。</li><li>我们是否直面过自己的内心，而不是逃避。</li></ul><h2 id="解读前文"><a href="#解读前文" class="headerlink" title="解读前文"></a>解读前文</h2><p>其实结合前面的故事你会发现，主角对于父亲的依赖蕴含着主角心中的痛，作为一个单亲妈妈被害怕的莫过于被抛弃，主角害怕，所以当男友的背叛</p><h1 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h1><p>作者在开头阐述关于心理咨询师的作用，并且这本书穿插了许多案例介绍心理咨询师的相关工作，奇怪的是让他改变的一切契机居然是因为男友的背叛，他选择退出演艺生涯而选择学医的决心令人钦佩。</p><p>虽然作者遭到反对并且其中遭到各种质疑，但是作者最终还是成为一个心理咨询师，并且成为一个合格的作者，完成了用心理咨询师的身份促进自己的写作，而不是写作来促进心理咨询师的工作。从主视角看来，作者借这本书是想告诉读者，当我们对自己诚实的时候，就为我们做下改变的种子，一切都似乎水到渠成，如果看不清自己的时候，最好找一个镜子来照一照自己，找个人聊聊，但是这个人不能是你的亲人和朋友，也不能是和你三观完全不同的人，他们需要在理解你的同时给予你建议，而不是给予你关怀，这样的人就好似古人说的“听君一席话，胜读十年书”的人，然而现实中多数人遇到的还是“听君一席话，胜听一席话”的人。</p><p><strong>种下一棵树，最好十年前，其次是现在，不对，无论何时他都应该是现在。</strong>当主视角做出改变的时候，无论是好是坏，她最终还是逐渐奔向了自己渴望的生活，我们常人最难的不是改变，而是做出改变的想法。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇读书笔记并没有过多的讨论书中的故事，一方面是我是选择跳读的形式读完而不是完整的线性阅读，另一方面我认为这本书的精华藏在暗线的关于单亲妈妈的思想转变和对于父亲的讨论和对话中以及关于痛与痛苦这个话题的讨论，刺激和回应的契机帮助我们成长，但是过量的信息会阻碍我们思考。心理学是一个难以琢磨的东西，我们的觉醒没有一个统一标准，我们无法做出对自己诚实的决定，并且内心不断的否认让自己做出改变，<strong>我们实际上居然在享受痛苦的过程</strong>，人性的心理就是如此的矛盾，为什么我们总是渴望改变却又无法转变？我们可以从书中人物的对话和心理活动的细节发现人性往往存在共同点，似乎一切并不是巧合。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>改变往往发生在一瞬间，这既是巧合，却又不是巧合。诚实面对自己的内心，如果我们难以抉择和承受，或许真的该找个人聊聊。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      确实该找个人聊聊
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://whitestore.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="书籍" scheme="https://whitestore.top/tags/%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>《蛤蟆先生去看心理医生》 - 人生状态与人生坐标</title>
    <link href="https://whitestore.top/2022/03/16/random/"/>
    <id>https://whitestore.top/2022/03/16/random/</id>
    <published>2022-03-16T00:59:26.000Z</published>
    <updated>2022-06-02T10:09:44.802Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《蛤蟆先生去看心理医生》-人生状态与人生坐标"><a href="#《蛤蟆先生去看心理医生》-人生状态与人生坐标" class="headerlink" title="《蛤蟆先生去看心理医生》 - 人生状态与人生坐标"></a>《蛤蟆先生去看心理医生》 - 人生状态与人生坐标</h1><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20220315183443.png" alt=""></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>提示：在看本文前事先声明，本读书笔记涉及故事内容剧透，所以如果对于故事感兴趣建议直接从资源链接下载下来阅读。</p></blockquote><p>​    这本书是看了<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MDYxNTk2NzY4MTMxMDg4Mzk4" title="https://juejin.cn/post/7061596768131088398">《也许你该找个人聊聊》<i class="fa fa-external-link"></i></span>之后找到的同作者这本书，我一直觉得能把自己所学专业用故事来介绍有需要十分深厚的经验和写作本领，这本书封面挺有意思一只颓废的绿蛤蟆，看到垂头丧气的样子像极了焦虑时候的自己，在粗略了扫了部分页数之后，我对于蛤蟆先生的经历产生了兴趣。</p><p>​    蛤蟆先生的身世在旁人看来算是“生在罗马的蛤蟆”，家族产业能确保一生无忧，过的也是令人羡慕的生活，为啥这样的“人”会抑郁呢？作者又想通过这个故事告诉我们什么呢？整体故事看下来虽然有点艺术加工但是并不是完全脱离实际，当然普通人难免和鼹鼠一样难以理解这种“凡尔赛的烦恼”吧。</p><a id="more"></a><h1 id="资源地址"><a href="#资源地址" class="headerlink" title="资源地址"></a>资源地址</h1><p>​    链接: <span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMWJVbWZCYlVPc0ZUNkc0NE01LWhiNlE=" title="https://pan.baidu.com/s/1bUmfBbUOsFT6G44M5-hb6Q">https://pan.baidu.com/s/1bUmfBbUOsFT6G44M5-hb6Q<i class="fa fa-external-link"></i></span> 提取码: q0sc </p><blockquote><p>欢迎关注公众号“懒时小窝”获取更多读书笔记和好书资源，本书如失效可以回复“蛤蟆先生”获取。</p></blockquote><p><strong>【下面内容包含故事内容剧透，请谨慎阅读！】</strong></p><h1 id="知识索引"><a href="#知识索引" class="headerlink" title="知识索引"></a>知识索引</h1><p>​    这部分知识索引来自于这本书的内容或者来自于自我感悟：</p><ul><li>父母自我状态：因为“共谋”的配合，我们陷入了父母和儿子的环境当中。 — 人生状态</li><li>人生坐标是：“你好，我好，你不好，我不好”，如果用它画一个四象限，我们日常状态总是停留在“你好，我不好”的状态。 — 人生坐标</li><li>当恐惧来临时我们会让焦虑跑到意识里无法放松，我们会在心里拉响警报：大事不好啦！ — 第九次咨询</li><li>怄气是失败者对于成功者的最大表现，失败者总是渴望成功人跌落深渊并且踩上两脚。— 第五次咨询</li><li>“共谋”游戏是让自己的情绪配合别人演出，我们配合他人演出“失败者角色”，犹如适应型儿童  - “共谋”</li><li><strong>成年人最大的悲哀大概是失去惊奇，但是更大的悲哀是不自觉的重复“儿童状态”。 — 索引自《为什么长大》</strong></li></ul><h1 id="故事简介"><a href="#故事简介" class="headerlink" title="故事简介"></a>故事简介</h1><p>​    蛤蟆先生活在父母的期待中而逐渐抑郁，朋友惊讶于活泼的蛤蟆先生日渐萎靡，他们劝说蛤蟆先生进行心理咨询遭到反感和敌视，蛤蟆先生始终处于自己所处的生活并不是自己应得的心理状态，但是他找不出为什么自己会如此的烦恼和抑郁，并且过错归咎于朋友的苛责和可怜，在真正的朋友鼹鼠的再三的劝说下，蛤蟆先生找到了心理咨询师苍鹭，企图找到自己抑郁的真正原因，就此拉开了心理咨询的面纱。</p><p>​    故事参考自《抑林风声》的剧本，作者也在序里面进行了解释，感兴趣的小伙伴可以查阅进行了解。个人时间有限只看了书……</p><h1 id="个人评价"><a href="#个人评价" class="headerlink" title="个人评价"></a>个人评价</h1><p>​    我认为这本书有三个核心：<strong>心理咨询、儿童状态、人生坐标。</strong></p><p>​    故事讲述的是“奢侈的烦恼”，然而却常常见于日常的生活中，我们在面对某种特殊环境似乎永远处在某种“儿童状态”，比如在陌生的环境我们总是想起我们的父母，因为在小时候遇到陌生环境总是有父母的陪伴，我们不自觉的陷入念家和恐惧的状态，这本是人之常情但我们应当警惕无论父母有没有给予我们应有的教育，父母的言行对于我们人生的影响是不可磨灭的，我们的行为在未来的某一刻总是会“模仿”过往的“父母自我状态”，就好像我们劝说朋友的时候总是抱持“父母自我状态”化身朋友最亲的人去教导他，却全然不知这样总是有反效果。我们需要警惕过往思想和教育中所留下的糟粕。</p><p>​    作为一本只有100多页的书挺适合作为地铁读物，国内心理咨询这个专业包括本人在内的很多人其实也不了解，如果对于心理咨询有点儿兴趣，这本书无疑是人人都能读懂的启蒙书，本书无论是作者还是翻译都是心理咨询行业的专业人士，是翻译十分到位的外文书，不用担心看不懂或者理解存在偏差。</p><p>​    看这本书还有另一个很重要的理由那就是对于上次看了作者另一本书之后对于心理咨询这一块比较有兴趣，我们都知道心理咨询这个词汇在国内是很少被提及的，甚至是外行都很难看热闹，也常常被误解似乎只有抑郁症患者才需要心理咨询，其实只要认真看这本书相信会让读者豁然开朗。</p><h1 id="如何阅读？"><a href="#如何阅读？" class="headerlink" title="如何阅读？"></a>如何阅读？</h1><p>​    这本书很适合利用《如何阅读一本书》中提到的检视阅读的方式，所谓的检视阅读，就是吃透序，书名，目录，和“抽页”的方式对于一本你想看的书进行预习，了解一本书的全貌，这是主动式阅读的第一步，如果看完这些内容没有吸引你，说明这本书可能和你不合拍，但是如果你有了强烈的兴趣，需要的是读出这个故事的言外之意，并且分解故事的叙事结构和传递的思想。</p><p>​    对于只看一遍就能有很多收获的好书，个人建议按照章节的方式划分：<strong>第四章、第五章、第十四章、第十五章</strong>，这四个章代表了第一次和咨询师对话，蛤蟆先生为什么抑郁的核心（心理问题的根），蛤蟆先生倒数第二次醒悟，以及蛤蟆先生最后一次人生状态的转变的努力和心理咨询师的道别。在这四个章节任意挑选一段内容，都会让你对于蛤蟆先生的共鸣。</p><h2 id="思考和索引"><a href="#思考和索引" class="headerlink" title="思考和索引"></a>思考和索引</h2><p>​    关于思考的部分，这本书我们需要思考什么呢？ 如果想要应用“主动性阅读”，不妨用下面的几个问题作为引导，如果能回答这几个问题：</p><ul><li>阅读完成之后如何解读苍鹭的心理咨询过程？如何理解何为心理咨询？</li><li>蛤蟆先生如何从开朗到抑郁？如何从抑郁到开朗？也就是所谓的因果。</li><li>和苍鹭的十次对话发什么了什么？这10次蛤蟆先生的心理状态是如何转变的？</li><li>什么是儿童状态？什么是人生坐标？</li><li>第1次和第9次以及第10次蛤蟆先生所处的状态？</li></ul><p>​    接下来是索引的部分，索引的部分我们从10次的心理咨询开始，这里给出个人的思考索引：</p><p>​    第一次（认识到我病了）：为了自我解脱走出过往抑郁的心理状态，而不是为了给朋友答复让自己自然变好，观念的转变与“康复”的信心。</p><p>​    第二次（启蒙“儿童状态”）蛤蟆先生明白自己所处状态，能实践的理论才是好理论，了解心理咨询需要切换“老师/学生状态”，苍鹭第一次引出“儿童状态”的概念。</p><p>​    第三次（理解童年）：理解童年是理解自己的关键线索，处于儿童状态会有自然型和适应型，蛤蟆先生的抑郁根源是父母的过高期待压迫使蛤蟆先生极度的自卑和不自信。</p><p>​    第四次（抉择）：对于自己的童年，抉择顺从还是反抗和回顾自然。</p><p>​    第五次（失败者表现）：怄气是失败者对于成功者的最大表现。</p><p>​    第六次（共谋游戏）：“共谋”游戏是让自己的情绪配合别人演出，就像是“父母自我状态”，我们要扮演孩子。</p><p>​    第八次（过往真相）：关于人生坐标的概念以及如何从过往的真相中找到悲伤的真正原因。</p><p>​    第九次（传奇筒）：“传奇筒”游戏会把自己的情绪发泄给比自己地位低或者身边人，蛤蟆先生做出第一次改变，对于苍鹭发泄了内心的不满，同时建立了一种全新的关系。</p><p>​    第十次（应用和转变）：最终蛤蟆先生转变为“自然型儿童”，蛤蟆先生勇敢的表现自己的想法，用9分的“情绪温度计”推动自己越变越好。</p><p>​    其实和心理咨询师的会面远不止十次，但是在主线的十次咨询过程中能明显感知到蛤蟆先生不再把过错归咎于环境和外因，而是不断的深入探讨过往与家庭教育对于自己的影响。</p><h1 id="心理咨询"><a href="#心理咨询" class="headerlink" title="心理咨询"></a>心理咨询</h1><p>​    心理咨询可以归纳为下面几点：</p><ol><li>心理咨询是双向学习的过程。</li><li>心理咨询是试图打破“旧关系”建立“新关系”，这种“关系”通常是你变好。</li><li>心理咨询寻找的是“自救”的策略，而不是解决办法。</li></ol><p>​    首先讲讲这本书的其中一个重点，那就是心理咨询到底是什么？很多人或许都会抱有疑问心理疾病这种东西除了靠自己解脱之外还能有别的办法么？好像我们烦恼的时候更多靠的是自我痊愈，能自我痊愈意味着我们有较为强大的内心，但是始终有些事情是我们无法跨过的门槛，就像内心的疙瘩，比如童年受到的阴影和伤害，父母过高的期待与压力（表扬和批评），对于未来的迷茫和无知，如果我们找不到自我解放的出路，那么大概率会一直陷入抑郁和烦恼，以及无意义的意志力和情绪消耗，这时寻求咨询是一种有效的方式。</p><p>​    可惜的是心理咨询在国内是难以普及的，因为我们对于“医生”总是存在一种不信任感，这与我们童年所接受的深刻记忆有关，比如我们不愿意想象牙医拔牙的场景，我们不愿意看到自己打吊针的场景，这让我们有了恐惧和不自由感，长大后我们的嘴上说着无所谓，实际上却绝口不提甚至不愿回忆，当这样的情感不可调和的时候，我们需要一位心理导师来帮助我们踩下刹车。</p><p>​    所以心理咨询并不是帮你“安全驾驶”的人，而是为我们踩下刹车的人，问题依然需要我们自己去解决，但是我们会受到暗示和指导让自己逐渐变好。</p><p>​    最后心理咨询师给了咨询者尝试改变的勇气，斩断过去自己与他人的关联，定下走出过往环境的决定，在咨询者蜕变的时候便是心理咨询师和咨询者“一刀两断”的时刻。</p><h1 id="人生状态"><a href="#人生状态" class="headerlink" title="人生状态"></a>人生状态</h1><p>​    在“共谋”游戏中一方和另一方总是按照某种剧本扮演角色，我们做出的表现近似于表演，比如离家出走，失恋，考试考砸了，在这样的情景中会发现大部分人总是无意识的做出某些“儿童状态”反应，比如发脾气就离家出走，失恋了就出门找朋友喝酒，这种状态似乎让我们认为这是正确的状态，然而这些状态却都是我们“自适应”状态下的自然表现，我们不自觉的逃避了，并且在这样的状态下也总是不自觉的渴望事情自己变好。</p><p>​    在第九次的心理咨询中，蛤蟆先生做出了惊人的举动，通过心理咨询的引导发泄了自己对于心理咨询的种种不满，不满于咨询师总是过度的给他指示和安排，在这样的情景下蛤蟆先生第一次有了自己的主见，他选择了成为自然型的状态而不是为别人的期待做出反应，他不再扮演剧本的某一方角色，也是全书看来比较诧异也比较值得反思的地方。</p><h1 id="人生坐标"><a href="#人生坐标" class="headerlink" title="人生坐标"></a>人生坐标</h1><p>​    如果把我们的人生坐标用下面的形式表示我们处于哪一个阶段呢？我想普通人多数左上或者右下的两个象限中，而强者在第二象限，心术不正的在第三象限，而极少部分在第四象限，这个坐标也很好的说明了为什么蛤蟆先生的朋友们好心进入“父母自我状态”劝说蛤蟆先生却遭到反感了。</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20220315183344.png" alt=""></p><p>​    基于这样的人生坐标也能理解为什么不同的人对于愤怒会有完全不同的表现，为什么我们会做出与我们内心完全相反的行为，我们站在不同的人生坐标下看待问题，我们会有完全不同的解答，下面举一个案例来更纤细的阐述，比如<strong>如何对抗攀比心理？</strong></p><ul><li>你好我好：现在他拥有的，我将来也要拥有，并且我拥有之后要让更多的人也拥有。</li><li>你好我不好：现在他拥有，我可能拥有，但是我觉得几乎不可能有，所以我很羡慕比我好的人。</li><li>我好你不好：现在他没有但是我有，我有了之后不能让其他有，不然会让我很烦躁。</li><li>你不好我不好：为什么他会拥有呢？我希望大家都没有。</li></ul><p>​    用这个简单的例子，去评判一下过去自己处理某件事情的时候基本可以发现基本都会准确落到某一个。</p><p>​    这个人生坐标的现实意义是什么？如果看过《肖申克的救赎》这部电影，那么你大体会听到这么一句话：<strong>坚强的人拯救自己，伟大的人拯救他人。</strong>在进行权衡和考量的时候，需要事先想好自己抱持着什么样子的心理坐标。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>​    软件“自适应”是好事，做人自适应那就是最大的坏事了。</p><p>​    好久没更读书笔记了，今年读书的脚步会逐渐放缓，更多的是挑选针对适合自己当前状态的书籍，而不是一味的看读书推荐去读书，同时为了锻炼阅读能力，也会反复的结合《如何阅读一本书》去提升自己的阅读技巧。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      蛤蟆先生的身世在旁人看来算是“生在罗马的蛤蟆”
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://whitestore.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="书籍" scheme="https://whitestore.top/tags/%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>《海龟交易法则》读书笔记</title>
    <link href="https://whitestore.top/2022/02/20/haigui/"/>
    <id>https://whitestore.top/2022/02/20/haigui/</id>
    <published>2022-02-20T15:01:08.000Z</published>
    <updated>2022-06-02T10:09:44.784Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《海龟交易法则》读书笔记"><a href="#《海龟交易法则》读书笔记" class="headerlink" title="《海龟交易法则》读书笔记"></a>《海龟交易法则》读书笔记</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  同样是评论推荐的一本书，实际看了一下确实挺不错的，作者讲述了如何用系统分析进行投资，以及投资当中如何设置止损线，如何止盈等等，当然对于作者的图表法粗略看看就行，美丽国的股票和市场都是十分成熟，我们只需要学习如何应用“海龟交易法”以及如何培养投资属于自己的投资从策略则即可。</p><p>  另外，让作者走上投机道路的第一本书就是《股票作手回忆录》，由于十分崇拜利弗莫尔所以对于投机有了兴趣。这里也推荐读者看看这本书。</p><a id="more"></a><h1 id="推荐语"><a href="#推荐语" class="headerlink" title="推荐语"></a>推荐语</h1><p>  海龟交易法则是作者经过亲身经历之后一套投资系统法则，虽然按照现代的眼光来看已经十分过时了，但是这本书的重点不在于交易法则，而是在于作者对于市场的分析以及人的心理分析，这是值得每一个人学习内容，也是书中真正值得学习和了解的内容。</p><h1 id="资源链接"><a href="#资源链接" class="headerlink" title="资源链接"></a>资源链接</h1><blockquote><p>链接：<span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMXlPRlE3Y2RQbHM5S1FWdnc4S1dfS1E=" title="https://pan.baidu.com/s/1yOFQ7cdPls9KQVvw8KW_KQ">https://pan.baidu.com/s/1yOFQ7cdPls9KQVvw8KW_KQ<i class="fa fa-external-link"></i></span><br>提取码：4u54<br>–来自百度网盘超级会员V6的分享</p></blockquote><h1 id="个人评价"><a href="#个人评价" class="headerlink" title="个人评价"></a>个人评价</h1><p>​    投资的策略总是需要随机应变的，而拥有和掌握一套自己的投资策略也是十分有必要的，如果你和趋势做朋友，趋势会帮你带来财富，但是如果你没有坚守你的策略，趋势往往会朝你最不希望的方向发展，说服自己做正确的交易不难，但是说服自己坚定不移的在正确交易上坚持很难，一旦自己的投资超过了自己的风险抵抗，就要缩紧的钱包和开销，并且及时从错误的交易当中脱身。</p><p>​    《海龟交易法则》说的是一切的投资都要付出代价，作为一个投资者一定要有自己清晰的头脑。</p><h1 id="海龟交易法则"><a href="#海龟交易法则" class="headerlink" title="海龟交易法则"></a>海龟交易法则</h1><h2 id="原版海龟交易法则"><a href="#原版海龟交易法则" class="headerlink" title="原版海龟交易法则"></a>原版海龟交易法则</h2><p>  虽然海龟交易法则在现代已经完全不适用了，但是在思想上面还是非常具有参考价值的，另外，系统必须要时刻更新紧跟时代才不会失效，同时因为各种效应关系，一旦你的系统被人模仿或者参考，它将会逐渐失效。</p><p>  原版的海龟交易法则在书本的最后一节，如果觉得这本书讲的系统十分复杂和难以理解可以直接看书本的最后一章内容。</p><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><p>  海龟交易法则是根据一套理论为指导的投资方针，包含风险，时机，投资策略，退场策略，心理博弈，预期差异和系统分析等几个方面，目的是为了引导投资者作具备投资期望的交易。</p><h2 id="海龟培训要点"><a href="#海龟培训要点" class="headerlink" title="海龟培训要点"></a>海龟培训要点</h2><ol><li><p>掌握优势：寻找一个正期望值的策略</p></li><li><p>管理风险：一旦投资超过风险，立即止损</p></li><li><p>坚定不移：一旦确定自己的策略就坚定的执行，孤身作战</p></li><li><p>简单明了：抓住每一个趋势，趋势会是你的朋友</p></li></ol><h2 id="情绪陷阱"><a href="#情绪陷阱" class="headerlink" title="情绪陷阱"></a>情绪陷阱</h2><p>  在投资和交易的过程，人最容易受到下面的感情所影响，所有的市场交易都脱离不了下面这几点：</p><ul><li><p>希望：购买之后，立刻上涨</p></li><li><p>绝望：选择有误，一直在赔钱</p></li><li><p>贪心：赚翻了，我要加仓</p></li><li><p>恐惧：再也不碰了</p><p>人一旦陷入了情绪陷阱是很难脱离出来的，人类害怕的是未知以及预期落差，未知指的是将钱投入进去之后不知道市场的运行，而预期落差则是在事态朝着自己最不想看到的方向发展的时候出现。</p></li></ul><h2 id="非理性效应"><a href="#非理性效应" class="headerlink" title="非理性效应"></a>非理性效应</h2><p>  在《海龟交易法则》一本书中提到了各种效应的机制，下面这些效应是投资过程中需要小心如下的内容，这里个人的整体概括是非理性效应：</p><ul><li><p>损失厌恶：对于损失强烈厌恶，不赔钱比不赚钱更重要</p></li><li><p>沉默成本：更重视已经投入的，而不是未来投入的</p></li><li><p>处置效应：过早兑现收益但是过晚的止损</p></li><li><p>近期偏好：更重视近期数据，而不看历史的数据</p></li><li><p>潮流效应：跟风效应</p></li><li><p>信奉小数法则：从小道消息盖棺定论。</p></li></ul><h2 id="交易者，投机商，帽客"><a href="#交易者，投机商，帽客" class="headerlink" title="交易者，投机商，帽客"></a>交易者，投机商，帽客</h2><p>  “海龟交易时代”基本的角色就是交易者，投机商和帽客，当然这些都已经是历史了，但是了解下历史也挺有意思的。</p><p>  这三者其实是互相牵制的关系，虽然本质上都是在交易，但是所站的角度各不相同。书中讲的是期货交易，所以会存在多方，并且期货是存在做多和做空的，而股票则不行。</p><p>  交易者的角度是在对冲交易时候紧盯着汇率，让汇率在自己设想的角度浮动，所做的交易都是为了降低风险。</p><p>  而帽客则是希望汇差的波动，比如在战争的时期，通过汇率的快速变化赚保证金等等。</p><p>  投机者则是我们常见的投机交易，即买入做多，低买高卖，或者借贷买入，低价赎回，高贷低还。</p><h2 id="作者的实践"><a href="#作者的实践" class="headerlink" title="作者的实践"></a>作者的实践</h2><p>  令人讽刺的是在海龟的第一次模拟实战中受海龟交易法则培训的所有人当中只有作者坚持了海龟交易法则并且在合适的实际低点买入高点卖出，然而奇怪的是和作者一起上课学习海龟交易法则的同学都在交易的过程中都没有抵抗住心理上的博弈。</p><p>  从作者的个人感悟也可以看出，其实投机交易<strong>多数人是亏钱</strong>的，少数人可以“蹭”一点利益，并且如果没有天赋，多数人只能通过不断的学习和观察研究才能掌握到投资的技巧，当然和有天赋的人也是在不断的观察和思考中学习提高的，但是总的来说人和人上限是不一样的。</p><h2 id="海龟的投资方式"><a href="#海龟的投资方式" class="headerlink" title="海龟的投资方式"></a>海龟的投资方式</h2><p>  海龟的投资方式讲究的是趋势的交易，趋势的交易则非常的讲究时机，在时机不成熟的时候交易，不管怎么投入都是亏损，但是一旦根据趋势进行交易，则无论什么时候入场都是赚的，当然分析趋势是最难的一个点，并且一旦失去趋势要立刻止损。海龟交易的方式并不是在绝对“赚”的点上进行投入，甚至30天里面又20天是在亏钱，这时候能顶住压力的人才能最终赚钱。最后，<strong>如果顺应趋势，趋势将会是你的朋友</strong>。</p><h1 id="历史教训"><a href="#历史教训" class="headerlink" title="历史教训"></a>历史教训</h1><p>  需要注意的是永远不要妄想现在会和历史一模一样，但是现在的市场规律可以从过去察觉，因为正如几次金融危机一样人类总是在重复犯同样的错误，分析历史是十分重要的，一个合格的投资者要学会从历史教训和走势图中看到市场的变化规律。</p><p>​    虽然市场总是存在着不可知和变动性，但是从历史教训中预测出一个期望值为正的交易十分重要。</p><h1 id="风险控制"><a href="#风险控制" class="headerlink" title="风险控制"></a>风险控制</h1><p>  风险控制也是书中重要的一节内容，很多的投资者都是将钱投进市场开始祈祷，但市场的走向和他们的想法不符的时候，这时候恐惧和忧虑会代替大脑思考，此时人已经失去了基本的判断，听凭感情和自己的内心的臆测，所以设置一个风险的控制是很有必要的。</p><p>  风险控制意味着在自己亏损的时候毫无犹豫的跳出来， 一旦超过自己的风险控制范围不管市场如何利好，哪怕市场是一个正期望值的市场，此时也要尽快退出，因为一旦超过风险之后，理性的思考会被感性左右，和《股票做手回忆录》类似，在作者穷途末路的时候，自己无论又多少天赋和本领，也会被破产这两个字影响自己的情感判断。</p><p>  说服自己做正确投资比说服自己早早退出要容易太多。</p><h1 id="应用系统投资法则"><a href="#应用系统投资法则" class="headerlink" title="应用系统投资法则"></a>应用系统投资法则</h1><p>  作者在本书的后文使用了大量的系统和曲线分析法，比如支撑点和突破点等专业术语，个人认为单靠书中的寥寥几笔是不能完全说明的，并且内容也不是必须的，这里个人参考了更多的是关于作者对于投资者的心理分析入手，比如在什么时候应该静静等待，以及找到自己心理能承受的风险以及寻找失去趋势的时机，对于系统的分析一切分析都是建立在一套合理的投资机制和风险管理机制之下的。作者曾经也在一天之内亏损自己的所有财产并且没有任何的反应机会。所以市场有风险，入市须谨慎。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>  总之《海龟交易法则》这本书是一本读完绝对会有收获的书，这本书能帮你了解一个系统的投资规则，建立一份属于自己的投资策略以及风险控制策略是非常重要的，也是这本书所要传达的重点。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>  最近忙着写技术文，这篇读书笔记也拖了比较久….</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      海龟交易法则
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://whitestore.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="书籍" scheme="https://whitestore.top/tags/%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>《HowTomcatWork》笔记总结（一）</title>
    <link href="https://whitestore.top/2022/02/20/howtomcat/"/>
    <id>https://whitestore.top/2022/02/20/howtomcat/</id>
    <published>2022-02-20T14:49:55.000Z</published>
    <updated>2022-06-02T10:09:44.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《HowTomcatWork》笔记总结（一）"><a href="#《HowTomcatWork》笔记总结（一）" class="headerlink" title="《HowTomcatWork》笔记总结（一）"></a>《HowTomcatWork》笔记总结（一）</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    这一篇是howTomcatWork的书籍笔记内容。下面是根据书中的内容做的一部分个人笔记。</p><h1 id="书籍地址："><a href="#书籍地址：" class="headerlink" title="书籍地址："></a>书籍地址：</h1><blockquote><p>链接：<span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMWphem81NXNBX2hDUDlfMlFfMk5CclE=" title="https://pan.baidu.com/s/1jazo55sA_hCP9_2Q_2NBrQ">https://pan.baidu.com/s/1jazo55sA_hCP9_2Q_2NBrQ<i class="fa fa-external-link"></i></span><br>提取码：lp96<br>–来自百度网盘超级会员V6的分享</p></blockquote><h1 id="个人评价"><a href="#个人评价" class="headerlink" title="个人评价"></a>个人评价</h1><p>​    没啥好说的，tomcat作者写的书，看了下海淘居然要500多确实吓到了。虽然代码使用的是tomcat5的版本，但是可以基本理解tomcat的内部工作机制。也可以看到作者是如何用一个十多行的肉鸡服务器代码不断升级成为现在的tomcat的模样。</p><p>​    本文是个人根据看书记录的一些笔记，中间逻辑不一定连贯，因为有些内容过于基础没有记录的价值，所以挑了一些个人关注的点。</p><a id="more"></a><h1 id="一个最简单的Servlet是如何工作的"><a href="#一个最简单的Servlet是如何工作的" class="headerlink" title="一个最简单的Servlet是如何工作的"></a>一个最简单的Servlet是如何工作的</h1><ol><li>创建Request 对象，并且解析HTTP的请求信息，通过Request对象封装了这些信息的具体细节</li></ol><p>具体接口：</p><blockquote><p><code>javax.servlet.ServletRequest</code> 或<code>javax.servlet.http.ServletRequest</code></p></blockquote><ol start="2"><li>创建Response对象,封装了客户需需要的真正数据，封装了响应体的相关信息</li></ol><blockquote><p> <code>javax.servlet.ServletResponse</code> 或<code>javax.servlet.http.ServletResponse</code></p></blockquote><ol start="3"><li>servlet的<code>service</code> 方法，根据此方法对于请求头进行解析，同时创建response将数据回传给客户端</li></ol><h1 id="tomcat的基本结构"><a href="#tomcat的基本结构" class="headerlink" title="tomcat的基本结构"></a>tomcat的基本结构</h1><p>​    Tomcat把服务器在大体上可以拆分为两部分，一部分叫做<strong>容器</strong>，另一部分叫做<strong>连接器</strong></p><h2 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h2><p>作用：接收到每一个 HTTP 请求构造一个 ==request== 和 ==response== 对象</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>作用：接受连接器的请求根据<code>service</code>方法进行响应给对应的客户端</p><blockquote><p> Tomcat 4 和 和  5的主要区别</p><ul><li><p>Tomcat 5 支持 Servlet 2.4 和 JSP 2.0 规范，而 Tomcat 4 支持 Servlet 2.3 和 JSP 1.2。</p></li><li><p>比起 Tomcat 4，Tomcat 5 有一些更有效率的默认连接器。</p></li><li><p>Tomcat 5 共享一个后台处理线程，而 Tomcat 4 的组件都有属于自己的后台处理线程。<br>因此，就这一点而言，Tomcat 5 消耗较少的资源。</p></li><li><p>Tomcat 5 并不需要一个映射组件(mapper component)用于查找子组件，因此简化了代码。</p></li></ul></blockquote><h1 id="构建一个最简单的web程序"><a href="#构建一个最简单的web程序" class="headerlink" title="构建一个最简单的web程序"></a>构建一个最简单的web程序</h1><h2 id="构建对象"><a href="#构建对象" class="headerlink" title="构建对象"></a>构建对象</h2><p>​    下方的代码简单阅读即可，无需自己动手实验</p><h3 id="HttpServer"><a href="#HttpServer" class="headerlink" title="HttpServer"></a>HttpServer</h3><p> 用于构建一个服务器，同时建立serverSocket套接字等待链接</p><ul><li>调用<code>httprequest.parse()</code>方法</li></ul><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭容器的请求路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SHUTDOWN = <span class="string">"/SHUTDOWN"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态资源根路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String WEBROOT = System.getProperty(<span class="string">"user.dir"</span>) + File.separator + <span class="string">"webroot"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否关闭标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> SHUTDOWN_FLAG = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> HttpServer().await();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体的server 方法，等待socket请求</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 默认为8080端口</span></span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">8080</span>;</span><br><span class="line">        String host = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建套接字</span></span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(port, <span class="number">1</span>, InetAddress.getByName(<span class="string">"127.0.0.1"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.exit(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!SHUTDOWN_FLAG) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 等待套接字</span></span><br><span class="line">                Socket accept = serverSocket.accept();</span><br><span class="line">                HttpRequest httpRequest = <span class="keyword">new</span> HttpRequest(accept.getInputStream());</span><br><span class="line">                <span class="comment">// 处理请求数据</span></span><br><span class="line">                httpRequest.parse();</span><br><span class="line">                <span class="comment">// 创建响应对象，处理响应信息</span></span><br><span class="line">                HttpResponse httpResponse = <span class="keyword">new</span> HttpResponse(accept.getOutputStream());</span><br><span class="line">                <span class="comment">// 设置静态资源</span></span><br><span class="line">                httpResponse.setRequest(httpRequest);</span><br><span class="line">                httpResponse.setResource();</span><br><span class="line">                <span class="comment">// 关闭的套接字</span></span><br><span class="line">                accept.close();</span><br><span class="line">                <span class="comment">// 判断请求Url是否为 /shutdown</span></span><br><span class="line">                SHUTDOWN_FLAG = httpRequest.getUri().equalsIgnoreCase(SHUTDOWN);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HttpRequest"><a href="#HttpRequest" class="headerlink" title="HttpRequest"></a>HttpRequest</h3><p>​    以httpserver 的请求inputstream, 解析请求内容，分解请求uri</p><p>​    使用<code>parse()</code>方法解析请求信息，设置到stringbuffer里面</p><p>​    使用<code>parseUri(str)</code>截取请求信息的请求uri,设置到属性里面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpRequest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓冲区的大小为 1M</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER_COUNT = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String uri;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> InputStream inputStream;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpRequest</span><span class="params">(InputStream inputStream)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.inputStream = inputStream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析inputstream 对于内容进行解析</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 字符串缓冲池</span></span><br><span class="line">        StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer(BUFFER_COUNT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] byteBuffer = <span class="keyword">new</span> <span class="keyword">byte</span>[BUFFER_COUNT];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (inputStream == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.err.println(<span class="string">"未找到套接字"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> read = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 读取数据到byte数组</span></span><br><span class="line">            read = inputStream.read(byteBuffer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.exit(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读取byte数组的数据进入到stringbuffer</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; read; i++) &#123;</span><br><span class="line">            stringBuffer.append((<span class="keyword">char</span>)byteBuffer[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印stringbuffer</span></span><br><span class="line">        System.err.println(stringBuffer.toString());</span><br><span class="line">        <span class="comment">// 获取uri</span></span><br><span class="line">        uri = parseUri(stringBuffer.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析请求，获取请求Uri</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestString 需要处理的uri</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">parseUri</span><span class="params">(String requestString)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 建立index1 和 2</span></span><br><span class="line">        <span class="keyword">int</span> index1, index2;</span><br><span class="line">        <span class="comment">// 获取到第一个空行</span></span><br><span class="line">        index1 = requestString.indexOf(<span class="string">' '</span>);</span><br><span class="line">        <span class="keyword">if</span>(index1 != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 从index1 开始找</span></span><br><span class="line">            index2 = requestString.indexOf(<span class="string">' '</span>, index1 + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(index2 &gt; index1)&#123;</span><br><span class="line">                <span class="comment">// 获取请求路径</span></span><br><span class="line">                <span class="keyword">return</span> requestString.substring(index1 + <span class="number">1</span>, index2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUri</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uri;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HttpResonse"><a href="#HttpResonse" class="headerlink" title="HttpResonse"></a>HttpResonse</h3><p>​    以 httpserver 的请求outputstream ，获取输入流，将数据返回给客户端</p><p>​    关键方法为<code>setResouces</code>，获取请求Uri，同时使用file 读取文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpResponse</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 组合httprequest</span></span><br><span class="line"><span class="comment">     * 根据request返回对应到信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> HttpRequest request;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> OutputStream outputStream;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓冲区大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER_COUNT = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpResponse</span><span class="params">(OutputStream outputStream)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.outputStream = outputStream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置静态资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResource</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String errMsg = <span class="string">"404 msg"</span>;</span><br><span class="line">        <span class="comment">// 字节缓存区</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[BUFFER_COUNT];</span><br><span class="line">        <span class="comment">// 读取静态资源</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(HttpServer.WEBROOT, request.getUri());</span><br><span class="line">        <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">            <span class="comment">// 文件流</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">                <span class="comment">// 读取字节</span></span><br><span class="line">                <span class="keyword">int</span> ch = fileInputStream.read(bytes, <span class="number">0</span>, BUFFER_COUNT);</span><br><span class="line">                <span class="comment">// 输出</span></span><br><span class="line">                <span class="keyword">while</span> (ch != -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 写入流</span></span><br><span class="line">                    outputStream.write(bytes, <span class="number">0</span>, ch);</span><br><span class="line">                    <span class="comment">// 重复读取数据到缓冲区</span></span><br><span class="line">                    ch = fileInputStream.read(bytes, <span class="number">0</span>, BUFFER_COUNT);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (outputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    outputStream.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                outputStream.write(errMsg.getBytes());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (outputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    outputStream.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置request</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> httpRequest</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRequest</span><span class="params">(HttpRequest httpRequest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.request = httpRequest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基本步骤："><a href="#基本步骤：" class="headerlink" title="基本步骤："></a>基本步骤：</h2><p>下面是代码的基本交互步骤：</p><ol><li>创建httpserver 对象</li><li>绑定端口和主机，建立套接字连接</li><li><code>accept()</code>方法等待请求，阻塞当前线程</li><li>创建reuqest 请求对象</li><li>获取<code>inputstream</code>解析请求信息</li><li>获取请求到uri,设置到Request对象</li><li>创建 response 响应对象</li><li>设置响应对象的request，拿到uri, 同时使用Io，读取请求对应到文件</li><li><code>outputstream</code> 解析文件流数据，使用write 返回到客户端</li><li>无论成功还是失败，关闭流（重要）</li></ol><h2 id="补充内容："><a href="#补充内容：" class="headerlink" title="补充内容："></a>补充内容：</h2><p>​    这里重点关注关于套接字的一些知识</p><h3 id="ServerSocket"><a href="#ServerSocket" class="headerlink" title="ServerSocket"></a>ServerSocket</h3><p>​    服务器套接字的另一个重要的属性是 <strong>backlog</strong>，这是服务器套接字开始==拒绝==传入的请求之前，传入的连接请求的==最大队列长度==。</p><h3 id="parseUri-处理逻辑"><a href="#parseUri-处理逻辑" class="headerlink" title="parseUri() 处理逻辑"></a>parseUri() 处理逻辑</h3><p><code>GET /index.html HTTP/1.1</code>。parse 方法从传递给 Requst 对象的套接字的 InputStream 中读取整个字节流并在一个缓冲区中存储字节数组。然后它使用缓冲区字节数据的字节来填入一个 StringBuffer 对象，并且把代表 StringBuffer 的字符串传递给 parseUri 方法。</p><h2 id="Http请求对于servlet的操作"><a href="#Http请求对于servlet的操作" class="headerlink" title="Http请求对于servlet的操作"></a>Http请求对于servlet的操作</h2><p>​    当第一次调用 servlet 的时候，加载该 servlet 类并调用 servlet 的 init 方法(仅仅一次)。</p><ul><li>对每次请求，构造一个 javax.servlet.ServletRequest 实例和一个<br>javax.servlet.ServletResponse 实例。</li><li>调用 servlet 的 service 方法，同时传递 ServletRequest 和 ServletResponse 对象。</li><li>当 servlet 类被关闭的时候，调用 servlet 的 destroy 方法并卸载 servlet 类。<br>本章的第一个servlet容器不是全功能的。因此，她不能运行什么除了非常简单的servlet，<br>而且也不调用 servlet 的 init 方法和 destroy 方法。相反它做了下面的事情：</li><li>等待 HTTP 请求。</li><li>构造一个 ServletRequest 对象和一个 ServletResponse 对象。</li><li>假如该请求需要一个静态资源的话，调用 StaticResourceProcessor 实例的 process 方<br>法，同时传递 ServletRequest 和 ServletResponse 对象。</li><li>假如该请求需要一个 servlet 的话，加载 servlet 类并调用 servlet 的 service 方法，<br>同时传递 ServletRequest 和 ServletResponse 对象</li></ul><h2 id="StringManager"><a href="#StringManager" class="headerlink" title="StringManager"></a>StringManager</h2><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ol><li>使用单例模式</li><li>每个实例会读取包对应的一个属性文件</li><li>StringManager 类被设计成一个 StringManager实例可以被包里边的所有类共享</li><li>getManager() 方法被 同步修饰，并且使用hashtable对于manager进行管理（tomcat4）</li></ol><h3 id="核心方法解释"><a href="#核心方法解释" class="headerlink" title="核心方法解释"></a>核心方法解释</h3><p><strong>SocketInputStream</strong>：套接字读取流，主要用于处理Http请求中的各种参数，为了提高效率，使用懒加载特性读取</p><ol><li>回收检查流数据</li><li>检查空行，如果出现-1抛出结尾异常</li><li>获取servlet方法名称<ol><li>如果缓冲区已经满了，则进行扩展<ol><li>我们在内部缓冲区的尽头</li><li>如果到了缓冲区结尾，将指针归位</li></ol></li><li>这里有一个关键点：<strong>System.arraycopy</strong> 用来扩展缓冲区</li></ol></li><li>阅读协议</li></ol><h1 id="模块解释"><a href="#模块解释" class="headerlink" title="模块解释"></a>模块解释</h1><p>​    关于部分模块的相关解释。</p><h2 id="解析头部"><a href="#解析头部" class="headerlink" title="解析头部"></a>解析头部</h2><ul><li>你可以通过使用类的无参数构造方法构造一个 HttpHeader 实例。</li><li>一旦你拥有一个HttpHeader实例，你可以把它传递给SocketInputStream的readHeader<br>方法。假如这里有头部需要读取，readHeader 方法将会相应的填充 HttpHeader 对象。<br>假如再也没有头部需要读取了，HttpHeader实例的nameEnd和valueEnd字段将会置零。</li><li>为了获取头部的名称和值，使用下面的方法：</li><li>String name = new String(header.name, 0, header.nameEnd);</li><li>String value = new String(header.value, 0, header.valueEnd);</li></ul><h2 id="启动器"><a href="#启动器" class="headerlink" title="启动器"></a>启动器</h2><ul><li><p>启动应用程序</p></li><li><p>连接器</p></li><li><p>创建一个 HttpRequest 对象</p></li><li><p>创建一个 HttpResponse 对象</p></li><li><p>静态资源处理器和 servlet 处理器</p></li><li><p>运行应用程序</p></li></ul><p>startup 模块只有一个类，Bootstrap，用来启动应用的。connector 模块的类可以分为五组：</p><ul><li><p>连接器和它的支撑类(HttpConnector 和 HttpProcessor)。</p></li><li><p>指代 HTTP 请求的类(HttpRequest)和它的辅助类。</p></li><li><p>指代 HTTP 响应的类(HttpResponse)和它的辅助类。</p></li><li><p>Facade 类(HttpRequestFacade 和 HttpResponseFacade)。</p></li><li><p>Constant 类</p></li></ul><h1 id="问题以及解决"><a href="#问题以及解决" class="headerlink" title="问题以及解决"></a>问题以及解决</h1><p>​    如何避免在servlet调用连接器的时候，不需要请求参数可以避免掉getParamMap,getAttribute等昂贵开销的操作？</p><p>​    Tomcat 的默认连接器(和本章应用程序的连接器)试图不解析参数直到 servlet 真正需要它的时候，通过这样来获得更高效率</p><h1 id="小知识补充"><a href="#小知识补充" class="headerlink" title="小知识补充"></a>小知识补充</h1><ol><li>System 在打印的时候 print 方法不会刷新输出。</li><li>在一个 servlet 容器里边，一个类加载器可以找到 servlet 的地方被称为资源库(repository）。</li><li>通过外观模式将Request对象的细节隐藏，setvlet调用内部无法知道，但是在解析的时候依然可以相互通信，只需要使用faced将接口进行一层包裹， 即可保证getUri()方法安全性</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​    书中第一个章节内容比较简单，后续章节代码的难度会逐渐上升，同时使用了不少的设计模式也是需要多加阅读理解和消化的</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>​    这篇笔记目的是让更多人了解这本书，这本书算是一本神书，毕竟开发的原作者自己写的东西毫无疑问是一手知识了。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      笔记总结
    
    </summary>
    
    
      <category term="java" scheme="https://whitestore.top/categories/java/"/>
    
    
      <category term="java" scheme="https://whitestore.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM - Hotspot算法细节</title>
    <link href="https://whitestore.top/2022/02/20/hotpots/"/>
    <id>https://whitestore.top/2022/02/20/hotpots/</id>
    <published>2022-02-20T14:45:30.000Z</published>
    <updated>2022-06-02T10:09:44.907Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解JVM-Hotspot算法细节"><a href="#深入理解JVM-Hotspot算法细节" class="headerlink" title="深入理解JVM - Hotspot算法细节"></a>深入理解JVM - Hotspot算法细节</h1><p>[TOC]</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    这一节来专门讨论一下HotSpot的算法的细节内容，内容说难也不难，说容易也确实不容易，有很多要理解的内容，个人在做这次文章的时候对于hotpspot有了更深的理解。</p><h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p>​    如果懒得看文字，这里整理了一份思维导图帮助理解：</p><p>地址：<span class="exturl" data-url="aHR0cHM6Ly93d3cubXVidWNtLmNvbS9kb2MvMXFUSDc3WFNMTkI=" title="https://www.mubucm.com/doc/1qTH77XSLNB">https://www.mubucm.com/doc/1qTH77XSLNB<i class="fa fa-external-link"></i></span></p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20210809213943.png" alt=""></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ol><li>可达性算法的大致内容和简述，以及JAVA固定GC ROOT的判定条件</li><li>根节点枚举的实现细节，讲述什么事安全点和安全区域，以及他们的实际作用</li><li>记忆集和卡集，一个是抽象一个是具体实现，在内部通过写屏障来维持引用关系的改动，介绍关于伪共享问题的解决方案</li><li>并发可达性分析当中的三色标记是一个高频“考点”，以及Hotspot是如何应对对象消失问题的。</li></ol><a id="more"></a><h1 id="可达性算法"><a href="#可达性算法" class="headerlink" title="可达性算法"></a>可达性算法</h1><p>​    在介绍具体的内容之前，这里先补充一下基础内容：什么是可达性算法呢？简单来讲本质就是<strong>判断对象是否已死</strong>？一般实现的方式有下面这几种：</p><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>​    实现的方式和原理十分简单，同样也十分的高效，就是当为每一个对象绑定一个引用计数器，当对象存活，则引用计数器+1，引用失效，则计数器-1，虽然这个计数器要消耗一定的空间，但是确实是效率十分高的方式。当然他的缺点也十分明显，如果存在 <strong>循环引用</strong>，会导致对象永远不能判定为死亡。</p><blockquote><p>循环引用：A引用B，B引用C，C引用D，D引用A</p></blockquote><h2 id="JAVA固定作为GC-Root的判定条件"><a href="#JAVA固定作为GC-Root的判定条件" class="headerlink" title="JAVA固定作为GC Root的判定条件"></a>JAVA固定作为GC Root的判定条件</h2><p>​    这里单纯作为笔记进行记录：</p><ul><li><p>虚拟机栈引用的对象</p></li><li><p>方法区的<strong>静态属性引用对象</strong>，也就是<code>static</code>对象属性</p></li><li><p>方法区的常量引用，比如<code>final</code>引用的静态常量</p></li><li><p>本地方法栈的JNI，即Native方法引用对象</p></li><li><p>虚拟机内部的，基本类型对应的Class对象，常驻异常对象Null…等</p></li><li><p><strong>同步锁（Syncronized）持有对象</strong></p></li></ul><h1 id="根节点枚举"><a href="#根节点枚举" class="headerlink" title="根节点枚举"></a>根节点枚举</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>​    在可达性算法当中是通过GC ROOT的引用找到存活对象的方式，在现代的收集器基本可以做到和用户线程一起并发执行的程度，但是根节点枚举要保证某个时间点的“快照”，这也意味着根节点枚举需要<strong>暂停用户线程</strong>。</p><h2 id="OopMap数据结构"><a href="#OopMap数据结构" class="headerlink" title="OopMap数据结构"></a>OopMap数据结构</h2><p>​    在HotSpot中使用的是<strong>OopMap</strong>的结构，用于存储对象的类型，或者存储特定位置记录栈里面的寄存器哪些位置是引用，垃圾收集器扫描的时候就可以直接从对应的位置开始，不需要大范围的扫描动作。</p><h3 id="这种结构会存在哪些问题？"><a href="#这种结构会存在哪些问题？" class="headerlink" title="这种结构会存在哪些问题？"></a>这种结构会存在哪些问题？</h3><p>​    这里可以看到，如果每一次对象的读取变化，都需要往OopMap里面存储内容，会导致OopMap的内容不断臃肿扩大，垃圾收集器的扫描成本会变得非常的昂贵。</p><p>​    为了应对这一类问题，HotSpot引入了“安全点这一机制进行处理”</p><h2 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h2><p>​    OopMap不会在任意的位置都收集相关的指令，而是使用一个安全点的东西，这个安全点用通俗的话理解就是高速上的“收费点”，而设置安全点的条件是：<strong>是否具备程序长时间运行特征</strong>。</p><h3 id="安全点有什么用？"><a href="#安全点有什么用？" class="headerlink" title="安全点有什么用？"></a>安全点有什么用？</h3><p>​    毫无疑问，安全点是为了减轻OopMap存储结构的压力，同时保证垃圾回收的时候不需要扫描过多的GC ROOT。</p><blockquote><p>缺点：这也决定了JVM虚拟机不能在任意的位置进行垃圾收集，而是要进入预先设定的“收费站”进行垃圾回收</p></blockquote><h3 id="如何触发安全点"><a href="#如何触发安全点" class="headerlink" title="如何触发安全点?"></a>如何触发安全点?</h3><p>​    实现方式有两种：<strong>抢断式中断</strong>和主动式中断</p><p>​    需要注意的是现代已经没有虚拟机使用“抢先式中断”暂停线程来响应GC事件，也就意味着垃圾收集的行为都是<strong>虚拟机主动执行</strong>的，而不是通过争抢的方式处理。</p><p>​    安全点采用主动式中断，当垃圾收集器需要中断线程，会预先设置标志，并且各个线程会轮询标志位，一旦到达安全点附近就中断挂起（有点像检查站通知检查）为了保证运行的高效性，JVM将使用 <strong>内存保护陷阱</strong>的方式进行自陷中断，并且这条汇编指令精简为一条，可以大大提高轮询的效率。当线程收到自陷信号，就自然会触发线程中断了。</p><p>​    但是这里是存在问题的，如果线程本身存在阻塞等待，或者睡眠的情况下，安全点不可能一直等待线程中断，所以这里又引入了安全区域的概念</p><h2 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h2><p>​    安全区域的主要作用是确保安全点一段的时间内，引用的关系不发生改变，为了完成判断，他做了下面的事情：</p><ul><li>判断当前线程是否进入了安全区域，如果进入了进行下面的判断<ul><li>如果没有完成根节点枚举，则需要等待完成根节点枚举才能放行</li><li>如果已经完成根节点枚举，则会直接放行线程。</li></ul></li></ul><blockquote><p>这里你可以想象在高速上等待出站，在这个区间内你要完成节点的根枚举操作才准许放行</p></blockquote><h1 id="记忆集与卡表"><a href="#记忆集与卡表" class="headerlink" title="记忆集与卡表"></a>记忆集与卡表</h1><p>​    在了解这两个名词之前，我们需要记住 他们的目的是<strong>解决对象跨代引用的问题</strong>，在传统的分代系统中，存在老年代引用新生代之间的相互引用，那么JVM是如何判断哪些对象引用是失效，哪些对象引用需要存活保留呢？</p><p>​    </p><h2 id="记忆集-RememberedSet"><a href="#记忆集-RememberedSet" class="headerlink" title="记忆集(RememberedSet)"></a>记忆集(RememberedSet)</h2><p>​    首先来看下<strong>记忆集（RememberedSet）</strong>是什么东西，在源代码的结构中他被声明为一个<code>Object[]</code>的数组结构，可以看到维护这种结构的代价是十分高昂的，所以为了节省记忆集的维护成本，存在如下的解决方案：</p><ul><li>字长精度：精确到机器字长（处理器的寻址位数）</li><li>对象精度：顾名思义，精确到一个对象</li><li>卡精度：精确到一块内存区域，实现最简单的方式是一个字节数组</li></ul><h3 id="卡表"><a href="#卡表" class="headerlink" title="卡表"></a>卡表</h3><p>​    注意卡表是记忆集的一种实现方式，切忌和记忆集混为一谈，他们的关系和方法区以及永久代或者元空间的关系类似，是一种 <strong>抽象与实现</strong>的关系。</p><p>​    既然卡精度是针对一块内存区域，而JVM刚好又是采用了固定分代来完成垃圾回收的，所以毫无疑问使用的是卡精度来实现。</p><p>​    HotSpot使用的卡精度实现恰好也是使用一个字节数组来完成，卡页是2个N次幂数，最终使用的是2的9次方也就是<strong>512长度</strong>的字节数组来构建一个卡表。</p><p><strong>如何操作</strong>？</p><p>​    HotSpot检测到对象存在跨代指针的时候，就会把数组的标志为1，没有就会标志位0，这个过程称为<strong>“变脏”</strong>，如果垃圾收集器开启并且扫描到当前的元素变脏，聚会放入到GC ROOT当中进行扫描。</p><p>​    </p><h2 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h2><blockquote><p>后续的内容，请在心里记住如下的问题：</p><ol><li>卡表如何维护？</li><li>写屏障的伪共享问题</li><li>谁来让元素变脏</li><li>什么是写屏障</li><li>如何维护整个卡表</li></ol></blockquote><p><strong>定义</strong>：</p><p>​    我们知道了卡表如何定义，并且如何进行判断的，但是我们还不清楚卡表是如何进行维护的，那么什么是写屏障呢？写屏障可以认为是虚拟机层面<strong>对于“引用字段类型”的AOP的切面</strong>，写屏障还分为<strong>写前屏障</strong>和<strong>写后屏障</strong>。这里后续在进行讨论。</p><p><strong>作用</strong>：</p><p>​    写屏障的作用是：<strong>维护卡表以及让卡表变脏</strong>，并且把维护卡表的操作放置到每一次赋值操作当中。</p><p>​    那么他是如何做到的呢，我们上一小节讲了HotSpot通过卡表变脏实现跨代引用和GC ROOT的判断。那么写屏障的作用就是在赋值的操作之前完成卡表的维护。</p><p><strong>总结：</strong></p><ol><li>卡表如何维护？使用写屏障进行维护</li><li>谁来让元素变脏？在写屏障中通过AOP的切面在赋值操作中通过指令完成</li><li>什么是写屏障？赋值操作的AOP切面</li><li>如何维护整个卡表？OopMap和写屏障</li></ol><blockquote><p>这里肯定会有疑问，在赋值操作之前加入写屏障会不会有性能问题？</p><p>​    JVM设计团队是肯定考虑过这个问题的，最终的结果是虽然要消耗一定的赋值操作效率和性能，但是和频繁的Minor GC相比代价还是要小很多的。</p></blockquote><h3 id="写前和写后屏障是什么？"><a href="#写前和写后屏障是什么？" class="headerlink" title="写前和写后屏障是什么？"></a>写前和写后屏障是什么？</h3><p>​    其实就是在赋值操作的AOP切面的前面或者后面操作，也就是通常AOP环绕前面的前置操作和后置操作，伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">doSomethingFront(); <span class="comment">//写前屏障</span></span><br><span class="line">proxy.proxy();</span><br><span class="line">doSomethingAfter(); <span class="comment">//写后屏障</span></span><br></pre></td></tr></table></figure><p>​    另外再提一点，<strong>CMS使用了写后屏障</strong>，而<strong>G1既使用了写前屏障，又使用了写后屏障</strong>。</p><h3 id="伪共享问题"><a href="#伪共享问题" class="headerlink" title="伪共享问题"></a>伪共享问题</h3><p>​    什么是伪共享？在处理底层并发的时候需要考虑的问题，由于现代处理器因为缓存等问题，指令其实是打乱之后执行的，如果多个变量共享一个缓存行，他们就会彼此之间发生影响。</p><p><strong>解决办法</strong>：</p><p>​    解决办法比较简单的一种是 <strong>检查卡表标记，只有卡表元素检查之后才会让元素发生变脏</strong>，当然这样又会损失一定的性能，但是是可以接受的。针对这一点JDK7增加了一个：<code>+UseCondCardMark</code>参数来控制表更新元素的条件。</p><h1 id="并发可达性分析："><a href="#并发可达性分析：" class="headerlink" title="并发可达性分析："></a>并发可达性分析：</h1><p>​    通过上面的分析，我们了解了JVM是如何实现对象之间的引用存放，以及如何实现GC ROOT以及如何让线程等待垃圾收集等一系列问题，下面我们来看下更细节的部分，我们都知道对象的引用不是一成不变的，比如在GC ROOT之前对象引用突然失效，垃圾对象突然变为存活对象….这些情况都是有可能的，那么面对复杂多变的 引用关系变化HotSpot是如何解决这个复杂的问题的呢？</p><p>​    要解决这个问题的关键<strong>如何保证“一致性快照”</strong>，针对这一点，HotSpot虚拟机使用了“三色标记”这一个重要的概念。</p><h2 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h2><p>​    为了维护一个对象的访问状态，在遍历对象过程中，Hotspot会将对象标记为下面的三种状态：</p><ul><li>白色：表示尚未被垃圾收集器访问过</li><li>黑色：表示对象已经被垃圾收集器访问过，并且 <strong>所有的引用都扫描过</strong>，意味着他不可能直接指向某个白色对象</li><li>灰色（重点）：表示已经被垃圾收集器访问过，至少有一个引用没有被扫描完。</li></ul><h2 id="“对象消失”的成立条件"><a href="#“对象消失”的成立条件" class="headerlink" title="“对象消失”的成立条件"></a>“对象消失”的成立条件</h2><p>​    在书本165页左右（个人看的是PDF）有一张示意图，这里简要说明一下“对象消失”的问题：</p><ul><li>垃圾变为存活对象：被切断的引用灰色对象即将变为白色对象经过并发线程修改和黑色对象产生引用。</li><li>存活对象变垃圾：被标记为白色的对象突然与扫描过的黑色对象产生引用。</li></ul><p>​    这里有个不能容忍的问题是原本存活的对象被标记为死亡。会直接导致系统出现委托，这是不能容忍的。</p><p>​    有大神总结了会出现对象消失问题的两个条件，只要排除<strong>任意一个</strong>就可以防止对象消失的问题：</p><ol><li><strong>赋值插入一条或者多条从黑色对象到白色对象的新引用</strong></li><li><strong>赋值删除了全部从灰色对象到白色对象的直接或者间接引用。</strong></li></ol><h2 id="增量更新和原始快照"><a href="#增量更新和原始快照" class="headerlink" title="增量更新和原始快照"></a>增量更新和原始快照</h2><p>​    解决上面的问题，JVM有两种方式，分别是“增量更新”和“原始快照”，增量更新是排除第一个条件，原始快照排除第二个条件。</p><p>​    <strong>增量更新</strong>：记录下黑色引用插入到白色对象的引用关系，并发标记结束之后以记录过的引用对象为根<strong>重新扫描</strong>。CMS的“重新标记”阶段的底层就是在做这个事情。</p><p>​    <strong>原始快照</strong>：原始快照指的是灰色对象删除白色引用的时候，把要删除的引用记录下来，并发扫描之后，再根据记录过引用关系的灰色对象为根进行扫描。G1和Shenandoah 收集器就是使用这种方式实现的。</p><p>​    这里的简化理解就是，<strong>增量更新是尝试将白色对象变为灰色对象，而原始快照则是让灰色对象真的变回白色对象</strong></p><p>​    </p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>​    HotSpot的细节包括三个难点，一个是根节点枚举，我们讲述了底层结构OopMap，可以看到他本质就是一个数组，之后我们讲到了安全点的设计类似收费站检查的方式提高根节点枚举的效率，接着我们讲述了安全区域，好比收费出站，对于没有进行过根节点枚举的就会阻塞等待进行处理，这些设计的根本目的是<strong>保证垃圾收集器停顿用户线程的时候拥有一份不会改变引用的快照</strong>。</p><p>​    接着我们讲述了抽象的记忆集以及Hotspot的实现卡表这一结构，卡表的作用是保存对象的引用关系以及跨代引用等，而修改和维护的工作则是由写屏障完成，写屏障的任务是在赋值操作的前后对于卡表里面的对应引用进行调整，保证对象可以正确归类为垃圾对象和存活对象。</p><p>​    最后，我们讲述了并发修改的时候，Hotspot如何保证快照的正确性以及防止用户线程并发修改”篡改”对象的状态，首先是使用三色标记，将对象标记为垃圾对象，未扫描完成的对象，和已扫描完成的对象，同时为了对抗对象消失的问题，提出了“原始快照”和“增量更新”的解决方案。</p><p>​    </p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>​    写稿不易，求赞，求收藏。本文有大量的文字说明，建议收藏慢慢看。</p><p>​    最后推荐一下个人的微信公众号：<strong>“懒时小窝</strong>”。有什么问题可以通过公众号私信和我交流，当然评论的问题看到的也会第一时间解答。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      jvm收集器算法细节处理
    
    </summary>
    
    
      <category term="java-jvm" scheme="https://whitestore.top/categories/java-jvm/"/>
    
    
      <category term="jvm" scheme="https://whitestore.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>深入理解jvm - 编译优化（上）</title>
    <link href="https://whitestore.top/2022/02/20/bianyijvm/"/>
    <id>https://whitestore.top/2022/02/20/bianyijvm/</id>
    <published>2022-02-20T14:25:01.000Z</published>
    <updated>2022-06-02T10:09:44.937Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  编译优化的内容还是不少的，当然主要的内容集中在后端的编译上面，为了控制篇幅的长度所以这里选择拆分为上下两部分讲解，我们平时写的代码和实际运行时候的代码效果是完全不一样的，了解编译优化的细节是有必要的。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ol><li>了解javac的基本编译过程以及基本的处理细节</li><li>了解基本的前端优化手段：语法糖和泛型的实现</li><li>了解前后端编译的内容以及部分后端编译的内容。</li></ol><a id="more"></a><h1 id="Javac的编译过程"><a href="#Javac的编译过程" class="headerlink" title="Javac的编译过程"></a>Javac的编译过程</h1><p>  javac的工程代码并不属于java se api的一部分，同时由于jdk9的版本之后模块化被单独分离出来了，书中使用了jdk9的版本来讲解关于javac的编译过程。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>  包所在的位置（jdk9）：JDK_SRC_HOM E/src/jdk.comp iler/share/classes/com/sun/tools/javac</p><p>  如果需要搭建一个javac的工程只要新建一个工程并且把下面路径的内容复制到工程的下面即可。</p><blockquote><p> J D K _ SR C _ H O M E / l a n gt o o l s / s r c / s h a r e / c l a s s e s / c o m / s u n / * </p></blockquote><p>  拷贝完成之后，一个支持javac命令的工程就搭建好了</p><h2 id="javac的编译步骤"><a href="#javac的编译步骤" class="headerlink" title="javac的编译步骤"></a>javac的编译步骤</h2><p>  关于javac的编译步骤基本如下，需要注意的是这里包含了jdk5版本中的注解处理器的内容：</p><ol><li><p>准备：初始化插入式注解处理器</p></li><li><p>解析和填充符号表过程</p><ol><li><p>词法分析</p></li><li><p>填充符号表</p></li></ol></li><li><p>插入式注解处理器处理过程：</p><ol><li>插入式注解处理器的执行阶段</li></ol></li><li><p>分析与字节码生成（语法分析是IDE常用部分）</p><ol><li><p>标注检查（数据分析，常量折叠优化）</p></li><li><p>数据流和数据分析（上下文语义分析检查）</p></li><li><p>解语法糖（由desagrc 方法触发）</p></li><li><p>字节码生成</p></li></ol><p>下面是书中对于整个编译过程的一张图表演示，可以看到顺序不是固定的，而是会存在更换顺序的情况：</p></li></ol><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20210823072723.png" alt=""></p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20210823134454.png" alt=""></p><h1 id="前端优化"><a href="#前端优化" class="headerlink" title="前端优化"></a>前端优化</h1><h2 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h2><p>  注解处理器的步骤是在jdk5当中新增的内容，在Javac源码中，插入式注解处理器的初始化过程是在initPorcessAnnotations()方法中完成的，而它 的执行过程则是在processAnnotations()方法中完成。这个方法会判断是否还有新的注解处理器需要执 行 ， 如 果 有 的 话 ， 通 过 c o m . s u n . t o o l s . j a v a c . p r o c e s s i n g. J a v a c P r o c e s s i n g- E n v i r o n m e n t 类 的 d o P r o c e s s i n g( ) 方 法 来生成一个新的JavaComp iler对象，对编译的后续步骤进行处理。</p><h2 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h2><p>  java 在升级的过程中引入了很多的语法糖写法， 比如jdk5的增强for循环和泛型，jdk7的泛型菱形标记和try-catch-resource，jdk8的lambada表达式等，这些语法糖对于jdk的易用性给予了很多支持。这里挑几个重点的升级进行描述：</p><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>  泛型的启发来源于pizza的后身scala语言的作者Martin Odersky，当他捣鼓出泛型这个东西 之后，立马被java官方邀请开发java的泛型，可怜的Martin Odersky受制于java的语法限制以及向后兼容的特性，最后做出来的成果反而更加类似C#的泛型（挺讽刺的），最终的结果就到了现在java官方还在背着这个技术偷懒的债。</p><p>  扯远了，泛型相信所有的java开发者都很熟悉了，这里不再进行单独介绍。通常情况下实现泛型有下面的两种办法：</p><ul><li><p>泛化类型以前保持不变，平行加入泛化新类型</p></li><li><p>已有类型泛型化，不加入任何泛型类型。</p><p>java使用的是第二种方式，原因无他，只是因为偷懒而已，在当时如果有更多时间讨论的话选择第一种是更好的选择也会有更多的解决方案，下面来简单了解一下泛型的基本特征以及需要实现的内容：</p><h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3></li></ul><p>​    首先，java引入了类型擦除的机制，java的泛型在初始阶段叫做裸类型（父类型），裸类型可以看作是jdk5之前的类型即不带尖括号的类型，在实现裸类型上面有两种实现方式：</p><ul><li>由虚拟机进行真正的构造</li><li>编译时还原，在元素访问的时候类型强转。</li></ul><p>没错，java实现的方式也是使用了第二种方式，强转的实现相比 第一种方法要简单很多，但是也会带来下面的问题：</p><ul><li>原始类型的支持变麻烦，java 用自动的类型转换替代直接导致了自动拆装箱的时候效率十分的低下</li><li>在运行阶段无法读取到泛型的类型，java的泛型只能算是一个“伪造”泛型。</li></ul><p>泛型的擦除机制决定了java的泛型支持更多的是服务于编译器。</p><blockquote><p>注意：1. 擦除只是code字节码擦除。2. 元数据保留擦除前的信息。</p></blockquote><h3 id="泛化后的属性"><a href="#泛化后的属性" class="headerlink" title="泛化后的属性"></a>泛化后的属性</h3><p>Sinature属性：：存储的是方法在字节码层面的特殊签名，属性中保存参数化的类型信息而不是原始的类型，</p><p>值类型的支持：值类型也称之为valueType也就是可以定义基础数据类型的类型。</p><h2 id="条件编译的实现"><a href="#条件编译的实现" class="headerlink" title="条件编译的实现"></a>条件编译的实现</h2><p>​    条件编译可以简单理解为通过if语句这个指令进行实现，java天生不支持条件编译，但是C和C++里面却是可以完成的。</p><p>​    Java语言中条件编译的实现，也是Java语言的一颗语法糖，根据布尔常量值的真假，编译器将会把 分支中不成立的代码块消除掉，这一工作将在编译器解除语法糖阶段(com.sun.tools.javac.comp .Lower 类中)完成。</p><p>​    最后条件编译上有个历史事件就是之前所说的<strong>Shenandoah</strong>收集器被jdk官方用条件编译给抹除，导致这款收集器不被商用jdk支持，也只能在openJDK上面使用。</p><p>  通过上面的内容学习和了解，可以发现前端的编译作用是比较小的，可以算是是语法糖的一部分，而后端优化就没有那么简单了，下面我们来看下后端优化是如何实现的。</p><h1 id="后端优化"><a href="#后端优化" class="headerlink" title="后端优化"></a>后端优化</h1><h2 id="即时编译器"><a href="#即时编译器" class="headerlink" title="即时编译器"></a>即时编译器</h2><p>  即使编译器的重要地位自不用说，到现在还是主流编译器的Hotspot就可以说明即时编译器的重要性，而Hotspot里面一项重要的优化就是即使编译器，在了解即时编译器之前，我们需要弄清楚下面的问题：</p><ul><li><p>为什么解释器和即时编译器并存</p></li><li><p>为什么要多个编译器</p></li><li><p>什么时候用解释器，什么时候用即时编译器</p></li><li><p>哪些代码为本地代码，如何编译</p></li><li><p>外部如何观察结果</p><p>通过解决上面的问题，我们就可以大致了解即时编译的核心内容。</p><blockquote><p>即时编译的方式：面向方法而不是面向局部代码，这种方法在字节码序列号替换的方式被称为栈上替换，方法还在栈桢的时候被编译器进行隐式替换。</p></blockquote></li></ul><h3 id="为什么会并存解释器和编译器？"><a href="#为什么会并存解释器和编译器？" class="headerlink" title="为什么会并存解释器和编译器？"></a>为什么会并存解释器和编译器？</h3><p>  并不是所有的即时编译器都是用的解释器和编译器并存的模式，但是目前主流的的几款产品中基本都存在这种共存的运行模式，他有什么作用呢？首先，它可以作为一个逃生门，在通常的情况下保持正常的配合操作，但是一旦编译器忙不过来的时候或者本地代码过多的情况下，就可以使用解释器“兜底”，可以保证任何情况下总是可以正常的运行代码。正所谓男女搭配，干活不累。</p><h3 id="为什么有多个呢？"><a href="#为什么有多个呢？" class="headerlink" title="为什么有多个呢？"></a>为什么有多个呢？</h3><p>  在Hotspot的编译器下有两个编译器：</p><ul><li><p>C1:客户端编译器：效率高，非常快，但是质量一般</p></li><li><p>C2:服务端编译器：质量高但是效率要低一些</p><p>编译器为什么不止一个还有多个，这又是有关历史的话题，在早期的工作模式下面，解释器会根据服务器的资源以及用户指定的匹配前端编译器处理来提高效率，所以存在多个也是可以理解的。</p></li></ul><h3 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a>分层编译</h3><p>  我们不再需要了解以前的工作原理，而是要了解jdk7之后彻底实现的分层编译手段：</p><ol><li><p><strong>纯解释器模式：第一层</strong></p></li><li><p><strong>客户端编译器执行，开启部分监控：第二层</strong></p></li><li><p><strong>客户端编译器执行，开启完整监控：第三层</strong></p></li><li><p><strong>服务端编译为本地代码：第四层</strong></p><p>当然上面的步骤不是完全固定的，根据实际情况会做顺序的调整，下面是书中给出的一张图：</p></li></ol><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20210823134454.png" alt="分层编译"></p><h2 id="热点代码探测"><a href="#热点代码探测" class="headerlink" title="热点代码探测"></a>热点代码探测</h2><p>  热点探测有两种方式：基于采样的热点探测(Sample Based Hot Spot Code Detection)和基于计数器的热点探测(Counter Based Hot Spot Code Detection)，在HotSpot虚拟机中使用的是第二种基于计数器的热点探测方法，为了实现热点计数，HotSpot为每个方法准备了 两类计数器:方法调用计数器(Invocation Counter)和回边计数器(Back Edge Counter，“回边”的意思 就是指在循环边界往回跳转)。</p><p>  热点代码探测是Hotspot又一项“灵魂”后端优化，热点代码又被称之为多次调用的代码或者多次执行循环体的代码，但是hotspot是如何判断的呢？如何获取某个方法执行多少次？以及怎么算“够久”？</p><p>  首先我们先回答执行多少次的问题，hotspot使用的是两种计数器来完成：<strong>方法调用计数器和回边计数器。</strong></p><p>  而够久稍微复杂一些，方法调用和回边计数的判定方式是不一样的。下面用一个简单的列表来说明一下触发方法调用器热点代码的判定条件：</p><h3 id="方法调用计数器"><a href="#方法调用计数器" class="headerlink" title="方法调用计数器"></a>方法调用计数器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方法调用器：客户端编译器<span class="number">15000</span>次，服务端编译器<span class="number">10000</span>次</span><br><span class="line">条件：回边+方法调用&gt;=上面的阈值</span><br><span class="line">注意：时间范围内的调用次数。</span><br><span class="line">统计方法：半衰周期。</span><br></pre></td></tr></table></figure><h3 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h3><p>  方法调用计数器好懂一些，这里不做过多解释，下面我们补充一下回边计数器的细节，回边计数器就是指统计循环代码中执行的次数，当然不是单纯的计算循环体的执行次数，而是使用下面的公示计算：</p><blockquote><p>客户端模式（默认为13995）：方法调用计数器阈值(-XX:  C o m p i l e T h r e s h o l d ) 乘 以 O SR 比 率 ( - X X : O n St a c k R e p l a c e P e r c e n t a ge ) 除 以 1 0 0 。 其 中 - X X : OnStackRep lacePercentage默认值为933</p><p>服务端模式（默认为10700）<strong>：</strong>方法调用计数器阈值(-XX:  C o m p i l e T h r e s h o l d ) 乘 以 ( O SR 比 率 ( - X X : O n St a c k R e p l a c e P e r c e n t a ge ) 减 去 解 释 器 监 控 比 率 ( - X X : InterpreterProfilePercentage)的差值)除以100。其中-XX:OnStack ReplacePercentage默认值为140，- X X : I n t e r p r e t e r P r o f i l e P e r c e n t a ge 默 认 值 为 3 3。</p></blockquote><p>  当回边方法触发到到阈值的时候，会触发一个叫做“栈上替换”的操作。并且回边计数器没有半衰周期的概念，当到达绝对值的条件的时候就会触发，而如果这个数字一直增长到达计数器的上限并且溢出，回边计数器会重置并且顺带把方法计数器的值为归0。最后在回边计数到达阈值的时候，会稍微降低当前回边计数器的值让下一次的代码依旧执行循环（不然栈上替换完了，循环也执行完了就没有意义了）。</p><h2 id="结构图对比："><a href="#结构图对比：" class="headerlink" title="结构图对比："></a>结构图对比：</h2><p>我们根据上面的描述来看下两个计数器的计算逻辑结构图：</p><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20210823220938.png" alt="方法调用触发即时编译"></p><p>​    </p><h3 id="回边计数器-1"><a href="#回边计数器-1" class="headerlink" title="回边计数器"></a>回边计数器</h3><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20210823220957.png" alt="回边计数器"></p><h3 id="前后端编译概览"><a href="#前后端编译概览" class="headerlink" title="前后端编译概览"></a>前后端编译概览</h3><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20210823220856.png" alt="前后端编译概览"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>  本节我们讲述了javac指令的底层执行过程，以及前端优化和后端优化，前端优化主要是对于java的语法糖优化以及一项重要的优化注解生成器。在后续的文章中我们介绍了部分后端编译优化的方式，即使编译器，以及热点代码探测，在即时编译里面我们讲述了分层编译的功能。最后我们用结构图讲述了编译的内容。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>  本文讲述了关于后端编译的部分，下一节将会讲述关于后端编译的另外一部分内容。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      编译优化
    
    </summary>
    
    
      <category term="java-jvm" scheme="https://whitestore.top/categories/java-jvm/"/>
    
    
      <category term="jvm" scheme="https://whitestore.top/tags/jvm/"/>
    
  </entry>
  
</feed>
