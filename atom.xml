<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>爱看书的阿东</title>
  
  <subtitle>赐他一块白色石头，石头上写着新名</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://whitestore.top/"/>
  <updated>2023-09-09T01:34:12.337Z</updated>
  <id>https://whitestore.top/</id>
  
  <author>
    <name>阿东</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【读书笔记】《一本书读懂支付》读书笔记（一）</title>
    <link href="https://whitestore.top/2023/09/09/onebookpay/"/>
    <id>https://whitestore.top/2023/09/09/onebookpay/</id>
    <published>2023-09-09T01:33:10.000Z</published>
    <updated>2023-09-09T01:34:12.337Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-交易"><a href="#一-交易" class="headerlink" title="一. 交易"></a>一. 交易</h1><h2 id="1-1-什么是交易？"><a href="#1-1-什么是交易？" class="headerlink" title="1.1 什么是交易？"></a>1.1 什么是交易？</h2><p>按照历史趋势：贝壳交换 =&gt; 实体货币 =&gt; 数据化虚拟货币（轻量化和虚拟化）。</p><p>一句话：<strong>等价交换行为</strong>。</p><h2 id="1-2-交易定义"><a href="#1-2-交易定义" class="headerlink" title="1.2 交易定义"></a>1.2 交易定义</h2><p>买卖双方对有价值的物品与服务互通有无的行为。</p><blockquote><p>关键：双方、有价值、互通有无、物品和服务</p></blockquote><h2 id="1-3-交易流程"><a href="#1-3-交易流程" class="headerlink" title="1.3 交易流程"></a>1.3 交易流程</h2><p>古代：<strong>袖内拉手</strong> 和 <strong>袖内比价</strong>。</p><p>现代：某些交易场景下有专业的手势，比如交易所手心向内和手心向外代表买入和卖出。</p><h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><p>步骤：签约 =&gt; 认证 =&gt; 交付 =&gt; 记录</p><p><strong>签约</strong>：交易条件一致。</p><p><strong>认证</strong>：互验真伪。</p><p><strong>交付</strong>：卖方物品服务托付买方。</p><p><strong>记录</strong>：买方转账给卖方。</p><h3 id="产生问题"><a href="#产生问题" class="headerlink" title="产生问题"></a>产生问题</h3><ol><li>跨境交易</li><li>失信问题</li><li>诈骗</li><li>换汇等一系列问题</li></ol><a id="more"></a><h1 id="二、支付"><a href="#二、支付" class="headerlink" title="二、支付"></a>二、支付</h1><h2 id="2-1-什么是支付"><a href="#2-1-什么是支付" class="headerlink" title="2.1 什么是支付"></a>2.1 什么是支付</h2><p>定义：付款人向收款人转移<strong>可接受</strong>的<strong>货币债权</strong>。</p><blockquote><p>对应了交易流程的”交付“步骤。</p></blockquote><h2 id="2-2-支付过程"><a href="#2-2-支付过程" class="headerlink" title="2.2 支付过程"></a>2.2 支付过程</h2><ol><li>当面交付</li><li>周期交付</li><li>代理交付</li><li>授权承诺<h2 id="2-3-支付要素"><a href="#2-3-支付要素" class="headerlink" title="2.3 支付要素"></a>2.3 支付要素</h2></li></ol><p>关键点：付款人、收款人、可接受的货币债权</p><p><strong>付款人</strong>：买方。<br><strong>收款人</strong>：卖方。<br><strong>可接受的货币债权</strong>。</p><p>可接受的货币债权包含下面几个点：</p><p><strong>支付时间</strong>：合约规定时间。<br><strong>支付货币</strong>：合约规定币种。<br><strong>支付金额</strong>：合约规定货币数量。<br><strong>支付方式</strong>：支票、电子转账等等多种方式。</p><h2 id="2-4-支付复杂性"><a href="#2-4-支付复杂性" class="headerlink" title="2.4 支付复杂性"></a>2.4 支付复杂性</h2><p><strong>身份认证</strong>：付款人不验明正身，无法把资金交割给收款人。<br><strong>约定资金交割</strong>：跨境交易存在换汇和不同银行的交互问题。<br><strong>各国监管机构</strong>：关注反洗钱，反贪污，防止偷税漏税等。</p><h2 id="2-5-易混淆概念"><a href="#2-5-易混淆概念" class="headerlink" title="2.5 易混淆概念"></a>2.5 易混淆概念</h2><p><strong>支付指令</strong>：支付机构按照消费者授权，向银行发起具体的指令。<br><strong>支付请求</strong>：消费者向商户支付款项。</p><h1 id="三、交易与支付"><a href="#三、交易与支付" class="headerlink" title="三、交易与支付"></a>三、交易与支付</h1><h2 id="3-1-概念"><a href="#3-1-概念" class="headerlink" title="3.1 概念"></a>3.1 概念</h2><p>交易是支付的关键环节。</p><h2 id="3-2-交易与支付的差异"><a href="#3-2-交易与支付的差异" class="headerlink" title="3.2 交易与支付的差异"></a>3.2 交易与支付的差异</h2><ol><li>不存在有价值物品交换，不存在支付。</li></ol><ul><li>以物换物。</li></ul><ol start="2"><li>交易发生与支付这两者无直接关系。</li></ol><ul><li>少部分交易不需要支付</li><li>少部分支付无交易</li><li>多数交易有支付</li></ul><p>比如：</p><ul><li>朋友借钱和还钱（无交易的支付）</li><li>捐款（无交易支付）<h1 id="四、支付中的常用概念"><a href="#四、支付中的常用概念" class="headerlink" title="四、支付中的常用概念"></a>四、支付中的常用概念</h1></li></ul><h2 id="4-1-应收账款"><a href="#4-1-应收账款" class="headerlink" title="4.1 应收账款"></a>4.1 应收账款</h2><p>会计科目，指的是因出售商品或者服务，进而对顾客产生的债权。从卖方角度看，应收账款是指卖方提供了买方需要的服务，<strong>卖方应该收到的买方款项</strong>。</p><h2 id="4-2-保理"><a href="#4-2-保理" class="headerlink" title="4.2 保理"></a>4.2 保理</h2><p>金融术语：交易所产生的应收账款转让给保理机构管理，由保理机构完成金融服务。</p><p>保理服务商：主要提供资金融通，卖家资信评估，销售账户管理，信用风险担保，账款催收等一系列服务的综合金融服务方式。</p><h2 id="4-3-收单"><a href="#4-3-收单" class="headerlink" title="4.3 收单"></a>4.3 收单</h2><p>收单需要先了解”单“的概念：单就是消费者完成交易之后的单据。</p><p>常见的收单方式：</p><ul><li><strong>ATM 收单</strong>：多指持卡人在非开户行ATM取款。<ul><li>如果是跨行取款，会涉及银行和银行之间的清算，收取活动。</li></ul></li><li><strong>POS 机收单</strong>：国外使用较多，POS机由银行提供，直接和收单机构间接部署到各个商铺。<ul><li>产生双份收据，消费者方收据用于日后查询备用，商户收据则用于发生交易纠纷的时候找银行核算。</li></ul></li><li><strong>网络收单</strong>：在线支付产生的收据。</li></ul><p>交易链：三方支付 -&gt; 收单行 -&gt; 卡组织  -&gt; 公共/专用网络。</p><h2 id="4-4-结算"><a href="#4-4-结算" class="headerlink" title="4.4 结算"></a>4.4 结算</h2><p>支付机构和商户商定结算周期费率，周期内支付请求总结性计算，结算会在汇总的过程中抽取手续费并且扣除。</p><h2 id="4-5-备付金"><a href="#4-5-备付金" class="headerlink" title="4.5 备付金"></a>4.5 备付金</h2><p>指的是预收待支付货币资金（通常为银行）。</p><blockquote><p>比如我们在支付宝微信的”余额“或者说账户余额就是备付金的概念。</p></blockquote><h2 id="4-6-清算"><a href="#4-6-清算" class="headerlink" title="4.6 清算"></a>4.6 清算</h2><p>定义：对于不同的银行进行机构定期长短款<strong>割差</strong>过程。</p><p>目的：<strong>避免金融机构不必要的资金转移</strong>。</p><p>再比如这个例子：中行 =&gt; 建行转500，建行=&gt;中行700，通过清算机构割差，最终为 中行 =&gt; 建行200。</p><h2 id="4-7-对比清算和结算的概念"><a href="#4-7-对比清算和结算的概念" class="headerlink" title="4.7 对比清算和结算的概念"></a>4.7 对比清算和结算的概念</h2><p>清算：机构之间算清互相欠款，重点是机构和机构。<br>结算：仅限支付服务提供商和服务商户之间的活动。</p><h1 id="五、会计系统"><a href="#五、会计系统" class="headerlink" title="五、会计系统"></a>五、会计系统</h1><p>注意这部分介绍的内容都是以中国的会计系统为基础。</p><h2 id="5-1-账户"><a href="#5-1-账户" class="headerlink" title="5.1 账户"></a>5.1 账户</h2><p>基本结构为：名称（会计科目）、日期摘要，（增加/减少）方金额、余额。</p><h2 id="5-2-账务"><a href="#5-2-账务" class="headerlink" title="5.2 账务"></a>5.2 账务</h2><p>实现汇集处理的原始单据收集，整理，记载，计算等会计实事务处理。</p><h2 id="5-3-账户模型"><a href="#5-3-账户模型" class="headerlink" title="5.3 账户模型"></a>5.3 账户模型</h2><p><strong>账户编号</strong>：系统授权的开户账户唯一编号。<br><strong>账户余额</strong>：现存并且未使用的货币数量（包含了可用+冻结金额）。<br><strong>可用余额</strong>：表示此时此刻可以动用的金额。<br><strong>冻结金额</strong>：业务操作冻结，或者个人账户错误，付款停滞，充值按月返现等都会出现冻结金额。<br><strong>货币种类</strong>：余额 + 币种 = 实际的货币价值。<br><strong>借贷属性</strong>：会计行业术语，表示账户金额的增减。借出=&gt;资产增加，负债减少，贷入=&gt;负债增加、资产减少。</p><blockquote><p>会计的借贷概念：<br> 借：资产、费用成本增加，负债、收入，所有者权益减少。<br> 贷：负债、收入、所有者权益增加，资产、费用、成本的减少。</p></blockquote><p><strong>所属科目</strong>：指的是所从属会计科目。一般所属科目设置是按照资金划分的，按照经济内容对于资产、负债、所有者权益等会计要素进一步分类的类型名称。<br><strong>帐套</strong>：会计核算对象，会计业务数据文件总称。</p><h1 id="六、信用与信用支付"><a href="#六、信用与信用支付" class="headerlink" title=";六、信用与信用支付"></a>;六、信用与信用支付</h1><p>最早的信用支付在农耕时代，农民借钱耕种，庄稼收获卖出获利之后还钱。信用支付的本质就是超前消费，花未来的钱解决现在的问题，现代社会生活中，信用和信用支付随处可见。</p><h2 id="信用（redit）衍生信用支付"><a href="#信用（redit）衍生信用支付" class="headerlink" title="信用（redit）衍生信用支付"></a>信用（redit）衍生信用支付</h2><p>不用立刻付款就可以获得资金，物资，服务能力，本身建立在<strong>信任</strong>的基础上，获得这能力的条件是<strong>以约定的期限偿还</strong>。</p><p><strong>信用支付</strong>：其实就是支付过程当中，<strong>把付款人借到的资金转移给收款人的过程</strong>。</p><h2 id="美国信用评价体系"><a href="#美国信用评价体系" class="headerlink" title="美国信用评价体系"></a>美国信用评价体系</h2><p>这部分比较科普向，简单认识名字即可，感兴趣可以看看维基百科。</p><p>三大征信公司：</p><ul><li>全联公司（TransUnion）；</li><li>艾贵发公司（Equifax）；</li><li>益百利公司（Experian）;<h2 id="FICO-（FairIssac-Company）"><a href="#FICO-（FairIssac-Company）" class="headerlink" title="FICO （FairIssac Company）"></a>FICO （FairIssac Company）</h2></li></ul><p><strong>FICO （FairIssac Company）</strong> （消费者信用分数算法模型）最初是计算消费者信用分数的算法模型，这也是首家信贷咨询公司。</p><h3 id="评估依据"><a href="#评估依据" class="headerlink" title="评估依据"></a>评估依据</h3><p>消费者信用分数的评估依据有：信用记录长度、债务数额、新申请信贷、信用组合、支付历史。</p><h3 id="评估结果"><a href="#评估结果" class="headerlink" title="评估结果"></a>评估结果</h3><p>美国的消费者信用评估分为下面五个等级（由最差到最好）：</p><ul><li>Poor：信用分数350分以下</li><li>Fair：信用分数 351 - 590</li><li>OK：信用分数 591 - 610</li><li>Good：信用分数 611 - 680</li><li>Great：信用分数 681 以上<h2 id="次贷危机"><a href="#次贷危机" class="headerlink" title="次贷危机"></a>次贷危机</h2></li></ul><p>2007年的次贷危机，原因是贷款人的信用评估结果不好，但是这部分人依然要买房子，贷款公司和银行依然放贷，只不过条件变得更为严苛，此时作为贷款人只能接受“剥削”硬着头皮接受条件…..</p><p>美国的信用体系整体上是可靠的，次贷危机树因为银行没有按照征信机构指引作业。</p><h2 id="征信差的生意"><a href="#征信差的生意" class="headerlink" title="征信差的生意"></a>征信差的生意</h2><p>当然征信差的人并不一定完全没有任何出路，美国的 Capital One 公司会专门对于信用评分不太好的人挑选一部分继续做生意。</p><p>Capital One 公司是典型的用管理风险来赚钱的金融科技公司。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      读懂支付
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://whitestore.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://whitestore.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【摄影】通向另一个世界的窗口——摄影构图三步法</title>
    <link href="https://whitestore.top/2023/09/09/photo1/"/>
    <id>https://whitestore.top/2023/09/09/photo1/</id>
    <published>2023-09-09T00:56:17.000Z</published>
    <updated>2023-09-09T00:57:12.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="相关视频"><a href="#相关视频" class="headerlink" title="相关视频"></a>相关视频</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXZ2NDExODczUy8/c3BtX2lkX2Zyb209MzMzLjc4OC5yZWNvbW1lbmRfbW9yZV92aWRlby4wJnZkX3NvdXJjZT04MmI2ZjI0ZmM2OTljNDAwYzA5NzdjNjNkN2IzN2Y2NA==" title="https://www.bilibili.com/video/BV1vv411873S/?spm_id_from=333.788.recommend_more_video.0&vd_source=82b6f24fc699c400c0977c63d7b37f64">通向另一个世界的窗口——摄影构图三步法<i class="fa fa-external-link"></i></span></p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>传统的构图模式适合新手，比如三分法，对称法，对角线构图等等，遵循模式的构图会造成成片的千篇一律，这个过程这好似应试教育讲解例题，按照例题去不断练习完成考试。</p><p>应试教育的方式学习摄获取不到真正的知识，真正的知识是<strong>以原理为基础，构建有效方法</strong>。</p><h2 id="二维影像的基本构成"><a href="#二维影像的基本构成" class="headerlink" title="二维影像的基本构成"></a>二维影像的基本构成</h2><p>影响构成的基本原理是<strong>形态</strong>，形态分为点线面等基本要素，色彩是附加在形态之上的，在影像构成的时候可以忽略色彩观察形态，色彩是在影像结构上的视觉和心理影响。</p><a id="more"></a><h1 id="摄影镜头的成像"><a href="#摄影镜头的成像" class="headerlink" title="摄影镜头的成像"></a>摄影镜头的成像</h1><p>摄影镜头的成像遵循<strong>几何光学</strong>原理：宏观状态下光线是直线传播的，经过介质的时候会发生折射和反射。</p><p>镜头投射的影像和影像的位置有关，镜头所在的位置可以叫做观察点， 摄影镜头是通向另一个世界的窗口，和人眼的成像原理类似，镜头成像是把三维世界的物体形态压缩转为二维影像的过程。</p><p>压缩的过程发生了什么？观察点的改变造成压缩画面的改变，反之亦然，观察点的改变会<strong>产生形态关系的改变。</strong></p><p>压缩画面的改变本质是<strong>多个物体形态排列组合发生变化</strong>，物体的位置变化最终变为<strong>近大远小</strong>的形态对比，同样观察点的变化也会产生物体形态的相互叠加或者分离。</p><p><strong>影像构成基于透视原理，画面结构取决于观察点。</strong> </p><h1 id="构图三步法"><a href="#构图三步法" class="headerlink" title="构图三步法"></a>构图三步法</h1><p>从影像构成的角度认识摄影，才是通向摄影的另一个窗口。</p><h2 id="用形态观察"><a href="#用形态观察" class="headerlink" title="用形态观察"></a>用形态观察</h2><p>观察要有感知和感受，涉及到心态和感知变化，这个过程确定了选取那些形态放到照片里。</p><h2 id="选取观察点"><a href="#选取观察点" class="headerlink" title="选取观察点"></a>选取观察点</h2><p>把这些形态进行排列组合，让它们形成二维平面里的构成关系，这一步需要一定的训练。<strong>体会多个形态之间的排列组合，如何产生新的感知和感受</strong>。这就是摄影语言的基础，在平时的拍摄中多体会这一点，你会获得非凡的观察力。</p><h2 id="确定画面视觉元素"><a href="#确定画面视觉元素" class="headerlink" title="确定画面视觉元素"></a>确定画面视觉元素</h2><p>焦距和相机的取景框确定最终画面以及它们此时的空间关系位置，也确定了<strong>透视关系</strong>。</p><p>采用定焦镜头，需要前后移动改变拍摄范围，前后移动会带来透视关系改变，此时需要重新选取观察点和确定画面视觉元素，定焦镜头可以很好的训练影响构成。</p><h1 id="简化理解构图三步法"><a href="#简化理解构图三步法" class="headerlink" title="简化理解构图三步法"></a>简化理解构图三步法</h1><ol><li>拍什么 </li><li>从哪儿拍  </li><li>拍多少（镜头和焦距）<h1 id="影像的构成"><a href="#影像的构成" class="headerlink" title="影像的构成"></a>影像的构成</h1></li></ol><p>视觉元素的整理过程，整理的结果是让杂乱变得有序，让演奏音乐有旋律和节奏，而不是杂乱的噪音。</p><p>长焦镜头和广角镜头本质上是对于画面进行压缩或者容纳更多的元素，镜头并不会改变透视关系，只有位置的变化才会改变透视关系。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>用“心”的摄影才是真正的摄影。</p><h1 id="作品鉴赏"><a href="#作品鉴赏" class="headerlink" title="作品鉴赏"></a>作品鉴赏</h1><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909075248.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909075303.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909075319.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909075330.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909075600.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909075617.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909075645.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909075711.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909075721.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909075815.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909075839.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909075850.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909075907.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909075920.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909075939.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080002.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080017.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080027.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080037.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080045.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080059.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080111.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080122.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080137.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080155.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080209.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080221.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080234.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080247.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080303.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080317.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080331.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080342.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080352.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080406.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080436.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080450.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080502.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080517.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080534.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080546.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080557.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080612.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080627.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080638.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080648.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080659.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080713.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080724.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080738.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080747.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080802.png" alt=""></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      摄影基础
    
    </summary>
    
    
      <category term="摄影" scheme="https://whitestore.top/categories/%E6%91%84%E5%BD%B1/"/>
    
    
      <category term="摄影" scheme="https://whitestore.top/tags/%E6%91%84%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>Jmeter压力测试学习</title>
    <link href="https://whitestore.top/2023/09/09/note20/"/>
    <id>https://whitestore.top/2023/09/09/note20/</id>
    <published>2023-09-09T00:55:00.446Z</published>
    <updated>2023-07-16T06:28:09.250Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>Jmeter 作为实操性的软件，更注重练习，理论作为参考掌握即可，不需要去具体的纠结</p><h1 id="1-目前用的常用测试工具对比"><a href="#1-目前用的常用测试工具对比" class="headerlink" title="1. 目前用的常用测试工具对比"></a>1. 目前用的常用测试工具对比</h1><h2 id="1、loadrunner"><a href="#1、loadrunner" class="headerlink" title="1、loadrunner"></a>1、loadrunner</h2><p>​    性能稳定，压测结果及细粒度大，可以自定义脚本进行压测，但是太过于重大，功能比较繁多</p><p>​    1、loadrunner</p><h2 id="2、apache-ab-单接口压测最方便"><a href="#2、apache-ab-单接口压测最方便" class="headerlink" title="2、apache ab(单接口压测最方便)"></a>2、apache ab(单接口压测最方便)</h2><p>​    模拟多线程并发请求,ab命令对发出负载的计算机要求很低，既不会占用很多CPU，也不会占用太多的内存，但却会给目标服务器造成巨大的负载, 简单DDOS攻击等</p><h2 id="3、webbench"><a href="#3、webbench" class="headerlink" title="3、webbench"></a>3、webbench</h2><p>​    webbench首先fork出多个子进程，每个子进程都循环做web访问测试。子进程把访问的结果通过pipe告诉父进程，父进程做最终的统计结果。</p><a id="more"></a><h1 id="2-Jmeter基本介绍和使用场景"><a href="#2-Jmeter基本介绍和使用场景" class="headerlink" title="2. Jmeter基本介绍和使用场景"></a>2. Jmeter基本介绍和使用场景</h1><h2 id="1、压测不同的协议和应用"><a href="#1、压测不同的协议和应用" class="headerlink" title="1、压测不同的协议和应用"></a>1、压测不同的协议和应用</h2><p>​    1) Web - HTTP, HTTPS (Java, NodeJS, PHP, <span class="exturl" data-url="aHR0cDovL0FTUC5ORVQ=" title="http://ASP.NET">ASP.NET<i class="fa fa-external-link"></i></span>, …)     2) SOAP / REST Webservices     3) FTP     4) Database via JDBC     5) LDAP 轻量目录访问协议     6) Message-oriented middleware (MOM) via JMS     7) Mail - SMTP(S), POP3(S) and IMAP(S)     8) TCP等等</p><h2 id="2、使用场景及优点"><a href="#2、使用场景及优点" class="headerlink" title="2、使用场景及优点"></a>2、使用场景及优点</h2><p>1）功能测试     </p><p>2）压力测试     </p><p>3）分布式压力测试     </p><p>4）纯java开发     </p><p>5）上手容易，高性能     </p><p>6）提供测试数据分析     </p><p>7）各种报表数据图形展示</p><h1 id="3-本地快速安装Jmeter4-x"><a href="#3-本地快速安装Jmeter4-x" class="headerlink" title="3. 本地快速安装Jmeter4.x"></a>3. 本地快速安装Jmeter4.x</h1><h2 id="1、需要安装JDK8。或者JDK9-JDK10-建议不要使用jre10"><a href="#1、需要安装JDK8。或者JDK9-JDK10-建议不要使用jre10" class="headerlink" title="1、需要安装JDK8。或者JDK9,JDK10 (建议不要使用jre10)"></a>1、需要安装JDK8。或者JDK9,JDK10 (建议不要使用jre10)</h2><h2 id="2、快速下载"><a href="#2、快速下载" class="headerlink" title="2、快速下载"></a>2、快速下载</h2><p>​    windows： <span class="exturl" data-url="aHR0cDovL21pcnJvcnMudHVuYS50c2luZ2h1YS5lZHUuY24vYXBhY2hlLy9qbWV0ZXIvYmluYXJpZXMvYXBhY2hlLWptZXRlci00LjAuemlw" title="http://mirrors.tuna.tsinghua.edu.cn/apache//jmeter/binaries/apache-jmeter-4.0.zip">http://mirrors.tuna.tsinghua.edu.cn/apache//jmeter/binaries/apache-jmeter-4.0.zip<i class="fa fa-external-link"></i></span>     </p><p>mac或者linux：<span class="exturl" data-url="aHR0cDovL21pcnJvcnMudHVuYS50c2luZ2h1YS5lZHUuY24vYXBhY2hlLy9qbWV0ZXIvYmluYXJpZXMvYXBhY2hlLWptZXRlci00LjAudGd6" title="http://mirrors.tuna.tsinghua.edu.cn/apache//jmeter/binaries/apache-jmeter-4.0.tgz">http://mirrors.tuna.tsinghua.edu.cn/apache//jmeter/binaries/apache-jmeter-4.0.tgz<i class="fa fa-external-link"></i></span></p><h2 id="3、文档地址：http-jmeter-apache-org-usermanual-get-started-html"><a href="#3、文档地址：http-jmeter-apache-org-usermanual-get-started-html" class="headerlink" title="3、文档地址：http://jmeter.apache.org/usermanual/get-started.html"></a>3、文档地址：<span class="exturl" data-url="aHR0cDovL2ptZXRlci5hcGFjaGUub3JnL3VzZXJtYW51YWwvZ2V0LXN0YXJ0ZWQuaHRtbA==" title="http://jmeter.apache.org/usermanual/get-started.html">http://jmeter.apache.org/usermanual/get-started.html<i class="fa fa-external-link"></i></span></h2><h2 id="4、建议安装JDK环境，虽然JRE也可以，但是压测https需要JDK里面的-keytool工具"><a href="#4、建议安装JDK环境，虽然JRE也可以，但是压测https需要JDK里面的-keytool工具" class="headerlink" title="4、建议安装JDK环境，虽然JRE也可以，但是压测https需要JDK里面的 keytool工具"></a>4、建议安装JDK环境，虽然JRE也可以，但是压测https需要JDK里面的 keytool工具</h2><h1 id="4-jemeter-目录结构"><a href="#4-jemeter-目录结构" class="headerlink" title="4. jemeter 目录结构"></a>4. jemeter 目录结构</h1><h2 id="bin-核心可执行文件，包含配置"><a href="#bin-核心可执行文件，包含配置" class="headerlink" title="bin:核心可执行文件，包含配置"></a>bin:核心可执行文件，包含配置</h2><p>jmeter.bat: windows启动文件：     </p><p>jmeter: mac或者linux启动文件：     </p><p>jmeter-server：mac或者Liunx分布式压测使用的启动文件  </p><p>jmeter-server.bat：mac或者Liunx分布式压测使用的启动文件     </p><p>jmeter.properties: 核心配置文件 </p><h2 id="extras：插件拓展的包"><a href="#extras：插件拓展的包" class="headerlink" title="extras：插件拓展的包"></a>extras：插件拓展的包</h2><p>lib:核心的依赖包     </p><p>ext:核心包     </p><p>junit:单元测试包</p><h1 id="5-改变jmeter的GUI界面语言版本"><a href="#5-改变jmeter的GUI界面语言版本" class="headerlink" title="5. 改变jmeter的GUI界面语言版本"></a>5. 改变jmeter的GUI界面语言版本</h1><h2 id="1、控制台修改"><a href="#1、控制台修改" class="headerlink" title="1、控制台修改"></a>1、控制台修改</h2><p>​    <code>menu -&gt; options -&gt; choose language</code></p><h2 id="2、配置文件修改"><a href="#2、配置文件修改" class="headerlink" title="2、配置文件修改"></a>2、配置文件修改</h2><p>​    <code>bin目录 -&gt; jmeter.properties     默认 #language=en     改为 language=zh_CN</code></p><h1 id="6-jemeter-菜单介绍"><a href="#6-jemeter-菜单介绍" class="headerlink" title="6. jemeter 菜单介绍"></a>6. jemeter 菜单介绍</h1><h2 id="1、添加-gt-threads-gt-线程组（控制总体并发）"><a href="#1、添加-gt-threads-gt-线程组（控制总体并发）" class="headerlink" title="1、添加-&gt;threads-&gt;线程组（控制总体并发）"></a>1、添加-&gt;threads-&gt;线程组（控制总体并发）</h2><ul><li>线程数：虚拟用户数。一个虚拟用户占用一个进程或线程</li><li>准备时长（Ramp-Up Period(in seconds)）：全部线程启动的时长，比如100个线程，20秒，则表示20秒内100个线程都要启动完成，每秒启动5个线程</li><li>循环次数：每个线程发送的次数，假如值为5，100个线程，则会发送500次请求，可以勾选永远循环</li></ul><h2 id="2、线程组-gt-添加-gt-Sampler-采样器-gt-Http-（一个线程组下面可以增加几个Sampler）"><a href="#2、线程组-gt-添加-gt-Sampler-采样器-gt-Http-（一个线程组下面可以增加几个Sampler）" class="headerlink" title="2、线程组-&gt;添加-&gt; Sampler(采样器) -&gt; Http （一个线程组下面可以增加几个Sampler）"></a>2、线程组-&gt;添加-&gt; Sampler(采样器) -&gt; Http （一个线程组下面可以增加几个Sampler）</h2><ul><li>名称：采样器名称</li><li>注释：对这个采样器的描述</li><li>web服务器：<ul><li>默认协议是http</li><li>默认端口是80</li><li>服务器名称或IP ：请求的目标服务器名称或IP地址</li></ul></li><li>路径：服务器URL</li><li><strong>Use multipart/from-data for HTTP POST</strong> ：当发送POST请求时，使用Use multipart/from-data方法发送，默认不选中。</li></ul><h2 id="3、查看测试结果"><a href="#3、查看测试结果" class="headerlink" title="3、查看测试结果"></a>3、查看测试结果</h2><h3 id="线程组-gt-添加-gt-监听器-gt-察看结果树"><a href="#线程组-gt-添加-gt-监听器-gt-察看结果树" class="headerlink" title="线程组-&gt;添加-&gt;监听器-&gt;察看结果树"></a>线程组-&gt;添加-&gt;监听器-&gt;察看结果树</h3><h1 id="7-断言的基本使用"><a href="#7-断言的基本使用" class="headerlink" title="7. 断言的基本使用"></a>7. 断言的基本使用</h1><h2 id="1-增加断言-线程组-gt-添加-gt-断言-gt-响应断言"><a href="#1-增加断言-线程组-gt-添加-gt-断言-gt-响应断言" class="headerlink" title="1. 增加断言: 线程组 -&gt; 添加 -&gt; 断言 -&gt; 响应断言"></a>1. 增加断言: 线程组 -&gt; 添加 -&gt; 断言 -&gt; 响应断言</h2><p>apply to(应用范围):     Main sample only: 仅当前父取样器 进行断言，一般一个请求，如果发一个请求会触发多个，则就有sub sample（比较少用）</p><h2 id="2-要测试的响应字段："><a href="#2-要测试的响应字段：" class="headerlink" title="2.要测试的响应字段："></a>2.要测试的响应字段：</h2><ul><li>响应文本：即响应的数据，比如json等文本</li><li>响应代码：http的响应状态码，比如200，302，404这些</li><li>响应信息：http响应代码对应的响应信息，例如：OK, Found</li><li>Response Header: 响应头</li></ul><h2 id="3-模式匹配规则："><a href="#3-模式匹配规则：" class="headerlink" title="3.模式匹配规则："></a>3.模式匹配规则：</h2><ul><li>包括：包含在里面就成功</li><li>匹配：响应内容完全匹配，不区分大小写</li><li>equals：完全匹配，区分大小写</li></ul><h2 id="4-断言结果监听器-线程组-gt-添加-gt-监听器-gt-断言结果"><a href="#4-断言结果监听器-线程组-gt-添加-gt-监听器-gt-断言结果" class="headerlink" title="4.断言结果监听器: 线程组-&gt; 添加 -&gt; 监听器 -&gt; 断言结果"></a>4.断言结果监听器: 线程组-&gt; 添加 -&gt; 监听器 -&gt; 断言结果</h2><p>里面的内容是sampler采样器的名称     断言失败，查看结果树任务结果颜色标红(通过结果数里面双击不通过的记录，可以看到错误信息)</p><h2 id="5-每个sample下面可以加单独的结果树，然后同时加多个断言，最外层可以加个结果树进行汇总"><a href="#5-每个sample下面可以加单独的结果树，然后同时加多个断言，最外层可以加个结果树进行汇总" class="headerlink" title="5.每个sample下面可以加单独的结果树，然后同时加多个断言，最外层可以加个结果树进行汇总"></a>5.每个sample下面可以加单独的结果树，然后同时加多个断言，最外层可以加个结果树进行汇总</h2><h1 id="8-Jmeter压测结果聚合报告分析"><a href="#8-Jmeter压测结果聚合报告分析" class="headerlink" title="8. Jmeter压测结果聚合报告分析"></a>8. Jmeter压测结果聚合报告分析</h1><h2 id="1-新增聚合报告：线程组-gt-添加-gt-监听器-gt-聚合报告（Aggregate-Report）"><a href="#1-新增聚合报告：线程组-gt-添加-gt-监听器-gt-聚合报告（Aggregate-Report）" class="headerlink" title="1.新增聚合报告：线程组-&gt;添加-&gt;监听器-&gt;聚合报告（Aggregate Report）"></a>1.新增聚合报告：线程组-&gt;添加-&gt;监听器-&gt;聚合报告（Aggregate Report）</h2><ul><li>lable: sampler的名称</li><li>Samples: 一共发出去多少请求,例如10个用户，循环10次，则是 100</li><li>Average: 平均响应时间</li><li>Median: 中位数，也就是 50％ 用户的响应时间</li><li>90% Line : 90％ 用户的响应不会超过该时间 （90% of the samples took no more than this time. The remaining samples at least as long as this）</li><li>95% Line : 95％ 用户的响应不会超过该时间</li><li>99% Line : 99％ 用户的响应不会超过该时间</li><li>min : 最小响应时间</li><li>max : 最大响应时间</li><li>Error%：错误的请求的数量/请求的总数</li><li><strong>Throughput： 吞吐量——默认情况下表示每秒完成的请求数（Request per Second) 可类比为qps     KB/Sec: 每秒接收数据量</strong></li></ul><h2 id="2-为什么使用：很多变量在全局中都有使用，或者测试数据更改，可以在一处定义，四处使用-比如服务器地址"><a href="#2-为什么使用：很多变量在全局中都有使用，或者测试数据更改，可以在一处定义，四处使用-比如服务器地址" class="headerlink" title="2.为什么使用：很多变量在全局中都有使用，或者测试数据更改，可以在一处定义，四处使用(比如服务器地址)"></a>2.为什么使用：很多变量在全局中都有使用，或者测试数据更改，可以在一处定义，四处使用(比如服务器地址)</h2><h3 id="1、线程组-gt-add-gt-Config-Element-配置原件-gt-User-Definde-Variable（用户定义的变量）"><a href="#1、线程组-gt-add-gt-Config-Element-配置原件-gt-User-Definde-Variable（用户定义的变量）" class="headerlink" title="1、线程组-&gt;add -&gt; Config Element(配置原件)-&gt; User Definde Variable（用户定义的变量）"></a>1、线程组-&gt;add -&gt; Config Element(配置原件)-&gt; User Definde Variable（用户定义的变量）</h3><h3 id="2、引用方式-XXX-，在接口中变量中使用"><a href="#2、引用方式-XXX-，在接口中变量中使用" class="headerlink" title="2、引用方式${XXX}，在接口中变量中使用"></a>2、引用方式${XXX}，在接口中变量中使用</h3><h3 id="3、原始查看结果树和非原生查看（基础按钮）"><a href="#3、原始查看结果树和非原生查看（基础按钮）" class="headerlink" title="3、原始查看结果树和非原生查看（基础按钮）"></a>3、原始查看结果树和非原生查看（基础按钮）</h3><h1 id="9-CSV可变参数压测（重要）"><a href="#9-CSV可变参数压测（重要）" class="headerlink" title="9. CSV可变参数压测（重要）"></a>9. CSV可变参数压测（重要）</h1><p><strong>实战操作jmeter读取CSV和Txt文本文件里面的参数进行压测</strong></p><h2 id="1、线程组-gt-add-gt-Config-Element-配置原件-gt-CSV-data-set-config-CSV数据文件设置"><a href="#1、线程组-gt-add-gt-Config-Element-配置原件-gt-CSV-data-set-config-CSV数据文件设置" class="headerlink" title="1、线程组-&gt;add -&gt; Config Element(配置原件)-&gt; CSV data set config (CSV数据文件设置)"></a>1、线程组-&gt;add -&gt; Config Element(配置原件)-&gt; CSV data set config (CSV数据文件设置)</h2><h2 id="2、在读取的配置文件里面，同时使用多个自定义参数"><a href="#2、在读取的配置文件里面，同时使用多个自定义参数" class="headerlink" title="2、在读取的配置文件里面，同时使用多个自定义参数"></a>2、在读取的配置文件里面，同时使用多个自定义参数</h2><p>如果是多个参数需要同时引用，则在CSV数据文件里面设置加多个字段 Variabled names(comma-delitited): csv_name,csv_pwd</p><h1 id="10、JDBC-request压测Mysql"><a href="#10、JDBC-request压测Mysql" class="headerlink" title="10、JDBC request压测Mysql"></a>10、JDBC request压测Mysql</h1><h2 id="1、Thread-Group-gt-add-gt-sampler-gt-jdbc-request"><a href="#1、Thread-Group-gt-add-gt-sampler-gt-jdbc-request" class="headerlink" title="1、Thread Group -&gt; add -&gt; sampler -&gt; jdbc request"></a>1、Thread Group -&gt; add -&gt; sampler -&gt; jdbc request</h2><h2 id="2、jar包添加-mysql-connector-java-5-1-30-jar"><a href="#2、jar包添加-mysql-connector-java-5-1-30-jar" class="headerlink" title="2、jar包添加 mysql-connector-java-5.1.30.jar"></a>2、jar包添加 mysql-connector-java-5.1.30.jar</h2><h2 id="3、JDBC-connection-Configuration-配置"><a href="#3、JDBC-connection-Configuration-配置" class="headerlink" title="3、JDBC connection Configuration 配置"></a>3、JDBC connection Configuration 配置</h2><p><strong>JDBC request-&gt;add -&gt; config element -&gt; JDBC connection configuration</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">核心配置</span><br><span class="line">Max Number of connections : 最大连接数</span><br><span class="line">MAX wait :最大等待时间</span><br><span class="line">Auto Commit: 是否自动提交事务</span><br><span class="line"></span><br><span class="line">DataBase URL : 数据库连接地址 jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;blog</span><br><span class="line">JDBC Driver Class : 数据库驱动，选择对应的mysql</span><br><span class="line">username:数据库用户名</span><br><span class="line">password:数据库密码</span><br></pre></td></tr></table></figure><h1 id="11-request压测Mysql-select语句"><a href="#11-request压测Mysql-select语句" class="headerlink" title="11. request压测Mysql, select语句"></a>11. request压测Mysql, select语句</h1><ul><li>个人测试1</li></ul><p>\</p><ul><li>个人测试2<ul><li>注意：需要添加一个全局的debug采集器采集查询结果</li><li>可以看到如图所示结果</li></ul></li></ul><h2 id="1-Debug-Sampler使用（结果树中查看）"><a href="#1-Debug-Sampler使用（结果树中查看）" class="headerlink" title="1. Debug Sampler使用（结果树中查看）"></a>1. Debug Sampler使用（结果树中查看）</h2><p>​    Thread Group -&gt; add -&gt; sampler -&gt; debug sampler</p><h2 id="2-参数讲解：-sql结尾不要加”-”"><a href="#2-参数讲解：-sql结尾不要加”-”" class="headerlink" title="2. 参数讲解：(sql结尾不要加”;”)"></a>2. 参数讲解：(sql结尾不要加”;”)</h2><ul><li>variable name of pool declared in JDBC connection configuration（和配置文件同名）</li><li>Query Type 查询类型</li><li>parameter values 参数值</li><li>parameter types 参数类型</li><li>variable names sql执行结果变量名</li><li>result variable names 所有结果当做一个对象存储</li><li>query timeouts 查询超时时间</li><li>handle results 处理结果集</li></ul><h1 id="12-分布式压测（学习重点）"><a href="#12-分布式压测（学习重点）" class="headerlink" title="12. 分布式压测（学习重点）"></a>12. 分布式压测（学习重点）</h1><p>官网教程： <span class="exturl" data-url="aHR0cDovL2ptZXRlci5hcGFjaGUub3JnL3VzZXJtYW51YWwvam1ldGVyX2Rpc3RyaWJ1dGVkX3Rlc3Rpbmdfc3RlcF9ieV9zdGVwLmh0bWw=" title="http://jmeter.apache.org/usermanual/jmeter_distributed_testing_step_by_step.html">http://jmeter.apache.org/usermanual/jmeter_distributed_testing_step_by_step.html<i class="fa fa-external-link"></i></span></p><ul><li>普通压测：单台机可以对目标机器产生的压力比较小，受限因素包括CPU，网络，IO等</li><li>分布式压测：利用多台机器向目标机器产生压力，模拟几万用户并发访问</li></ul><h1 id="13-Jmeter分布式压测原理-了解"><a href="#13-Jmeter分布式压测原理-了解" class="headerlink" title="13. Jmeter分布式压测原理(了解)"></a>13. Jmeter分布式压测原理(了解)</h1><p>1、总控机器的节点master，其他产生压力的机器叫“肉鸡” server</p><p>2、master会把压测脚本发送到 server上面</p><p>3、执行的时候，server上只需要把jmeter-server打开就可以了，不用启动jmeter</p><p>4、结束后，server会把压测数据回传给master,然后master汇总输出报告</p><p>5、配置详情</p><h1 id="14-阿里云安装jmeter-守护进程：nohup-java-jar-xxxxx-amp"><a href="#14-阿里云安装jmeter-守护进程：nohup-java-jar-xxxxx-amp" class="headerlink" title="14. 阿里云安装jmeter (守护进程：nohup java -jar xxxxx &amp;)"></a>14. 阿里云安装jmeter (守护进程：nohup java -jar xxxxx &amp;)</h1><h2 id="1-下载方式：wget-http-apache-osuosl-org-jmeter-binaries-apache-jmeter-4-0-tgz"><a href="#1-下载方式：wget-http-apache-osuosl-org-jmeter-binaries-apache-jmeter-4-0-tgz" class="headerlink" title="1. 下载方式：wget http://apache.osuosl.org//jmeter/binaries/apache-jmeter-4.0.tgz"></a>1. 下载方式：wget <span class="exturl" data-url="aHR0cDovL2FwYWNoZS5vc3Vvc2wub3JnLy9qbWV0ZXIvYmluYXJpZXMvYXBhY2hlLWptZXRlci00LjAudGd6" title="http://apache.osuosl.org//jmeter/binaries/apache-jmeter-4.0.tgz">http://apache.osuosl.org//jmeter/binaries/apache-jmeter-4.0.tgz<i class="fa fa-external-link"></i></span></h2><h2 id="2-直接到官网下载对应tag-gz包，并在服务器解压"><a href="#2-直接到官网下载对应tag-gz包，并在服务器解压" class="headerlink" title="2. 直接到官网下载对应tag.gz包，并在服务器解压"></a>2. 直接到官网下载对应tag.gz包，并在服务器解压</h2><h1 id="15-Jmeter非GUI界面-参数讲解-必须掌握"><a href="#15-Jmeter非GUI界面-参数讲解-必须掌握" class="headerlink" title="15. Jmeter非GUI界面 参数讲解(必须掌握)"></a>15. Jmeter非GUI界面 参数讲解(必须掌握)</h1><p>官方配置文件地址： <span class="exturl" data-url="aHR0cDovL2ptZXRlci5hcGFjaGUub3JnL3VzZXJtYW51YWwvZ2V0LXN0YXJ0ZWQuaHRtbA==" title="http://jmeter.apache.org/usermanual/get-started.html">http://jmeter.apache.org/usermanual/get-started.html<i class="fa fa-external-link"></i></span></p><ul><li><strong>-h</strong> 帮助</li><li><strong>-n</strong> 非GUI模式</li><li><strong>-t</strong> 指定要运行的 JMeter 测试脚本文件</li><li><strong>-l</strong> 记录结果的文件 每次运行之前，(要确保之前没有运行过,即xxx.jtl不存在，不然报错)</li><li><strong>-r</strong> Jmter.properties文件中指定的所有远程服务器</li><li><strong>-e</strong> 在脚本运行结束后生成html报告</li><li><strong>-o</strong> 用于存放html报告的目录（目录要为空，不然报错）</li></ul><p>jmeter -n -t linux_users_api.jmx -l result.jtl -e -o /usr/local/softwate/jmeter/temp/ResultReport</p><p>jmeter -n -t /Users/jack/Desktop/linux_users_api.jmx -l result.jtl -e -o /Users/jack/Desktop/person/jmeter/temp</p><p>个人： /usr/local/software/jmeter/project/temp 。。。。</p><h2 id="1-阿里云非GUI-jmeter-压测"><a href="#1-阿里云非GUI-jmeter-压测" class="headerlink" title="1.阿里云非GUI jmeter 压测"></a>1.阿里云非GUI jmeter 压测</h2><p>jmx目录：/usr/local/software/jmeter/temp</p><p>示例</p><p>jmeter -n -t /usr/local/software/jmeter/temp/linux_users_api.jmx -l /usr/local/software/jmeter/temp/jtl/result.jtl</p><p>利用软件从阿里云Centos服务器下载压测报告，讲解Jtl文件，并怎么查看文件 可以通过打开jmeter，新建线程组-&gt;summary report-&gt;浏览文件 进行查看</p><h2 id="2-讲解Jmeter压测减少资源使用的一些建议，即压测结果更准确"><a href="#2-讲解Jmeter压测减少资源使用的一些建议，即压测结果更准确" class="headerlink" title="2.讲解Jmeter压测减少资源使用的一些建议，即压测结果更准确"></a>2.讲解Jmeter压测减少资源使用的一些建议，即压测结果更准确</h2><p>1、使用非GUI模式：jmeter -n -t test.jmx -l result.jtl</p><p>2、少使用Listener， 如果使用-l参数，它们都可以被删除或禁用。</p><p>3、在加载测试期间不要使用“查看结果树”或“查看结果”表监听器，只能在脚本阶段使用它们来调试脚本。</p><p>4、包含控制器在这里没有帮助，因为它将文件中的所有测试元素添加到测试计划中。]</p><p>5、不要使用功能模式,使用CSV输出而不是XML</p><p>6、只保存你需要的数据,尽可能少地使用断言</p><p>7、如果测试需要大量数据，可以提前准备好测试数据放到数据文件中，以CSV Read方式读取。</p><p>8、用内网压测，减少其他带宽影响压测结果</p><p>9、如果压测大流量，尽量用多几个节点以非GUI模式向服务器施压</p><p>官方推荐 ：<span class="exturl" data-url="aHR0cDovL2pha2FydGEuYXBhY2hlLm9yZy9qbWV0ZXIvdXNlcm1hbnVhbC9iZXN0LXByYWN0aWNlcy5odG1sI2xlYW5fbWVhbg==" title="http://jakarta.apache.org/jmeter/usermanual/best-practices.html#lean_mean">http://jakarta.apache.org/jmeter/usermanual/best-practices.html#lean_mean<i class="fa fa-external-link"></i></span></p><h2 id="3-把Jmtere压测结果转换为Html"><a href="#3-把Jmtere压测结果转换为Html" class="headerlink" title="3. 把Jmtere压测结果转换为Html"></a>3. 把Jmtere压测结果转换为Html</h2><p>jmeter -n -t /usr/local/software/jmeter/temp/linux_users_api.jmx -l /usr/local/software/jmeter/temp/jtl/result.jtl -e -o /usr/local/software/jmeter/temp/result讲解压测报告 html里面Dashboard的核心指标</p><h3 id="1、dashboard讲解"><a href="#1、dashboard讲解" class="headerlink" title="1、dashboard讲解"></a>1、dashboard讲解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1）Test and Report informations</span><br><span class="line">Source file：jtl文件名</span><br><span class="line">Start Time ：压测开始时间</span><br><span class="line">End Time ：压测结束时间</span><br><span class="line">Filter for display：过滤器</span><br><span class="line">Lable:sampler采样器名称</span><br><span class="line"></span><br><span class="line">2）APDEX(Application performance Index)</span><br><span class="line">apdex:应用程序性能指标,范围在0~1之间，1表示达到所有用户均满意</span><br><span class="line">T(Toleration threshold)：可接受阀值</span><br><span class="line">F(Frustration threshold)：失败阀值</span><br><span class="line"></span><br><span class="line">3）Requests Summary</span><br><span class="line">OK:成功率</span><br><span class="line">KO:失败率</span><br><span class="line">4）Statistics 统计数据</span><br><span class="line">lable:sampler采样器名称</span><br><span class="line"></span><br><span class="line">samples:请求总数，并发数*循环次数</span><br><span class="line">KO:失败次数</span><br><span class="line">Error%:失败率</span><br><span class="line"></span><br><span class="line">Average:平均响应时间</span><br><span class="line">Min:最小响应时间</span><br><span class="line">Max:最大响应时间</span><br><span class="line">90th pct: 90%的用户响应时间不会超过这个值（关注这个就可以了）</span><br><span class="line">2ms,3ms,4,5,2,6,8,3,9</span><br><span class="line"></span><br><span class="line">95th pct: 95%的用户响应时间不会超过这个值</span><br><span class="line">99th pct: 99%的用户响应时间不会超过这个值 (存在极端值)</span><br><span class="line">throughtput:Request per Second吞吐量 qps</span><br><span class="line"></span><br><span class="line">received:每秒从服务器接收的数据量</span><br><span class="line">send：每秒发送的数据量</span><br></pre></td></tr></table></figure><h3 id="2、charts讲解"><a href="#2、charts讲解" class="headerlink" title="2、charts讲解"></a>2、charts讲解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1)Over Time（随着时间的变化）</span><br><span class="line">Response Times Over Time：响应时间变化趋势</span><br><span class="line">Response Time Percentiles Over Time (successful responses)：最大，最小，平均，用户响应时间分布</span><br><span class="line">Active Threads Over Time：并发用户数趋势</span><br><span class="line">Bytes Throughput Over Time：每秒接收和请求字节数变化，蓝色表示发送，黄色表示接受</span><br><span class="line">Latencies Over Time：平均响应延时趋势</span><br><span class="line">Connect Time Over Time：连接耗时趋势</span><br><span class="line"></span><br><span class="line">1)Throughput</span><br><span class="line">Hits Per Second (excluding embedded resources):每秒点击次数</span><br><span class="line">Codes Per Second (excluding embedded resources)：每秒状态码数量</span><br><span class="line">Transactions Per Second：即TPS，每秒事务数</span><br><span class="line">Response Time Vs Request：响应时间和请求数对比</span><br><span class="line">Latency Vs Request：延迟时间和请求数对比</span><br><span class="line"></span><br><span class="line">1)Response Times</span><br><span class="line">Response Time Percentiles：响应时间百分比</span><br><span class="line">Response Time Overview：响应时间概述</span><br><span class="line">Time Vs Threads：活跃线程数和响应时间</span><br><span class="line">Response Time Distribution：响应时间分布图</span><br></pre></td></tr></table></figure><h1 id="16、Linux服务器上jmeter进行分布式压测"><a href="#16、Linux服务器上jmeter进行分布式压测" class="headerlink" title="16、Linux服务器上jmeter进行分布式压测"></a>16、Linux服务器上jmeter进行分布式压测</h1><h2 id="1、压测注意事项"><a href="#1、压测注意事项" class="headerlink" title="1、压测注意事项"></a>1、压测注意事项</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">the firewalls on the systems are turned off or correct ports are opened.</span><br><span class="line">系统上的防火墙被关闭或正确的端口被打开。</span><br><span class="line"></span><br><span class="line">all the clients are on the same subnet.</span><br><span class="line">所有的客户端都在同一个子网上。</span><br><span class="line"></span><br><span class="line">the server is in the same subnet, if 192.x.x.x or 10.x.x.x IP addresses are used. If the server doesn&#39;t use 192.xx or 10.xx IP address, there shouldn&#39;t be any problems.</span><br><span class="line">如果使用192.x.x.x或10.x.x.x IP地址，则服务器位于同一子网中。 如果服务器不使用192.xx或10.xx IP地址，则不应该有任何问题。</span><br><span class="line"></span><br><span class="line">Make sure JMeter can access the server.</span><br><span class="line">确保JMeter可以访问服务器。</span><br><span class="line"></span><br><span class="line">Make sure you use the same version of JMeter and Java on all the systems. Mixing versions will not work correctly.</span><br><span class="line">确保在所有系统上使用相同版本的JMeter和Java。 混合版本将无法正常工作。</span><br><span class="line"></span><br><span class="line">You have setup SSL for RMI or disabled it.</span><br><span class="line">您已为RMI设置SSL或将其禁用。</span><br><span class="line"></span><br><span class="line">官网地址 http:&#x2F;&#x2F;jmeter.apache.org&#x2F;usermanual&#x2F;jmeter_distributed_testing_step_by_step.html</span><br><span class="line"></span><br><span class="line">压测注意事项：一定要用内网IP，不用用公网IP,用ping去检查</span><br></pre></td></tr></table></figure><h2 id="2、专业名字"><a href="#2、专业名字" class="headerlink" title="2、专业名字"></a>2、专业名字</h2><p>master:司令 slave：</p><p>奴隶 target：目标</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>地址：<span class="exturl" data-url="aHR0cDovL2ptZXRlci5hcGFjaGUub3JnL2ltYWdlcy9zY3JlZW5zaG90cy9kaXN0cmlidXRlZC1uYW1lcy5zdmc=" title="http://jmeter.apache.org/images/screenshots/distributed-names.svg">http://jmeter.apache.org/images/screenshots/distributed-names.svg<i class="fa fa-external-link"></i></span> </p><p>地址：<span class="exturl" data-url="aHR0cDovL2ptZXRlci5hcGFjaGUub3JnL2ltYWdlcy9zY3JlZW5zaG90cy9kaXN0cmlidXRlZC1qbWV0ZXIuc3Zn" title="http://jmeter.apache.org/images/screenshots/distributed-jmeter.svg">http://jmeter.apache.org/images/screenshots/distributed-jmeter.svg<i class="fa fa-external-link"></i></span></p><h2 id="3、远程拷贝-内网地址-："><a href="#3、远程拷贝-内网地址-：" class="headerlink" title="3、远程拷贝(内网地址)："></a>3、远程拷贝(内网地址)：</h2><p>scp -r /usr/local/software/jdk-8u141-linux-x64.tar.gz <span class="exturl" data-url="aHR0cDovL21haWx0bzpyb290QDE3Mi4xOC4yMzAuMjMz" title="http://mailto:root@172.18.230.233">root@172.18.230.233<i class="fa fa-external-link"></i></span>:/usr/local/software</p><p>scp -r /usr/local/software/jmeter/apache-jmeter-4.0.tgz <span class="exturl" data-url="aHR0cDovL21haWx0bzpyb290QDE3Mi4xOC4yMzAuMjMz" title="http://mailto:root@172.18.230.233">root@172.18.230.233<i class="fa fa-external-link"></i></span>:/usr/local/software/jmeter</p><h2 id="4、启动"><a href="#4、启动" class="headerlink" title="4、启动"></a>4、启动</h2><p>./jmeter-server 或者 nohup ./jmeter-server &amp;</p><h2 id="5、检查启动是否成功"><a href="#5、检查启动是否成功" class="headerlink" title="5、检查启动是否成功"></a>5、检查启动是否成功</h2><p>ps -ef|grep jmeter-server</p><p>ps aux|grep jmeter-server</p><h1 id="17、Jmeter分布式压测"><a href="#17、Jmeter分布式压测" class="headerlink" title="17、Jmeter分布式压测"></a>17、Jmeter分布式压测</h1><h2 id="本地非GUI分布式压测-r"><a href="#本地非GUI分布式压测-r" class="headerlink" title="本地非GUI分布式压测 -r"></a>本地非GUI分布式压测 -r</h2><p>jmeter -n -t /Users/jack/Desktop/remote.jmx -r -l /Users/jack/Desktop/jtl/result.jtl -e -o /Users/jack/Desktop/result</p><h2 id="压测结果"><a href="#压测结果" class="headerlink" title="压测结果"></a>压测结果</h2><p>./jmeter -n -t /Users/jack/Desktop/remote.jmx -r -l /Users/jack/Desktop/jtl/result.jtl -e -o /Users/jack/Desktop/result</p><h2 id="压测报告"><a href="#压测报告" class="headerlink" title="压测报告"></a>压测报告</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Creating summariser &lt;summary&gt;</span><br><span class="line">Created the tree successfully using &#x2F;Users&#x2F;jack&#x2F;Desktop&#x2F;remote.jmx</span><br><span class="line">Configuring remote engine: 172.20.10.3:8899</span><br><span class="line">Using local port: 8899</span><br><span class="line">Configuring remote engine: 172.20.10.11:8899</span><br><span class="line">Starting remote engines</span><br><span class="line">Starting the test @ Thu Mar 29 23:21:13 CST 2018 (1522336873931)</span><br><span class="line">Remote engines have been started</span><br><span class="line">Waiting for possible Shutdown&#x2F;StopTestNow&#x2F;Heapdump message on port 4445</span><br><span class="line">summary &#x3D;      4 in 00:00:22 &#x3D;    0.2&#x2F;s Avg:  5582 Min:    94 Max: 21006 Err:     1 (25.00%)</span><br><span class="line">Tidying up remote @ Thu Mar 29 23:21:36 CST 2018 (1522336896842)</span><br><span class="line">... end of run</span><br></pre></td></tr></table></figure><h2 id="压测修改master节点信息"><a href="#压测修改master节点信息" class="headerlink" title="压测修改master节点信息"></a>压测修改master节点信息</h2><p>jemeter.properties 值是slave机器的ip+端口号，如果有多个，用逗号分隔 remote_hosts=192.168.0.102:8899,192.168.0.101:8899 server.rmi.ssl.disable=true (前面有说到)</p><h2 id="启动slave机器，注意要同个网段，ip地址用内网ip"><a href="#启动slave机器，注意要同个网段，ip地址用内网ip" class="headerlink" title="启动slave机器，注意要同个网段，ip地址用内网ip"></a>启动slave机器，注意要同个网段，ip地址用内网ip</h2><p>./jmeter-server Using local port: 8899 Created remote object: UnicastServerRef2 [liveRef: [endpoint:<span class="exturl" data-url="aHR0cDovL2xvY2Fs" title="http://local">192.168.0.102:8899<i class="fa fa-external-link"></i></span>,objID:[3a585a4d:162724586ab:-7fff, 3963132813614033916]]]</p><h2 id="相关资料："><a href="#相关资料：" class="headerlink" title="相关资料："></a>相关资料：</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vRmluZS1DaGFuL3AvNjIzMzgyMy5odG1s" title="https://www.cnblogs.com/Fine-Chan/p/6233823.html">https://www.cnblogs.com/Fine-Chan/p/6233823.html<i class="fa fa-external-link"></i></span> <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdWppbmdxaXUvYXJ0aWNsZS9kZXRhaWxzLzUyNjM1Mjg5aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vcHVyZXNvdWwvcC80ODQ0NTM5Lmh0bWw=" title="https://blog.csdn.net/liujingqiu/article/details/52635289https://www.cnblogs.com/puresoul/p/4844539.html">https://blog.csdn.net/liujingqiu/article/details/52635289https://www.cnblogs.com/puresoul/p/4844539.html<i class="fa fa-external-link"></i></span></p><h1 id="18-、测试基本内容"><a href="#18-、测试基本内容" class="headerlink" title="18.、测试基本内容"></a>18.、测试基本内容</h1><p><strong>配置元件=》前置处理器=》定时器=》采样器=》后置处理器=》断言=》监听器</strong></p><h1 id="19、安装常见问题"><a href="#19、安装常见问题" class="headerlink" title="19、安装常见问题"></a>19、安装常见问题</h1><h2 id="1、问题：无法解析"><a href="#1、问题：无法解析" class="headerlink" title="1、问题：无法解析"></a>1、问题：无法解析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz95j86y235aroi85ht0Z bin]# .&#x2F;jmeter-server</span><br><span class="line">Created remote object: UnicastServerRef2 [liveRef: [endpoint:[:39308](local),objID:[24e78a63:16243c70661:-7fff, 7492480871343944173]]]</span><br><span class="line">Server failed to start: java.rmi.RemoteException: Cannot start. Unable to get local host IP address.; nested exception is:</span><br><span class="line">java.net.UnknownHostException: iZwz95j86y235aroi85ht0Z: iZwz95j86y235aroi85ht0Z: Name or service not known</span><br><span class="line">An error occurred: Cannot start. Unable to get local host IP address.; nested exception is:</span><br><span class="line">java.net.UnknownHostException: iZwz95j86y235aroi85ht0Z: iZwz95j86y235aroi85ht0Z: Name or service not known</span><br></pre></td></tr></table></figure><h3 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hostname  命令获取机器名称，追加一个映射  iZwz95j86y235aroi85ht0Z</span><br><span class="line">vim &#x2F;etc&#x2F;hosts</span><br><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line">120.79.160.143 iZwz95j86y235aroi85ht0Z</span><br><span class="line"></span><br><span class="line">windows用户 修改c:\windows\system32\drivers\etc\hosts文件，增加一条域名 与IP的映射</span><br></pre></td></tr></table></figure><h2 id="2-问题：禁用了SSL"><a href="#2-问题：禁用了SSL" class="headerlink" title="2.问题：禁用了SSL"></a>2.问题：禁用了SSL</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz95j86y235aroi85ht0Z bin]# .&#x2F;jmeter-server</span><br><span class="line">Server failed to start: java.rmi.server.ExportException: Listen failed on port: 0; nested exception is:</span><br><span class="line">java.io.FileNotFoundException: rmi_keystore.jks (No such file or directory)</span><br><span class="line">An error occurred: Listen failed on port: 0; nested exception is:</span><br><span class="line">java.io.FileNotFoundException: rmi_keystore.jks (No such file or directory)</span><br></pre></td></tr></table></figure><h3 id="解决：-1"><a href="#解决：-1" class="headerlink" title="解决："></a>解决：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">拥有RMI over SSL的有效密钥库，或者禁用了SSL。</span><br><span class="line">1、禁用SSL</span><br><span class="line">  jmeter.property里面 server.rmi.ssl.disable 改为 true，表示禁用</span><br></pre></td></tr></table></figure><h2 id="3、问题："><a href="#3、问题：" class="headerlink" title="3、问题："></a>3、问题：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ949uw2xehZ bin]# .&#x2F;jmeter</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: INFO: os::commit_memory(0x00000000c0000000, 1073741824, 0) failed; error&#x3D;&#39;Cannot allocate memory&#39; (errno&#x3D;12)</span><br><span class="line">#</span><br><span class="line"># There is insufficient memory for the Java Runtime Environment to continue.</span><br><span class="line"># Native memory allocation (mmap) failed to map 1073741824 bytes for committing reserved memory.</span><br><span class="line"># An error report file with more information is saved as:</span><br><span class="line"># &#x2F;usr&#x2F;local&#x2F;jmeter&#x2F;apache-jmeter-4.0&#x2F;bin&#x2F;hs_err_pid5855.log</span><br></pre></td></tr></table></figure><h3 id="解决：-2"><a href="#解决：-2" class="headerlink" title="解决："></a>解决：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">编辑jmeter</span><br><span class="line">搜索 : &quot;$&#123;HEAP:&#x3D;&quot;-Xms1g -Xmx1g -XX:MaxMetaspaceSize&#x3D;256m&quot;&#125;&quot;</span><br><span class="line">改变初始堆内存和最大堆内存</span><br></pre></td></tr></table></figure><h2 id="4、仅修改-server-port-即可-下面两者一样"><a href="#4、仅修改-server-port-即可-下面两者一样" class="headerlink" title="4、仅修改 server_port 即可,下面两者一样"></a>4、仅修改 server_port 即可,下面两者一样</h2><p>server.rmi.localport=8899 表示slave server启动显示的端口</p><p>server_port=8899 表示master机器要远程连接的端口 即 remote_hosts=xxxx:8899</p><h2 id="5、—–"><a href="#5、—–" class="headerlink" title="5、—–"></a>5、—–</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- jmeter 分布式性能测试（多网卡配置） --&gt;</span><br><span class="line">我们要在多网卡的服务器上开启RMI服务的话必须指定IP，使他们能够在同一个网段内。 </span><br><span class="line"></span><br><span class="line">需要以下几步（假定所有机器都在10.120.11.*网段,agent服务器为linux,controller服务器为windows）：</span><br><span class="line"></span><br><span class="line">1、 修改agent服务器，指定agent机器的IP</span><br><span class="line">修改jmeter-server文件</span><br><span class="line"># vi jmeter-server</span><br><span class="line">修改RMI_HOST_DEF&#x3D;-Djava.rmi.server.hostname&#x3D;xxx.xxx.xxx.xxx(需要连接的IP)</span><br><span class="line"></span><br><span class="line">2、修改server服务器，指定server机器的IP</span><br><span class="line"></span><br><span class="line">修改jmeter.bat文件 </span><br><span class="line"></span><br><span class="line">新增set rmi_host&#x3D;-Djava.rmi.server.hostname&#x3D;10.120.11.214</span><br><span class="line"></span><br><span class="line">修改set ARGS&#x3D;%DUMP% %HEAP% %NEW% %SURVIVOR% %TENURING% %PERM% %DDRAW% %rmi_host%</span><br></pre></td></tr></table></figure><h2 id="6、确定在controller机器上安装jdk-版本和jmeter一致，配置环境变量：Java-home等"><a href="#6、确定在controller机器上安装jdk-版本和jmeter一致，配置环境变量：Java-home等" class="headerlink" title="6、确定在controller机器上安装jdk,版本和jmeter一致，配置环境变量：Java_home等"></a>6、确定在controller机器上安装jdk,版本和jmeter一致，配置环境变量：Java_home等</h2><ul><li>在Agent机器上安装jdk，配置环境变量：Java_home和JMeter_home</li><li>安装目录不要带空格，最好都是简短的英文路径</li></ul><h2 id="7、master机器启动后会拷贝jmx文件到slave机器，所以不需要在每台slave机器上也上传一份jmx，只需要在master机器上上传一份jmx脚本即可。"><a href="#7、master机器启动后会拷贝jmx文件到slave机器，所以不需要在每台slave机器上也上传一份jmx，只需要在master机器上上传一份jmx脚本即可。" class="headerlink" title="7、master机器启动后会拷贝jmx文件到slave机器，所以不需要在每台slave机器上也上传一份jmx，只需要在master机器上上传一份jmx脚本即可。"></a>7、master机器启动后会拷贝jmx文件到slave机器，所以不需要在每台slave机器上也上传一份jmx，只需要在master机器上上传一份jmx脚本即可。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果使用csv进行参数化，则需要把参数文件在每台slave上拷一份且路径需要设置成一样的。</span><br><span class="line"></span><br><span class="line">总样本数 &#x3D; 线程数 * 循环次数 * 执行机总数</span><br></pre></td></tr></table></figure><h2 id="8、连接失败原因排查"><a href="#8、连接失败原因排查" class="headerlink" title="8、连接失败原因排查"></a>8、连接失败原因排查</h2><h4 id="以下步骤进行排查："><a href="#以下步骤进行排查：" class="headerlink" title="以下步骤进行排查："></a>以下步骤进行排查：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. jmeter-server是否启动；</span><br><span class="line">2. 是否联网</span><br><span class="line">3. ping 服务器IP是否畅通.</span><br><span class="line">4. telnet 端口 192.168.3.10 1099</span><br><span class="line">5. 检查服务器的防火墙是否关闭。</span><br><span class="line">6. 阿里云安全策略是否正常</span><br></pre></td></tr></table></figure><h2 id="9、”could-not-find-ApacheJmeter-core-jar”"><a href="#9、”could-not-find-ApacheJmeter-core-jar”" class="headerlink" title="9、”could not find ApacheJmeter_core.jar”"></a>9、”could not find ApacheJmeter_core.jar”</h2><p>​    <strong>解决：在Agent机器安装jdk，并设置环境变量</strong></p><h2 id="10、”Bad-call-to-remote-host”"><a href="#10、”Bad-call-to-remote-host”" class="headerlink" title="10、”Bad call to remote host”"></a>10、”Bad call to remote host”</h2><p>解决：检查被控制机器上的jmeter-server有没有启动，或者remote_hosts的配置是否正确。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      学习如何使用jmeter压力测试
    
    </summary>
    
    
      <category term="Java" scheme="https://whitestore.top/categories/Java/"/>
    
    
      <category term="Java" scheme="https://whitestore.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Java】Mastering Backend Development with Java</title>
    <link href="https://whitestore.top/2023/09/07/masteringjava/"/>
    <id>https://whitestore.top/2023/09/07/masteringjava/</id>
    <published>2023-09-07T06:03:14.000Z</published>
    <updated>2023-09-09T00:53:49.935Z</updated>
    
    <content type="html"><![CDATA[<p>#springboot</p><h1 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h1><p><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BpdHpuaWhhbC9tYXN0ZXJpbmctYmFja2VuZC1kZXZlbG9wbWVudC13aXRoLWphdmEtc3ByaW5nLWJvb3QtYmVzdC1wcmFjdGljZXMtYW5kLXByby10aXBzLTNmYzBmNTAxNDE4ZQ==" title="https://medium.com/@itznihal/mastering-backend-development-with-java-spring-boot-best-practices-and-pro-tips-3fc0f501418e">Mastering Backend Development with Java Spring Boot: Best Practices and Pro Tips | by Nihal Parmar | Medium<i class="fa fa-external-link"></i></span></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230907131707.png" alt="image.png"></p><p>Spring Boot is a widely used and very popular enterprise-level high-performance framework. </p><p>Spring Boot 是一种广泛使用且非常流行的企业级高性能框架。</p><p>Here are some best practices and a few tips you can use to improve your Spring Boot application and make it more efficient. </p><p>以下是一些最佳实践和技巧，您可以用来改进 Spring Boot 应用程序，使其更加高效。</p><p>This article will be a little longer, and it will take some time to completely read the article.</p><p>本文篇幅稍长，完整阅读需要耗费不少时间。</p><a id="more"></a><h1 id="Proper-packaging-style-适当的包装风格"><a href="#Proper-packaging-style-适当的包装风格" class="headerlink" title="Proper packaging style  适当的包装风格"></a>Proper packaging style  适当的包装风格</h1><ul><li><p>Proper packaging will help to understand the code and the flow of the application easily.</p></li><li><p>适当的包装有助于轻松理解代码和应用程序的流程。</p></li><li><p>You can structure your application with meaningful packaging.</p></li><li><p>您可以通过有意义的打包来构建应用程序。</p></li><li><p>You can include all your controllers into a separate package, services in a separate package, util classes into a separate package…etc. This style is very convenient in small-size microservices.</p></li><li><p>您可以将所有<code>controller</code>打包成一个单独的包，将服务打包成一个单独的包，将 <code>util</code> 类打包成一个单独的包……等等。这种风格在小型微服务中非常方便。</p></li><li><p>If you are working on a huge code base, a feature-based approach can be used. You can decide on your requirement.</p></li><li><p>如果您正在处理庞大的代码库，则可以使用基于功能的方法。您可以根据自己的需求来决定。</p></li></ul><p><strong>Based on type</strong></p><p><strong>基于类型</strong></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230907131717.png" alt="image.png"></p><p><strong>Based on feature</strong></p><p><strong>基于功能</strong></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230907131741.png" alt="image.png"></p><h1 id="Use-design-patterns-使用设计模式"><a href="#Use-design-patterns-使用设计模式" class="headerlink" title="Use design patterns 使用设计模式"></a>Use design patterns 使用设计模式</h1><ul><li><p>No complaints. Design patterns are already best practices.</p></li><li><p>But you must identify the place where you can use them.</p></li><li><p>Please check this article to understand “<a href="https://www.javastackflow.com/2022/09/how-to-use-builder-design-pattern-with.html" target="_blank" rel="noopener"><strong><em>how to use the Builder design pattern</em></strong></a>” in our Spring Boot applications.</p></li><li><p>不要埋怨。设计模式已经是最佳实践。</p></li><li><p>但您必须确定可以使用它们的地方。</p></li><li><p>请查看本文以了解：”<a href="https://www.javastackflow.com/2022/09/how-to-use-builder-design-pattern-with.html" target="_blank" rel="noopener"><strong><em>如何在 Spring Boot 应用程序中使用生成器设计模式</em></strong></a>“。</p></li></ul><h1 id="Use-Spring-Boot-starters-使用-Spring-Boot-启动器"><a href="#Use-Spring-Boot-starters-使用-Spring-Boot-启动器" class="headerlink" title="Use Spring Boot starters 使用 Spring Boot 启动器"></a>Use Spring Boot starters 使用 Spring Boot 启动器</h1><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230907131756.png" alt="image.png"></p><p>Image: <span class="exturl" data-url="aHR0cHM6Ly93d3cubWVycmlhbS13ZWJzdGVyLmNvbS93b3Jkcy1hdC1wbGF5L25hbWVzLW9mLWFwcGV0aXplcnM=" title="https://www.merriam-webster.com/words-at-play/names-of-appetizers">https://www.merriam-webster.com/words-at-play/names-of-appetizers<i class="fa fa-external-link"></i></span></p><ul><li><p>This is a cool feature of Spring Boot.</p></li><li><p>这是 Spring Boot 的一个很酷的功能。</p></li><li><p>We can very easily use starter dependencies without adding single dependencies one by one. These starter dependencies are already bundled with the required dependencies.</p></li><li><p>我们可以非常轻松地使用启动依赖，而无需逐个添加单个依赖。这些启动依赖已经与所需的依赖捆绑在一起。</p></li><li><p>For example, if we add <strong>spring-boot-starter-web</strong> dependency，by default,  it is bundled with <strong>jackson, spring-core, spring-mvc, and spring-boot-starter-tomcat dependencies</strong>.</p></li><li><p>例如，如果我们添加了<strong>spring-boot-starter-web</strong>依赖，默认情况下，它与 <strong>jackson、spring-core、spring-mvc 和 spring-boot-starter-tomcat 依赖</strong>捆绑在一起。</p></li><li><p>So we don’t need to care about adding dependencies separately.</p></li><li><p>因此，我们无需单独添加依赖。</p></li><li><p>And also it helps us to avoid version mismatches.</p></li><li><p>此外，它还能帮助我们避免版本不匹配。</p><h1 id="Use-proper-versions-of-the-dependencies-使用正确的依赖版本"><a href="#Use-proper-versions-of-the-dependencies-使用正确的依赖版本" class="headerlink" title="Use proper versions of the dependencies 使用正确的依赖版本"></a>Use proper versions of the dependencies 使用正确的依赖版本</h1></li><li><p>It is always recommended to use the latest stable <strong>GA</strong> versions.</p></li><li><p>建议始终使用最新的稳定<strong>GA</strong>版本。</p></li><li><p>Sometimes it may vary with the Java version, server versions, the type of the application…etc.</p></li><li><p>有时可能会因 Java 版本、服务器版本、应用程序类型……等而有所不同。</p></li><li><p>Do not use different versions of the same package and always use &lt; properties&gt; to specify the version if there are multiple dependencies.</p></li><li><p>不要使用同一软件包的不同版本，如果存在多个依赖关系，应始终使用 &lt; properties&gt; 来指定版本。</p></li></ul><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230907131843.png" alt="image.png"></p><h1 id="Use-Lombok-使用-Lombok"><a href="#Use-Lombok-使用-Lombok" class="headerlink" title="Use Lombok 使用 Lombok"></a>Use Lombok 使用 Lombok</h1><ul><li><p>As a Java developer, you have probably heard of the <strong>Lombok project</strong>.</p></li><li><p>Lombok is a Java library that can be used to reduce your codes and allow you to write clean code using its annotations.</p></li><li><p>For example, you may use plenty of lines for getters and setters in some classes like entities, request/response objects, dtos…etc.</p></li><li><p>But if you use Lombok, it is just one line, you can use <strong>@Data, @Getter</strong> or <strong>@Setter</strong> as per your requirement.</p></li><li><p>You can use <strong><em>Lombok</em></strong> logger annotations as well. <strong><em>@Slf4j</em></strong> is recommended.</p></li><li><p>Check this <a href="https://github.com/raviyasas/springboot-gcs-demo/blob/master/src/main/java/com/app/entity/InputFile.java" target="_blank" rel="noopener"><strong><em>file</em></strong></a> for your reference.</p></li><li><p>作为一名 Java 开发人员，您可能听说过<strong>Lombok 项目</strong>。</p></li><li><p><code>Lombok</code> 是一个 Java 库，可用于减少代码，并允许您使用其注解编写简洁的代码。</p></li><li><p>例如，在一些类（如实体、请求/响应对象、dtos……等）中，您可能会使用大量的行来表示 <code>getters</code> 和 <code>setters</code>。</p></li><li><p>但如果使用 <strong>Lombok</strong>，则只需一行，您可以根据需要使用 <strong>@Data</strong>、<strong>@Getter</strong> 或 <strong>@Setter</strong>。</p></li><li><p>您还可以使用 <strong><em>Lombok</em></strong> 日志注释。 建议使用 <strong><em>@Slf4j</em></strong>。</p></li><li><p>请查看此 <a href="https://github.com/raviyasas/springboot-gcs-demo/blob/master/src/main/java/com/app/entity/InputFile.java" target="_blank" rel="noopener"><strong><em>file</em></strong></a>，以供参考。</p><h1 id="Use-constructor-injection-with-Lombok-使用-Lombok-注入构造函数"><a href="#Use-constructor-injection-with-Lombok-使用-Lombok-注入构造函数" class="headerlink" title="Use constructor injection with Lombok 使用 Lombok 注入构造函数"></a>Use constructor injection with Lombok 使用 Lombok 注入构造函数</h1></li></ul><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230907131901.png" alt="image.png"></p><ul><li><p>When we talk about dependency injection, there are two types.</p></li><li><p>当我们谈论依赖注入时，有两种类型。</p></li><li><p>One is “<strong>constructor injection</strong>” and the other is “<strong>setter injection</strong>”. Apart from that, you can also use “<strong>field injection</strong>” using the very popular <strong>@Autowired</strong> annotation.</p></li><li><p>一种是 “<strong>构造器注入</strong>“，另一种是 “<strong>设置器注入</strong>“。除此之外，你还可以使用非常流行的<strong>@Autowired</strong>注解来进行 “ <strong>字段注入</strong> “。</p></li><li><p>But we highly recommend using <strong>Constructor injection</strong> over other types. Because it allows the application to initialize all required dependencies at the initialization time.</p></li><li><p>但我们强烈建议使用<strong>构造器注入</strong>，而不是其他类型。因为<strong>它允许应用程序在初始化时初始化所有需要的依赖关系</strong>。</p></li><li><p>This is very useful for unit testing.</p></li><li><p>这对<strong>单元测试</strong>非常有用。</p></li><li><p>The important thing is, that we can use the <strong>@RequiredArgsConstructor</strong> annotation by Lombok to use constructor injection.</p></li><li><p>重要的是，我们可以使用 Lombok 的 <strong>@RequiredArgsConstructor</strong> 注解来使用构造器注入。</p></li><li><p>Check this <a href="https://github.com/raviyasas/springboot-gcs-demo/blob/master/src/main/java/com/app/controller/FileController.java" target="_blank" rel="noopener"><em>sample controller</em></a> for your reference.</p></li><li><p>请查看 <a href="https://github.com/raviyasas/springboot-gcs-demo/blob/master/src/main/java/com/app/controller/FileController.java" target="_blank" rel="noopener"><em>sample controller</em></a> 以供参考。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.app.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.app.entity.InputFile;</span><br><span class="line"><span class="keyword">import</span> com.app.service.FileService;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/api/v1/files"</span>)</span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(FileController<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FileService fileService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(consumes = &#123;MediaType.MULTIPART_FORM_DATA_VALUE&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;InputFile&gt; <span class="title">addFile</span><span class="params">(@RequestParam(<span class="string">"files"</span>)</span>MultipartFile[] files)</span>&#123;</span><br><span class="line">        LOGGER.debug(<span class="string">"Call addFile API"</span>);</span><br><span class="line">        <span class="keyword">return</span> fileService.uploadFiles(files);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Use-slf4j-logging-使用-slf4j-日志"><a href="#Use-slf4j-logging-使用-slf4j-日志" class="headerlink" title="Use slf4j logging 使用 slf4j 日志"></a>Use slf4j logging 使用 slf4j 日志</h1><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230907131917.png" alt="image.png"></p><ul><li><p>Logging is very important.</p></li><li><p>If a problem occurs while your application is in production, logging is the only way to find out the root cause.</p></li><li><p>Therefore, you should think carefully before adding loggers, log message types, logger levels, and logger messages.</p></li><li><p>Do not use System.out.print()</p></li><li><p>Slf4j is recommended to use along with logback which is the default logging framework in Spring Boot.</p></li><li><p>Always use slf4j { } and avoid using String interpolation in logger messages. Because string interpolation consumes more memory.</p></li><li><p>Please check <a href="https://github.com/raviyasas/springboot-gcs-demo/blob/master/src/main/java/com/app/service/FileServiceImpl.java" target="_blank" rel="noopener"><em>this file</em></a> for your reference to get an idea about, implementing a logger.</p></li><li><p>==You can use Lombok== ==<strong><em>@Slf4j</em></strong>== ==<em>annotation to create a logger very easily.</em>==</p></li><li><p>If you are in a micro-services environment, you can use the ELK stack.</p></li><li><p>日志记录非常重要。  </p></li><li><p>如果应用程序在生产过程中出现问题，日志记录是找出根本原因的唯一途径。  </p></li><li><p>因此，在添加日志记录器、日志消息类型、日志记录器级别和日志记录器消息之前，应仔细考虑。  </p></li><li><p><strong>不要使用 System.out.print()</strong></p></li><li><p>建议使用 <code>Slf4j</code> 和 <code>logback</code>，后者是 <code>Spring Boot</code> 的默认日志框架。  </p></li><li><p>始终使用 slf4j { }，避免在日志记录器消息中使用字符串插值。因为字符串插值会消耗更多内存。  </p></li><li><p>请查看 <a href="https://github.com/raviyasas/springboot-gcs-demo/blob/master/src/main/java/com/app/service/FileServiceImpl.java" target="_blank" rel="noopener"><em>此文件</em></a> 以了解如何实现日志记录器，供您参考。  </p></li><li><p>===你可以使用 Lombok== ==<strong><em>@Slf4j</em></strong>== ==_annotation 来轻松创建日志记录器。  </p></li><li><p>如果你身处微服务环境，可以使用 ELK 栈。  </p></li></ul><h1 id="Use-Controllers-only-for-routing-仅在路由时使用控制器"><a href="#Use-Controllers-only-for-routing-仅在路由时使用控制器" class="headerlink" title="Use Controllers only for routing 仅在路由时使用控制器"></a>Use Controllers only for routing 仅在路由时使用控制器</h1><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230907133704.png" alt="image.png"></p><ul><li><p>Controllers are dedicated to routing.</p></li><li><p>It is <strong>stateless</strong> and <strong>singleton</strong>.</p></li><li><p>The DispatcherServlet will check the <em>@RequestMapping</em> on <em>Controllers</em></p></li><li><p>Controllers are the ultimate target of requests, then requests will be handed over to the service layer and processed by the service layer.</p></li><li><p>The business logic <strong>should not be</strong> in the controllers.</p></li><li><p>控制器专用于路由。</p></li><li><p>它是<strong>无状态</strong>和<strong>单例</strong>。</p></li><li><p>DispatcherServlet 会检查控制器上的 <em>@RequestMapping</em> 。</p></li><li><p>控制器是请求的最终目标，然后请求将被移交给服务层并由服务层处理。</p></li><li><p>业务逻辑<strong>不应该</strong>在控制器中。</p><h1 id="Use-Services-for-business-logic-业务逻辑使用服务"><a href="#Use-Services-for-business-logic-业务逻辑使用服务" class="headerlink" title="Use Services for business logic 业务逻辑使用服务"></a>Use Services for business logic 业务逻辑使用服务</h1></li><li><p>The <strong>complete business logic goes here</strong> with validations, caching…etc.</p></li><li><p>Services communicate with the persistence layer and receive the results.</p></li><li><p>Services are also singleton.</p></li><li><p>这里***完整的业务逻辑，包括验证、缓存……等。</p></li><li><p>服务与持久层通信并接收结果。</p></li><li><p>服务也是单例的。</p></li></ul><blockquote><p><em>Bonus article:</em> <a href="https://medium.com/@raviyasas/why-stress-and-how-to-manage-it-as-a-software-engineer-204b4e21ed9" target="_blank" rel="noopener"><em>Manage stress as a Software Engineer</em></a></p><p><em>Bonus article:</em> <a href="https://medium.com/@raviyasas/why-stress-and-how-to-manage-it-as-a-software-engineer-204b4e21ed9" target="_blank" rel="noopener"><em>Manage stress as a Software Engineer</em></a></p></blockquote><h1 id="Avoid-NullPointerException-避免-NullPointerException"><a href="#Avoid-NullPointerException-避免-NullPointerException" class="headerlink" title="Avoid NullPointerException 避免 NullPointerException"></a>Avoid NullPointerException 避免 NullPointerException</h1><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230907134658.png" alt="image.png"></p><ul><li><p>To avoid <strong>NullPointerException</strong> you can use <strong>Optional</strong> from java.util package.</p></li><li><p>You can also use null-safe libraries. Ex: <strong>Apache Commons StringUtils</strong></p></li><li><p>Call <strong>equals()</strong> and <strong>equalsIgnoreCase()</strong> methods on known objects.</p></li><li><p>Use <strong>valueOf()</strong> over <strong>toString()</strong></p></li><li><p>Use IDE-based <strong>@NotNull</strong> and <strong>@Nullable</strong> annotations.</p></li><li><p>避免<strong>NullPointerException</strong>，您可以使用 java.util 包中的<strong>Optional</strong>。</p></li><li><p>您还可以使用空安全库。例如：<strong>Apache Commons StringUtils</strong></p></li><li><p>在已知对象上调用 <strong>equals()</strong> 和 <strong>equalsIgnoreCase()</strong> 方法。</p></li><li><p>使用 <strong>valueOf()</strong> 而非 <strong>toString()</strong></p></li><li><p>使用基于 IDE 的 <strong>@NotNull</strong> 和 <strong>@Nullable</strong> 注解。</p><h1 id="Use-best-practices-for-the-Collection-framework-使用Collection框架的最佳实践"><a href="#Use-best-practices-for-the-Collection-framework-使用Collection框架的最佳实践" class="headerlink" title="Use best practices for the Collection framework 使用Collection框架的最佳实践"></a>Use best practices for the Collection framework 使用Collection框架的最佳实践</h1></li><li><p>Use appropriate collection for your data set.</p></li><li><p>Use <strong>forEach</strong> with Java 8 features and avoid using legacy for loops.</p></li><li><p>Use <strong>interface type</strong> instead of the implementation.</p></li><li><p>Use <strong>isEmpty()</strong> over <strong>size()</strong> for better readability.</p></li><li><p>Do not return null values, you can return an empty collection.</p></li><li><p>If you are using objects as data to be stored in a hash-based collection, you should override equals() and hashCode() methods. Please check this article “<a href="https://medium.com/@raviyasas/how-a-hashmap-internally-works-93e3887978f3" target="_blank" rel="noopener"><em>How does a HashMap internally work</em></a>”.</p></li><li><p>针对数据集使用适当的集合。</p></li><li><p>使用 Java 8 Lambda 的 <strong>forEach</strong>，避免使用传统的 for 循环。</p></li><li><p>使用 <strong>接口类型</strong> 而不是具体实现。</p></li><li><p>使用 <strong>isEmpty()</strong>，而不是 <strong>size()</strong>，以获得更好的可读性。</p></li><li><p>不要返回空值，可以返回空集合。</p></li><li><p>如果使用对象作为数据存储在基于Hash的集合中，则应覆盖 equals() 和 hashCode() 方法。请查看本文”<a href="https://medium.com/@raviyasas/how-a-hashmap-internally-works-93e3887978f3" target="_blank" rel="noopener"><em>HashMap 内部如何工作</em></a>“。</p></li></ul><h1 id="Use-pagination-使用分页"><a href="#Use-pagination-使用分页" class="headerlink" title="Use pagination 使用分页"></a>Use pagination 使用分页</h1><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230907134647.png" alt="image.png"></p><ul><li><p>This will improve the performance of the application.</p></li><li><p>If you’re using <strong>Spring Data JPA</strong>, the <strong><em>PagingAndSortingRepository</em></strong> makes using pagination very easy and with little effort.</p></li><li><p>这将提高应用程序的性能。</p></li><li><p>如果你使用的是<strong>Spring Data JPA</strong>，那么 <strong><em>PagingAndSortingRepository</em></strong> 会让分页功能的使用变得非常简单，而且几乎不费吹灰之力。</p><h1 id="Use-caching-使用缓存"><a href="#Use-caching-使用缓存" class="headerlink" title="Use caching 使用缓存"></a>Use caching 使用缓存</h1></li><li><p>Caching is another important factor when talking about application performance.</p></li><li><p>By default Spring Boot provides caching with <strong>ConcurrentHashMap</strong> and you can achieve this by <strong>@EnableCaching</strong> annotation.</p></li><li><p>If you are not satisfied with default caching, you can use <strong>Redis</strong>, <strong>Hazelcast,</strong> or any other distributed caching implementations.</p></li><li><p>Redis and Hazelcast are <strong>in-memory</strong> caching methods. You also can use database cache implementations as well.</p></li><li><p>缓存是影响应用程序性能的另一个重要因素。</p></li><li><p>默认情况下，Spring Boot 通过 <strong>ConcurrentHashMap</strong> 提供缓存，您可以通过 <strong>@EnableCaching</strong> 注解实现缓存。</p></li><li><p>如果对默认缓存不满意，可以使用 <strong>Redis</strong>、<strong>Hazelcast</strong> 或其他分布式缓存实现。</p></li><li><p><strong>Redis</strong> 和 <strong>Hazelcast</strong> 是<strong>内存</strong>缓存方法。您也可以使用数据库缓存实现。</p><h1 id="Use-custom-exception-handler-with-global-exception-handling-使用自定义异常处理程序和全局异常处理"><a href="#Use-custom-exception-handler-with-global-exception-handling-使用自定义异常处理程序和全局异常处理" class="headerlink" title="Use custom exception handler with global exception handling 使用自定义异常处理程序和全局异常处理"></a>Use custom exception handler with global exception handling 使用自定义异常处理程序和全局异常处理</h1></li></ul><p><img src="https://miro.medium.com/v2/resize:fit:875/0*ErfHekfADhtYb8e9.png" alt=""></p><ul><li><p>This is very important when working with large enterprise-level applications.</p></li><li><p>Apart from the general exceptions, we may have some scenarios to identify some specific error cases.</p></li><li><p>Exception adviser can be created with <strong>@ControllerAdvice</strong> and we can create separate exceptions with meaningful details.</p></li><li><p>It will make it much easier to identify and debug errors in the future.</p></li><li><p>Please check <a href="https://github.com/raviyasas/springboot-exceptions-demo/tree/master/src/main/java/com/app/exception" target="_blank" rel="noopener"><em>this</em></a> and <a href="https://github.com/raviyasas/springboot-gcs-demo/tree/master/src/main/java/com/app/exception" target="_blank" rel="noopener"><em>this</em></a> for your reference.</p></li><li><p>在处理大型企业级应用程序时，这一点非常重要。</p></li><li><p>除了一般的异常情况外，我们可能还需要在某些情况下识别一些特定的错误案例。</p></li><li><p>可以使用 <strong>@ControllerAdvice</strong> 创建异常切面，我们可以创建具有有意义细节的单独异常。</p></li><li><p>这将大大方便今后识别和调试错误。</p></li><li><p>请查看 <a href="https://github.com/raviyasas/springboot-exceptions-demo/tree/master/src/main/java/com/app/exception" target="_blank" rel="noopener"><em>this</em></a> 和 <a href="https://github.com/raviyasas/springboot-gcs-demo/tree/master/src/main/java/com/app/exception" target="_blank" rel="noopener"><em>this</em></a>，以供参考。</p></li></ul><blockquote><p><em>Bonus article:</em> <a href="https://www.javastackflow.com/2022/09/what-is-serverless-architecture.html" target="_blank" rel="noopener"><em>What is serverless Architecture?</em></a></p><p><em>Bonus article:</em> <a href="https://www.javastackflow.com/2022/09/what-is-serverless-architecture.html" target="_blank" rel="noopener"><em>什么是无服务架构？</em></a></p></blockquote><h1 id="Use-custom-response-object-使用自定义响应对象"><a href="#Use-custom-response-object-使用自定义响应对象" class="headerlink" title="Use custom response object 使用自定义响应对象"></a>Use custom response object 使用自定义响应对象</h1><p><img src="https://miro.medium.com/v2/resize:fit:875/0*HsR7UP64pwDENvq8.png" alt=""></p><ul><li><p>A custom response object can be used to return an object with some specific data with the requirements like HTTP status code, API code, message…etc.</p></li><li><p>We can use the <strong>builder design pattern</strong> to create a custom response object with custom attributes.</p></li><li><p>Please check <a href="https://www.javastackflow.com/2022/09/how-to-use-builder-design-pattern-with.html" target="_blank" rel="noopener"><strong><em>this article</em></strong></a> for your reference.</p></li><li><p>自定义响应对象可用于返回带有某些特定数据的对象，这些数据应符合 HTTP 状态代码、API 代码、消息等要求。</p></li><li><p>我们可以使用 ** 生成器设计模式** 来创建带有自定义属性的自定义响应对象。</p></li><li><p>请查阅<a href="https://www.javastackflow.com/2022/09/how-to-use-builder-design-pattern-with.html" target="_blank" rel="noopener"><strong><em>本文</em></strong></a>以供参考。</p><h1 id="Remove-unnecessary-codes-variables-methods-and-classes-删除不必要的代码、变量、方法和类"><a href="#Remove-unnecessary-codes-variables-methods-and-classes-删除不必要的代码、变量、方法和类" class="headerlink" title="Remove unnecessary codes, variables, methods, and classes.  删除不必要的代码、变量、方法和类"></a>Remove unnecessary codes, variables, methods, and classes.  删除不必要的代码、变量、方法和类</h1></li></ul><p><img src="https://miro.medium.com/v2/resize:fit:875/0*I1A3DYUGTcDRdIQ2.png" alt=""></p><p>commented code in the production</p><p>生产中的注释代码</p><ul><li><p><strong>Unused variable</strong> declarations will acquire some memory.</p></li><li><p>Remove unused methods, classes…etc because it will impact the performance of the application.</p></li><li><p>Try to avoid nested loops. You can use maps instead.</p></li><li><p>未使用的变量，**声明会占用一些内存。</p></li><li><p>删除未使用的方法、类……等，因为这将影响应用程序的性能。</p></li><li><p>尽量避免嵌套循环。可以使用映射来代替。</p><h1 id="Using-comments-使用注释"><a href="#Using-comments-使用注释" class="headerlink" title="Using comments 使用注释"></a>Using comments 使用注释</h1></li><li><p>Commenting is a good practice unless you abuse it.</p></li><li><p>DO NOT comment on everything. Instead, you can write descriptive code using meaningful words for classes, functions, methods, variables…etc.</p></li><li><p>Remove commented codes, misleading comments, and story-type comments.</p></li><li><p>You can use comments for warnings and explain something difficult to understand at first sight.</p></li><li><p>注释是一种很好的做法，除非你滥用它。</p></li><li><p><strong>切勿对所有内容进行注释</strong>。相反，您可以使用有意义的词来描述类、函数、方法、变量……等，编写描述性代码。</p></li><li><p>删除<strong>注释代码</strong>、<strong>误导性注释</strong>和<strong>故事型注释</strong>。</p></li><li><p>您可以使用注释来警告和解释一些<strong>乍一看难以理解</strong>的内容。</p><h1 id="Use-meaningful-words-for-classes-methods-functions-variables-and-other-attributes-对类、方法、函数、变量和其他属性使用有意义的词语。"><a href="#Use-meaningful-words-for-classes-methods-functions-variables-and-other-attributes-对类、方法、函数、变量和其他属性使用有意义的词语。" class="headerlink" title="Use meaningful words for classes, methods, functions, variables, and other attributes. 对类、方法、函数、变量和其他属性使用有意义的词语。"></a>Use meaningful words for classes, methods, functions, variables, and other attributes. 对类、方法、函数、变量和其他属性使用有意义的词语。</h1></li></ul><p><img src="https://miro.medium.com/v2/resize:fit:875/0*uJmiodAstz6j0-1j.png" alt=""></p><ul><li><p>This looks very simple, but the impact is huge.</p></li><li><p>Always use proper <strong>meaningful and searchable</strong> naming conventions with proper case.</p></li><li><p>Usually, we use <strong>nouns or short phrases</strong> when declaring <strong>classes</strong>, <strong>variables</strong>, and <strong>constants</strong>. Ex: String firstName, const isValid</p></li><li><p>You can use <strong>verbs and short phrases with adjectives</strong> for <strong>functions</strong> and <strong>methods</strong>. Ex: readFile(), sendData()</p></li><li><p>Avoid using <strong>abbreviating variable</strong> names and <strong>intention revealing</strong> names. Ex: int i; String getExUsr;</p></li><li><p>If you use this meaningfully, declaration comment lines can be reduced. Since it has meaningful names, a fresh developer can easily understand by reading the code.</p></li><li><p>这看起来很简单，但影响却很大。</p></li><li><p>始终使用<strong>有意义且可搜索的</strong>命名规则，并使用正确的大小写。</p></li><li><p>通常，我们在声明<strong>类</strong>、<strong>变量</strong>和<strong>常量</strong>时使用<strong>名词或短语</strong>。例如：字符串 firstName、常量 isValid</p></li><li><p>在声明<strong>函数</strong>和<strong>方法</strong>时，可以使用<strong>谚语和带有形容词的短语</strong>。例如：readFile()、sendData()</p></li><li><p>避免使用<strong>缩略变量</strong>名和<strong>暴露想法</strong>名。例如：int i; String getExUsr；</p></li><li><p>如果使用这些有意义的名称，就可以减少声明注释行。由于使用了有意义的名称，新开发人员在阅读代码时很容易理解。</p><h1 id="Use-proper-case-for-declarations-在声明中使用合适的大小写"><a href="#Use-proper-case-for-declarations-在声明中使用合适的大小写" class="headerlink" title="Use proper case for declarations 在声明中使用合适的大小写"></a>Use proper case for declarations 在声明中使用合适的大小写</h1></li></ul><p><img src="https://miro.medium.com/v2/resize:fit:875/0*LWJF3cRbzU4wU09A.png" alt=""></p><ul><li><p>There are many different cases like <strong>UPPERCASE, lowercase, camelCase, PascalCase, snake_case, SCREAMING_SNAKE_CASE, kebab-case</strong>…etc.</p></li><li><p>But we need to identify which case is dedicated to which variable.</p></li><li><p>Usually, I follow,</p></li><li><p>有许多不同的大小写，如 <strong>大写、小写、骆驼大写、帕斯卡大写、蛇大写、SCREAMING_SNAKE_CASE、kebab-case</strong>……等等。</p></li><li><p>但我们需要确定哪个大小写专用于哪个变量。</p></li><li><p>通常，我是这样做的。</p></li></ul><p>classes — <strong>PascalCase</strong></p><p>methods &amp; variables — <strong>camelCase</strong></p><p>方法和变量–<strong>camelCase</strong></p><p>constants — <strong>SCREAMING_SNAKE_CASE</strong></p><p>常量 - <strong>SCREAMING_SNAKE_CASE</strong></p><p>DB-related fields — <strong>snake_case</strong></p><p>与 DB 相关的字段 - <strong>snake_case</strong></p><ul><li><p>This is just an example. It can be different from the standard you follow in the company.</p></li><li><p>这只是一个示例。它可能与您在公司中遵循的标准不同。</p><h1 id="Be-simple-保持简单"><a href="#Be-simple-保持简单" class="headerlink" title="Be simple 保持简单"></a>Be simple 保持简单</h1></li></ul><p><img src="https://miro.medium.com/v2/resize:fit:875/0*am8Xo9e4ngoABycE.png" alt=""></p><ul><li><p>Always try to write simple, readable codes.</p></li><li><p>The same simple logic can be implemented using different ways, but it is difficult to understand if it is not readable or understandable.</p></li><li><p>Sometimes complex logic consumes more memory.</p></li><li><p>Try to use <strong>KISS</strong>, <strong>DRY</strong>, and <strong>SOLID</strong> principles when writing codes. I will explain this in a future article.</p></li><li><p>始终尽量编写简单、可读的代码。</p></li><li><p>同样简单的逻辑可以用不同的方法实现，但如果不可读性或不可懂性，就很难理解。</p></li><li><p>有时复杂的逻辑会消耗更多内存。</p></li><li><p>在编写代码时，尽量使用<strong>KISS</strong>、<strong>DRY</strong>和<strong>SOLID</strong>原则。我将在今后的文章中对此进行解释。</p></li></ul><blockquote><p>DRY stands for “Don’s Repeat Yourself</p></blockquote><p>如果代码可以公用就尽量公用，不要复制粘贴代码。</p><blockquote><p>kiss：KISS stands for “Keep It Simple, Stupid”.</p></blockquote><p>KISS就是保持简单，愚蠢。这个愚蠢指的是方法最好只知道干一件事情。这两点和Unix最初的设计的理念是一样的，简单好用即是美。</p><p><strong>SOLID</strong>原则：</p><p><strong>Single Responsibility Principle</strong> 单一职责：每个类和接口有明确目标。</p><p><strong>Open-Closed Principle</strong> 开闭原则：开放扩展，封闭修改。</p><p><strong>Liskov Substitution Principle</strong> 里式替代：尽可能让代码多态。</p><p><strong>Interface Segregation Principle</strong> 接口隔离：实现接口替代类继承。</p><p><strong>Dependency Inversion Principle</strong> 依赖倒转原则：依赖抽象而不是依赖实现。</p><h1 id="Use-a-common-code-formatting-style-使用通用的代码格式样式"><a href="#Use-a-common-code-formatting-style-使用通用的代码格式样式" class="headerlink" title="Use a common code formatting style 使用通用的代码格式样式"></a>Use a common code formatting style 使用通用的代码格式样式</h1><p><img src="https://miro.medium.com/v2/resize:fit:875/0*IW4rJbi2sMKKak9P.png" alt=""></p><ul><li><p>Formatting styles vary from developer to developer. Coding style changes are also considered a change and can make code merging very difficult.</p></li><li><p>To avoid this, the team can have a common coding format.</p></li><li><p>格式风格因开发人员而异。编码风格的改变也被认为是一种改变，会使代码合并变得非常困难。</p></li><li><p>为了避免这种情况，团队可以采用统一的编码格式。</p></li></ul><h1 id="Use-SonarLint-使用-SonarLint"><a href="#Use-SonarLint-使用-SonarLint" class="headerlink" title="Use SonarLint 使用 SonarLint"></a>Use SonarLint 使用 SonarLint</h1><p><img src="https://miro.medium.com/v2/resize:fit:240/0*ChADmyd-l_RX102d.png" alt=""></p><ul><li><p>This is very useful for identifying small bugs and best practices to avoid unnecessary bugs and code quality issues.</p></li><li><p>这对识别小错误和最佳实践非常有用，可避免不必要的错误和代码质量问题。</p></li><li><p>You can install the plugin into your favorite IDE.</p></li><li><p>您可以将该插件安装到自己喜欢的集成开发环境中。</p></li></ul><p>Follow me for <em>new tidbits</em> on the <strong>domain of tech.</strong></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      请输入描述信息
    
    </summary>
    
    
      <category term="Java" scheme="https://whitestore.top/categories/Java/"/>
    
    
      <category term="Java" scheme="https://whitestore.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Obsidian Day-Planner 插件新版本使用（0.7.X以上版本）</title>
    <link href="https://whitestore.top/2023/09/06/obsidiandayplan/"/>
    <id>https://whitestore.top/2023/09/06/obsidiandayplan/</id>
    <published>2023-09-06T03:10:21.000Z</published>
    <updated>2023-09-09T00:53:49.932Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>这几天把 <strong>Obsidian</strong> 和<strong>Day-Planner</strong>插件做了升级，突然发现原来的<strong>时间视图</strong>不见了。</p><p>起初个人认为是新版本的Obsidian和插件不兼容，于是选择换成旧版本，后来看了一眼<strong>Day-Planner</strong>更新日志，才发现原来作者基本把插件重做了。</p><p>更新之后的<strong>Day-Planner</strong>插件和旧版本差别挺大，个人花了不少时间熟悉新版本，本文将介绍如何快速使用和适应新版本的<strong>Day-Planner</strong>插件。</p><a id="more"></a><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2l2YW4tbGVkbmV2L29ic2lkaWFuLWRheS1wbGFubmVy" title="https://github.com/ivan-lednev/obsidian-day-planner">GitHub - ivan-lednev/obsidian-day-planner: An Obsidian plugin for day planning and managing pomodoro timers from a task list in a Markdown note.<i class="fa fa-external-link"></i></span></p><h2 id="简单说明"><a href="#简单说明" class="headerlink" title="简单说明"></a>简单说明</h2><blockquote><p>0.7.0 significantly changes what the plugin looks like and what it does. If you like to have some of the old behaviors back, <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2l2YW4tbGVkbmV2L29ic2lkaWFuLWRheS1wbGFubmVyL2lzc3Vlcw==" title="https://github.com/ivan-lednev/obsidian-day-planner/issues">consider creating an issue<i class="fa fa-external-link"></i></span>.</p><p>If for some reason you still want to use the old version, there are community forks, which you can use via <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1RmVEhhY2tlci9vYnNpZGlhbjQyLWJyYXQ=" title="https://github.com/TfTHacker/obsidian42-brat">BRAT<i class="fa fa-external-link"></i></span>. <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2VidWxsaWVudC9vYnNpZGlhbi1kYXktcGxhbm5lci1vZw==" title="https://github.com/ebullient/obsidian-day-planner-og">Here is one such fork<i class="fa fa-external-link"></i></span>.</p></blockquote><p>Github的README部分说的很清楚了，作者在 0.7.X 之后对于 Day-Planner 插件的功能和界面进行<strong>重做</strong>，基本可以当做一个新插件使用。</p><p>如果习惯老版本的使用方式，可以进入下面的网站下载之后进行手动安装。</p><blockquote><p>这也意味着旧版本做任何扩展和维护</p></blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2VidWxsaWVudC9vYnNpZGlhbi1kYXktcGxhbm5lci1vZw==" title="https://github.com/ebullient/obsidian-day-planner-og">GitHub - ebullient/obsidian-day-planner-og: An Obsidian plugin for day planning and managing pomodoro timers from a task list in a Markdown note.<i class="fa fa-external-link"></i></span></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230905105427.png" alt="image.png"></p><h1 id="新版本如何使用？"><a href="#新版本如何使用？" class="headerlink" title="新版本如何使用？"></a>新版本如何使用？</h1><p>下面来看下新版本插件的使用流程。</p><h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>新版本的Day-Planner通过左侧的菜单栏访问：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230905120656.png" alt="image.png"></p><p>点击进入，发现这是一个“周计划”视图：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230905120752.png" alt="image.png"></p><p>功能设计有点类似 IOS系统的 的日历视图，在任意的时间轴可以做自己的时间规划，比如我们选择在 “<strong>9月4日的8点设置出门</strong>”：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230905121029.png" alt="image.png"></p><p>点击对应的时间区间，插件会在选中的区间生成“item”。</p><blockquote><p>注意下面的界面“New Item”可以上下拖动。</p></blockquote><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230905121153.png" alt="image.png"></p><p>它的时间范围对应如下，作者的设计思路是：“<strong>一个Item为半小时</strong>”，在周计划界面拖动 Item 也是<strong>以固定半小时的间隔动态调整</strong>。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230905121231.png" alt="image.png"></p><p>注意，它并没有（个人期望的）通过拖动“一长段”时间设置1到两个小时或者更长时间的规划，希望作者后续更新可以加入这项功能。</p><p>以上就是对于新版本插件的简单快速上手，说实话半小时的设置操作不是很方便，个人做了一些直接可以复制粘贴的<strong>每日规划模板</strong>，只需要按照所需的日志一键粘贴就可以快速上手内容，个人习惯是一小时为“一段”，分割一天为24份，具体效果可以继续阅读下文。</p><h2 id="个人模板"><a href="#个人模板" class="headerlink" title="个人模板"></a>个人模板</h2><h3 id="旧版本"><a href="#旧版本" class="headerlink" title="旧版本"></a>旧版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#日记</span><br><span class="line"></span><br><span class="line">## 每日记录模板</span><br><span class="line"></span><br><span class="line">- [ ] 06:00 - 07:00 </span><br><span class="line">- [ ] 07:00 - 08:00</span><br><span class="line">- [ ] 08:00 - 09:00</span><br><span class="line">- [ ] 09:00 - 10:00</span><br><span class="line">- [ ] 10:00 - 11:00</span><br><span class="line">- [ ] 11:00 - 12:00</span><br><span class="line">- [ ] 12:00 - 13:00</span><br><span class="line">- [ ] 13:00 - 14:00</span><br><span class="line">- [ ] 14:00 - 15:00</span><br><span class="line">- [ ] 15:00 - 16:00</span><br><span class="line">- [ ] 16:00 - 17:00</span><br><span class="line">- [ ] 17:00 - 18:00</span><br><span class="line">- [ ] 18:00 - 19:00</span><br><span class="line">- [ ] 19:00 - 20:00</span><br><span class="line">- [ ] 20:00 - 21:00</span><br><span class="line">- [ ] 21:00 - 22:00</span><br><span class="line">- [ ] 22:00 - 23:00</span><br><span class="line"></span><br><span class="line"># 规划</span><br><span class="line"></span><br><span class="line"># 输入</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line"></span><br><span class="line"># 专注详情</span><br></pre></td></tr></table></figure><h3 id="新版本"><a href="#新版本" class="headerlink" title="新版本"></a>新版本</h3><p>新版本的出现导致旧模板也需要做更新，对应新版本的插件做了下面的微调：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#日记</span><br><span class="line"># Day planner</span><br><span class="line"></span><br><span class="line">-  06:00 - 07:00 </span><br><span class="line">-  07:00 - 08:00</span><br><span class="line">-  08:00 - 09:00</span><br><span class="line">-  09:00 - 10:00</span><br><span class="line">- 10:00 - 11:00</span><br><span class="line">-  11:00 - 12:00</span><br><span class="line">- 12:00 - 13:00</span><br><span class="line">-  13:00 - 14:00</span><br><span class="line">- 14:00 - 15:00</span><br><span class="line">- 15:00 - 16:00</span><br><span class="line">- 16:00 - 17:00</span><br><span class="line">- 17:00 - 18:00</span><br><span class="line">- 18:00 - 19:00</span><br><span class="line">- 19:00 - 20:00</span><br><span class="line">- 20:00 - 21:00</span><br><span class="line">- 21:00 - 22:00</span><br><span class="line">-  22:00 - 23:00</span><br><span class="line"></span><br><span class="line"># 规划</span><br><span class="line"></span><br><span class="line"># 输入</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line"></span><br><span class="line"># 专注详情</span><br></pre></td></tr></table></figure><p>上面的内容复制黏贴到对应日期文件，就可以在对应的日期指定一个“基础模板”，当然从截图看效果怪怪的，其实只要根据自己的需要填写内容即可正常显示：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230905120752.png" alt="image.png"></p><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>需要注意，如果读者想修改上面提供自定义模板内容，顶部的<code># Day planner</code>这样的一级标题是必须要保留的，<strong>不能做任何调整</strong>。</p><p>为了方便理解，直接看下面两张图对比：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230905115513.png" alt="image.png"></p><p><code># Day planner</code>可以修改为多级标题，但是<code># Day planner</code>这个“关键词”的本身的文本不能做任何变更，否则就变成下面这样“诡异”的情况：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230905115437.png" alt="image.png"></p><p>这样的设计也可以理解，顺着作者的设计规划自己的模板即可。</p><h2 id="Ctrl-P-变化"><a href="#Ctrl-P-变化" class="headerlink" title="Ctrl + P 变化"></a>Ctrl + P 变化</h2><p>如果使用过旧版本Day-Planner，我们可以在<code>Obsidian</code>中使用<code>ctrl + P</code>的快捷按钮做快捷操作，没错，新版本插件这里的功能按钮也完全不一样了。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230905111854.png" alt="image.png"></p><p>下面按照从上往下的顺序，介绍截图每一项快捷指令的作用。</p><h3 id="1-展示本周的时间视图规划。"><a href="#1-展示本周的时间视图规划。" class="headerlink" title="1. 展示本周的时间视图规划。"></a>1. 展示本周的时间视图规划。</h3><ul><li><p>优点：和点击左边的按钮效果相同，优点是不需要动用鼠标靠键盘就可以快速访问 =v=。</p></li><li><p>缺点：会覆盖当前<code>Tab</code>，个人更希望新开<code>Tab</code>展示。</p><h3 id="2-进入当天的Day-Planner"><a href="#2-进入当天的Day-Planner" class="headerlink" title="2. 进入当天的Day-Planner"></a>2. 进入当天的Day-Planner</h3></li><li><p>PS：旧版本是在 Day Planners 的文件夹下面每日自动创建。</p></li><li><p>新版本：如果发现对应日期的md文件不存在，默认会在<code>Obsidian</code>的仓库 <strong>根目录</strong> 创建一个新的文件，命名格式如下：</p></li></ul><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230905112419.png" alt="2. 进入当天的Dat-Planner"></p><h3 id="3-展示时间线"><a href="#3-展示时间线" class="headerlink" title="3. 展示时间线"></a>3. 展示时间线</h3><p>第三个选项是时间线展示，选择之后<code>Obsidian</code>右边的视窗多一个“选项”，这样就可以看到<strong>当天的时间线</strong>（新版本外观重做了）：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230905113547.png" alt="image.png"></p><p>左右箭头是切换当前日期的上一天和下一天，右上角的按钮可以选择：</p><ul><li><p><strong>调节当前时间线的间隔</strong>。比如个人设置了Zoom的等级为1，整个时间线的间隔会窄一些。</p></li><li><p><strong>是否自动滚动到当前的时间点</strong>，假设现在7点50，就会自动定位到7点-8点这个时间段。</p></li></ul><blockquote><p>选择自动滚动，时间线会随着当前时间自动滚动定位：</p></blockquote><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230905113723.png" alt="image.png"></p><h3 id="4-插入-Day-planner"><a href="#4-插入-Day-planner" class="headerlink" title="4. 插入 Day planner"></a>4. 插入 Day planner</h3><p>效果就是在<strong>当前的光标位置插入一个“Day planner” 的一级标题</strong>。</p><p>比如下面这样的效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#Day planner</span><br></pre></td></tr></table></figure><p>个人认为这个选项没什么用，模板赋值粘贴更为方便。</p><h3 id="5-进入当天的日期视图"><a href="#5-进入当天的日期视图" class="headerlink" title="5. 进入当天的日期视图"></a>5. 进入当天的日期视图</h3><p>最后一项就是进入到当天的日期视图，也是一个快捷操作。</p><h2 id="设置变化"><a href="#设置变化" class="headerlink" title="设置变化"></a>设置变化</h2><p>新版本插件的设置基本全默认即可，个人的调整为：变更 Zoom Level=1，把第一项做了选中，其他基本保持原样。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230905122240.png" alt="image.png"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>新版本的 Day-Planner 整体上比较容易上手，比起旧版本要实用不少，希望作者后续继续更新。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230905114923.png" alt="image.png"></p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>与时俱进，个人认为旧版本<strong>记录每一天的时间流</strong>不利于做个人规划，很容易变成流水账，个人还需要额外借助<strong>时间序</strong>或者<strong>滴答清单</strong>这样的软件，做一周或者更长时间的时间规划。</p><p>新版本把整个插件重做，贴合了目前大部分时间管理APP的风格，整个界面十分的简洁直观，当然目前的插件不是很完善，希望作者后续可以继续改进操作。</p><p>从个人角度来看，本次插件“换代”最大意义是，类似滴答清单这样需要付费高级会员才能体验“日历视图”，在 Day-Planner 是完全免费的，白嫖党表示非常Nice。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230905105639.png" alt="image.png"></p><p>总而言之，这次更新非常香。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      Obsidian 使用
    
    </summary>
    
    
      <category term="其他" scheme="https://whitestore.top/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="其他" scheme="https://whitestore.top/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>【Java】Garbage Collection Logging to a File in Java</title>
    <link href="https://whitestore.top/2023/09/04/engctojava/"/>
    <id>https://whitestore.top/2023/09/04/engctojava/</id>
    <published>2023-09-04T06:35:23.000Z</published>
    <updated>2023-09-09T00:53:49.934Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFlbGR1bmcuY29tL2phdmEtZ2MtbG9nZ2luZy10by1maWxl" title="https://www.baeldung.com/java-gc-logging-to-file">https://www.baeldung.com/java-gc-logging-to-file<i class="fa fa-external-link"></i></span></p><h2 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFlbGR1bmcuY29tL2phdmEtZ2MtbG9nZ2luZy10by1maWxlI292ZXJ2aWV3" title="https://www.baeldung.com/java-gc-logging-to-file#overview">1. Overview<i class="fa fa-external-link"></i></span></h2><p>Garbage collection is a marvel of the Java programming language providing us with automatic memory management. </p><p>垃圾回收是 Java 编程语言的一个奇迹，它为我们提供了自动内存管理功能。</p><p>Garbage collection hides the details of having to manually allocate and deallocate memory. </p><p>垃圾回收隐藏了手动分配和删除内存的细节。</p><p>While this mechanism is fantastic, sometimes it doesn’t work the way we want. </p><p>虽然这种机制非常好，但有时并不能如我们所愿。</p><p>In this tutorial, we’ll explore Java’s <strong>logging options for garbage collection statistics</strong> and discover how to <strong>redirect these statistics to a file</strong>.</p><p>在本教程中，我们将探索 Java 的<strong>垃圾收集统计日志选项</strong>，并了解如何<strong>将这些统计信息重定向到文件</strong>。</p><a id="more"></a><h2 id="2-GC-Logging-Flags-in-Java-8-and-Earlier"><a href="#2-GC-Logging-Flags-in-Java-8-and-Earlier" class="headerlink" title="2. GC Logging Flags in Java 8 and Earlier"></a>2. GC Logging Flags in Java 8 and Earlier<a href="https://www.baeldung.com/java-gc-logging-to-file#gc-logging-flags-in-java-8-and-earlier" target="_blank" rel="noopener"></a></h2><p>First, let’s explore the JVM flags relating to GC logging in Java versions prior to Java 9.</p><p>首先，让我们探讨 Java 9 之前的 Java 版本中与 GC 日志相关的 JVM 标志。</p><h3 id="2-1-XX-PrintGC"><a href="#2-1-XX-PrintGC" class="headerlink" title="2.1. -XX:+PrintGC"></a><a href="https://www.baeldung.com/java-gc-logging-to-file#1--xxprintgc" target="_blank" rel="noopener">2.1. <em>-XX:+PrintGC</em></a></h3><p>The <em>-XX:+PrintGC</em> flag is an alias for <em>-verbose:gc</em> and <strong>turns on basic GC logging</strong>. </p><p><em>-XX:+PrintGC</em> 标志是_-verbose:gc_的别名，作用是<strong>开启基本的 GC 日志</strong>。</p><p>In this mode, a single line is printed for every young-generation and every full-generation collection. </p><p>在这个模式中，每个年轻代和完整代的收集操作都会打印一行。</p><p>Let’s now turn our attention to providing detailed GC information.</p><p>现在，让我们把注意力转向提供详细的 GC 信息。</p><h3 id="2-2-XX-PrintGCDetails"><a href="#2-2-XX-PrintGCDetails" class="headerlink" title="2.2. -XX:+PrintGCDetails"></a><a href="https://www.baeldung.com/java-gc-logging-to-file#2--xxprintgcdetails" target="_blank" rel="noopener">2.2. <em>-XX:+PrintGCDetails</em></a></h3><p>Similarly, we have the flag <em>-XX:+PrintGCDetails</em> used to <strong>activate detailed GC logging</strong> instead of <em>-XX:+PrintGC</em>.</p><p>同样，我们使用标记 <em>-XX:+PrintGCDetails</em> 来<strong>激活详细的 GC 日志</strong>，而不是 _-XX:+PrintGC_。</p><p>Note that the output from <em>-XX:+PrintGCDetails</em> changes depending on the GC algorithm in use.</p><blockquote><p>请注意，<em>-XX:+PrintGCDetails</em> 的输出会根据使用的 GC 算法而改变。</p></blockquote><p>Next, we’ll look at annotating our logs with date and time information.</p><blockquote><p>接下来，我们将了解如何用日期和时间信息来注释日志。</p></blockquote><h3 id="2-3-XX-PrintGCDateStamps-and-XX-PrintGCTimeStamps"><a href="#2-3-XX-PrintGCDateStamps-and-XX-PrintGCTimeStamps" class="headerlink" title="2.3. -XX:+PrintGCDateStamps and -XX:+PrintGCTimeStamps"></a><a href="https://www.baeldung.com/java-gc-logging-to-file#3--xxprintgcdatestamps-and--xxprintgctimestamps" target="_blank" rel="noopener">2.3. <em>-XX:+PrintGCDateStamps</em> and <em>-XX:+PrintGCTimeStamps</em></a></h3><p>We can <strong>add dates and timing information to our GC logs</strong> by utilizing the flags <em>-XX:+PrintGCDateStamps</em> and <em>-XX:+PrintGCTimeStamps</em>, respectively.</p><p>我们可以分别利用标记 <em>-XX:+PrintGCDateStamps</em> 和 <em>-XX:+PrintGCTimeStamps</em> 在 GC 日志中**添加日期和时间信息。</p><p>First, <em>-XX:+PrintGCDateStamps</em> adds the date and time of the log entry to the beginning of each line.</p><p>首先，<em>-XX:+PrintGCDateStamps</em> 会在每行开头添加日志条目的日期和时间。</p><p>Second, <em>-XX:PrintGCTimeStamps</em> adds a timestamp to every line of the log detailing the time passed (in seconds) since the JVM was started.</p><p>其次，<em>-XX:PrintGCTimeStamps</em> 会在日志的每一行添加一个时间戳，详细记录 JVM 启动后的时间（以秒为单位）。</p><h3 id="2-4-Xloggc"><a href="#2-4-Xloggc" class="headerlink" title="2.4. -Xloggc"></a><a href="https://www.baeldung.com/java-gc-logging-to-file#4--xloggc" target="_blank" rel="noopener">2.4. <em>-Xloggc</em></a></h3><p>Finally, we come to <strong>redirecting the GC log to a file</strong>. </p><p>最后，我们来<strong>将 GC 日志重定向到文件</strong>。</p><p>This flag takes an optional filename as an argument using the syntax <em>-Xloggc:file</em> and without the presence of a file name the GC log is written to standard out.</p><p>该标志使用 <em>-Xloggc:file</em> 语法将一个可选的文件名作为参数，如果没有文件名，GC 日志将被写入标准输出。</p><p>Additionally, this flag also sets the <em>-XX:PrintGC</em> and <em>-XX:PrintGCTimestamps</em> flags for us. Let’s look at some examples:</p><p>此外，该标记还会为我们设置 <em>-XX:PrintGC</em> 和 <em>-XX:PrintGCTimestamps</em> 标记。让我们来看几个例子：</p><p>If we want to write the GC log to standard output, we can run:</p><p>如果我们想将 GC 日志写入标准输出，可以运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp <span class="variable">$CLASSPATH</span> -Xloggc mypackage.MainClass</span><br></pre></td></tr></table></figure><p>Or to write the GC log to a file, we would run:</p><p>如果要写入GC日志到一个文件，使用下面参数</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp <span class="variable">$CLASSPATH</span> -Xloggc:/tmp/gc.log mypackage.MainClass</span><br></pre></td></tr></table></figure><h2 id="3-GC-Logging-Flags-in-Java-9-and-Later"><a href="#3-GC-Logging-Flags-in-Java-9-and-Later" class="headerlink" title="3. GC Logging Flags in Java 9 and Later"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFlbGR1bmcuY29tL2phdmEtZ2MtbG9nZ2luZy10by1maWxlI2djLWxvZ2dpbmctZmxhZ3MtaW4tamF2YS05LWFuZC1sYXRlcg==" title="https://www.baeldung.com/java-gc-logging-to-file#gc-logging-flags-in-java-9-and-later">3. GC Logging Flags in Java 9 and Later<i class="fa fa-external-link"></i></span></h2><p>In Java 9+, <em>-XX:PrintGC</em>, the alias for <em>-verbose:gc</em>, has been deprecated in favor of the <strong>unified logging option, <em>-Xlog</em></strong>. </p><p>Java9+ 的版本，<em>-Xlog</em> 取代了  <em>-XX:PrintGC</em> 和别名 _-verbose:gc_，此前的两个参数均已经标记为“已弃用”</p><p>All other GC flags mentioned above are still valid in Java 9+. </p><p>当然，虽然被标记弃用，但是上述所有其他 GC 标志在 Java 9+ 中仍然有效。</p><p>This new logging option allows us to <strong>specify which messages should be shown, set the log level, and redirect the output</strong>.</p><p>这个新的日志选项允许我们<strong>指定应显示哪些信息、设置日志级别和重定向输出</strong>。</p><p>We can run the below command to see all the available options for log levels, log decorators, and tag sets:</p><p>我们可以使用下面的命令查看所有可用的参数，比如日志等级，日志装饰器和标记集：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xlog:logging=debug -version</span><br></pre></td></tr></table></figure><p>For example, if we wanted to log all GC messages to a file, we would run:</p><p>如果我们想要记录GC日志到一个外部文件，可以使用下面的启动参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp <span class="variable">$CLASSPATH</span> -Xlog:gc*=debug:file=/tmp/gc.log mypackage.MainClass</span><br></pre></td></tr></table></figure><p>Additionally, this new unified logging flag is repeatable, so you can, for example, <strong>log all GC messages to both standard out and a file</strong>:</p><p>此外，这一新的统一日志标记（-Xlog:gc）是可重复的，因此您可以<strong>将所有 GC 消息同时记录到标准输出和文件</strong>中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp <span class="variable">$CLASSPATH</span> -Xlog:gc*=debug:stdout -Xlog:gc*=debug:file=/tmp/gc.log mypackage.MainClass</span><br></pre></td></tr></table></figure><h2 id="4-Conclusion"><a href="#4-Conclusion" class="headerlink" title="4. Conclusion"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFlbGR1bmcuY29tL2phdmEtZ2MtbG9nZ2luZy10by1maWxlI2NvbmNsdXNpb24=" title="https://www.baeldung.com/java-gc-logging-to-file#conclusion">4. Conclusion<i class="fa fa-external-link"></i></span></h2><p>In this article, we’ve shown how to log garbage collection output in both Java 8 and Java 9+ including how to redirect that output to a file.</p><p>本节内容展示了开启收集打印日志在JDK8和JDK9+的区别，包括如何将输出重定向到文件等操作。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      gc
    
    </summary>
    
    
      <category term="Java" scheme="https://whitestore.top/categories/Java/"/>
    
    
      <category term="Java" scheme="https://whitestore.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Zookeeper】Apach Curator 框架源码分析：后台构造器和节点操作相关源码分析（二）【Ver 4.3.0】</title>
    <link href="https://whitestore.top/2023/08/10/curatorsource2/"/>
    <id>https://whitestore.top/2023/08/10/curatorsource2/</id>
    <published>2023-08-10T09:00:47.000Z</published>
    <updated>2023-09-09T00:53:49.937Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>本文介绍后台任务延迟队列的“元素” <strong>后台任务构造器</strong> 以及Curator 对于常见的ZK节点操作封装API。<strong>后台任务构造器</strong>对应了和ZK交互的常见”后台“操作，比如创建和销毁Watch，而ZK节点操作API涉及各种建造者模式的应用。可以说，Curator 整个框架各种地方都有建造者模式的身影。</p><p><code>Curator</code> 除了对于ZK本身交互和操作封装之外，还引入了<strong>Cache</strong>的概念来实现对ZooKeeper服务器端进行事件监听，本质上就是构建本地缓存，在远程节点出现”状态“变动的时候进行”联动“触发各种事件。</p><p>不过，<code>Cache</code> 的部分个人认为并不是很重要的内容，更多重心还是在分布式锁，再加上查询各种资料本身应用场景也比较少，因此放到了文章最后分析，读者可以按需阅读。</p><a id="more"></a><h1 id="相关应用场景和重要概念"><a href="#相关应用场景和重要概念" class="headerlink" title="相关应用场景和重要概念"></a>相关应用场景和重要概念</h1><p>本文的源码分析涉及到 ZK 的应用场景和重要概念，这里先补充相关概念，为后面的源码分析铺垫。</p><h2 id="相关应用场景"><a href="#相关应用场景" class="headerlink" title="相关应用场景"></a>相关应用场景</h2><p>ZK 中可以完成数据发布订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举，分布式锁和分布式队列。</p><p><strong>命名服务</strong>： 使用 ZooKeeper 的顺序节点生成全局唯一 ID。</p><p><strong>数据发布/订阅</strong>：通过 <strong>Watcher 机制</strong> 可以很方便地实现数据发布/订阅。</p><p><strong>分布式锁</strong>：通过创建唯一节点获得分布式锁，通常会使用临时节点的方式持有锁，特点是在节点宕机之后会自动释放。</p><h2 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h2><h3 id="ZNode-概念"><a href="#ZNode-概念" class="headerlink" title="ZNode 概念"></a>ZNode 概念</h3><p><code>Zookeeper</code> 的数据模型使用的是多叉树结构，每个节点上面可以存储任意类型的数据，比如数组、字符串、二进制序列，由于是树状节点，每个节点还可以有子节点。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230713133555.png" alt="image.png"></p><blockquote><p>注意 ZNode 通常用于临时创建，适合用于比较小体积的锁应用，不建议存储过大的业务数据，不要把过大的数据放到 ZNode上。</p></blockquote><h3 id="ZNode-数据节点"><a href="#ZNode-数据节点" class="headerlink" title="ZNode 数据节点"></a>ZNode 数据节点</h3><p>Zookeeper 的数据节点 ZNode 是最小组成单元，ZNode 是 ZK 实现分布式锁的重要基础，它主要有如下分类：</p><ul><li><strong>持久（PERSISTENT）节点</strong>：一旦创建就会一直存在，直到 ZK集群宕机才会删除。</li><li><strong>临时（EPHEMERAL）节点</strong>：临时节点的生命周期是与 <strong>客户端会话（session）</strong> 绑定，会话消失则节点消失，</li><li><strong>持久顺序（PERSISTENT_SEQUENTIAL）节点</strong>：在持久节点的特性上，子节点的名称依然有顺序性，比如 <code>/node1/app0000000001</code>、<code>/node1/app0000000002</code> 。</li><li><strong>临时顺序（EPHEMERAL_SEQUENTIAL）节点</strong>：除了具备临时（EPHEMERAL）节点的特性之外，子节点的名称还具有顺序性。</li></ul><h2 id="Watcher（事件监听器）"><a href="#Watcher（事件监听器）" class="headerlink" title="Watcher（事件监听器）"></a>Watcher（事件监听器）</h2><p><strong>Watcher</strong> 事件监听器是 Zookeeper 当中非常重要的特性，ZK 允许用户在指定的 Znode 上面注册监听器 Watcher，特定的事件触发时候，ZK服务端会把事件通知到注册Watcher的客户端,。事件监听器也是分布式协调服务的重要组成部分。</p><blockquote><p>在 Curator 中，Watcher 事件监听器是不同客户端监听分布式锁释放的重要应用组件。</p></blockquote><h1 id="ZK可视化客户端-PrettyZoo"><a href="#ZK可视化客户端-PrettyZoo" class="headerlink" title="ZK可视化客户端 PrettyZoo"></a>ZK可视化客户端 PrettyZoo</h1><p>为了方便我们调试源码的同时观察ZK节点变更，这里推荐使用 <strong>PrettyZoo</strong> 客户端。</p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3ZyYW4tZGV2L1ByZXR0eVpvbw==" title="https://github.com/vran-dev/PrettyZoo">PrettyZoo<i class="fa fa-external-link"></i></span> 是一个基于 Apache Curator 和 JavaFX 实现的 Zookeeper 图形化管理客户端。使用了 Java 的模块化（Jigsaw）技术，并基于 JPackage 打包了多平台的可运行文件（无需要额外安装 Java 运行时）。</p><p>目前已提供了 mac（dmg 文件）、Linux（deb 和 rpm 文件）、windows（msi 文件） 的安装包，<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3ZyYW4tZGV2L1ByZXR0eVpvby9yZWxlYXNlcw==" title="https://github.com/vran-dev/PrettyZoo/releases">下载地址<i class="fa fa-external-link"></i></span>。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230713143622.png" alt="image.png"></p><p>个人为Win系统，选择<code>win.msi</code> 的安装包，安装并启动并且就进入到主页面</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230713144539.png" alt="image.png"></p><p>完成配置之后进行连接，最终的连接效果如图：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230713144757.png" alt="image.png"></p><p>前面的铺垫已经完成，下面正式进入主题。</p><h1 id="后台任务构造器"><a href="#后台任务构造器" class="headerlink" title="后台任务构造器"></a>后台任务构造器</h1><p>在[[【Zookeeper】Apach Curator 框架源码分析：初始化过程（一）【Ver 4.3.0】]]当中，我们介绍了Curator实例化、Zookeeper连接以及各种组件初始化和启动过程，其中就有一个后台执行操作队列不断执行后台操作。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230720062506.png" alt="image.png"></p><p><strong>OperationAndData</strong>中的 <strong>BackgroundOperation</strong> ，封装各种常见ZK指令的构造器。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230703204542.png" alt="image.png"></p><p>下面以 <strong>BackgroundOperation</strong> 作为切入点，看看它的构造器是如何实现的？</p><h2 id="后台操作接口-BackgroundOperation-lt-T-gt"><a href="#后台操作接口-BackgroundOperation-lt-T-gt" class="headerlink" title="后台操作接口 BackgroundOperation&lt; T &gt;"></a>后台操作接口 BackgroundOperation&lt; T &gt;</h2><p><strong>BackgroundOperation</strong> 是后台操作接口的 <strong>顶级接口</strong>，其中只有一个方法，它接收 <strong>OperationAndData</strong> 作为请求参数。</p><p><strong>org.apache.curator.framework.imps.BackgroundOperation</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">BackgroundOperation</span>&lt;<span class="title">T</span>&gt;  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performBackgroundOperation</span><span class="params">(OperationAndData&lt;T&gt; data)</span> <span class="keyword">throws</span> Exception</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种设计让我联想到 Executor 的设计（略显牵强），Runnable 是线程的执行操作分离抽象，与之对应的<code>OperationAndData</code>是对于后台操作的抽象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;  </span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后台事件数据对象-OperationAndData"><a href="#后台事件数据对象-OperationAndData" class="headerlink" title="后台事件数据对象 OperationAndData"></a>后台事件数据对象 OperationAndData</h2><p><strong>org.apache.curator.framework.imps.OperationAndData</strong></p><p>OperationAndData 对象的代码略多，这里拆分介绍，首先来看下继承结构， <strong>OperationAndData</strong> 最终被存储在<strong>后台线程执行的操作队列backgroundOperations</strong>，backgroundOperations使用JDK原生并发延迟队列<strong>DelayQueue</strong>作为基础。</p><p>按照 <strong>DelayQueue</strong> 的设计存储要求，内部元素必须实现<code>Delayed</code>接口以支持延迟操作，除此之外， OperationAndData 还实现了 <strong>RetrySleeper</strong> 接口，从英文名称也可以大致猜出它是 <strong>对重试政策的抽象化</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OperationAndData</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Delayed</span>, <span class="title">RetrySleeper</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后台线程执行的操作队列</span></span><br><span class="line">backgroundOperations = <span class="keyword">new</span> DelayQueue&lt;OperationAndData&lt;?&gt;&gt;();</span><br></pre></td></tr></table></figure><p>下面来看下相关成员变量定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">初始化为0，每执行一次 reset() 重置，此计数器的值会+1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong nextOrdinal = <span class="keyword">new</span> AtomicLong();  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">BackgroundOperation 相关引用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BackgroundOperation&lt;T&gt; operation;  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">后台操作的相关对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> T data;  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">异步后台操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BackgroundCallback callback;  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">执行开始时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> startTimeMs = System.currentTimeMillis();  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">错误回调</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ErrorCallback&lt;T&gt; errorCallback;  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">重试次数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger retryCount = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">休眠时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicLong sleepUntilTimeMs = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">执行顺序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicLong ordinal = <span class="keyword">new</span> AtomicLong();  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">上下文</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object context;  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">需要连接</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> connectionRequired;</span><br></pre></td></tr></table></figure><p>重要的方法如下，执行后台操作就是调用<code>operation.performBackgroundOperation(this);</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callPerformBackgroundOperation</span><span class="params">()</span> <span class="keyword">throws</span> Exception  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    operation.performBackgroundOperation(<span class="keyword">this</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>BackgroundOperation</strong> 的实现类非常多。这里举几个例子。</p><p><strong>BackgroundSyncImpl</strong></p><p>从单词意思来看，这个实现是负责后台同步的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BackgroundSyncImpl</span> <span class="keyword">implements</span> <span class="title">BackgroundOperation</span>&lt;<span class="title">String</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CuratorFrameworkImpl client;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object context;</span><br><span class="line"></span><br><span class="line">    BackgroundSyncImpl(CuratorFrameworkImpl client, Object context)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performBackgroundOperation</span><span class="params">(<span class="keyword">final</span> OperationAndData&lt;String&gt; operationAndData)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> OperationTrace trace = client.getZookeeperClient().startAdvancedTracer(<span class="string">"BackgroundSyncImpl"</span>);</span><br><span class="line">        <span class="keyword">final</span> String data = operationAndData.getData();</span><br><span class="line">        client.getZooKeeper().sync</span><br><span class="line">        (</span><br><span class="line">            data,</span><br><span class="line">            <span class="keyword">new</span> AsyncCallback.VoidCallback()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx)</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                    trace.setReturnCode(rc).setRequestBytesLength(data).commit();</span><br><span class="line">                    CuratorEventImpl event = <span class="keyword">new</span> CuratorEventImpl(client, CuratorEventType.SYNC, rc, path, <span class="keyword">null</span>, ctx, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                    client.processBackgroundOperation(operationAndData, event);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            context</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过构造<code>CuratorEventImpl</code>实现类，把<code>operationAndData</code>和<code>event</code>事件传给<code>CuratorFrameworkImpl</code>。</p><p><strong>RemoveWatchesBuilderImpl</strong></p><p><strong>RemoveWatchesBuilderImpl</strong>定义了删除<code>Watcher</code>监听器的后台操作，简单看下相关代码实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoveWatchesBuilderImpl</span> <span class="keyword">implements</span> <span class="title">RemoveWatchesBuilder</span>, <span class="title">RemoveWatchesType</span>, <span class="title">RemoveWatchesLocal</span>, <span class="title">BackgroundOperation</span>&lt;<span class="title">String</span>&gt;, <span class="title">ErrorListenerPathable</span>&lt;<span class="title">Void</span>&gt;  </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> CuratorFrameworkImpl client;</span><br><span class="line">    <span class="keyword">private</span> Watcher watcher;</span><br><span class="line">    <span class="keyword">private</span> CuratorWatcher curatorWatcher;</span><br><span class="line">    <span class="keyword">private</span> WatcherType watcherType;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> guaranteed;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> local;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> quietly;    </span><br><span class="line">    <span class="keyword">private</span> Backgrounding backgrounding;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performBackgroundOperation</span><span class="params">(<span class="keyword">final</span> OperationAndData&lt;String&gt; operationAndData)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">final</span> TimeTrace   trace = client.getZookeeperClient().startTracer(<span class="string">"RemoteWatches-Background"</span>);</span><br><span class="line"></span><br><span class="line">            AsyncCallback.VoidCallback callback = <span class="keyword">new</span> AsyncCallback.VoidCallback()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx)</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                    trace.commit();</span><br><span class="line">                    CuratorEvent event = <span class="keyword">new</span> CuratorEventImpl(client, CuratorEventType.REMOVE_WATCHES, rc, path, <span class="keyword">null</span>, ctx, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                    client.processBackgroundOperation(operationAndData, event);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            ZooKeeper zkClient = client.getZooKeeper();</span><br><span class="line">            <span class="comment">// 命名空间 Watch </span></span><br><span class="line">            NamespaceWatcher namespaceWatcher = makeNamespaceWatcher(operationAndData.getData());</span><br><span class="line">            <span class="keyword">if</span>(namespaceWatcher == <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="comment">// ZK 客户端移除 Watch </span></span><br><span class="line">                zkClient.removeAllWatches(operationAndData.getData(), watcherType, local, callback, operationAndData.getContext());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                zkClient.removeWatches(operationAndData.getData(), namespaceWatcher, watcherType, local, callback, operationAndData.getContext());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> ( Throwable e )</span><br><span class="line">        &#123;</span><br><span class="line">            backgrounding.checkError(e, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="执行后台事件-CuratorFrameworkImpl-processBackgroundOperation"><a href="#执行后台事件-CuratorFrameworkImpl-processBackgroundOperation" class="headerlink" title="执行后台事件 CuratorFrameworkImpl#processBackgroundOperation"></a>执行后台事件 CuratorFrameworkImpl#processBackgroundOperation</h2><p>所有的后台任务操作都会回调Curator 实例<strong>CuratorFrameworkImpl</strong>的 <code>processBackgroundOperation</code>方法，下面简单分析相关方法细节。</p><p><strong>org.apache.curator.framework.imps.CuratorFrameworkImpl#processBackgroundOperation</strong></p><p>主要的逻辑如下：</p><ol><li>判断是否初次执行，初次执行会进行连接状态检查呵护后续的重试判断处理。</li><li>校验是否需要重试。</li><li>检查是否发送回调。</li><li>监听器事件回调通知（这里会进行事件通知回调）。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;DATA_TYPE&gt; <span class="function"><span class="keyword">void</span> <span class="title">processBackgroundOperation</span><span class="params">(OperationAndData&lt;DATA_TYPE&gt; operationAndData, CuratorEvent event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> isInitialExecution = (event == <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 如果是初次执行</span></span><br><span class="line"><span class="keyword">if</span> ( isInitialExecution )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 初次执行会进行连接状态检查呵护后续的重试判断处理</span></span><br><span class="line">performBackgroundOperation(operationAndData);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> doQueueOperation = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">do</span>                                                                                          </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 校验是否需要重试</span></span><br><span class="line"><span class="keyword">if</span> ( RetryLoop.shouldRetry(event.getResultCode()) )</span><br><span class="line">&#123;</span><br><span class="line">doQueueOperation = checkBackgroundRetry(operationAndData, event);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查是否发送回调</span></span><br><span class="line"><span class="keyword">if</span> ( operationAndData.getCallback() != <span class="keyword">null</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 发送后台回调</span></span><br><span class="line">sendToBackgroundCallback(operationAndData, event);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 监听器事件回调通知</span></span><br><span class="line">processEvent(event);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ( <span class="keyword">false</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( doQueueOperation )</span><br><span class="line">&#123;</span><br><span class="line">queueOperation(operationAndData);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>真心看不懂 while ( false );  这的写法=-=。</p></blockquote><p>以上简单分析了后台任务构造器以及如何执行，设计比较好懂，这里就不做过多分析了。</p><h1 id="Curator-节点操作"><a href="#Curator-节点操作" class="headerlink" title="Curator 节点操作"></a>Curator 节点操作</h1><h2 id="创建节点API"><a href="#创建节点API" class="headerlink" title="创建节点API"></a>创建节点API</h2><p>这里以个人阅读的 Curator 4.3.0 版本为例，创建节点的 API 涉及下面几个组件：</p><ul><li><strong>CuratorFramework</strong>：<ul><li><code>public CreateBuilder create();</code></li></ul></li><li><strong>CreateBuilder</strong>：<ul><li><code>public ProtectACLCreateModePathAndBytesable&lt;String&gt; createParentsIfNeeded();</code></li></ul></li><li><strong>CreateModable</strong>：<ul><li><code>public T withMode(CreateMode mode);</code></li></ul></li><li><strong>PathAndBytesable&lt; T&gt;</strong>：<ul><li><code>public T forPath(String path, byte[] data) throws Exception;</code></li><li><code>public T forPath(String path) throws Exception;</code></li></ul></li></ul><p>下面是几个常见的API使用Demo：</p><p><strong>创建一个节点，初始内容为空</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.create().forPath(path);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个节点，初始内容为空  </span></span><br><span class="line">client.create().forPath(<span class="string">"/tmp"</span>);</span><br></pre></td></tr></table></figure><p>从结果可以看到，<strong>如果没有设置节点属性，那么Curator默认创建的是持久节点</strong>。</p><p><strong>创建一个节点，附带初始内容</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个节点，附带初始内容  </span></span><br><span class="line">client.create().forPath(<span class="string">"/tmp"</span>, <span class="string">"init"</span>.getBytes());;</span><br></pre></td></tr></table></figure><p>和上面的区别就是在对应的节点写入内容，注意 Curator 使用了 Zookeeper 的原始API风格。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  KeeperErrorCode = NodeExists for /tmp</span></span><br></pre></td></tr></table></figure><p>由于上面已经创建过节点，这里创建节点出现报错，我们在Pretty客户端中执行删除节点操作。删除之后重新执行，”/tmp”节点被正确创建。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230713145410.png" alt="image.png"></p><p><strong>创建一个临时节点，初始内容为空</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.create().withMode(CreateMode.EPHEMERAL).forPath(path);</span><br></pre></td></tr></table></figure><p>临时节点属于会话级别，我们在编写Demo代码的时候，如果没有手动 close 客户端，那么服务端会判断客户端会在<strong>会话超时之后自动释放临时节点</strong>。</p><p>临时节点的好处是即使ZK集群宕机，也可以保证及时释放，防止锁长期占用，适合作为分布式锁设计使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个临时节点，初始内容为空  </span></span><br><span class="line">client.create().withMode(CreateMode.EPHEMERAL).forPath(<span class="string">"/temp"</span>);  </span><br><span class="line"><span class="comment">// 如果立即Close，那么临时节点会立即释放</span></span><br><span class="line">client.close();</span><br></pre></td></tr></table></figure><p>如果我们 close 客户端，那么临时节点的创建和销毁会立即触发，在 <strong>prettyZoo</strong> 看来就是“什么也没发送过”。</p><p><strong>创建一个临时节点，并自动递归创建父节点</strong></p><p>使用ZooKeeper的过程中，开发人员经常会碰到<strong>NoNodeException</strong>异常，其中一个可能的原因就是试图对一个不存在的父节点创建子节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 试图对一个不存在的父节点创建子节点  </span></span><br><span class="line">client.create().withMode(CreateMode.EPHEMERAL).forPath(<span class="string">"/temp/childNode"</span>);  </span><br><span class="line"><span class="comment">// 报错KeeperErrorCode = NoNode for /temp/childNode</span></span><br></pre></td></tr></table></figure><p>在使用Curator之后，通过调用<code>creatingParentsIfNeeded</code>接口，Curator就能够自动递归创建所有需要的父节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lient.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(path);</span><br></pre></td></tr></table></figure><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230713151258.png" alt="image.png"></p><h2 id="创建节点源码分析"><a href="#创建节点源码分析" class="headerlink" title="创建节点源码分析"></a>创建节点源码分析</h2><p>节点API的涉及都比较简单，<strong>CreateBuilder</strong> 的继承结构图如下：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230713142916.png" alt="image.png"></p><p><strong>CreateBuilder</strong> 的对应实现类为 <strong>CreateBuilderImpl</strong>，我们通过一串API调用Demo来简单分析构建过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(<span class="string">"/temp/childNode"</span>, <span class="string">"init"</span>.getBytes());</span><br></pre></td></tr></table></figure><p><strong>org.apache.curator.framework.imps.CuratorFrameworkImpl#create</strong></p><ol><li>检查ZK的连接状态。</li><li>new CreateBuilderImpl,，这里的 this 为 <strong>CuratorFrameworkImpl</strong> ，也就是client 客户端实例。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CreateBuilder <span class="title">create</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"><span class="comment">// 检查ZK的连接状态</span></span><br><span class="line">    checkState();  </span><br><span class="line">    <span class="comment">// new构造器, this 为 CuratorFrameworkImpl 也就是client 客户端实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CreateBuilderImpl(<span class="keyword">this</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>org.apache.curator.framework.imps.CreateBuilderImpl#creatingParentsIfNeeded</strong></p><p>下面代码的关键是<code>createParentsIfNeeded = true;</code>这一行，其他代码可以忽略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> ProtectACLCreateModeStatPathAndBytesable&lt;String&gt; <span class="title">creatingParentsIfNeeded</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    createParentsIfNeeded = <span class="keyword">true</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ProtectACLCreateModeStatPathAndBytesable&lt;String&gt;()  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>withMode(CreateMode.EPHEMERAL)</strong></p><p>这一部分属于ZK的客户端提供的，<strong>CreateMode</strong> 一般用的比较多的是<strong>临时节点</strong>。</p><p>具体使用这里不一一介绍，简单看下源码中的英文注释很容易理解不同模式的作用。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230713152956.png" alt="image.png"></p><blockquote><p>默认为 <strong>PERSISTENT</strong> 持久节点。</p></blockquote><p><strong>org.apache.curator.framework.imps.CreateBuilderImpl#forPath(java.lang.String, byte[])</strong></p><p><strong>forPath</strong> 对应了创建节点的最终操作，这里大致逻辑如下：</p><ol><li>判断是否需要压缩。</li><li>acl 权限检查。</li><li>判断是否执行回调。</li><li>核心：使用 ZooKeeper 的顺序节点生成全局唯一 ID。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">forPath</span><span class="params">(<span class="keyword">final</span> String givenPath, <span class="keyword">byte</span>[] data)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 判断是否需要压缩</span></span><br><span class="line"><span class="keyword">if</span> ( compress )</span><br><span class="line">&#123;</span><br><span class="line">data = client.getCompressionProvider().compress(givenPath, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> String adjustedPath = adjustPath(client.fixForNamespace(givenPath, createMode.isSequential()));</span><br><span class="line">List&lt;ACL&gt; aclList = acling.getAclList(adjustedPath);</span><br><span class="line">client.getSchemaSet().getSchema(givenPath).validateCreate(createMode, givenPath, data, aclList);</span><br><span class="line"></span><br><span class="line">String returnPath = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 后台回调</span></span><br><span class="line"><span class="keyword">if</span> ( backgrounding.inBackground() )</span><br><span class="line">&#123;</span><br><span class="line">pathInBackground(adjustedPath, data, givenPath);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// forpath 会走这一段逻辑</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">String path = protectedPathInForeground(adjustedPath, data, aclList);</span><br><span class="line"></span><br><span class="line">returnPath = client.unfixForNamespace(path);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> returnPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺着<code>String path = protectedPathInForeground(adjustedPath, data, aclList);</code>这一段代码一路往下探，找到对应截图部分的代码：</p><p><strong>org.apache.curator.framework.imps.CreateBuilderImpl#pathInForeground</strong></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230713155631.png" alt="image.png"></p><p>这里使用<code>RetryLoop.callWithRetry</code>嵌套了一个 <code>Callable</code>操作，但是这个操作并没有做任何多线程操作，而是进行了<code>result = proc.call();</code>调用？？？不太理解这一段封装处理的含义，于是看了下JavaDoc解释：</p><blockquote><p>在Zookeeper上执行操作的机制，可安全防止断开连接和 “可恢复 “错误。如果在操作过程中出现异常，RetryLoop将处理该异常，检查当前重试策略，并尝试重新连接或重新抛出异常。</p></blockquote><p>典型用法如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RetryLoop retryLoop = client.newRetryLoop();</span><br><span class="line"><span class="keyword">while</span> ( retryLoop.shouldContinue() )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// do your work</span></span><br><span class="line">        ZooKeeper zk = client.getZooKeeper();    <span class="comment">// it's important to re-get the ZK instance in case there was an error and the instance was re-created</span></span><br><span class="line"> </span><br><span class="line">        retryLoop.markComplete();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> ( Exception e )</span><br><span class="line">    &#123;</span><br><span class="line">        retryLoop.takeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说白了，它主要封装了类似下面这样的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">while</span> (count &lt; <span class="number">3</span>)&#123;  </span><br><span class="line"><span class="keyword">try</span>&#123;  </span><br><span class="line"><span class="comment">//                ZooKeeper zk = client.getZooKeeper();  </span></span><br><span class="line"><span class="comment">//                zk.create(final String path, byte data[], List&lt;ACL &gt; acl,  </span></span><br><span class="line"><span class="comment">//                        CreateMode createMode)  </span></span><br><span class="line"><span class="keyword">break</span>;  </span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;  </span><br><span class="line">count++;  </span><br><span class="line"><span class="keyword">continue</span>;            </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果就是把重试的重复代码做了一个封装，其中<code>call()</code>方法则是具体委托ZK的客户端进行节点的创建操作了，这里的<code>ttl</code>为 <strong>-1</strong>。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230713160928.png" alt="image.png"></p><p>截图对应代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createdPath = client.getZooKeeper().create(path, data, aclList, createMode, storingStat, ttl);</span><br></pre></td></tr></table></figure><p>此外，个人在阅读代码过程中，发现在进行path的字符串拼接操作的时候，这里有一个小小的  <strong>StringBuilder</strong> 优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Avoid internal StringBuilder's buffer reallocation by specifying the max path length  </span></span><br><span class="line">StringBuilder path = <span class="keyword">new</span> StringBuilder(maxPathLength);</span><br></pre></td></tr></table></figure><p>至此，创建节点的相关操作源码已经了解，下面我们来过一下删除的相关API操作和源码。</p><h2 id="删除节点API"><a href="#删除节点API" class="headerlink" title="删除节点API"></a>删除节点API</h2><ul><li><strong>CuratorFramework</strong>：<ul><li><code>public CreateBuilder create();</code></li></ul></li><li><strong>DeleteBuilder</strong></li><li><strong>ChildrenDeletable</strong><ul><li><code>public BackgroundVersionable deletingChildrenIfNeeded();</code></li></ul></li><li><strong>PathAndBytesable&lt; T&gt;</strong>：<ul><li><code>public T forPath(String path, byte[] data) throws Exception;</code></li><li>`public T forPath(String path) throws Exception;</li></ul></li></ul><p><strong>DeleteBuilder</strong> 的继承结构图如下：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230713163524.png" alt="image.png"></p><p>删除节点的API较为简单，这里直接贴出相关的Demo代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先创建一个持久节点  </span></span><br><span class="line">client.create().forPath(<span class="string">"/create"</span>);  </span><br><span class="line"><span class="comment">// 删除节点  </span></span><br><span class="line">client.delete().forPath(<span class="string">"/create"</span>);  </span><br><span class="line"><span class="comment">// 如果节点不存在：KeeperErrorCode = NoNode for /create</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先创建一个持久节点  </span></span><br><span class="line">client.create().creatingParentsIfNeeded().forPath(<span class="string">"/create/child0"</span>);  </span><br><span class="line">client.create().creatingParentsIfNeeded().forPath(<span class="string">"/create/child1"</span>);  </span><br><span class="line"><span class="comment">// 删除并且判断是否需要同时删除子节点，如果有子节点并且确定一并删除需要添加 </span></span><br><span class="line">deletingChildrenIfNeededclient.delete().deletingChildrenIfNeeded().forPath(<span class="string">"/create"</span>);</span><br></pre></td></tr></table></figure><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230713164006.png" alt="image.png"></p><h2 id="删除节点源码分析"><a href="#删除节点源码分析" class="headerlink" title="删除节点源码分析"></a>删除节点源码分析</h2><p>由于基本的CRUDE操作逻辑实现比较类似，这里主要介绍下<code>deletingChildrenIfNeeded</code>是如何作用的，处理思路是在访问ZK出现<strong>NotEmptyException</strong>异常之后，这里在异常中判断是否设置删除子节点的操作并且重新发起请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> ( KeeperException.NotEmptyException e )  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span> ( deletingChildrenIfNeeded )  </span><br><span class="line">    &#123;  </span><br><span class="line">        ZKPaths.deleteChildren(client.getZooKeeper(), path, <span class="keyword">true</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">throw</span> e;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ZKPaths.deleteChildren(client.getZooKeeper(), path, true);</code>这个工具方法具体操作是利用<strong>递归</strong>的方式遍历所有子ZNode，然后挨个执行<code>delete</code>方法删除。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230713164635.png" alt="image.png"></p><h2 id="获取节点API"><a href="#获取节点API" class="headerlink" title="获取节点API"></a>获取节点API</h2><ul><li><strong>CuratorFramework</strong>：<ul><li><code>public GetDataBuilder getData();</code></li></ul></li><li><strong>GetDataBuilder</strong></li><li><strong>GetChildrenBuilder</strong><ul><li><code>public GetChildrenBuilder getChildren();</code></li></ul></li><li><strong>PathAndBytesable&lt; T&gt;</strong>：<ul><li>`public T forPath(String path) throws Exception;</li></ul></li></ul><p><strong>GetDataBuilder</strong> 的类继承结构图如下：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230715152747.png" alt="image.png"></p><p>下面是简单的API使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">client.create().creatingParentsIfNeeded().withMode(CreateMode.CONTAINER).forPath(<span class="string">"/app2"</span>, <span class="string">"Test"</span>.getBytes());</span><br><span class="line"><span class="comment">//1、查询数据：get</span></span><br><span class="line"><span class="keyword">byte</span>[] data = client.getData().forPath(<span class="string">"/app2"</span>);</span><br><span class="line"><span class="comment">// KeeperErrorCode = NoNode for /app1</span></span><br><span class="line">log.info(<span class="string">"查询数据 &#123;&#125;"</span>, <span class="keyword">new</span> String(data));</span><br><span class="line"><span class="comment">// 运行结果：查询数据 Test</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、查询子节点：ls</span></span><br><span class="line">List&lt;String&gt; list = client.getChildren().forPath(<span class="string">"/app2"</span>);</span><br><span class="line">log.info(<span class="string">"查询子节点 &#123;&#125;"</span>, list);</span><br><span class="line"><span class="comment">//运行结果：查询子节点 []</span></span><br><span class="line">client.close();</span><br><span class="line"><span class="comment">//3、查询节点状态信息：ls -s</span></span><br><span class="line">Stat stat = <span class="keyword">new</span> Stat();</span><br><span class="line">client.getData().storingStatIn(stat).forPath(<span class="string">"/app2"</span>);</span><br></pre></td></tr></table></figure><h2 id="获取节点源码分析"><a href="#获取节点源码分析" class="headerlink" title="获取节点源码分析"></a>获取节点源码分析</h2><p>获取节点的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] forPath(String path) <span class="keyword">throws</span> Exception</span><br><span class="line">   &#123;</span><br><span class="line">       client.getSchemaSet().getSchema(path).validateWatch(path, watching.isWatched() || watching.hasWatcher());</span><br><span class="line"></span><br><span class="line">       path = client.fixForNamespace(path);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">byte</span>[]      responseData = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">if</span> ( backgrounding.inBackground() )</span><br><span class="line">       &#123;</span><br><span class="line">           client.processBackgroundOperation(<span class="keyword">new</span> OperationAndData&lt;String&gt;(<span class="keyword">this</span>, path, backgrounding.getCallback(), <span class="keyword">null</span>, backgrounding.getContext(), watching), <span class="keyword">null</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           responseData = pathInForeground(path);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> responseData;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>前台调用方法操作如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] pathInForeground(<span class="keyword">final</span> String path) <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        OperationTrace   trace = client.getZookeeperClient().startAdvancedTracer(<span class="string">"GetDataBuilderImpl-Foreground"</span>);</span><br><span class="line">        <span class="keyword">byte</span>[]      responseData = RetryLoop.callWithRetry</span><br><span class="line">        (</span><br><span class="line">            client.getZookeeperClient(),</span><br><span class="line">            <span class="keyword">new</span> Callable&lt;<span class="keyword">byte</span>[]&gt;()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">byte</span>[] call() <span class="keyword">throws</span> Exception</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">byte</span>[]      responseData;</span><br><span class="line">                    <span class="keyword">if</span> ( watching.isWatched() )</span><br><span class="line">                    &#123;</span><br><span class="line">                        responseData = client.getZooKeeper().getData(path, <span class="keyword">true</span>, responseStat);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        responseData = client.getZooKeeper().getData(path, watching.getWatcher(path), responseStat);</span><br><span class="line">                        watching.commitWatcher(KeeperException.NoNodeException.Code.OK.intValue(), <span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> responseData;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">        trace.setResponseBytesLength(responseData).setPath(path).setWithWatcher(watching.hasWatcher()).setStat(responseStat).commit();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> decompress ? client.getCompressionProvider().decompress(path, responseData) : responseData;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="修改节点API"><a href="#修改节点API" class="headerlink" title="修改节点API"></a>修改节点API</h2><ul><li><strong>CuratorFramework</strong>：<ul><li><code>public SetDataBuilder setData();</code></li></ul></li><li><strong>SetDataBuilder</strong><ul><li><code>SetDataBuilder setData()</code></li></ul></li><li><strong>PathAndBytesable&lt; T&gt;</strong>：<ul><li>`public T forPath(String path) throws Exception;</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、修改节点数据（基本修改）</span></span><br><span class="line">curatorFramework.setData().forPath(<span class="string">"/app1"</span>, <span class="string">"333"</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、根据版本号修改</span></span><br><span class="line">Stat stat1 = <span class="keyword">new</span> Stat();</span><br><span class="line">curatorFramework.getData().storingStatIn(stat1).forPath(<span class="string">"/app1"</span>);</span><br><span class="line">curatorFramework.setData().withVersion(stat1.getVersion()).forPath(<span class="string">"/app1"</span>, <span class="string">"itcast"</span>.getBytes(StandardCharsets.UTF_8));</span><br></pre></td></tr></table></figure><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230715154642.png" alt="image.png"></p><h2 id="修改节点源码分析"><a href="#修改节点源码分析" class="headerlink" title="修改节点源码分析"></a>修改节点源码分析</h2><p>设计思路都是类似的，这里挑选<code>forPath</code>的相关代码进行展示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> Stat <span class="title">forPath</span><span class="params">(String path, <span class="keyword">byte</span>[] data)</span> <span class="keyword">throws</span> Exception  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    client.getSchemaSet().getSchema(path).validateGeneral(path, data, <span class="keyword">null</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> ( compress )  </span><br><span class="line">    &#123;  </span><br><span class="line">        data = client.getCompressionProvider().compress(path, data);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    path = client.fixForNamespace(path);  </span><br><span class="line">  </span><br><span class="line">    Stat        resultStat = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="keyword">if</span> ( backgrounding.inBackground()  )  </span><br><span class="line">    &#123;  </span><br><span class="line">        client.processBackgroundOperation(<span class="keyword">new</span> OperationAndData&lt;&gt;(<span class="keyword">this</span>, <span class="keyword">new</span> PathAndBytes(path, data), backgrounding.getCallback(), <span class="keyword">null</span>, backgrounding.getContext(), <span class="keyword">null</span>), <span class="keyword">null</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        resultStat = pathInForeground(path, data);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> resultStat;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="监听节点"><a href="#监听节点" class="headerlink" title="监听节点"></a>监听节点</h2><p>在使用原生的ZooKeeper的时候，是可以使用Watcher对节点进行监听的，但是唯一不方便的是一个Watcher只能生效一次，也就是说每次进行监听回调之后我们需要自己重新的设置监听才能达到永久监听的效果。</p><p>Curator在这方面做了优化，Curator引入了Cache的概念用来实现对ZooKeeper服务器端进行事件监听。<strong>Cache是Curator对事件监听的包装</strong>，其对事件的监听可以近似看做是<strong>本地缓存视图和远程ZooKeeper视图的对比过程</strong>。而且Curator会<strong>自动再次监听</strong>，我们就不需要自己手动的重复监听了。</p><p>Curator支持的cache种类有3种Path Cache，Node Cache，Tree Cache。</p><p><strong>1）Path Cache</strong></p><p>Path Cache用来观察ZNode的子节点并缓存状态，如果ZNode的子节点被创建，更新或者删除，那么Path Cache会更新缓存，并且触发事件给注册的监听器。</p><p>Path Cache是通过PathChildrenCache类来实现的，监听器注册是通过PathChildrenCacheListener。</p><p><strong>2）Node Cache</strong></p><p>Node Cache用来观察ZNode自身，如果ZNode节点本身被创建，更新或者删除，那么Node Cache会更新缓存，并触发事件给注册的监听器。</p><p>Node Cache是通过NodeCache类来实现的，监听器对应的接口为NodeCacheListener。</p><p><strong>3）Tree Cache</strong></p><p>可以看做是上两种的合体，Tree Cache观察的是所有节点的所有数据。</p><p>Curator 拥有一套在节点上进行监听的API，具体操作是利用<strong>节点缓存</strong>上的监听器监听节点的数据变化。监听节点主要分为下面几个操作：</p><ul><li>监听单个节点</li><li>监听所有子节点</li><li>监听节点树</li></ul><h3 id="监听单个节点API"><a href="#监听单个节点API" class="headerlink" title="监听单个节点API"></a>监听单个节点API</h3><p>监听单个节点的案例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//----------------- 监听单个节点 -----------------------------------</span></span><br><span class="line"><span class="comment">//1. 创建NodeCache对象</span></span><br><span class="line"><span class="keyword">final</span> NodeCache nodeCache = <span class="keyword">new</span> NodeCache(client,<span class="string">"/app1"</span>);</span><br><span class="line"><span class="comment">//2. 注册监听</span></span><br><span class="line">nodeCache.getListenable().addListener(<span class="keyword">new</span> NodeCacheListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nodeChanged</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"节点变化了~"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取修改节点后的数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] data = nodeCache.getCurrentData().getData();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(data));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//3. 开启监听.如果设置为true，则开启监听是，加载缓冲数据</span></span><br><span class="line">nodeCache.start(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h3 id="监听子节点API"><a href="#监听子节点API" class="headerlink" title="监听子节点API"></a>监听子节点API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//----------------- 监听子节点 -----------------------------------</span></span><br><span class="line"><span class="comment">//1.创建监听对象</span></span><br><span class="line">PathChildrenCache pathChildrenCache = <span class="keyword">new</span> PathChildrenCache(client,<span class="string">"/app2"</span>,<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//2. 绑定监听器</span></span><br><span class="line">pathChildrenCache.getListenable().addListener(<span class="keyword">new</span> PathChildrenCacheListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">childEvent</span><span class="params">(CuratorFramework client, PathChildrenCacheEvent event)</span>  </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"子节点变化了~"</span>);</span><br><span class="line">System.out.println(event);</span><br><span class="line"><span class="comment">//监听子节点的数据变更，并且拿到变更后的数据</span></span><br><span class="line"><span class="comment">//1.获取类型</span></span><br><span class="line">PathChildrenCacheEvent.Type type = event.getType();</span><br><span class="line"><span class="comment">//2.判断类型是否是update</span></span><br><span class="line"><span class="keyword">if</span>(type.equals(PathChildrenCacheEvent.Type.CHILD_UPDATED))&#123;</span><br><span class="line">System.out.println(<span class="string">"数据变了！！！"</span>);</span><br><span class="line"><span class="keyword">byte</span>[] data = event.getData().getData();</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(data));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//3. 开启</span></span><br><span class="line">pathChildrenCache.start();</span><br></pre></td></tr></table></figure><h3 id="监听节点树"><a href="#监听节点树" class="headerlink" title="监听节点树"></a>监听节点树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//----------------- 监听节点树 -----------------------------------</span></span><br><span class="line"><span class="comment">//1. 创建监听器</span></span><br><span class="line">TreeCache treeCache = <span class="keyword">new</span> TreeCache(client,<span class="string">"/app2"</span>);</span><br><span class="line"><span class="comment">//2. 注册监听</span></span><br><span class="line">treeCache.getListenable().addListener(<span class="keyword">new</span> TreeCacheListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">childEvent</span><span class="params">(CuratorFramework client, TreeCacheEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"节点变化了"</span>);</span><br><span class="line">        System.out.println(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//3. 开启</span></span><br><span class="line">treeCache.start();</span><br></pre></td></tr></table></figure><h2 id="NodeCache-源码解析"><a href="#NodeCache-源码解析" class="headerlink" title="NodeCache 源码解析"></a>NodeCache 源码解析</h2><p>有关节点监听机制，和ZK 的 watch 机制也有关，下面来简单解析 NodeCache 相关源码实现。</p><h3 id="初始化部分"><a href="#初始化部分" class="headerlink" title="初始化部分"></a>初始化部分</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NodeCache</span><span class="params">(CuratorFramework client, String path, <span class="keyword">boolean</span> dataIsCompressed)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.client = client.newWatcherRemoveCuratorFramework();  </span><br><span class="line">    <span class="keyword">this</span>.path = PathUtils.validatePath(path);  </span><br><span class="line">    <span class="keyword">this</span>.dataIsCompressed = dataIsCompressed;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键部分是构建了<code>WatcherRemovalFacade</code>监听器的门面对象，在Cache 发生变化之后会触发事件监听回调通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> WatcherRemovalFacade(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><h3 id="start-启动"><a href="#start-启动" class="headerlink" title="start() 启动"></a>start() 启动</h3><p><strong>NodeCache</strong> 使用必须要结合 <code>xxx.start();</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>     <span class="title">start</span><span class="params">(<span class="keyword">boolean</span> buildInitial)</span> <span class="keyword">throws</span> Exception  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"><span class="comment">// 检查启动状态</span></span><br><span class="line">    Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), <span class="string">"Cannot be started more than once"</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加连接状态监听器</span></span><br><span class="line">    client.getConnectionStateListenable().addListener(connectionStateListener);  </span><br><span class="line"><span class="comment">// 初始化处理</span></span><br><span class="line">    <span class="keyword">if</span> ( buildInitial )  </span><br><span class="line">    &#123;  </span><br><span class="line">        client.checkExists().creatingParentContainersIfNeeded().forPath(path);  </span><br><span class="line">        internalRebuild();  </span><br><span class="line">    &#125;  </span><br><span class="line">    reset();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要注意<code>client.getConnectionStateListenable().addListener(connectionStateListener);</code>这一串代码实际上是注册到 <strong>CuratorFrameworkImpl</strong>内部的连接状态管理器 <strong>ConnectionStateManager</strong>。</p><p>连接状态监听器的实现如下，主要是解决了原生客户端Watch只能使用一次的问题，这里通过监听状态变化并且结合CAS操作完成更新。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ConnectionStateListener connectionStateListener = <span class="keyword">new</span> ConnectionStateListener()  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(CuratorFramework client, ConnectionState newState)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> ( (newState == ConnectionState.CONNECTED) || (newState == ConnectionState.RECONNECTED) )  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span> ( isConnected.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>) )  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">try</span>  </span><br><span class="line">                &#123;  </span><br><span class="line">                    reset();  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">catch</span> ( Exception e )  </span><br><span class="line">                &#123;  </span><br><span class="line">                    ThreadUtils.checkInterrupted(e);  </span><br><span class="line">                    log.error(<span class="string">"Trying to reset after reconnection"</span>, e);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            isConnected.set(<span class="keyword">false</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上下两部分代码都调用了<code>reset()</code>方法，它在内部传递了两个对象 <strong>监听对象watcher</strong> 以及 <strong>回调对象backgroundCallback(异步回调)</strong>，前者在一开始启动就会注册进来，而后者则需要返回数据的时候执行回调函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reset() 方法内部实现</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span>  <span class="title">reset</span><span class="params">()</span> <span class="keyword">throws</span> Exception  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> ( (state.get() == State.STARTED) &amp;&amp; isConnected.get() )  </span><br><span class="line">    &#123;  </span><br><span class="line">        </span><br><span class="line">        client.checkExists().creatingParentContainersIfNeeded().usingWatcher(watcher).inBackground(backgroundCallback).forPath(path);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>监听对象watcher</strong> 所干的事情就是不断重新执行<code>reset</code>方法，把监听器重新注册到对应的节点上面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Watcher watcher = <span class="keyword">new</span> Watcher()  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">try</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            reset();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">catch</span>(Exception e)  </span><br><span class="line">        &#123;  </span><br><span class="line">            ThreadUtils.checkInterrupted(e);  </span><br><span class="line">            handleException(e);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="异步回调逻辑"><a href="#异步回调逻辑" class="headerlink" title="异步回调逻辑"></a>异步回调逻辑</h3><p>异步回调的任务是判断当前事件是获取数据还是检查是否存在，之后进行本地缓存数据的变更，以及刷新本地缓存数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BackgroundCallback backgroundCallback = <span class="keyword">new</span> BackgroundCallback()  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(CuratorFramework client, CuratorEvent event)</span> <span class="keyword">throws</span> Exception  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        processBackgroundResult(event);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processBackgroundResult</span><span class="params">(CuratorEvent event)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="comment">// 当发生获取数据或者是判断节点是否存在时候进行监听</span></span><br><span class="line">        <span class="keyword">switch</span> ( event.getType() )</span><br><span class="line">        &#123;</span><br><span class="line">         <span class="comment">// 响应状态为ok时，将刷新本地缓存的数据</span></span><br><span class="line">            <span class="keyword">case</span> GET_DATA:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ( event.getResultCode() == KeeperException.Code.OK.intValue() )</span><br><span class="line">                &#123;</span><br><span class="line">                 <span class="comment">// 获取监听到的数据变动集合</span></span><br><span class="line">                    ChildData childData = <span class="keyword">new</span> ChildData(path, event.getStat(), event.getData());</span><br><span class="line">                <span class="comment">// 刷新本地缓存数据</span></span><br><span class="line">                    setNewData(childData);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> EXISTS:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )</span><br><span class="line">                &#123;</span><br><span class="line">                    setNewData(<span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ( event.getResultCode() == KeeperException.Code.OK.intValue() )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( dataIsCompressed )</span><br><span class="line">                    &#123;</span><br><span class="line">                        client.getData().decompressed().usingWatcher(watcher).inBackground(backgroundCallback).forPath(path);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        client.getData().usingWatcher(watcher).inBackground(backgroundCallback).forPath(path);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 调用<strong>setNewData(childData);</strong> 之后会刷新本地缓存数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setNewData</span><span class="params">(ChildData newData)</span> <span class="keyword">throws</span> InterruptedException  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"><span class="comment">// 比较最新数据和变更前的数据，查看是否有变更</span></span><br><span class="line">    ChildData   previousData = data.getAndSet(newData);  </span><br><span class="line">    <span class="keyword">if</span> ( !Objects.equal(previousData, newData) )  </span><br><span class="line">    &#123;  </span><br><span class="line">        listeners.forEach  </span><br><span class="line">        (  </span><br><span class="line">        <span class="comment">// 用节点监听容器内部的监听器处理目录变更事件</span></span><br><span class="line">            <span class="keyword">new</span> Function&lt;NodeCacheListener, Void&gt;()  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="meta">@Override</span>  </span><br><span class="line">                <span class="function"><span class="keyword">public</span> Void <span class="title">apply</span><span class="params">(NodeCacheListener listener)</span>  </span></span><br><span class="line"><span class="function">                </span>&#123;  </span><br><span class="line">                    <span class="keyword">try</span>  </span><br><span class="line">                    &#123;  </span><br><span class="line">                        listener.nodeChanged();  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    <span class="keyword">catch</span> ( Exception e )  </span><br><span class="line">                    &#123;  </span><br><span class="line">                        ThreadUtils.checkInterrupted(e);  </span><br><span class="line">                        log.error(<span class="string">"Calling listener"</span>, e);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        );  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> ( rebuildTestExchanger != <span class="keyword">null</span> )  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">try</span>  </span><br><span class="line">            &#123;  </span><br><span class="line">                rebuildTestExchanger.exchange(<span class="keyword">new</span> Object());  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">catch</span> ( InterruptedException e )  </span><br><span class="line">            &#123;  </span><br><span class="line">                Thread.currentThread().interrupt();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何触发注册的监听器？"><a href="#如何触发注册的监听器？" class="headerlink" title="如何触发注册的监听器？"></a>如何触发注册的监听器？</h3><p>我们回到 <code>start()</code> 启动这部分代码，来看下如何触发监听器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加连接状态监听器</span></span><br><span class="line">client.getConnectionStateListenable().addListener(connectionStateListener);</span><br></pre></td></tr></table></figure><p>这里注册到 <strong>CuratorFrameworkImpl</strong>内部的连接状态管理器 <strong>ConnectionStateManager</strong>，具体的注册过程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Listenable&lt;ConnectionStateListener&gt; <span class="title">getListenable</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> listeners;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 <code>listeners</code> 成员变量定义如下，可以看到它是一个监听器的管理容器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> UnaryListenerManager&lt;ConnectionStateListener&gt; listeners;</span><br></pre></td></tr></table></figure><p>这个容器什么时候会通知注册在其中的监听器？</p><p>答案是在出现状态变更的时候：</p><p><strong>org.apache.curator.framework.state.ConnectionStateManager#processEvents</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listeners.forEach(listener -&gt; listener.stateChanged(client, newState));</span><br></pre></td></tr></table></figure><p>这部分内容在[[【Zookeeper】Apach Curator 框架源码分析：初始化过程（一）【Ver 4.3.0】]] 的通知机制中有详细介绍【参考：注册 ConnectionStateListener 通知部分】。</p><p>这里节省读者时间，我们直接看一个草图：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230717111550.png" alt="image.png"></p><p><code>ConnectionStateManager</code> 调用<code>start</code> 启动之后，会开启一个单线程线程池异步的轮询，并且在状态变更的时候回调<strong>UnaryListenerManager</strong>容器中注册的监听器。</p><p>以上就是关于如何触发注册的监听器的问题解答。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>节点监听缓存 NodeCache，内部关联Curator框架客户端CuratorFramework，通过节点内部的监听器容器 listeners（ListenerContainer）存放节点监听器。</p><p>添加节点监听器，实际上是注册到节点缓存的节点监听器容器<strong>ListenerContainer</strong>（CuratorFrameworkImpl内部的成员添加节点监听器，注册到节点缓存的节点监听器容器ListenerContainer）中。 </p><p>启动节点监听器，注册节点监听器到CuratorFramework实现的连接状态管理器中<strong>ConnectionStateManager</strong>，如果需要则重新构建节点数据，同时重新注册节点监听器 <strong>CuratorWatcher</strong>，如果连接状态有变更， 重新注册节点监听器CuratorWatcher。</p><p>以上内容需要区分添加和启动过程，两者分别存储在两个不同的容器当中，这个添加过程类似先把鸡蛋放自己的篮子，启动之后再把自己篮子的鸡蛋倒入”机器“中运作。</p><p>当然上面的API没有分析PathChildrenCache，这里进行简单描述大致了解即可。</p><p>子目录监听器PathChildrenCache，主要成员变量为客户端框架实现CuratorFramework，子路径监听器容器 ListenerContainer（ListenerAble），及事件执行器CloseableExecutorService，事件操作集Set。</p><p>一级目录监听器PathChildrenCache，启动过程主要是注册连接状态监听器ConnectionStateListener，连接状态监听器根据连接状态来添加事件EventOperation和RefreshOperation操作到操作集。 </p><p><strong>事件操作EventOperation</strong>：主要是触发监听器的子目录事件操作；</p><p><strong>事件刷新操作 RefreshOperation</strong>：主要是完成子目录的添加和刷新事件，并重新注册子目录监听器。 然后根据启动模式来决定是重添加事件操作，刷新、事件操作，或者重新构建，即刷新缓存路径数据，并注册刷新操作。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>这里还是吐槽Curator 这代码设计挺绕的，还有很多贴合设计模式的古怪代码。</p><h1 id="上一篇"><a href="#上一篇" class="headerlink" title="上一篇"></a>上一篇</h1><p>[[【Zookeeper】Apach Curator 框架源码分析：初始化过程（一）【Ver 4.3.0】]]</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VuX2pva2VyL2FydGljbGUvZGV0YWlscy83ODc4MTc1MA==" title="https://blog.csdn.net/en_joker/article/details/78781750">(3条消息) Curator之创建节点_curator创建节点_孤芳不自賞的博客-CSDN博客<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9qYXZhZ3VpZGUuY24vZGlzdHJpYnV0ZWQtc3lzdGVtL2Rpc3RyaWJ1dGVkLXByb2Nlc3MtY29vcmRpbmF0aW9uL3pvb2tlZXBlci96b29rZWVwZXItaW50cm8uaHRtbCN6bm9kZS0lRTYlOTUlQjAlRTYlOEQlQUUlRTglOEElODIlRTclODIlQjk=" title="https://javaguide.cn/distributed-system/distributed-process-coordination/zookeeper/zookeeper-intro.html#znode-%E6%95%B0%E6%8D%AE%E8%8A%82%E7%82%B9">ZooKeeper相关概念总结(入门) | JavaGuide(Java面试 + 学习指南)<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9hODY0YmY4YTZjM2M=" title="https://www.jianshu.com/p/a864bf8a6c3c">https://www.jianshu.com/p/a864bf8a6c3c<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9kb25hbGRoYW4uZ2l0aHViLmlvL3pvb2tlZXBlci8yMDE4LzA2LzI5L2N1cmF0b3IlRTclOUIlQUUlRTUlQkQlOTUlRTclOUIlOTElRTUlOTAlQUMuaHRtbCMlRTglOEElODIlRTclODIlQjklRTclOUIlOTElRTUlOTAlQUMlRTUlOTklQThub2RlY2FjaGU=" title="https://donaldhan.github.io/zookeeper/2018/06/29/curator%E7%9B%AE%E5%BD%95%E7%9B%91%E5%90%AC.html#%E8%8A%82%E7%82%B9%E7%9B%91%E5%90%AC%E5%99%A8nodecache">https://donaldhan.github.io/zookeeper/2018/06/29/curator%E7%9B%AE%E5%BD%95%E7%9B%91%E5%90%AC.html#%E8%8A%82%E7%82%B9%E7%9B%91%E5%90%AC%E5%99%A8nodecache<i class="fa fa-external-link"></i></span></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      源码分析Curator的使用
    
    </summary>
    
    
      <category term="Zookeeper" scheme="https://whitestore.top/categories/Zookeeper/"/>
    
    
      <category term="Zookeeper" scheme="https://whitestore.top/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>【Zookeeper】Apach Curator 框架源码分析：初始化过程（一）【Ver 4.3.0】</title>
    <link href="https://whitestore.top/2023/08/10/curatorsource1/"/>
    <id>https://whitestore.top/2023/08/10/curatorsource1/</id>
    <published>2023-08-10T08:57:00.000Z</published>
    <updated>2023-09-09T00:53:49.936Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Curator是netflix公司开源的一套zookeeper客户端，目前是Apache的顶级项目。</p><p>和ZK的原生客户端相比，Curator的抽象层次要更高，同时简化了ZK的常用功能开发量，比如Curator自带连接重试、反复注册Watcher、NodeExistsException 异常处理等等。</p><p>根据官方的介绍，我们可以了解到它是一个用于分布式的Java客户端API工具。它基于<code>high-level API</code>，拥有它可以更简单易懂的指挥Zookeeper实现分布式安全应用程序开发。</p><p>Curator由一系列的模块构成，对于一般开发者而言，常用的是<strong>curator-framework</strong>和<strong>curator-recipes</strong>，以及广为熟知的 <strong>分布式锁</strong>。</p><p>Curator 当然也包括许多扩展，比如<strong>服务发现</strong>和<strong>基于Java 8异步DSL</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Apache Curator is a Java&#x2F;JVM client library for [Apache ZooKeeper](https:&#x2F;&#x2F;zookeeper.apache.org&#x2F;), a distributed coordination service.</span><br><span class="line"></span><br><span class="line">Apache Curator includes a high-level API framework and utilities to make using Apache ZooKeeper much easier and more reliable. It also includes recipes for common use cases and extensions such as service discovery and a Java 8 asynchronous DSL.</span><br></pre></td></tr></table></figure><blockquote><p>用官方的介绍来说就是：guava之于java就像curator之于zookeeper </p></blockquote><a id="more"></a><h1 id="ZK-版本支持"><a href="#ZK-版本支持" class="headerlink" title="ZK 版本支持"></a>ZK 版本支持</h1><p>Curator 目前最新的版本为 5.X 的版本，已经不支持 ZK 的 3.4.X 以及之前的版本，阅读源码之前经过认真考虑，最终选择了 ZK的 <strong>3.5.10</strong> 版本。</p><blockquote><p>5.X 对于 Curator 做了不少破坏性的改动，不兼容的原因如下：</p><ul><li>旧的ListenerContainer类已经被移除，以避免Guava类泄漏。</li><li>ConnectionHandlingPolicy和相关类已被删除</li><li>Reaper和ChildReaper类/recipes已被删除。您应该改用 ZooKeeper 容器节点。</li><li>newPersistentEphemeralNode()和newPathChildrenCache()已从GroupMember中移除。</li><li>ServiceCacheBuilder&lt; T&gt; executorService(CloseableExecutorService executorService)已从ServiceCacheBuilder中移除。</li><li>ServiceProviderBuilder&lt; T&gt; executorService(CloseableExecutorService executorService)已从ServiceProviderBuilder中移除。</li><li>static boolean shouldRetry(int rc)已从RetryLoop中移除。</li><li>static boolean isRetryException(Throwable exception)已从RetryLoop中移除。</li></ul></blockquote><h1 id="官网地址"><a href="#官网地址" class="headerlink" title="官网地址"></a>官网地址</h1><p><span class="exturl" data-url="aHR0cHM6Ly9jdXJhdG9yLmFwYWNoZS5vcmcv" title="https://curator.apache.org/">Apache Curator<i class="fa fa-external-link"></i></span></p><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><p>Curator Maven 相关地址：<span class="exturl" data-url="aHR0cHM6Ly9tdm5yZXBvc2l0b3J5LmNvbS9hcnRpZmFjdC9vcmcuYXBhY2hlLmN1cmF0b3I=" title="https://mvnrepository.com/artifact/org.apache.curator">https://mvnrepository.com/artifact/org.apache.curator<i class="fa fa-external-link"></i></span></p><p>Curator jar包下载地址：<span class="exturl" data-url="aHR0cHM6Ly9jd2lraS5hcGFjaGUub3JnL2NvbmZsdWVuY2UvZGlzcGxheS9DVVJBVE9SL1JlbGVhc2Vz" title="https://cwiki.apache.org/confluence/display/CURATOR/Releases">https://cwiki.apache.org/confluence/display/CURATOR/Releases<i class="fa fa-external-link"></i></span></p><h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><h2 id="ZK-集群部署"><a href="#ZK-集群部署" class="headerlink" title="ZK 集群部署"></a>ZK 集群部署</h2><p>学习之前需要使用ZK搭建集群环境，方便Debug的时候调试代码。这部分搭建过程放到另一篇文章：</p><p>[[【Zookeeper】基于3台linux虚拟机搭建zookeeper集群]]</p><h2 id="Maven依赖引入"><a href="#Maven依赖引入" class="headerlink" title="Maven依赖引入"></a>Maven依赖引入</h2><p>下面是对应的Zookeeper和Curator的版本选择。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">curator.version</span>&gt;</span>4.3.0<span class="tag">&lt;/<span class="name">curator.version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">zookeeper.version</span>&gt;</span>3.5.10<span class="tag">&lt;/<span class="name">zookeeper.version</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;curator.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;curator.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;zookeeper.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="构建入门实例"><a href="#构建入门实例" class="headerlink" title="构建入门实例"></a>构建入门实例</h2><p>Curator 最为核心和强大并且常用功能是分布式锁。</p><p>在入门demo中可以看到整个 Curator 依靠 <strong>CuratorFrameworkFactory</strong> 构建，使用 Curator 进行分布式加锁解锁操作，只需要为所连接的ZooKeeper集群提供一个CuratorFramework对象即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CuratorFrameworkFactory.newClient(zookeeperConnectionString, retryPolicy)</span><br></pre></td></tr></table></figure><p>上面的方法将会使用默认值创建与ZooKeeper集群的连接，调用放只需要关注使用到的重试策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>)</span><br><span class="line">CuratorFramework client = CuratorFrameworkFactory.newClient(zookeeperConnectionString, retryPolicy);</span><br><span class="line">client.start();</span><br></pre></td></tr></table></figure><p>从参数值可以大致了解到，这里使用的策略是指数递增间隔的方式尝试重试时间，并且指定重试三次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>);  </span><br><span class="line">CuratorFramework client =  </span><br><span class="line">        CuratorFrameworkFactory.newClient(<span class="string">"192.168.0.1;192.168.0.2;192.168.0.3"</span>, retryPolicy);  </span><br><span class="line">client.start();  </span><br><span class="line"><span class="comment">// 此处就获取到 zk的一个连接实例。  </span></span><br><span class="line"><span class="comment">//.....</span></span><br></pre></td></tr></table></figure><p>拥有了 <strong>CuratorFramework</strong> 实例之后，就可以直接通过 API 调用操作ZK。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.create().forPath(<span class="string">"/my/path"</span>, myData)</span><br></pre></td></tr></table></figure><blockquote><p>这样的直接调用还有个好处是client实例如果碰到网络抖动等情况会自动重试，重试过程不需要开发者自己实现。</p></blockquote><h2 id="可重入锁（公平锁）案例代码"><a href="#可重入锁（公平锁）案例代码" class="headerlink" title="可重入锁（公平锁）案例代码"></a>可重入锁（公平锁）案例代码</h2><p>下面是官网可重入锁的Demo使用代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">InterProcessMutex lock = <span class="keyword">new</span> InterProcessMutex(client, lockPath);</span><br><span class="line"><span class="keyword">if</span> ( lock.acquire(maxWait, waitUnit) ) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// do some work inside of the critical section here</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        lock.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里改造一下即可简单使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>);  </span><br><span class="line">CuratorFramework client =  </span><br><span class="line">        CuratorFrameworkFactory.newClient(<span class="string">"192.168.0.1,192.168.0.2,192.168.0.3"</span>, retryPolicy);  </span><br><span class="line">client.start();  </span><br><span class="line"><span class="comment">// 此处就获取到 zk的一个连接实例。  </span></span><br><span class="line"><span class="comment">//.....  </span></span><br><span class="line">client.create().forPath(<span class="string">"/my/path"</span>, <span class="string">"Test"</span>.getBytes());  </span><br><span class="line">InterProcessMutex lock = <span class="keyword">new</span> InterProcessMutex(client, <span class="string">"/test/myLock"</span>);  </span><br><span class="line">lock.acquire();  </span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">    <span class="comment">// do some work inside of the critical section here  </span></span><br><span class="line">    Thread.sleep(<span class="number">3000</span>);  </span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">    lock.release();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个Demo案例代码比较简单，下面直接开始介绍初始化过程。</p><p>本文主要介绍和<strong>Curator初始化</strong>、内部的<strong>通知机制</strong>以及<strong>会话管理</strong>部分。</p><h1 id="初始化过程流程图"><a href="#初始化过程流程图" class="headerlink" title="初始化过程流程图"></a>初始化过程流程图</h1><p>初始化过程流程图全图如下。下面将会一步步拆解这幅图是如何拼凑的。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/Curator%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.drawio.png" alt="Curator 源码分析.drawio.png"></p><blockquote><p>Drawio 源文件和图片地址如下：<br>链接：<span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMThQb01qa3AxMUx6dG1OQjNYZ1owcXc/cHdkPTRidWc=" title="https://pan.baidu.com/s/18PoMjkp11LztmNB3XgZ0qw?pwd=4bug">https://pan.baidu.com/s/18PoMjkp11LztmNB3XgZ0qw?pwd=4bug<i class="fa fa-external-link"></i></span><br>    提取码：4bug </p></blockquote><h1 id="初始化源码分析"><a href="#初始化源码分析" class="headerlink" title="初始化源码分析"></a>初始化源码分析</h1><h2 id="CuratorFramework-初始化过程"><a href="#CuratorFramework-初始化过程" class="headerlink" title="CuratorFramework 初始化过程"></a>CuratorFramework 初始化过程</h2><h3 id="初始化过程流程图-1"><a href="#初始化过程流程图-1" class="headerlink" title="初始化过程流程图"></a>初始化过程流程图</h3><p>CuratorFramework 初始化过程为下面截图这一部分，红色部分为个人认为相对比较重要的对象和变量。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230708120150.png" alt="image.png"></p><h3 id="CuratorFrameworkFactory-newClient-代码分析"><a href="#CuratorFrameworkFactory-newClient-代码分析" class="headerlink" title="CuratorFrameworkFactory.newClient() 代码分析"></a>CuratorFrameworkFactory.newClient() 代码分析</h3><p>下面通过<code>CuratorFrameworkFactory.newClient()</code>一步步探究整个初始化过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>);  </span><br><span class="line">CuratorFramework client =  </span><br><span class="line">        CuratorFrameworkFactory.newClient(<span class="string">"192.168.19.100:2181,192.168.19.101:2181,192.168.19.102:2181"</span>, retryPolicy);</span><br></pre></td></tr></table></figure><p>在获取分布式锁之前，我们需要先连接ZK集群，整个过程通过两行代码完成。</p><p>首先，我们需要确定连接ZK的重试策略，接着通过<code>CuratorFrameworkFactory</code>构建<code>Curator</code> 实例，<code>Curator</code>内部根据ZK原生客户端做了一层封装，开发者使用过程中不需要关注。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>);  </span><br><span class="line">CuratorFramework client =  CuratorFrameworkFactory.newClient(<span class="string">"192.168.0.1,192.168.0.2,192.168.0.3"</span>, retryPolicy);</span><br></pre></td></tr></table></figure><p>上面是简单的模板代码。<strong>ExponentialBackoffRetry</strong> 构建重试策略为按照指数增长重试时间，比如第一次1秒，第二次2秒，第三次4秒，第四次8秒….. </p><p>接着是利用<code>CuratorFrameworkFactory</code>构建实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> newClient(connectString, DEFAULT_SESSION_TIMEOUT_MS, DEFAULT_CONNECTION_TIMEOUT_MS, retryPolicy);</span><br></pre></td></tr></table></figure><p>这里强调一下两个常量 <strong>DEFAULT_SESSION_TIMEOUT_MS</strong> （默认的会话超时时间）、<strong>DEFAULT_CONNECTION_TIMEOUT_MS</strong>（默认的连接超时时间），作用是传入重试策略时候填写默认参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_SESSION_TIMEOUT_MS</span><br><span class="line">    = Integer.getInteger(<span class="string">"curator-default-session-timeout"</span>, <span class="number">60</span> * <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONNECTION_TIMEOUT_MS = Integer.getInteger(<span class="string">"curator-default-connection-timeout"</span>, <span class="number">15</span> * <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>我们进一步进入构造方法，这里用了建造者模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> builder().  </span><br><span class="line">    connectString(connectString).  </span><br><span class="line">    sessionTimeoutMs(sessionTimeoutMs).  </span><br><span class="line">    connectionTimeoutMs(connectionTimeoutMs).  </span><br><span class="line">    retryPolicy(retryPolicy).  </span><br><span class="line">    build();</span><br></pre></td></tr></table></figure><p><code>build()</code>工作完成之后，后续的调用实际上调用的是<strong>CuratorFrameworkImpl</strong>实例，注意这里把<strong>CuratorFrameworkFactory</strong>的<strong>this</strong>引用逸出给<strong>CuratorFrameworkImpl</strong>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> CuratorFrameworkImpl(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p><code>CuratorFrameworkImpl</code> 构造方法的内容比较多，这里在源码对于相对重要的组件进行标注，这里的<strong>CuratorZookeeperClient</strong>这个对象，相当于ZK原生客户端的封装对象，Curator的很多质量都是由它来完成调用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CuratorFrameworkImpl</span><span class="params">(CuratorFrameworkFactory.Builder builder)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    ZookeeperFactory localZookeeperFactory = makeZookeeperFactory(builder.getZookeeperFactory());  </span><br><span class="line">    <span class="keyword">this</span>.client = <span class="keyword">new</span> CuratorZookeeperClient  </span><br><span class="line">        (  </span><br><span class="line">            localZookeeperFactory,  </span><br><span class="line">            builder.getEnsembleProvider(),  </span><br><span class="line">            builder.getSessionTimeoutMs(),  </span><br><span class="line">            builder.getConnectionTimeoutMs(),  </span><br><span class="line">            builder.getWaitForShutdownTimeoutMs(),  </span><br><span class="line">            <span class="keyword">new</span> Watcher()  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="meta">@Override</span>  </span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span>  </span></span><br><span class="line"><span class="function">                </span>&#123;  </span><br><span class="line">                    CuratorEvent event = <span class="keyword">new</span> CuratorEventImpl(CuratorFrameworkImpl.<span class="keyword">this</span>, CuratorEventType.WATCHED, watchedEvent.getState().getIntValue(), unfixForNamespace(watchedEvent.getPath()), <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, watchedEvent, <span class="keyword">null</span>, <span class="keyword">null</span>);  </span><br><span class="line">                    processEvent(event);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;,  </span><br><span class="line">            builder.getRetryPolicy(),  </span><br><span class="line">            builder.canBeReadOnly(),  </span><br><span class="line">            builder.getConnectionHandlingPolicy()  </span><br><span class="line">        );  </span><br><span class="line">  <span class="comment">//用于判断连接断开和连接超时的状态，设置curator的连接状态，并通过connectionStateManager触发连接事件状态通知</span></span><br><span class="line">    internalConnectionHandler = <span class="keyword">new</span> StandardInternalConnectionHandler();</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//接收事件的通知。后台线程操作事件和连接状态事件会触发 </span></span><br><span class="line">    listeners = <span class="keyword">new</span> ListenerContainer&lt;CuratorListener&gt;();  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当后台线程发生异常或者handler发生异常的时候会触发</span></span><br><span class="line">    unhandledErrorListeners = <span class="keyword">new</span> ListenerContainer&lt;UnhandledErrorListener&gt;();  </span><br><span class="line">    <span class="comment">//后台线程执行的操作队列</span></span><br><span class="line">    backgroundOperations = <span class="keyword">new</span> DelayQueue&lt;OperationAndData&lt;?&gt;&gt;();  </span><br><span class="line">    forcedSleepOperations = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();  </span><br><span class="line">    <span class="comment">//命名空间</span></span><br><span class="line">    namespace = <span class="keyword">new</span> NamespaceImpl(<span class="keyword">this</span>, builder.getNamespace());  </span><br><span class="line"></span><br><span class="line"><span class="comment">//线程工厂方法，初始化后台线程池时会使用</span></span><br><span class="line">    threadFactory = getThreadFactory(builder);  </span><br><span class="line"></span><br><span class="line">maxCloseWaitMs = builder.getMaxCloseWaitMs();  </span><br><span class="line"></span><br><span class="line"><span class="comment">//负责连接状态变化时的通知</span></span><br><span class="line">    connectionStateManager = <span class="keyword">new</span> ConnectionStateManager(<span class="keyword">this</span>, builder.getThreadFactory(), builder.getSessionTimeoutMs(), builder.getConnectionHandlingPolicy().getSimulatedSessionExpirationPercent(), builder.getConnectionStateListenerDecorator());  </span><br><span class="line">    compressionProvider = builder.getCompressionProvider();  </span><br><span class="line">    aclProvider = builder.getAclProvider();  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//CuratorFrameworkImpl的状态，调用start方法之前为 LATENT，调用start方法之后为 STARTED ,调用close()方法之后为STOPPEDstate = new AtomicReference&lt;CuratorFrameworkState&gt;(CuratorFrameworkState.LATENT);  </span></span><br><span class="line">    useContainerParentsIfAvailable = builder.useContainerParentsIfAvailable(); </span><br><span class="line">    <span class="comment">//错误连接策略 </span></span><br><span class="line">    connectionStateErrorPolicy = Preconditions.checkNotNull(builder.getConnectionStateErrorPolicy(), <span class="string">"errorPolicy cannot be null"</span>);  </span><br><span class="line">    schemaSet = Preconditions.checkNotNull(builder.getSchemaSet(), <span class="string">"schemaSet cannot be null"</span>);  </span><br><span class="line">    zk34CompatibilityMode = builder.isZk34CompatibilityMode();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">byte</span>[] builderDefaultData = builder.getDefaultData();  </span><br><span class="line">    defaultData = (builderDefaultData != <span class="keyword">null</span>) ? Arrays.copyOf(builderDefaultData, builderDefaultData.length) : <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];  </span><br><span class="line">    authInfos = buildAuths(builder);  </span><br><span class="line">    </span><br><span class="line">  <span class="comment">//有保障的执行删除操作，其实是不断尝试直到删除成功，通过递归调用实现</span></span><br><span class="line">    failedDeleteManager = <span class="keyword">new</span> FailedDeleteManager(<span class="keyword">this</span>);  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//有保障的执行删除watch操作</span></span><br><span class="line">    failedRemoveWatcherManager = <span class="keyword">new</span> FailedRemoveWatchManager(<span class="keyword">this</span>);  </span><br><span class="line">    </span><br><span class="line">    namespaceFacadeCache = <span class="keyword">new</span> NamespaceFacadeCache(<span class="keyword">this</span>);  </span><br><span class="line">    </span><br><span class="line">  <span class="comment">//服务端可用节点的检测器，第一次连接和重连成功之后都会触发重新获取服务端列表</span></span><br><span class="line">    ensembleTracker = zk34CompatibilityMode ? <span class="keyword">null</span> : <span class="keyword">new</span> EnsembleTracker(<span class="keyword">this</span>, builder.getEnsembleProvider());  </span><br><span class="line">  </span><br><span class="line">    runSafeService = makeRunSafeService(builder);</span><br></pre></td></tr></table></figure><p><code>newClient</code>的目的是构建ZK连接实例，包括一系列附加核心组件：后台操作、连接事件、异常监控、容器，命名空间、负载均衡等等。</p><h2 id="CuratorZookeeperClient-初始化过程"><a href="#CuratorZookeeperClient-初始化过程" class="headerlink" title="CuratorZookeeperClient 初始化过程"></a>CuratorZookeeperClient 初始化过程</h2><h3 id="CuratorZookeeperClient-初始化过程流程图"><a href="#CuratorZookeeperClient-初始化过程流程图" class="headerlink" title="CuratorZookeeperClient 初始化过程流程图"></a>CuratorZookeeperClient 初始化过程流程图</h3><p>CuratorZookeeperClient 初始化过程图如下：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230708120426.png" alt="image.png"></p><h3 id="CuratorZookeeperClient-初始化代码分析"><a href="#CuratorZookeeperClient-初始化代码分析" class="headerlink" title="CuratorZookeeperClient 初始化代码分析"></a>CuratorZookeeperClient 初始化代码分析</h3><p>上面提到，<code>CuratorFrameworkImp</code>l的初始化过程中，有一段比较重要的<code>CuratorZookeeperClient</code>客户端初始化过程，下面就来看看这个初始化过程干了啥。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CuratorZookeeperClient</span><span class="params">(ZookeeperFactory zookeeperFactory, EnsembleProvider ensembleProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> sessionTimeoutMs, <span class="keyword">int</span> connectionTimeoutMs, <span class="keyword">int</span> waitForShutdownTimeoutMs, Watcher watcher,</span></span></span><br><span class="line"><span class="function"><span class="params">            RetryPolicy retryPolicy, <span class="keyword">boolean</span> canBeReadOnly, ConnectionHandlingPolicy connectionHandlingPolicy)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StandardConnectionHandler当收到Disconnect事件后，如果在规定时间内没有重连到服务器，则会主动触发Expired事件</span></span><br><span class="line">        <span class="keyword">this</span>.connectionHandlingPolicy = connectionHandlingPolicy;</span><br><span class="line">        <span class="keyword">if</span> ( sessionTimeoutMs &lt; connectionTimeoutMs )</span><br><span class="line">        &#123;</span><br><span class="line">            log.warn(String.format(<span class="string">"session timeout [%d] is less than connection timeout [%d]"</span>, sessionTimeoutMs, connectionTimeoutMs));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 重连策略</span></span><br><span class="line">        retryPolicy = Preconditions.checkNotNull(retryPolicy, <span class="string">"retryPolicy cannot be null"</span>);</span><br><span class="line">        ensembleProvider = Preconditions.checkNotNull(ensembleProvider, <span class="string">"ensembleProvider cannot be null"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.connectionTimeoutMs = connectionTimeoutMs;</span><br><span class="line">        <span class="keyword">this</span>.waitForShutdownTimeoutMs = waitForShutdownTimeoutMs;</span><br><span class="line">        <span class="comment">// //curator注册到原生客户端上的defaultWatcher,会收到和连接状态有关的事件通知等，负责超时重连</span></span><br><span class="line">        state = <span class="keyword">new</span> ConnectionState(zookeeperFactory, ensembleProvider, sessionTimeoutMs, connectionTimeoutMs, watcher, tracer, canBeReadOnly, connectionHandlingPolicy);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  重试策略设置</span></span><br><span class="line">        setRetryPolicy(retryPolicy);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>ConnectionState</strong>是<code>Curator</code>注册到原生客户端上的<strong>defaultWatcher</strong>，它会收到和连接状态有关的事件通知等，负责超时重连操作等。</p><p>再来看下<code>ConnectionState</code>的构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ConnectionState(ZookeeperFactory zookeeperFactory, EnsembleProvider ensembleProvider, <span class="keyword">int</span> sessionTimeoutMs, <span class="keyword">int</span> connectionTimeoutMs, Watcher parentWatcher, AtomicReference&lt;TracerDriver&gt; tracer, <span class="keyword">boolean</span> canBeReadOnly, ConnectionHandlingPolicy connectionHandlingPolicy)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">this</span>.ensembleProvider = ensembleProvider;  </span><br><span class="line">    <span class="keyword">this</span>.sessionTimeoutMs = sessionTimeoutMs;  </span><br><span class="line">    <span class="keyword">this</span>.connectionTimeoutMs = connectionTimeoutMs;  </span><br><span class="line">    <span class="keyword">this</span>.tracer = tracer;  </span><br><span class="line">    <span class="keyword">this</span>.connectionHandlingPolicy = connectionHandlingPolicy;  </span><br><span class="line">    <span class="keyword">if</span> ( parentWatcher != <span class="keyword">null</span> )  </span><br><span class="line">    &#123;  </span><br><span class="line">    <span class="comment">// 因为defaultWatcher只能有一个，通过parentWatchers可实现defaultWatcher接到事件通知时parentWatchers的回调</span></span><br><span class="line">        parentWatchers.offer(parentWatcher);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    handleHolder = <span class="keyword">new</span> HandleHolder(zookeeperFactory, <span class="keyword">this</span>, ensembleProvider, sessionTimeoutMs, canBeReadOnly);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>parentWatchers</strong> 使用了并发安全队列 <strong>ConcurrentLinkedQueue</strong>，这部分属于JDK并发编程的基础内容，这个队列的作用如下：</p><blockquote><p><strong>ConcurrentLinkedQueue</strong>：一个基于链接节点的<strong>无界线程安全队列</strong>。此队列按照 FIFO（<strong>先进先出</strong>）原则对元素进行排序。队列的<strong>头部</strong> 是队列中<strong>时间最长的元素</strong>。队列的尾部 是队列中时间最短的元素。<strong>新的元素插入到队列的尾部</strong>，队列获取操作从队列头部获得元素。当多个线程共享访问一个公共 collection 时，ConcurrentLinkedQueue 是一个恰当的选择。此队列不允许使用 null 元素。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Watcher&gt; parentWatchers = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;Watcher&gt;();</span><br></pre></td></tr></table></figure><h2 id="ConnectionStateManager-初始化过程"><a href="#ConnectionStateManager-初始化过程" class="headerlink" title="ConnectionStateManager 初始化过程"></a>ConnectionStateManager 初始化过程</h2><h3 id="ConnectionStateManager-初始化过程流程图"><a href="#ConnectionStateManager-初始化过程流程图" class="headerlink" title="ConnectionStateManager 初始化过程流程图"></a>ConnectionStateManager 初始化过程流程图</h3><p><strong>ConnectionStateManager</strong> 主要是持有<code>Client</code>引用，通过连接状态管理工程创建构建监听器，以及构建只允许一个线程执行的线程池。</p><blockquote><p>Curator 的设计记录是一个客户端永远只有一个线程负责工作。</p></blockquote><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230704210542.png" alt="image.png"></p><h3 id="ConnectionStateManager-初始化代码分析"><a href="#ConnectionStateManager-初始化代码分析" class="headerlink" title="ConnectionStateManager 初始化代码分析"></a>ConnectionStateManager 初始化代码分析</h3><p>在<code>Curator</code>框架初始化代码中包含了 <strong>ConnectionStateManager</strong> 初始化，它主要负责状态维护和连接状态变更通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//负责连接状态变化时的通知</span></span><br><span class="line">connectionStateManager = <span class="keyword">new</span> ConnectionStateManager(<span class="keyword">this</span>, builder.getThreadFactory(), builder.getSessionTimeoutMs(), builder.getConnectionHandlingPolicy().getSimulatedSessionExpirationPercent(), builder.getConnectionStateListenerManagerFactory());</span><br></pre></td></tr></table></figure><p>可以看到，如果要监听状态改变，需要注册一个监听器。相关的注册方式在“”部分进行详细介绍，这里先看下相关的成员变量以及初始化方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//连接状态事件通知队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;ConnectionState&gt; eventQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;ConnectionState&gt;(QUEUE_SIZE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要通知的listeners </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> UnaryListenerManager&lt;ConnectionStateListener&gt; listeners;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ConnectionStateManager的运行状态 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;State&gt; state = <span class="keyword">new</span> AtomicReference&lt;State&gt;(State.LATENT);</span><br></pre></td></tr></table></figure><p><strong>ConnectionStateManager#ConnectionStateManager</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Params:</span></span><br><span class="line"><span class="comment">client – the client </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">threadFactory – thread factory to use or null for a default </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">sessionTimeoutMs – the ZK session timeout in milliseconds </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">sessionExpirationPercent – percentage of negotiated session timeout to use when simulating a session timeout. 0 means don't simulate at all </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">managerFactory – manager factory to use</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConnectionStateManager</span><span class="params">(CuratorFramework client, ThreadFactory threadFactory, <span class="keyword">int</span> sessionTimeoutMs, <span class="keyword">int</span> sessionExpirationPercent, ConnectionStateListenerManagerFactory managerFactory)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.client = client;  </span><br><span class="line">    <span class="keyword">this</span>.sessionTimeoutMs = sessionTimeoutMs;  </span><br><span class="line">    <span class="keyword">this</span>.sessionExpirationPercent = sessionExpirationPercent;  </span><br><span class="line">    <span class="keyword">if</span> ( threadFactory == <span class="keyword">null</span> )  </span><br><span class="line">    &#123;  </span><br><span class="line">        threadFactory = ThreadUtils.newThreadFactory(<span class="string">"ConnectionStateManager"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//事件队列处理线程池</span></span><br><span class="line">    service = Executors.newSingleThreadExecutor(threadFactory);  </span><br><span class="line">    <span class="comment">// 构建监听器队列</span></span><br><span class="line">    listeners = managerFactory.newManager(client);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CuratorFrameworkImpl-启动过程"><a href="#CuratorFrameworkImpl-启动过程" class="headerlink" title="CuratorFrameworkImpl 启动过程"></a>CuratorFrameworkImpl 启动过程</h2><p><code>CuratorFrameworkImpl</code>启动过程的主要工作如下：</p><ol><li>启动 <strong>ConnectionStateManager</strong>，同时负责连接事件的通知准备。</li><li>启动 <strong>CuratorZookeeperClient</strong> ，建立服务端会话连接。</li><li>启动一个单线程线程池，这个线程负责监听执行后台任务队列，不断从任务队列取出元素并且执行。</li></ol><h3 id="CuratorFrameworkImpl-启动过程流程图"><a href="#CuratorFrameworkImpl-启动过程流程图" class="headerlink" title="CuratorFrameworkImpl 启动过程流程图"></a>CuratorFrameworkImpl 启动过程流程图</h3><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230705073357.png" alt="image.png"></p><h3 id="客户端连接-client-start"><a href="#客户端连接-client-start" class="headerlink" title="客户端连接 client.start();"></a>客户端连接 client.start();</h3><p>调用<code>start</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.start();</span><br></pre></td></tr></table></figure><p><code>client.start();</code>内部逻辑如下，这个方法的代码都比较简单，具体可以参考注释理解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    log.info(<span class="string">"Starting"</span>);  </span><br><span class="line">    <span class="comment">// 使用CAS把当前的运行状态切换为 STARTED，状态切换之后不可逆</span></span><br><span class="line">    <span class="comment">// LATENT:CuratorFramework.start() has not yet been called</span></span><br><span class="line">    <span class="comment">// STARTED: CuratorFramework.start() has been called</span></span><br><span class="line">    <span class="keyword">if</span> ( !state.compareAndSet(CuratorFrameworkState.LATENT, CuratorFrameworkState.STARTED) )  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot be started more than once"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">try</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">    <span class="comment">// ordering dependency - must be called before client.start()  </span></span><br><span class="line">    <span class="comment">// 顺序依赖 - 必须在 client.start()之前调用。 </span></span><br><span class="line">        connectionStateManager.start(); </span><br><span class="line"><span class="comment">// 构建连接监听器，监听异常连接状态</span></span><br><span class="line">        <span class="keyword">final</span> ConnectionStateListener listener = <span class="keyword">new</span> ConnectionStateListener()  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(CuratorFramework client, ConnectionState newState)</span>  </span></span><br><span class="line"><span class="function">            </span>&#123;  </span><br><span class="line">            <span class="comment">// CONNECTED：为第一次成功连接到服务器而发送。注意：对于任何一个CuratorFramework实例只会收到其中一条信息。</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// RECONNECTED：一个暂停的、丢失的或只读的连接已被重新建立</span></span><br><span class="line">            <span class="comment">// RECONNECTED：A suspended, lost, or read-only connection has been re-established</span></span><br><span class="line">            <span class="comment">// 如果已经连接或者正在重连</span></span><br><span class="line">                <span class="keyword">if</span> ( ConnectionState.CONNECTED == newState || ConnectionState.RECONNECTED == newState )  </span><br><span class="line">                &#123;  </span><br><span class="line">                    logAsErrorConnectionErrors.set(<span class="keyword">true</span>);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doNotDecorate</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">            </span>&#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;;  </span><br><span class="line"><span class="comment">// 注册监听器</span></span><br><span class="line">        <span class="keyword">this</span>.getConnectionStateListenable().addListener(listener);  </span><br><span class="line"><span class="comment">// 全局启动开发设置为true，ConnectionState 状态更新</span></span><br><span class="line">        client.start();  </span><br><span class="line"><span class="comment">// 构建线程池</span></span><br><span class="line">        executorService = Executors.newSingleThreadScheduledExecutor(threadFactory);         <span class="comment">// 执行具备返回值的Callable 任务</span></span><br><span class="line">        executorService.submit(<span class="keyword">new</span> Callable&lt;Object&gt;()  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception  </span></span><br><span class="line"><span class="function">            </span>&#123;  </span><br><span class="line">            <span class="comment">// 关键部分：挂起后台操作</span></span><br><span class="line">                backgroundOperationsLoop();  </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;            </span><br><span class="line">&#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> ( ensembleTracker != <span class="keyword">null</span> )  </span><br><span class="line">        &#123;  </span><br><span class="line">            ensembleTracker.start();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        log.info(schemaSet.toDocumentation());  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">catch</span> ( Exception e )  </span><br><span class="line">    &#123;  </span><br><span class="line">        ThreadUtils.checkInterrupted(e);  </span><br><span class="line">        handleBackgroundOperationException(<span class="keyword">null</span>, e);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过CAS操作将当前状态更新为 <strong>STARTED</strong>，同时根据<code>if</code>逻辑可以得知<code>start()</code>方法不允许重复调用，这和 JDK的 Thread 设计思路比较相似，Thread 同样只允许执行一次<code>start()</code>方法。</p><p>CAS 操作成功则构建连接监听器监听异常连接状态，监听器中会判断当前客户端是否已经连接或者正在重连，如果是则设置<strong>logAsErrorConnectionErrors=true</strong>。</p><p>我们继续看关键部分<code>backgroundOperationsLoop();</code>。</p><h3 id="后台轮询操作指令-backgroundOperationsLoop"><a href="#后台轮询操作指令-backgroundOperationsLoop" class="headerlink" title="后台轮询操作指令 backgroundOperationsLoop()"></a>后台轮询操作指令 <code>backgroundOperationsLoop()</code></h3><p><code>backgroundOperationsLoop()</code>方法，根据名称得知这是一个后台循环，后台任务的整体流程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backgroundOperationsLoop</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">try</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">while</span> ( state.get() == CuratorFrameworkState.STARTED )  </span><br><span class="line">        &#123;  </span><br><span class="line">            OperationAndData&lt;?&gt; operationAndData;  </span><br><span class="line">            <span class="keyword">try</span>            </span><br><span class="line">            &#123;  </span><br><span class="line">                operationAndData = backgroundOperations.take();  </span><br><span class="line">                <span class="keyword">if</span> ( debugListener != <span class="keyword">null</span> )  </span><br><span class="line">                &#123;  </span><br><span class="line">                    debugListener.listen(operationAndData);  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="comment">// 执行后台操作</span></span><br><span class="line">                performBackgroundOperation(operationAndData);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">catch</span> ( InterruptedException e )  </span><br><span class="line">            &#123;  </span><br><span class="line">            <span class="comment">// 在这里中断异常会被吞掉。</span></span><br><span class="line">                <span class="comment">// swallow the interrupt as it's only possible from either a background  </span></span><br><span class="line">                <span class="comment">// operation and, thus, doesn't apply to this loop or the instance                // is being closed in which case the while test will get it            &#125;  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">finally</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        log.info(<span class="string">"backgroundOperationsLoop exiting"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>OperationAndData</code> 实现了 Delayed 接口用于实现阻塞队列延迟重试。</p></blockquote><p>上面的处理逻辑如下：</p><ol><li>判断当前是否为<code>STARTED</code>状态，一直循环。</li><li>从阻塞队列<strong>BlockingQueue</strong>当中弹出操作指令对象，在初始化代码中可以得知是一个<code>DelayQueue</code> 延迟并发安全阻塞队列，<code>OperationAndData</code> 对象毫无疑问实现了<code>Delayed</code>接口。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">backgroundOperations = <span class="keyword">new</span> DelayQueue&lt;OperationAndData&lt;?&gt;&gt;();</span><br></pre></td></tr></table></figure><ol start="3"><li>判断Debug 监听器是否存在，如果存在则监听<code>OperationAndData</code>。</li><li>执行后台操作<code>performBackgroundOperation</code>，它的工作是从阻塞队列不断获取数据操作<code>OperationAndData</code> 对象调用<code>callPerformBackgroundOperation</code>方法执行。</li><li>如果无法正常连接ZK集群，此时会走else分支并且进入重连判断逻辑。如果符合条件，则添加到阻塞队列的当中等待下一次重试。（注意这里是<strong>主动重试，同步操作</strong>）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performBackgroundOperation</span><span class="params">(OperationAndData&lt;?&gt; operationAndData)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( !operationAndData.isConnectionRequired() || client.isConnected() )</span><br><span class="line">            &#123;</span><br><span class="line">                operationAndData.callPerformBackgroundOperation();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">            <span class="comment">// 允许重连或者超时这样的情况发生</span></span><br><span class="line">                client.getZooKeeper();  <span class="comment">// important - allow connection resets, timeouts, etc. to occur</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果连接超时，则跑出 CuratorConnectionLossException 异常</span></span><br><span class="line">                <span class="keyword">if</span> ( operationAndData.getElapsedTimeMs() &gt;= client.getConnectionTimeoutMs() )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> CuratorConnectionLossException();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果没有超时，则推入到 forcedSleepOperations 强制睡眠后等待重连</span></span><br><span class="line">                sleepAndQueueOperation(operationAndData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> ( Throwable e )</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">// 检查线程中断</span></span><br><span class="line">            ThreadUtils.checkInterrupted(e);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * Fix edge case reported as CURATOR-52. ConnectionState.checkTimeouts() throws KeeperException.ConnectionLossException</span></span><br><span class="line"><span class="comment">             * when the initial (or previously failed) connection cannot be re-established. This needs to be run through the retry policy</span></span><br><span class="line"><span class="comment">             * and callbacks need to get invoked, etc.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">             <span class="comment">/*</span></span><br><span class="line"><span class="comment">             修复报告为CURATOR-52的边缘案例。当初始（或之前失败的）连接无法重新建立时，ConnectionState.checkTimeouts()会抛出KeeperException.ConnectionLossException。这需要通过重试策略运行，回调需要被调用，等等。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">             <span class="comment">// 连接丢失异常处理</span></span><br><span class="line">            <span class="keyword">if</span> ( e <span class="keyword">instanceof</span> CuratorConnectionLossException )</span><br><span class="line">            &#123;</span><br><span class="line">                WatchedEvent watchedEvent = <span class="keyword">new</span> WatchedEvent(Watcher.Event.EventType.None, Watcher.Event.KeeperState.Disconnected, <span class="keyword">null</span>);</span><br><span class="line">                CuratorEvent event = <span class="keyword">new</span> CuratorEventImpl(<span class="keyword">this</span>, CuratorEventType.WATCHED, KeeperException.Code.CONNECTIONLOSS.intValue(), <span class="keyword">null</span>, <span class="keyword">null</span>, operationAndData.getContext(), <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, watchedEvent, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">// 如果重连次数</span></span><br><span class="line">                <span class="keyword">if</span> ( checkBackgroundRetry(operationAndData, event) )</span><br><span class="line">                &#123;</span><br><span class="line">                <span class="comment">// 推送到backgroundOperations队列尝试重连</span></span><br><span class="line">                    queueOperation(operationAndData);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                <span class="comment">// 放弃重连</span></span><br><span class="line">                    logError(<span class="string">"Background retry gave up"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">            <span class="comment">// 否则需要处理后台操作异常</span></span><br><span class="line">                handleBackgroundOperationException(operationAndData, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里顺带介绍下后台决定是否重试的判断逻辑，主要是根据用户传输的重试策略执行对应的重试逻辑判断，比较经典的<strong>策略模式</strong>实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.getRetryPolicy().allowRetry(operationAndData.getThenIncrementRetryCount(), operationAndData.getElapsedTimeMs(), operationAndData)</span><br></pre></td></tr></table></figure><h3 id="operationAndData-callPerformBackgroundOperation-后台任务执行"><a href="#operationAndData-callPerformBackgroundOperation-后台任务执行" class="headerlink" title="operationAndData.callPerformBackgroundOperation() 后台任务执行"></a>operationAndData.callPerformBackgroundOperation() 后台任务执行</h3><p><strong>operationAndData</strong> 继承了<strong>DelayQueue</strong>，运用多态特性拥有不同实现，内部只有一行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callPerformBackgroundOperation</span><span class="params">()</span> <span class="keyword">throws</span> Exception  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    operation.performBackgroundOperation(<span class="keyword">this</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>operation.performBackgroundOperation(this);  对应 <strong>BackgroundOperation#performBackgroundOperation</strong></p></blockquote><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230708125752.png" alt="image.png"></p><p><strong>BackgroundOperation</strong> 后台操作有很多具体的实现，对应了ZK常见操作。传递的<code>this</code>就是 <code>operationAndData</code> 对象。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230703204542.png" alt="image.png"></p><h2 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h2><ol><li>Client 连接状态都是通过 <strong>ConnectionState</strong> 进行管理的，它会负责尝试超时重连的操作。</li><li><strong>ConnectionStateManager</strong> 会负责连接状态的改变和通知。</li><li><strong>ConnectionHandlingPolicy</strong>  则对应了连接超时策略的触发。</li></ol><p>在后台轮询队列操作指令对象过程中会在状态改变的时候尝试重连，客户端重连必然要通知到对应的监听器，那么 <strong>Curator</strong> 是如何进行客户端 <strong>会话状态通知</strong>以及<strong>会话超时重连</strong>的？</p><h3 id="连接事件监听和状态变更-ConnectionState-process"><a href="#连接事件监听和状态变更-ConnectionState-process" class="headerlink" title="连接事件监听和状态变更 ConnectionState#process"></a>连接事件监听和状态变更 ConnectionState#process</h3><p>从<code>ConnectionState#process</code>的代码可以得知，连接状态相关的事件类型为<code>Watcher.Event.EventType.None</code>，会通知到所有的Wathcer。</p><p>其中<code>ConnectionState</code>作为 <strong>defaultWatcher</strong> ，它的事件回调如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> ( LOG_EVENTS )  </span><br><span class="line">    &#123;  </span><br><span class="line">        log.debug(<span class="string">"ConnectState watcher: "</span> + event);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> ( event.getType() == Watcher.Event.EventType.None )  </span><br><span class="line">    &#123;  </span><br><span class="line">    <span class="comment">//isConnected：客户当前的连接状态，true表示已连接（SyncConnected 和 ConnectedReadOnly 状态）</span></span><br><span class="line">        <span class="keyword">boolean</span> wasConnected = isConnected.get(); </span><br><span class="line">        <span class="comment">// 根据 org.apache.zookeeper.Watcher.Event.KeeperState 进行状态判断。 </span></span><br><span class="line">        <span class="keyword">boolean</span> newIsConnected = checkState(event.getState(), wasConnected);  </span><br><span class="line">        <span class="keyword">if</span> ( newIsConnected != wasConnected )  </span><br><span class="line">        &#123;  </span><br><span class="line">        <span class="comment">// /如果连接状态发生改变，则更新</span></span><br><span class="line">            isConnected.set(newIsConnected);  </span><br><span class="line">            connectionStartMs = System.currentTimeMillis();  </span><br><span class="line">            <span class="keyword">if</span> ( newIsConnected )  </span><br><span class="line">            &#123;  </span><br><span class="line">                </span><br><span class="line"><span class="comment">//重连，更新会话超时协商时间</span></span><br><span class="line"><span class="comment">// NegotiatedSessionTimeoutMs（协商会话超时）。</span></span><br><span class="line">                lastNegotiatedSessionTimeoutMs.set(handleHolder.getNegotiatedSessionTimeoutMs());  </span><br><span class="line">                log.debug(<span class="string">"Negotiated session timeout: "</span> + lastNegotiatedSessionTimeoutMs.get());  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知parentWatchers, 注意初始化的时候其实传入了一个parentWatcher,会调用CuratorFrameworkImpl.processEvent</span></span><br><span class="line">    <span class="keyword">for</span> ( Watcher parentWatcher : parentWatchers )  </span><br><span class="line">    &#123;  </span><br><span class="line">        OperationTrace trace = <span class="keyword">new</span> OperationTrace(<span class="string">"connection-state-parent-process"</span>, tracer.get(), getSessionId());  </span><br><span class="line">        parentWatcher.process(event);  </span><br><span class="line">        trace.commit();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一段注释提到可以看到遍历<code>parentWatchers</code>并且调用<code>process</code>方法。这里实际上默认会有个Watcher，那就是在初始化的时候默认会注册一个Watch作为parentWatcher传入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.client = <span class="keyword">new</span> CuratorZookeeperClient  </span><br><span class="line">      (  </span><br><span class="line">          localZookeeperFactory,  </span><br><span class="line">          builder.getEnsembleProvider(),  </span><br><span class="line">          builder.getSessionTimeoutMs(),  </span><br><span class="line">          builder.getConnectionTimeoutMs(),  </span><br><span class="line">          builder.getWaitForShutdownTimeoutMs(),  </span><br><span class="line">          <span class="keyword">new</span> Watcher()  </span><br><span class="line">          &#123;  </span><br><span class="line">              <span class="meta">@Override</span>  </span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span>  </span></span><br><span class="line"><span class="function">              </span>&#123;  </span><br><span class="line">                  CuratorEvent event = <span class="keyword">new</span> CuratorEventImpl(CuratorFrameworkImpl.<span class="keyword">this</span>, CuratorEventType.WATCHED, watchedEvent.getState().getIntValue(), unfixForNamespace(watchedEvent.getPath()), <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, watchedEvent, <span class="keyword">null</span>, <span class="keyword">null</span>);  </span><br><span class="line">                  <span class="comment">// 注意初始化的时候其实传入了一个parentWatcher,会调用CuratorFrameworkImpl.processEvent</span></span><br><span class="line">                  processEvent(event);  </span><br><span class="line">              &#125;  </span><br><span class="line">          &#125;,  </span><br><span class="line">          builder.getRetryPolicy(),  </span><br><span class="line">          builder.canBeReadOnly(),  </span><br><span class="line">          builder.getConnectionHandlingPolicy()  </span><br><span class="line">      );</span><br></pre></td></tr></table></figure><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230706215011.png" alt="image.png"></p><p>这部分通知事件回调在下文会再次提到，这里简单有关印象即可。</p><h3 id="连接状态检查和处理-ConnectionState-checkState"><a href="#连接状态检查和处理-ConnectionState-checkState" class="headerlink" title="连接状态检查和处理 ConnectionState#checkState"></a>连接状态检查和处理 ConnectionState#checkState</h3><p>连接状态检查和处理在<code>ConnectionState#checkState</code>方法中进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> newIsConnected = checkState(event.getState(), wasConnected);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkState</span><span class="params">(Event.KeeperState state, <span class="keyword">boolean</span> wasConnected)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">boolean</span> isConnected = wasConnected;  </span><br><span class="line">    <span class="keyword">boolean</span> checkNewConnectionString = <span class="keyword">true</span>;  </span><br><span class="line">    <span class="keyword">switch</span> ( state )  </span><br><span class="line">    &#123;  </span><br><span class="line">    <span class="keyword">default</span>:  </span><br><span class="line">    <span class="keyword">case</span> Disconnected:  </span><br><span class="line">    &#123;  </span><br><span class="line">        isConnected = <span class="keyword">false</span>;  </span><br><span class="line">        <span class="keyword">break</span>;    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">case</span> SyncConnected:  </span><br><span class="line">    <span class="keyword">case</span> ConnectedReadOnly:  </span><br><span class="line">    &#123;  </span><br><span class="line">        isConnected = <span class="keyword">true</span>;  </span><br><span class="line">        <span class="keyword">break</span>;    &#125;  </span><br><span class="line"><span class="comment">// 访问权限异常</span></span><br><span class="line">    <span class="keyword">case</span> AuthFailed:  </span><br><span class="line">    &#123;  </span><br><span class="line">        isConnected = <span class="keyword">false</span>;  </span><br><span class="line">        log.error(<span class="string">"Authentication failed"</span>);  </span><br><span class="line">        <span class="keyword">break</span>;    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">case</span> Expired:  </span><br><span class="line">    &#123;  </span><br><span class="line">        isConnected = <span class="keyword">false</span>;  </span><br><span class="line">        checkNewConnectionString = <span class="keyword">false</span>;  </span><br><span class="line">        handleExpiredSession();  </span><br><span class="line">        <span class="keyword">break</span>;    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">case</span> SaslAuthenticated:  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">// NOP  </span></span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// the session expired is logged in handleExpiredSession, so not log here  </span></span><br><span class="line">    <span class="comment">// 会话过期被记录在handleExpiredSession中，所以不记录在这里。 </span></span><br><span class="line">    <span class="keyword">if</span> (state != Event.KeeperState.Expired) &#123;  </span><br><span class="line">        <span class="keyword">new</span> EventTrace(state.toString(), tracer.get(), getSessionId()).commit();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> ( checkNewConnectionString )  </span><br><span class="line">    &#123;  </span><br><span class="line">    <span class="comment">//如果服务端列表发生变化，则更新</span></span><br><span class="line">        String newConnectionString = handleHolder.getNewConnectionString();  </span><br><span class="line">        <span class="keyword">if</span> ( newConnectionString != <span class="keyword">null</span> )  </span><br><span class="line">        &#123;  </span><br><span class="line">            handleNewConnectionString(newConnectionString);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> isConnected;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面根据不同连接状态判断连接是否异常， 返回结果为<strong>true</strong>则表示连接是正常的，当会话超时过期<code>Expired</code>时，会调用<code>handleExpiredSession</code>进行<code>reset</code>操作（会话<strong>被动重连</strong>），这里对于非连接超时的状态进行时间追踪。</p><blockquote><p>注意重连策略 <strong>RetryPolicy</strong>这个策略在主动和被动重连中均会调用。</p></blockquote><h3 id="parentWatchers-注册和回调"><a href="#parentWatchers-注册和回调" class="headerlink" title="parentWatchers 注册和回调"></a>parentWatchers 注册和回调</h3><p>发生状态变更的方法最后部分是通知所有的parentWatchers，下面来看看这个循环干了什么事情。</p><p>再次强调初始化的时候传入了一个 <strong>parentWatcher</strong>，会调用<code>CuratorFrameworkImpl.processEvent</code> 方法，现在来看看这部分是如何注册和回调的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通知parentWatchers,注意初始化的时候其实传入了一个parentWatcher,会调用CuratorFrameworkImpl.processEvent</span></span><br><span class="line">    <span class="keyword">for</span> ( Watcher parentWatcher : parentWatchers )  </span><br><span class="line">    &#123;  </span><br><span class="line">        OperationTrace trace = <span class="keyword">new</span> OperationTrace(<span class="string">"connection-state-parent-process"</span>, tracer.get(), getSessionId());  </span><br><span class="line">        parentWatcher.process(event);  </span><br><span class="line">        trace.commit();  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们直接看看这个默认的Watcher回调<code>CuratorFrameworkImpl#processEvent(event)</code> 相关代码逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Watcher()  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        CuratorEvent event = <span class="keyword">new</span> CuratorEventImpl(CuratorFrameworkImpl.<span class="keyword">this</span>, CuratorEventType.WATCHED, watchedEvent.getState().getIntValue(), unfixForNamespace(watchedEvent.getPath()), <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, watchedEvent, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 处理事件  </span></span><br><span class="line">        processEvent(event);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><code>processEvent(event)</code>相关逻辑如下，首先对于状态变更判断，状态如果出现变更则通知到所有注册在 <strong>CuratorListener</strong> 上的监听器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processEvent</span><span class="params">(<span class="keyword">final</span> CuratorEvent curatorEvent)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> ( curatorEvent.getType() == CuratorEventType.WATCHED )  </span><br><span class="line">    &#123;  </span><br><span class="line">    <span class="comment">//状态转换</span></span><br><span class="line">        validateConnection(curatorEvent.getWatchedEvent().getState());  </span><br><span class="line">    &#125;  </span><br><span class="line">  <span class="comment">//通知所有注册的CuratorListener</span></span><br><span class="line">    listeners.forEach(<span class="keyword">new</span> Function&lt;CuratorListener, Void&gt;()  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">apply</span><span class="params">(CuratorListener listener)</span>  </span></span><br><span class="line"><span class="function">        </span>&#123;  </span><br><span class="line">            <span class="keyword">try</span>  </span><br><span class="line">            &#123;  </span><br><span class="line">                OperationTrace trace = client.startAdvancedTracer(<span class="string">"EventListener"</span>);  </span><br><span class="line">                <span class="comment">// 接收回调事件</span></span><br><span class="line">                listener.eventReceived(CuratorFrameworkImpl.<span class="keyword">this</span>, curatorEvent);  </span><br><span class="line">                trace.commit();  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">catch</span> ( Exception e )  </span><br><span class="line">            &#123;  </span><br><span class="line">                ThreadUtils.checkInterrupted(e);  </span><br><span class="line">                logError(<span class="string">"Event listener threw exception"</span>, e);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>validateConnection</code> 负责连接状态的转换代码。</p><p><strong>CuratorFrameworkImpl#validateConnection</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">validateConnection</span><span class="params">(Watcher.Event.KeeperState state)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> ( state == Watcher.Event.KeeperState.Disconnected )  </span><br><span class="line">    &#123;  </span><br><span class="line">        internalConnectionHandler.suspendConnection(<span class="keyword">this</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( state == Watcher.Event.KeeperState.Expired )  </span><br><span class="line">    &#123;  </span><br><span class="line">        connectionStateManager.addStateChange(ConnectionState.LOST);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( state == Watcher.Event.KeeperState.SyncConnected )  </span><br><span class="line">    &#123;  </span><br><span class="line">        internalConnectionHandler.checkNewConnection(<span class="keyword">this</span>);  </span><br><span class="line">        connectionStateManager.addStateChange(ConnectionState.RECONNECTED);  </span><br><span class="line">        unSleepBackgroundOperations();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( state == Watcher.Event.KeeperState.ConnectedReadOnly )  </span><br><span class="line">    &#123;  </span><br><span class="line">        internalConnectionHandler.checkNewConnection(<span class="keyword">this</span>);  </span><br><span class="line">        connectionStateManager.addStateChange(ConnectionState.READ_ONLY);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到实际的状态变更是依靠 <strong>ConnectionStateManager</strong> 组件负责的，<strong>ZK的原生客户端状态和Curator包装的状态对应</strong>表如下：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230706220450.png" alt="image.png"></p><p>此外还需要注意每一个 <code>if</code> 判断的最后一行代码中有一个添加 <strong>ConnectionState</strong> 的操作，这个操作的意义是通知所有注册到 <code>listeners</code>的<code>ConnectionStateListener</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connectionStateManager.addStateChange(ConnectionState.READ_ONLY);</span><br></pre></td></tr></table></figure><blockquote><p>至于怎么通知的会在下文介绍。</p></blockquote><h2 id="通知机制"><a href="#通知机制" class="headerlink" title="通知机制"></a>通知机制</h2><p>通知是干什么？其实就是在事件发生的时候，及时回调注册的<strong>Listenrner监听器</strong>对应的回调函数。Curator 针对不同组件设计了不同的监听器注册和回调。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义监听器 CuratorListener</span></span><br><span class="line">client.getCuratorListenable().addListener((_fk, e) -&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (e.getType().equals(CuratorEventType.WATCHED)) &#123;</span><br><span class="line">log.info(<span class="string">"测试"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">ConnectionStateListener connectionStateListener = (client1, newState) -&gt; &#123;</span><br><span class="line"><span class="comment">//Some details</span></span><br><span class="line">log.info(<span class="string">"newState =&gt; "</span>+ newState);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以注册的监听器方式如下：</p><ul><li>一次性 Watch 通知</li><li>注册 CuratorListener 通知</li><li>注册 ConnectionStateListener 通知</li><li>注册 UnhandledErrorListener 通知</li><li>后台线程操作完成时的回调通知</li><li>缓存机制，多次注册</li></ul><h3 id="一次性-Watch-通知"><a href="#一次性-Watch-通知" class="headerlink" title="一次性 Watch 通知"></a>一次性 Watch 通知</h3><p>每次都需要反复通过下面的方法重新注册。这里涉及到 NodeCache 的相关组件，由于目前并没有介绍相关的前置代码，这里暂时跳过介绍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.checkExists().creatingParentContainersIfNeeded().usingWatcher(watcher).inBackground(backgroundCallback).forPath(path);</span><br></pre></td></tr></table></figure><h3 id="注册-CuratorListener-通知"><a href="#注册-CuratorListener-通知" class="headerlink" title="注册 CuratorListener 通知"></a>注册 CuratorListener 通知</h3><p>实现方式很简单，就是把监听器注册到<code>CuratorFrameworkImpl.listeners</code>这个容器当中，后台线程完成操作通知该监听器容器的所有监听器。</p><p>比如异步的方式在ZK上面创建路径会触发<strong>CuratorEventType.CREATE</strong>事件，还有就是连接状态事件触发的时候<strong>parentWatcher</strong>也会回调这些listeners，比如下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * connect ZK, register watchers</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CuratorFramework <span class="title">mkClient</span><span class="params">(Map conf, List&lt;String&gt; servers, Object port,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String root, <span class="keyword">final</span> WatcherCallBack watcher)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    CuratorFramework fk = Utils.newCurator(conf, servers, port, root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义监听器 CuratorListener</span></span><br><span class="line">    fk.getCuratorListenable().addListener(<span class="keyword">new</span> CuratorListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eventReceived</span><span class="params">(CuratorFramework _fk, CuratorEvent e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (e.getType().equals(CuratorEventType.WATCHED)) &#123;</span><br><span class="line">                WatchedEvent event = e.getWatchedEvent();</span><br><span class="line"></span><br><span class="line">                watcher.execute(event.getState(), event.getType(), event.getPath());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    fk.start();</span><br><span class="line">    <span class="keyword">return</span> fk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CuratorFrameworkImpl#processEvent</strong></p><p><code>processEvent</code> 方法总会进行注册的 <strong>CuratorListener</strong> 回调操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processEvent</span><span class="params">(<span class="keyword">final</span> CuratorEvent curatorEvent)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( curatorEvent.getType() == CuratorEventType.WATCHED )</span><br><span class="line">        &#123;</span><br><span class="line">            validateConnection(curatorEvent.getWatchedEvent().getState());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        listeners.forEach(<span class="keyword">new</span> Function&lt;CuratorListener, Void&gt;()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Void <span class="title">apply</span><span class="params">(CuratorListener listener)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    OperationTrace trace = client.startAdvancedTracer(<span class="string">"EventListener"</span>);</span><br><span class="line">                    listener.eventReceived(CuratorFrameworkImpl.<span class="keyword">this</span>, curatorEvent);</span><br><span class="line">                    trace.commit();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> ( Exception e )</span><br><span class="line">                &#123;</span><br><span class="line">                    ThreadUtils.checkInterrupted(e);</span><br><span class="line">                    logError(<span class="string">"Event listener threw exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>具体回调则是有各种执行构建实现器完成的，这一块深究比较复杂，这里有个概念后续有需要查看相关实现即可。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230708111456.png" alt="image.png"></p><h3 id="注册-ConnectionStateListener-通知"><a href="#注册-ConnectionStateListener-通知" class="headerlink" title="注册 ConnectionStateListener 通知"></a>注册 ConnectionStateListener 通知</h3><p>如果添加 <strong>ConnectionStateListener</strong> 监听器，则在连接状态发生改变时，会收到通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ConnectionStateListener connectionStateListener = <span class="keyword">new</span> ConnectionStateListener()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(CuratorFramework client, ConnectionState newState)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">          <span class="comment">//Some details</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">client.getConnectionStateListenable().addListener(connectionStateListener);</span><br></pre></td></tr></table></figure><p>ConnectionStateListener 监听器的事件回调发生在<strong>ConnectionStateManager</strong>当中，但是前面我们只介绍了如何初始化，下面扩展介绍回调<code>ConnectionStateListener</code>的部分</p><h4 id="ConnectionStateManager-如何回调-ConnectionStateListener？"><a href="#ConnectionStateManager-如何回调-ConnectionStateListener？" class="headerlink" title="ConnectionStateManager 如何回调 ConnectionStateListener？"></a>ConnectionStateManager 如何回调 ConnectionStateListener？</h4><p><strong>CuratorFrameworkImpl#validateConnection</strong></p><p>上面讲解<strong>会话机制</strong>的时候，提到了最后有一个添加 <strong>ConnectionState</strong> 的操作，这里将介绍收到 <strong>ConnectionState</strong> 变更之后如何回调注册在自己身上的监听器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">validateConnection</span><span class="params">(Watcher.Event.KeeperState state)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( state == Watcher.Event.KeeperState.Expired )  </span><br><span class="line">    &#123;  </span><br><span class="line">        connectionStateManager.addStateChange(ConnectionState.LOST);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( state == Watcher.Event.KeeperState.SyncConnected )  </span><br><span class="line">    &#123;  </span><br><span class="line">        unSleepBackgroundOperations();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( state == Watcher.Event.KeeperState.ConnectedReadOnly )  </span><br><span class="line">    &#123;  </span><br><span class="line">        connectionStateManager.addStateChange(ConnectionState.READ_ONLY);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体处理在下面这个方法中完成。</p><p><strong>ConnectionStateManager#processEvents</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processEvents</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> ( state.get() == State.STARTED )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> useSessionTimeoutMs = getUseSessionTimeoutMs();</span><br><span class="line">                <span class="keyword">long</span> elapsedMs = startOfSuspendedEpoch == <span class="number">0</span> ? useSessionTimeoutMs / <span class="number">2</span> : System.currentTimeMillis() - startOfSuspendedEpoch;</span><br><span class="line">                <span class="keyword">long</span> pollMaxMs = useSessionTimeoutMs - elapsedMs;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> ConnectionState newState = eventQueue.poll(pollMaxMs, TimeUnit.MILLISECONDS);</span><br><span class="line">                <span class="keyword">if</span> ( newState != <span class="keyword">null</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( listeners.isEmpty() )</span><br><span class="line">                    &#123;</span><br><span class="line">                        log.warn(<span class="string">"There are no ConnectionStateListeners registered."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="comment">// 关键部分，当出现状态变更进行回调监听器通知</span></span><br><span class="line">                    listeners.forEach(listener -&gt; listener.stateChanged(client, newState));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ( sessionExpirationPercent &gt; <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span>(<span class="keyword">this</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        checkSessionExpiration();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> ( InterruptedException e )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// swallow the interrupt as it's only possible from either a background</span></span><br><span class="line">                <span class="comment">//  吞下中断，因为它只可能来自后台操作</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// operation and, thus, doesn't apply to this loop or the instance</span></span><br><span class="line">                <span class="comment">// is being closed in which case the while test will get it</span></span><br><span class="line">                <span class="comment">// 如果实例在关闭有可能走到这一块代码</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面内容重要的其实就一行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listeners.forEach(listener -&gt; listener.stateChanged(client, newState));</span><br></pre></td></tr></table></figure><p>这个<strong>processEvents</strong>是怎么回调的？其实在之前画的 <strong>CuratorFrameworkImpl</strong> 启动过程流程图中就有展示。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230706222022.png" alt="image.png"></p><p><strong>ConnectionStateManager</strong> 当中有一个 <strong>ExecutorService</strong> 线程池，翻看代码可以得知他的实现是 <strong>SingleThreadScheduledExecutor</strong>，这里含义明显就是单独开启一个线程轮询这一段代码检查 <strong>listener</strong>，状态变更通知注册在 <strong>ConnectionStateManager</strong> 上的监听器。</p><h3 id="注册-UnhandledErrorListener-通知"><a href="#注册-UnhandledErrorListener-通知" class="headerlink" title="注册 UnhandledErrorListener 通知"></a>注册 UnhandledErrorListener 通知</h3><p>同理注册到<code>CuratorFrameworkImpl.unhandledErrorListeners</code>当中，当后台线程操作发生异常或者handler发生异常的时候会触发。</p><p><strong>注册方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * connect ZK, register watchers</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CuratorFramework <span class="title">mkClient</span><span class="params">(Map conf, List&lt;String&gt; servers, Object port,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String root, <span class="keyword">final</span> WatcherCallBack watcher)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    CuratorFramework fk = Utils.newCurator(conf, servers, port, root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义监听器 UnhandledErrorListener</span></span><br><span class="line">   fk.getUnhandledErrorListenable().addListener(<span class="keyword">new</span> UnhandledErrorListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unhandledError</span><span class="params">(String msg, Throwable error)</span> </span>&#123;</span><br><span class="line">            String errmsg = <span class="string">"Unrecoverable zookeeper error, halting process: "</span> + msg;</span><br><span class="line">            LOG.error(errmsg, error);</span><br><span class="line">            JStormUtils.halt_process(<span class="number">1</span>, <span class="string">"Unrecoverable zookeeper error"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    fk.start();</span><br><span class="line">    <span class="keyword">return</span> fk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如何触发？</strong></p><p>触发的相关代码在<code>CuratorFrameworkImpl#logError</code>方法中，注意这里的<code>apply</code>方法处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logError</span><span class="params">(String reason, <span class="keyword">final</span> Throwable e)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"><span class="comment">// 省略其他无关代码</span></span><br><span class="line">    unhandledErrorListeners.forEach(<span class="keyword">new</span> Function&lt;UnhandledErrorListener, Void&gt;()  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">apply</span><span class="params">(UnhandledErrorListener listener)</span>  </span></span><br><span class="line"><span class="function">        </span>&#123;  </span><br><span class="line">            listener.unhandledError(localReason, e);  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;        </span><br><span class="line">            &#125;  </span><br><span class="line">    &#125;);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略无关代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后台线程操作完成时的回调通知"><a href="#后台线程操作完成时的回调通知" class="headerlink" title="后台线程操作完成时的回调通知"></a>后台线程操作完成时的回调通知</h3><p>对于不同操作比如 <code>setData</code>，可以通过链式调用的方式传入回调函数 callback，操作完成之后会执行回调函数完成回调操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDataAsyncWithCallback</span><span class="params">(CuratorFramework client, BackgroundCallback callback, String path, <span class="keyword">byte</span>[] payload)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">// this is another method of getting notification of an async completion</span></span><br><span class="line">       client.setData().inBackground(callback).forPath(path, payload);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="缓存机制，多次注册"><a href="#缓存机制，多次注册" class="headerlink" title="缓存机制，多次注册"></a>缓存机制，多次注册</h3><p>Curator的缓存机制是一块比较大的部头，Curator 的缓存方式包括：</p><ul><li>Path Cache</li><li>Node Cache </li><li>Tree Cache</li></ul><p>缓存在使用之前会和服务端的节点数据进行对比，当数据不一致时，会通过watch机制触发回调刷新本地缓存，同时再次注册Watch，每次重连会注册新的 Watcher，保证 Watcher永远不丢失。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过通知机制和会话管理两个部分，我们了解到：</p><ul><li><strong>客户端通知</strong>是同步完成。</li><li><code>connectionStateManager.listeners</code>是由<strong>内部的线程池</strong>做异步通知</li><li><code>CuratorFrameworkImpl.listeners</code> 对于连接状态的通知，与watcher通知线程为<strong>同步</strong>，由后台线程通知时为<strong>异步</strong>。</li><li>watcher注册过多可能导致重连之后watcher丢失。</li></ul><h2 id="回顾初始化过程"><a href="#回顾初始化过程" class="headerlink" title="回顾初始化过程"></a>回顾初始化过程</h2><p>Curator框架实现CuratorFrameworkImpl启动时，首先启动连接状态管理器<strong>ConnectionStateManager</strong>， 然后再启动客户端<strong>CuratorZookeeperClient</strong>。</p><p>构造Curator框架实现CuratorFrameworkImpl初始化动客户端CuratorZookeeperClient，注意在这里会默认传入一个Watcher，用于处理CuratorEvent。)。 </p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230717113221.png" alt="image.png"></p><p>CuratorZookeeperClient启动过程，关键点是在启动连接状态ConnectionState（在构造CuratorZookeeperClient，初始化连接状态，并将内部Watcher传给连接状态）。 </p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230717112918.png" alt="image.png"></p><p>连接状态实现了观察者Watcher，在连接状态建立时，调用客户端CuratorZookeeperClient传入的Watcher，处理相关事件。而这个Watcher是在现CuratorFrameworkImpl初始化动客户端CuratorZookeeperClient时 传入的。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230717113503.png" alt="image.png"></p><p><strong>客户端观察者的实际处理业务逻辑在CuratorFrameworkImpl实现</strong>，也就是<code>processEvent</code>方法，processEvent主要处理逻辑为，遍历CuratorFrameworkImpl内部的监听器容器内的监听器处理相关CuratorEvent 事件。这个CuratorEvent事件，是由原生WatchedEvent事件包装而来。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230717113536.png" alt="image.png"></p><p>启动连接状态管理器<strong>ConnectionStateManager</strong>，主要是使用连接状态监听器容器（UnaryListenerManager&lt; ConnectionStateListener&gt;）<strong>Listenabler</strong>（之前版本叫 <strong>ListenerContainer</strong>）中的监听器。</p><p><strong>ConnectionStateManager</strong>中监听器触发具体工作是消费连接状态事件队列<strong>BlockingQueue</strong>中事件。这里<strong>BlockingQueue</strong>里面存放的是ConnectionState状态变更之后【offer】的节点。</p><p>这部分又回到【注册 ConnectionStateListener 通知】部分，状态变更之后最后一段有一个<code>connectionStateManager.addStateChange(XXXX);</code>的小动作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">validateConnection</span><span class="params">(Watcher.Event.KeeperState state)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( state == Watcher.Event.KeeperState.Expired )  </span><br><span class="line">    &#123;  </span><br><span class="line">        connectionStateManager.addStateChange(ConnectionState.LOST);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( state == Watcher.Event.KeeperState.SyncConnected )  </span><br><span class="line">    &#123;  </span><br><span class="line">        unSleepBackgroundOperations();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( state == Watcher.Event.KeeperState.ConnectedReadOnly )  </span><br><span class="line">    &#123;  </span><br><span class="line">        connectionStateManager.addStateChange(ConnectionState.READ_ONLY);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过代码下探，最终回到下面的部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postState</span><span class="params">(ConnectionState state)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       log.info(<span class="string">"State change: "</span> + state);</span><br><span class="line"></span><br><span class="line">       notifyAll();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> ( !eventQueue.offer(state) )</span><br><span class="line">       &#123;</span><br><span class="line">           eventQueue.poll();</span><br><span class="line">           log.warn(<span class="string">"ConnectionStateManager queue full - dropping events to make room"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>@since 4.2.0 return type has changed from ListenerContainer to Listenable</p></blockquote><h1 id="写到最后"><a href="#写到最后" class="headerlink" title="写到最后"></a>写到最后</h1><p>本节介绍了Curator的基础使用，从源码角度分析了Curator 组件的初始化过程，并且简单分析会话管理和通知机制的相关源码调用。</p><p>下面是本文涉及到的源码讲解汇总的一副总图。个人源码分析过程如果有存在错误或者疑问欢迎反馈和讨论。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/Curator%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.drawio.png" alt="Curator 源码分析.drawio.png"></p><p>最后是整个demo代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorTestExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>);</span><br><span class="line">        CuratorFramework client =</span><br><span class="line">                CuratorFrameworkFactory.newClient(<span class="string">"192.168.19.100:2181,192.168.19.101:2181,192.168.19.102:2181"</span>, retryPolicy);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接ZK,开启连接</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自定义监听器 CuratorListener</span></span><br><span class="line">        client.getCuratorListenable().addListener((_fk, e) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.getType().equals(CuratorEventType.WATCHED)) &#123;</span><br><span class="line">                log.info(<span class="string">"测试"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">        ConnectionStateListener connectionStateListener = (client1, newState) -&gt; &#123;</span><br><span class="line">            <span class="comment">//Some details</span></span><br><span class="line">            log.info(<span class="string">"newState =&gt; "</span>+ newState);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 11:31:17.026 [Curator-ConnectionStateManager-0] INFO com.zxd.interview.zkcurator.CuratorTestExample - newState =&gt; CONNECTED</span></span><br><span class="line">        client.getConnectionStateListenable().addListener(connectionStateListener);</span><br><span class="line">        client.start();</span><br><span class="line">        <span class="comment">// 此处就获取到 zk的一个连接实例。</span></span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">        <span class="comment">// 创建znode，如果有必要需要创建父目录</span></span><br><span class="line">        client.create().creatingParentsIfNeeded().withProtection().forPath(<span class="string">"/my/path"</span>, <span class="string">"Test"</span>.getBytes());</span><br><span class="line">        InterProcessMutex lock = <span class="keyword">new</span> InterProcessMutex(client, <span class="string">"/my/path"</span>);</span><br><span class="line">        lock.acquire();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// do some work inside of the critical section here</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.release();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMzUzMzQ3NjA=" title="https://zhuanlan.zhihu.com/p/135334760">ZK客户端Curator使用详解 - 知乎 (zhihu.com)<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xNjQ4OTc2P2FyZWFTb3VyY2U9MTA2MDA1LjE0" title="https://cloud.tencent.com/developer/article/1648976?areaSource=106005.14">https://cloud.tencent.com/developer/article/1648976?areaSource=106005.14<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9kb25hbGRoYW4uZ2l0aHViLmlvL3pvb2tlZXBlci8yMDE4LzA2LzI5L2N1cmF0b3IlRTclOUIlQUUlRTUlQkQlOTUlRTclOUIlOTElRTUlOTAlQUMuaHRtbA==" title="https://donaldhan.github.io/zookeeper/2018/06/29/curator%E7%9B%AE%E5%BD%95%E7%9B%91%E5%90%AC.html">Curator目录监听 | Ravitn Blog (donaldhan.github.io)<i class="fa fa-external-link"></i></span></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      Zookeeper的客户端Curator使用
    
    </summary>
    
    
      <category term="Zookeeper" scheme="https://whitestore.top/categories/Zookeeper/"/>
    
    
      <category term="Zookeeper" scheme="https://whitestore.top/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>【Java】Effective Lambda Expressions in Java</title>
    <link href="https://whitestore.top/2023/08/10/effectivelambda/"/>
    <id>https://whitestore.top/2023/08/10/effectivelambda/</id>
    <published>2023-08-10T08:53:42.000Z</published>
    <updated>2023-09-09T00:53:49.934Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><p><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BidWJ1LnRyaXBhdGh5L2VmZmVjdGl2ZS1sYW1iZGEtZXhwcmVzc2lvbnMtaW4tamF2YS0yZDQwNjFkZGU3N2E=" title="https://medium.com/@bubu.tripathy/effective-lambda-expressions-in-java-2d4061dde77a">Effective Lambda Expressions in Java | by Bubu Tripathy | Medium<i class="fa fa-external-link"></i></span></p><h2 id="Introductory"><a href="#Introductory" class="headerlink" title="Introductory"></a>Introductory</h2><p>Lambda expressions were introduced in Java 8 to allow functional programming in Java. They are a concise way to express functions that can be used as data and provide a more functional approach to programming. Lambda expressions can be used in a variety of ways, from simple expressions to complex functions. In this article, we will discuss 20 best practices of using lambda expressions in Java with examples for each.</p><a id="more"></a><p>Lambda 表达式在 Java 8 中引入，允许在 Java 中进行函数式编程。Lambda表达式是表达可用作数据的函数的一种简洁方式，并为编程提供了一种功能性更强的方法。Lambda表达式的使用方式多种多样，从简单的表达式到复杂的函数。在本文中，我们将讨论在Java中使用lambda表达式的20个最佳实践，并分别举例说明。</p><h2 id="Use-Lambda-expressions-to-create-functional-Interfaces-使用Lambda表达式创建功能接口"><a href="#Use-Lambda-expressions-to-create-functional-Interfaces-使用Lambda表达式创建功能接口" class="headerlink" title="Use Lambda expressions to create functional Interfaces 使用Lambda表达式创建功能接口"></a>Use Lambda expressions to create functional Interfaces 使用Lambda表达式创建功能接口</h2><p>A functional interface is an interface that contains a single abstract method. Functional interfaces are used extensively in Java to represent functions and Lambdas.</p><p>功能接口是一个包含单个抽象方法的接口。<strong>功能接口</strong>在Java中广泛用于表示函数和Lambdas。</p><blockquote><p>When using Lambda expressions to create functional interfaces, the Lambda expression is used to define the implementation of the abstract method. The Lambda expression takes the same parameters as the abstract method, and returns a value that represents the result of the method.</p><p>当时用Lambda 表达式创建功能接口的时候，Lambda 表达式用于定义抽象方法实现。Lambda 表达式接受和抽象方法相同的参数，并且返回代表方法结果的值。</p></blockquote><p>Here is an example of using Lambda expressions to create a functional interface for a calculator:</p><p>下面是使用Lambda 表达式来创建功能接口计算器的案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span>  </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Calculator</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaDemo</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Calculator add = (a, b) -&gt; a + b;  </span><br><span class="line">        Calculator subtract = (a, b) -&gt; a - b;  </span><br><span class="line">  </span><br><span class="line">        System.out.println(<span class="string">"10 + 5 = "</span> + add.calculate(<span class="number">10</span>, <span class="number">5</span>));  </span><br><span class="line">        System.out.println(<span class="string">"10 - 5 = "</span> + subtract.calculate(<span class="number">10</span>, <span class="number">5</span>));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In this example, we are using a Lambda expression to define the implementation of the <code>calculate()</code> method of the Calculator interface. The <code>calculate()</code> method takes two integer values as input (a and b), and returns an integer value representing the result of the calculation.</p><p>在这个例子中，我们使用Lambda 表达式定义Calculator 接口的 <code>calculate()</code> 方法的实现。<code>calculate()</code> 方法接收两个整型参数作为输入（a 和 b），并且返回一个整型结果代表计算结果</p><p>Note that in this example, we are using the <em>@FunctionalInterface</em> annotation to indicate that the Calculator interface is a functional interface. This annotation is not strictly necessary, but it can help to clarify the intent of the interface.</p><p>注意在这个例子中我们使用了 <strong>@FunctionalInterface</strong>  注解指定在 Calculator 接口的接口方法上面。这个注解严格上来来说是<strong>非必要</strong>的， 但它有助于明确界面的意图。</p><h2 id="Use-the-right-syntax-for-Lambda-Expressions-为Lambda表达式使用正确的语法"><a href="#Use-the-right-syntax-for-Lambda-Expressions-为Lambda表达式使用正确的语法" class="headerlink" title="Use the right syntax for Lambda Expressions 为Lambda表达式使用正确的语法"></a>Use the right syntax for Lambda Expressions 为Lambda表达式使用正确的语法</h2><p>When using Lambda expressions in Java, it is important to use the correct syntax for defining and using them. The syntax of a Lambda expression consists of three parts: the parameter list, the arrow operator, and the body.</p><p>在Java中使用Lambda表达式， 使用正确的语法定义和使用它们非常重要的。Lambda表达式的语法由三部分组成：<strong>参数列表</strong>、<strong>箭头操作符</strong>和<strong>主体</strong>。</p><p>The parameter list [specifies] the input parameters that the Lambda expression will take. If there are no parameters, an empty parameter list must still be specified, as shown here:</p><p>参数列表指定了Lambda表达式将使用的输入参数，如果没有任何参数，一个空的参数化列表依然必须被指定，它的表现形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; System.out.println(<span class="string">"Hello, world!"</span>);</span><br></pre></td></tr></table></figure><p>The arrow operator separates the parameter list from the body of the Lambda expression. The arrow operator can be either a hyphen and greater-than symbol (-&gt;), or the word “goes to” written as an equals sign followed by a greater-than symbol (=&gt;).</p><p>箭头操作符将参数列表与Lambda表达式的主体分开，箭头运算符可以是<code>-</code>字符和大于号组合(-&gt;)，也可以是等号和大于号组合(=&gt;)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hyphen and greater-than symbol  </span></span><br><span class="line">x -&gt; x * x</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// equals sign followed by a greater-than symbol  </span></span><br><span class="line">(x, y) =&gt; x + y</span><br></pre></td></tr></table></figure><p>The body of the Lambda expression specifies the behavior of the expression. The body can be a single expression, or a block of statements enclosed in braces. If the body is a single expression, the braces are optional.</p><p>Lambda 表达式的主体指定表达式的行为，主题可以是一个单独的表达式，也可以是用大括号括起来的语句块，如果主体是单个表达式，则大括号是可选的。</p><p>函数表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// single expression  </span></span><br><span class="line">x -&gt; x * x</span><br></pre></td></tr></table></figure><p>语句块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// block of statements  </span></span><br><span class="line">(x, y) -&gt; &#123;  </span><br><span class="line">    <span class="keyword">int</span> sum = x + y;  </span><br><span class="line">    System.out.println(<span class="string">"The sum is: "</span> + sum);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>It is also important to use the correct type for Lambda expressions when they are assigned to variables or parameters. When a Lambda expression is assigned to a variable or parameter, the type of the variable or parameter must be a functional interface that is compatible with the Lambda expression.</p><p>当Lambda表达式设置变量或者参数的时候，使用正确的类型也是十分重要。当一个Lambda 表达式设置了变量或者参数，变量或参数必须是与<strong>Lambda表达式兼容的功能接口</strong>。</p><p>For example, the following Lambda expression:</p><p>比如下面这个函数表达式的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x, y) -&gt; x + y</span><br></pre></td></tr></table></figure><p>can be assigned to a variable of type <em>IntBinaryOperator</em>:</p><p>这里只能够设置变量类型为 <em>IntBinaryOperator</em> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntBinaryOperator add = (x, y) -&gt; x + y;</span><br></pre></td></tr></table></figure><h2 id="Use-Lambda-expressions-to-implement-Functional-Programming-使用-Lambda-表达式实现函数式编程"><a href="#Use-Lambda-expressions-to-implement-Functional-Programming-使用-Lambda-表达式实现函数式编程" class="headerlink" title="Use Lambda expressions to implement Functional Programming 使用 Lambda 表达式实现函数式编程"></a>Use Lambda expressions to implement Functional Programming 使用 Lambda 表达式实现函数式编程</h2><p>Functional programming is a programming paradigm that emphasizes the use of functions and functional composition to solve problems. In Java, Lambda expressions can be used to implement functional programming by creating and using functions as first-class objects.</p><p>函数式编程是一种编程范式，强调使用函数和函数组合来解决问题。在Java中，可以使用Lambda表达式来实现函数式编程，将函数作为头等对象来创建和使用。</p><blockquote><p>Functions in functional programming are defined by their behavior, rather than their implementation. This means that a function can be treated as an object, and passed around as a parameter or returned as a result. This is where Lambda expressions come in — they allow us to define functions as expressions, and pass them around as objects.</p><p>函数式编程当中行为是通过具体行为而不是实现定义的，也就是说函数可以是对象，并且把参数传递作为结果返回。Lambda表达式的强大之处就在于此，可以把函数作为表达式，并且把对应的对象进行传递。</p></blockquote><p>Here is an example of using Lambda expressions to implement functional programming in Java:</p><p>下面是使用Lambda表达式使Java实现函数式编程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionalProgrammingDemo</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);  </span><br><span class="line">        numbers.stream()  </span><br><span class="line">            .filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>)  </span><br><span class="line">            .map(n -&gt; n * n)  </span><br><span class="line">            .forEach(System.out::println);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In this example, we are using Lambda expressions to implement functional programming in Java. The code first creates a list of integers, and then uses a stream to process the list using functional operations.</p><p>在本示例中，我们使用Lambda表达式在Java中实现函数式编程。代码首先创建一个整数列表，然后使用<code>stream</code>的函数式操作来处理该列表。</p><p>The filter() operation uses a Lambda expression to define a predicate that filters out all odd numbers from the list. The map() operation uses another Lambda expression to define a function that squares each even number in the list. Finally, the <em>forEach()</em> operation uses a method reference to print each squared even number to the console.</p><p><code>filter()</code> 操作使用 Lambda 表达式定义一个<code>predicate</code>，<code>predicate</code>中定义了过滤列表所有奇数的操作，<code>map()</code>操作使用另一个Lambda表达式定义一个函数，该函数将列表中的每个元素求平方，最后使用 forEach 的方式，把每个处理之后的数据打印出来。</p><p>By using Lambda expressions to implement functional programming, you can create more expressive and modular code, and solve problems in a more concise and efficient way. Lambda expressions provide a powerful and flexible way to implement functional programming in Java and are a key feature of the Stream API in Java 8 and later versions.</p><p>使用函数表达式实现函数式编程，你可以创建更多更具表现力和模块化的代码，解决问你也会更加的简单高效，Lambda表达his提供一个强大并且流畅的方法在Java中实现函数式编程，这是Java 8及更高版本中流API的关键特性。</p><h2 id="Use-Lambda-expressions-to-create-Anonymous-Classes-使用-Lambda-表达式创建匿名类"><a href="#Use-Lambda-expressions-to-create-Anonymous-Classes-使用-Lambda-表达式创建匿名类" class="headerlink" title="Use Lambda expressions to create Anonymous Classes 使用 Lambda 表达式创建匿名类"></a>Use Lambda expressions to create Anonymous Classes 使用 Lambda 表达式创建匿名类</h2><p>Anonymous classes are often used in Java to create objects with a specific behavior, such as event listeners or runnable tasks.</p><p>在Java中，匿名类通常用于创建具有特定行为的对象，如事件监听器或可运行任务。</p><p>Lambda expressions can be used to create anonymous classes in Java. When using Lambda expressions to create anonymous classes, the Lambda expression is used to define the behavior of the anonymous class.</p><p>Lambda表达式可用于在Java中创建匿名类。使用Lambda表达式创建匿名类时，Lambda表达式用于定义匿名类的行为。</p><p>Here is an example of using Lambda expressions to create an anonymous class that implements the Runnable interface:</p><p>下面是一个使用Lambda表达式创建一个实现Runnable接口的匿名类的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousClassDemo</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Runnable runnable = () -&gt; &#123;  </span><br><span class="line">            System.out.println(<span class="string">"Hello from anonymous class!"</span>);  </span><br><span class="line">        &#125;;  </span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(runnable);  </span><br><span class="line">        thread.start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In this example, we are using a Lambda expression to create an anonymous class that implements the Runnable interface. The code first defines a Lambda expression that simply prints a message to the console. This Lambda expression is then used to create an anonymous class that implements the Runnable interface. Finally, the anonymous class is passed to a Thread object and started.</p><p>在这个案例中，我们通过Lambda表达式创建Runnable的匿名类，代码首先定义了一个Lambda表达式，该表达式简单地向控制台打印一条消息。然后使用该Lambda表达式创建一个实现Runnable接口的匿名类。最后，匿名类被传递给Thread对象并启动。</p><p>Note that in this example, we are using a Lambda expression with a block of statements enclosed in braces. This is because the Runnable interface has a single abstract method, run(), that takes no arguments and returns no value. Therefore, the Lambda expression must define the behavior of the run() method using a block of statements.</p><p>请注意，在本示例中，我们使用的是一个Lambda表达式，其中的语句块用大括号括起来。这是因为<strong>Runnable接口只有一个抽象方法run()</strong>，它不需要参数也不返回值。因此，Lambda表达式必须使用语句块来定义run()方法的行为。</p><h2 id="Use-Lambda-expressions-to-create-Event-Listeners-使用-Lambda-表达式创建事件监听器"><a href="#Use-Lambda-expressions-to-create-Event-Listeners-使用-Lambda-表达式创建事件监听器" class="headerlink" title="Use Lambda expressions to create Event Listeners 使用 Lambda 表达式创建事件监听器"></a>Use Lambda expressions to create Event Listeners 使用 Lambda 表达式创建事件监听器</h2><p>Event listeners are used in Java to handle events that occur in a user interface or other system. Events can include things like button clicks, mouse movements, and keyboard inputs.</p><p>Java中的事件监听器用于处理用户界面或其他系统中发生的事件。</p><p>事件包括按钮点击、鼠标移动和键盘输入等。</p><blockquote><p>When using Lambda expressions to implement event listeners, the Lambda expression is used to define the behavior that should be executed when the event occurs. The Lambda expression takes an event object as input, and performs some action based on the event.</p><p>当我们使用Lambda表达式实现事件监听器，通常需要用于定义事件发生时应执行的行为。Lambda表达式接收一个事件对象作为输入，并且根据事件的执行某些操作。</p></blockquote><p>Here is an example of using Lambda expressions to implement an event listener for a button click:</p><p>下面是一个使用 Lambda 表达式实现按钮点击事件监听器的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ButtonDemo</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        JButton button = <span class="keyword">new</span> JButton(<span class="string">"Click me!"</span>);  </span><br><span class="line">        button.addActionListener(event -&gt; System.out.println(<span class="string">"Button clicked!"</span>));  </span><br><span class="line">        JFrame frame = <span class="keyword">new</span> JFrame();  </span><br><span class="line">        frame.add(button);  </span><br><span class="line">        frame.pack();  </span><br><span class="line">        frame.setVisible(<span class="keyword">true</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In this example, we are using a Lambda expression to define the behavior that should be executed when the button is clicked. The addActionListener() method of the JButton class takes a ActionListener object as input, which is implemented as a Lambda expression in this case. The Lambda expression simply prints a message to the console when the button is clicked.</p><p>在本示例中，我们使用Lambda表达式来定义点击按钮时应执行的行为。JButton类的addActionListener()方法将ActionListener对象作为输入，在本例中以Lambda表达式的形式实现。当按钮被点击时，Lambda表达式简单地向控制台打印一条消息。</p><p>Note that in this example, we are using the “arrow” notation (-&gt;) to separate the parameter list from the body of the Lambda expression. The parameter list consists of a single event object, which represents the button click event. The body of the Lambda expression simply prints a message to the console.</p><p>请注意，在本例中，我们使用了 “箭头 “符号 (-&gt;) 来分隔参数列表和 Lambda 表达式的主体。参数列表由单个字符串值组成，代表列表中的每个字符串。Lambda 表达式的主体只是将字符串打印到控制台。</p><h2 id="Use-Lambda-expressions-to-Iterate-over-Collections-使用-Lambda-表达式遍历集合"><a href="#Use-Lambda-expressions-to-Iterate-over-Collections-使用-Lambda-表达式遍历集合" class="headerlink" title="Use Lambda expressions to Iterate over Collections 使用 Lambda 表达式遍历集合"></a>Use Lambda expressions to Iterate over Collections 使用 Lambda 表达式遍历集合</h2><p>Iterating over collections is a common operation in Java, and Lambda expressions can be used to simplify and streamline this process. When using Lambda expressions to iterate over collections, the Lambda expression is used to define the behavior that should be executed for each element in the collection.</p><p>在 Java 中，遍历集合是一种常见操作，而 Lambda 表达式可用于简化和精简这一过程。使用 Lambda 表达式遍历集合时，Lambda 表达式用于定义应针对集合中的每个元素执行的行为。</p><p>Here is an example of using Lambda expressions to iterate over a list of strings and print each string to the console:</p><p>下面是一个使用 Lambda 表达式遍历字符串列表并将每个字符串打印到控制台的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"cherry"</span>);  </span><br><span class="line">strings.forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure><p>In this example, we are using the forEach() method of the List interface to iterate over a list of strings. The forEach() method takes a Consumer object as input, which is implemented as a Lambda expression in this case. The Lambda expression simply prints each string to the console.</p><p>在本示例中，我们使用 List 接口的 forEach() 方法遍历字符串列表。forEach()方法将Consumer对象作为输入，在本例中以Lambda表达式的形式实现。Lambda 表达式简单地将每个字符串打印到控制台。</p><p>Note that in this example, we are using the “arrow” notation (-&gt;) to separate the parameter list from the body of the Lambda expression. The parameter list consists of a single string value, which represents each string in the list. The body of the Lambda expression simply prints the string to the console.</p><p>请注意，在本例中，我们使用了 “箭头 “符号 (-&gt;) 来分隔参数列表和 Lambda 表达式的主体。参数列表由单个字符串值组成，代表列表中的每个字符串。Lambda 表达式的主体只是将字符串打印到控制台。</p><p>Here is another example of using Lambda expressions to iterate over a map of key-value pairs and print each pair to the console:</p><p>下面是另一个使用 Lambda 表达式遍历键值对映射并将每一对键值对打印到控制台的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();  </span><br><span class="line">map.put(<span class="string">"apple"</span>, <span class="number">1</span>);  </span><br><span class="line">map.put(<span class="string">"banana"</span>, <span class="number">2</span>);  </span><br><span class="line">map.put(<span class="string">"cherry"</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.forEach((k, v) -&gt; System.out.println(k + <span class="string">" -&gt; "</span> + v));</span><br></pre></td></tr></table></figure><p>In this example, we are using the <em>forEach()</em> method of the Map interface to iterate over a map of key-value pairs. The forEach() method takes a <em>BiConsumer</em> object as input, which is implemented as a Lambda expression in this case. The Lambda expression takes two parameters, a key and a value, and simply prints each key-value pair to the console.</p><p>在本例中，我们使用 <code>Map</code> 接口的 <em>forEach()</em> 方法遍历键值对映射。forEach()方法将 <em>BiConsumer</em> 对象作为输入，在本例中是以 Lambda 表达式的形式实现的。</p><p>Lambda 表达式接收两个参数，一个键和一个值，并简单地将每个键值对打印到控制台。</p><p>Note that in this example, we are using the “arrow” notation (-&gt;) to separate the parameter list from the body of the Lambda expression. The parameter list consists of two values, a key and a value, which represent each key-value pair in the map. The body of the Lambda expression simply prints the key-value pair to the console.</p><p>请注意，在这个示例中，我们使用了 “箭头 “符号 (-&gt;) 来分隔参数列表和 Lambda 表达式的主体。参数列表由两个值（一个 key 和一个 value）组成，分别代表 map 中的每个键值对。Lambda 表达式的主体只是将键值对打印到控制台。</p><h2 id="Use-Lambda-expressions-to-Filter-Collections-使用-Lambda-表达式过滤集合"><a href="#Use-Lambda-expressions-to-Filter-Collections-使用-Lambda-表达式过滤集合" class="headerlink" title="Use Lambda expressions to Filter Collections 使用 Lambda 表达式过滤集合"></a>Use Lambda expressions to Filter Collections 使用 Lambda 表达式过滤集合</h2><p>Filtering collections is a common operation in Java, and Lambda expressions can be used to simplify and streamline this process. When using Lambda expressions to filter collections, the Lambda expression is used to define a predicate that selects which elements in the collection should be included or excluded.</p><p>过滤集合是 Java 中的一种常见操作，而 Lambda 表达式可用于简化和精简这一过程。使用 Lambda 表达式过滤集合时，Lambda 表达式用于定义一个谓词，该谓词用于选择应包含或排除集合中的哪些元素。</p><p>Here is an example of using Lambda expressions to filter a list of integers and create a new list that contains only the even numbers:</p><p>下面是一个使用 Lambda 表达式过滤整数列表并创建一个只包含偶数的新列表的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);  </span><br><span class="line">List&lt;Integer&gt; evenNumbers = numbers.stream()  </span><br><span class="line">                                    .filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>)  </span><br><span class="line">                                    .collect(Collectors.toList());  </span><br><span class="line">System.out.println(evenNumbers);</span><br></pre></td></tr></table></figure><p>In this example, we are using the filter() method of the Stream interface to filter a list of integers. The filter() method takes a predicate as input, which is implemented as a Lambda expression in this case. The Lambda expression defines a predicate that tests whether a number is even or not by checking if its remainder is zero when divided by two.</p><p>在本例中，我们使用流接口的 filter() 方法过滤整数列表。filter() 方法将一个谓词作为输入，在本例中以 Lambda 表达式的形式实现。Lambda 表达式定义了一个谓词，该谓词通过检查一个数字除以 2 后的余数是否为零来检验该数字是否为偶数。</p><p>Note that in this example, we are using the “arrow” notation (-&gt;) to separate the parameter list from the body of the Lambda expression. The parameter list consists of a single integer value, which represents each element in the stream. The body of the Lambda expression is a boolean expression that defines the predicate.</p><p>请注意，在这个示例中，我们使用了 “箭头 “符号 (-&gt;) 来分隔参数列表和 Lambda 表达式的主体。参数列表由单个整数值组成，代表流中的每个元素。Lambda 表达式的主体是定义谓词的布尔表达式。</p><p>The filtered elements are then collected into a new list using the collect() method of the Stream interface, which takes a Collector object as input. The Collector object in this case is the toList() method of the Collectors class, which creates a new list of the filtered elements.</p><p>然后，使用流接口的 collect() 方法将过滤后的元素收集到一个新的列表中，该方法将收集器对象作为输入。本例中的收集器对象是收集器类的 toList() 方法，它将创建一个包含过滤元素的新列表。</p><h2 id="Use-Lambda-expressions-to-Sort-Collections-使用-Lambda-表达式对集合进行排序"><a href="#Use-Lambda-expressions-to-Sort-Collections-使用-Lambda-表达式对集合进行排序" class="headerlink" title="Use Lambda expressions to Sort Collections 使用 Lambda 表达式对集合进行排序"></a>Use Lambda expressions to Sort Collections 使用 Lambda 表达式对集合进行排序</h2><p>Sorting is the process of arranging the elements of a collection in a specific order. In Java, collections can be sorted using the <em>sorted()</em> method of the Stream API.</p><p>排序是将集合中的元素按特定顺序排列的过程。在Java中，可以使用流API的 <em>sorted()</em> 方法对集合进行排序。 </p><blockquote><p>When using Lambda expressions to sort collections, the Lambda expression is used to define the <em>order</em> in which the elements should be sorted. </p><p>使用 Lambda 表达式对集合进行排序时，Lambda 表达式用于定义元素的排序顺序。</p><p>The Lambda expression takes two elements from the collection as input, and returns an integer value indicating their relative order. </p><p>Lambda 表达式将集合中的两个元素作为输入，并返回一个整数值，表示它们的相对顺序。</p><p>If the first element should come before the second element in the sorted collection, the Lambda expression returns a negative integer. </p><p>如果在排序集合中，第一个元素应在第二个元素之前，则 Lambda 表达式会返回一个负整数。</p><p>If the first element should come after the second element, the Lambda expression returns a positive integer. If the two elements are equal, the Lambda expression returns zero.</p><p>如果第一个元素位于第二个元素之后，则 Lambda 表达式返回一个正整数。如果两个元素相等，则 Lambda 表达式返回 0。</p></blockquote><p>Here is an example of using Lambda expressions to sort a list of integers:</p><p>下面是一个使用 Lambda 表达式对整数列表进行排序的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">5</span>);  </span><br><span class="line">List&lt;Integer&gt; sortedNumbers = numbers.stream().sorted().collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>In this example, we are using a Lambda expression to sort the list of integers in ascending order. The sorted() method uses this Lambda expression to create a new stream that contains the elements of the original list in sorted order.</p><p>在这个示例中，我们使用 Lambda 表达式按升序对整数列表进行排序。</p><p>sorted()方法使用该Lambda表达式创建一个新的流，其中包含按排序顺序排列的原始列表元素。</p><p>Note that in this example, we are not explicitly defining a Lambda expression for the sorted() method. This is because the default behavior of the sorted() method is to sort the elements in natural order. However, you can also provide a custom Lambda expression to the sorted() method to define a custom sort order.</p><p>请注意，在这个示例中，我们没有为 sorted() 方法明确定义一个 Lambda 表达式。这是因为 sorted() 方法的默认行为是按自然顺序对元素进行排序。</p><p>不过，您也可以为 sorted() 方法提供自定义 Lambda 表达式，以定义自定义排序顺序。</p><p>Here is an example of using a Lambda expression to sort a list of strings in descending order:</p><p>下面是一个使用 Lambda 表达式对字符串列表进行降序排序的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; words = Arrays.asList(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"cherry"</span>, <span class="string">"date"</span>, <span class="string">"elderberry"</span>);  </span><br><span class="line">List&lt;String&gt; sortedWords = words.stream().sorted((a, b) -&gt; b.compareTo(a)).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>In this example, we are using a Lambda expression to sort the list of strings in descending order. The Lambda expression takes two strings as input, and returns the result of comparing the second string to the first string using the <em>compareTo()</em> method of the String class.</p><p>在本例中，我们使用 Lambda 表达式对字符串列表进行降序排序。Lambda 表达式将两个字符串作为输入，并使用 String 类的 <em>compareTo()</em> 方法返回第二个字符串与第一个字符串的比较结果。</p><h2 id="Use-Lambda-expressions-to-Map-Collections"><a href="#Use-Lambda-expressions-to-Map-Collections" class="headerlink" title="Use Lambda expressions to Map Collections"></a>Use Lambda expressions to Map Collections</h2><p>Mapping is the process of transforming one collection into another. In Java, collections can be mapped using the map() method of the Stream API.</p><p>Map是将一个集合转换成另一个集合的过程。在 Java 中，可以使用流 API 的 map() 方法对集合进行映射。</p><blockquote><p>When using Lambda expressions to map collections, the Lambda expression is used to define the transformation that should be applied to each element in the collection. The Lambda expression takes an element from the collection as input and returns a new value that represents the transformed element.</p><p>使用 Lambda 表达式映射集合时，Lambda 表达式用于定义应用于集合中每个元素的转换。Lambda 表达式将集合中的元素作为输入，并返回一个代表转换后元素的新值。</p></blockquote><p>Here is an example of using Lambda expressions to map a list of strings to a list of integers:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>);  </span><br><span class="line">List&lt;Integer&gt; integers = strings.stream().map(Integer::parseInt).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>In this example, we are using a Lambda expression to map the list of strings to a list of integers. The Lambda expression applies the parseInt() method of the Integer class to each string in the list, converting it to an integer value. The map() method then uses this Lambda expression to create a new stream that contains the transformed elements.</p><p>在本例中，我们使用 Lambda 表达式将字符串列表映射为整数列表。Lambda 表达式对列表中的每个字符串应用 Integer 类的 parseInt() 方法，将其转换为整数值。然后，map() 方法使用此 Lambda 表达式创建一个包含转换后元素的新流。</p><p>Note that in this example, we are using the method reference notation (::) to refer to the parseInt() method of the Integer class. This is a shorthand notation for a Lambda expression that simply calls a single method.</p><p>请注意，在本例中，我们使用方法引用符号（::）来引用 Integer 类的 parseInt() 方法。这是一个 Lambda 表达式的简写符号，只需调用一个方法即可。</p><p>Here is another example of using a Lambda expression to map a list of strings to a list of uppercase strings:</p><p>下面是另一个使用 <code>Lambda</code> 表达式将字符串列表映射为大写字符串列表的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; words = Arrays.asList(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"cherry"</span>, <span class="string">"date"</span>, <span class="string">"elderberry"</span>);  </span><br><span class="line">List&lt;String&gt; uppercaseWords = words.stream().map(s -&gt; s.toUpperCase()).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>In this example, we are using a Lambda expression to map the list of strings to a list of uppercase strings. The Lambda expression applies the toUpperCase() method of the String class to each string in the list, converting it to an uppercase string. The map() method then uses this Lambda expression to create a new stream that contains the transformed elements.</p><p>在本例中，我们使用 Lambda 表达式将字符串列表映射为大写字符串列表。Lambda 表达式将 String 类的 toUpperCase() 方法应用于列表中的每个字符串，将其转换为大写字符串。然后，map() 方法使用此 Lambda 表达式创建一个包含转换后元素的新流。</p><h2 id="Use-Lambda-expressions-to-Reduce-Collections-使用-Lambda-表达式精简集合"><a href="#Use-Lambda-expressions-to-Reduce-Collections-使用-Lambda-表达式精简集合" class="headerlink" title="Use Lambda expressions to Reduce Collections 使用 Lambda 表达式精简集合"></a>Use Lambda expressions to Reduce Collections 使用 Lambda 表达式精简集合</h2><p>Reducing is the process of applying an operation to all the elements of a collection to produce a single result. In Java, collections can be reduced using the reduce() method of the Stream API.</p><p><code>Reducing</code> 是对集合中的所有元素进行操作以产生单一结果的过程。在 Java 中，可以使用流 API 的 <code>reduce()</code>方法对集合进行还原。</p><blockquote><p>When using Lambda expressions to reduce collections, the Lambda expression is used to define the operation that should be applied to each element in the collection. The Lambda expression takes two arguments as input: an accumulator and an element from the collection. The accumulator is the result of the previous operation, or an initial value if this is the first operation. The Lambda expression returns a new value that represents the result of applying the operation to the accumulator and the current element.</p><p>使用 Lambda 表达式还原集合时，Lambda 表达式用于定义应用于集合中每个元素的操作。Lambda 表达式将两个参数作为输入：累加器和集合中的一个元素。累加器是前一次操作的结果，如果是第一次操作，则是初始值。Lambda 表达式返回一个新值，该值代表对累加器和当前元素应用操作的结果。</p></blockquote><p>Here is an example of using Lambda expressions to reduce a list of integers to a single sum:</p><p>下面是一个使用 Lambda 表达式将整数列表简化为单个和的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);  </span><br><span class="line"><span class="keyword">int</span> sum = numbers.stream().reduce(<span class="number">0</span>, (a, b) -&gt; a + b);</span><br></pre></td></tr></table></figure><p>In this example, we are using a Lambda expression to reduce the list of integers to a single sum. The Lambda expression takes two integer values as input: an accumulator (initialized to zero in this case), and an element from the list. The Lambda expression adds the element to the accumulator, and returns the new value of the <em>accumulator</em>. The reduce() method then uses this Lambda expression to apply the operation to each element in the list, producing the final sum.</p><p>在本例中，我们使用 Lambda 表达式将整数列表还原为单个和。Lambda 表达式将两个整数值作为输入：一个累加器（本例中初始化为零）和列表中的一个元素。Lambda 表达式将元素加到累加器中，并返回_accumulator_的新值。然后，reduce() 方法使用此 Lambda 表达式对列表中的每个元素进行运算，得出最终总和。</p><p>Note that in this example, we are using the “arrow” notation (-&gt;) to separate the parameter list  from the body of the Lambda expression. The parameter list consists of two integer values: the accumulator and the current element from the list. The body of the Lambda expression adds the current element to the accumulator using the + operator.</p><p>请注意，在本例中，我们使用了 “箭头 “符号 (-&gt;) 来分隔参数列表和 Lambda 表达式的主体。参数列表由两个整数值组成：累加器和列表中的当前元素。Lambda 表达式的主体使用 + 运算符将当前元素添加到累加器中。</p><p>Here is another example of using a Lambda expression to reduce a list of strings to a single concatenated string:</p><p>下面是另一个使用 Lambda 表达式将字符串列表缩减为单个连接字符串的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; words = Arrays.asList(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"cherry"</span>, <span class="string">"date"</span>, <span class="string">"elderberry"</span>);  </span><br><span class="line">String concatenated = words.stream().reduce(<span class="string">""</span>, (a, b) -&gt; a + b);</span><br></pre></td></tr></table></figure><p>In this example, we are using a Lambda expression to reduce the list of strings to a single concatenated string. The Lambda expression takes two string values as input: an accumulator (initialized to an empty string in this case), and an element from the list. The Lambda expression concatenates the element to the accumulator, and returns the new value of the accumulator. The reduce() method then uses this Lambda expression to apply the operation to each element in the list, producing the final concatenated string.</p><p>在本例中，我们使用 Lambda 表达式将字符串列表还原为单个连接字符串。Lambda 表达式将两个字符串值作为输入：一个累加器（本例中初始化为空字符串）和列表中的一个元素。Lambda 表达式将元素连接到累加器，并返回累加器的新值。然后，reduce() 方法使用此 Lambda 表达式对列表中的每个元素进行操作，生成最终的连接字符串。</p><h2 id="Use-Lambda-expressions-to-Group-Collections-使用-Lambda-表达式对集合进行分组"><a href="#Use-Lambda-expressions-to-Group-Collections-使用-Lambda-表达式对集合进行分组" class="headerlink" title="Use Lambda expressions to Group Collections  使用 Lambda 表达式对集合进行分组"></a>Use Lambda expressions to Group Collections  使用 Lambda 表达式对集合进行分组</h2><p>Grouping is the process of grouping the elements of a collection based on a common property or criterion. In Java, collections can be grouped using the <em>groupingBy()</em> method of the Collectors class.</p><p>分组是根据共同属性或标准对集合中的元素进行分组的过程。在 Java 中，可以使用 Collectors 类的 <em>groupingBy()</em> 方法对集合进行分组。</p><blockquote><p>When using Lambda expressions to group collections, the Lambda expression is used to define the criterion that should be used to group the elements. The Lambda expression takes an element from the collection as input, and returns a value that represents the grouping criterion.</p><p>使用 Lambda 表达式对集合进行分组时，Lambda 表达式用于定义对元素进行分组的标准。Lambda 表达式将集合中的元素作为输入，并返回一个代表分组标准的值。</p></blockquote><p>Here is an example of using Lambda expressions to group a list of words by their length:</p><p>下面是一个使用 Lambda 表达式按单词长度分组的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; words = Arrays.asList(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"cherry"</span>, <span class="string">"date"</span>, <span class="string">"elderberry"</span>);  </span><br><span class="line">Map&lt;Integer, List&lt;String&gt;&gt; groups = words.stream().collect(Collectors.groupingBy(String::length));</span><br></pre></td></tr></table></figure><p>In this example, we are using a Lambda expression to group the list of words by their length. The groupingBy() method uses this Lambda expression to create a map that groups the words by their length. The key of each entry in the map is an integer value representing the length of the words, and the value of each entry is a list of words with that length.</p><p>在本例中，我们使用 <code>Lambda</code> 表达式按单词长度对单词列表进行分组。<code>groupingBy()</code> 方法使用此 <code>Lambda</code> 表达式创建一个按单词长度分组的映射。映射中每个条目的键是代表单词长度的整数值，每个条目的值是具有该长度的单词列表。</p><p>Note that in this example, we are using the method reference notation (::) to refer to the length() method of the String class. This is a shorthand notation for a Lambda expression that simply calls a single method.</p><p>请注意，在本例中，我们使用方法引用符号（<code>::</code>）来引用 <code>String</code> 类的 <code>length()</code> 方法。这是简单调用单个方法的 Lambda 表达式的速记符号。</p><p>Here is another example of using a Lambda expression to group a list of employees by their department:</p><p>下面是另一个使用 Lambda 表达式按部门对员工列表进行分组的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Employee&gt; employees = Arrays.asList(  </span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="string">"Alice"</span>, <span class="string">"Sales"</span>),  </span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="string">"Bob"</span>, <span class="string">"Marketing"</span>),  </span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="string">"Charlie"</span>, <span class="string">"Sales"</span>),  </span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="string">"Dave"</span>, <span class="string">"Marketing"</span>),  </span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="string">"Eve"</span>, <span class="string">"HR"</span>)  </span><br><span class="line">);  </span><br><span class="line"></span><br><span class="line">Map&lt;String, List&lt;Employee&gt;&gt; groups = employees.stream().collect(Collectors.groupingBy(Employee::getDepartment));</span><br></pre></td></tr></table></figure><p>In this example, we are using a Lambda expression to group the list of employees by their department. The groupingBy() method uses this Lambda expression to create a map that groups the employees by their department. The key of each entry in the map is a string value representing the department of the employees, and the value of each entry is a list of employees in that department.</p><p>在本例中，我们使用 Lambda 表达式按部门对员工列表进行分组。groupingBy()方法使用此 Lambda 表达式创建了一个按部门对员工进行分组的映射。映射中每个条目的键是代表员工部门的字符串值，每个条目的值是该部门的员工列表。</p><h2 id="Use-Lambda-expressions-to-Handle-Exceptions-使用-Lambda-表达式处理异常"><a href="#Use-Lambda-expressions-to-Handle-Exceptions-使用-Lambda-表达式处理异常" class="headerlink" title="Use Lambda expressions to Handle Exceptions 使用 Lambda 表达式处理异常"></a>Use Lambda expressions to Handle Exceptions 使用 Lambda 表达式处理异常</h2><p>Lambda expressions can be used to handle checked exceptions in Java. Checked exceptions are a type of exception that must be declared in a method’s signature or handled by the caller. When using Lambda expressions to handle checked exceptions, the Lambda expression is used to define the behavior that should be executed in case of an exception, while still allowing the checked exception to be propagated up to the caller.</p><p>Lambda 表达式可用于处理 Java 中的校验异常。校验异常是一种必须在方法签名中声明或由调用者处理的异常类型。使用 Lambda 表达式处理校验异常时，Lambda 表达式用于定义异常情况下应执行的行为，同时仍允许将校验异常传播给调用者。</p><p>Here is an example of using Lambda expressions to handle a checked exception when reading a file:</p><p>下面是一个使用 Lambda 表达式处理读取文件时已检查异常的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; lines = <span class="keyword">null</span>;  </span><br><span class="line"><span class="keyword">try</span> (BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"file.txt"</span>))) &#123;  </span><br><span class="line">    lines = reader.lines()  </span><br><span class="line">                  .map(line -&gt; &#123;  </span><br><span class="line">                      <span class="keyword">try</span> &#123;  </span><br><span class="line">                          <span class="keyword">return</span> process(line);  </span><br><span class="line">                      &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">                          <span class="keyword">throw</span> <span class="keyword">new</span> UncheckedIOException(e);  </span><br><span class="line">                      &#125;  </span><br><span class="line">                  &#125;)  </span><br><span class="line">                  .collect(Collectors.toList());  </span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">    e.printStackTrace();  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">process</span><span class="params">(String line)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">    <span class="comment">// process the line  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In this example, we are using a Lambda expression to handle a checked exception when processing each line of a file. The code first creates a <em>BufferedReader</em> object that reads from a file named “file.txt”. The lines from the file are then processed using the map() method of the Stream interface. The map() method takes a Function object as input, which is implemented as a Lambda expression in this case. The Lambda expression calls the process() method to process each line, and catches any IOException that may occur. If an IOException occurs, the Lambda expression throws an UncheckedIOException, which is a runtime exception that wraps the original checked exception.</p><p>在本示例中，我们使用 Lambda 表达式来处理处理文件每一行时检查到的异常。代码首先创建了一个 <em>BufferedReader</em> 对象，用于读取名为 “file.txt “的文件。</p><p>然后使用 Stream 接口的 map() 方法处理文件中的行。</p><p>map() 方法将一个 Function 对象作为输入，在本例中实现为一个 Lambda 表达式。Lambda 表达式调用 process() 方法处理每一行，并捕获可能出现的任何 IOException。</p><p>如果出现 IO 异常，Lambda 表达式会抛出一个未检查的 IO 异常，这是一个运行时异常，它封装了原始的已检查异常。</p><p>Note that in this example, we are using a Lambda expression with a block of statements enclosed in braces. This is because the <em>process()</em> method throws an <em>IOException</em>, which must be caught or re-thrown by the Lambda expression.</p><p>请注意，在这个示例中，我们使用的是一个 Lambda 表达式和一个用大括号括起来的语句块。这是因为 <em>process()</em> 方法会抛出一个<em>IOException_，而 Lambda 表达式必须捕获或重新抛出这个 _IOException</em> 。</p><p>By using Lambda expressions to handle checked exceptions, you can create more concise and readable code, and handle exceptions with greater flexibility and modularity. Lambda expressions provide a powerful and flexible way to handle checked exceptions in Java, and can be used in a wide range of scenarios, such as file I/O, network communication, and database access.</p><p>通过使用 <code>Lambda</code> 表达式来处理校验异常，您可以创建更简洁、更易读的代码，并以更大的灵活性和模块化来处理异常。Lambda 表达式为在 Java 中处理检查异常提供了一种强大而灵活的方法，可用于文件 I/O、网络通信和数据库访问等多种场景。</p><h2 id="Use-Lambda-expressions-to-Handle-Null-Values-使用-Lambda-表达式处理空值"><a href="#Use-Lambda-expressions-to-Handle-Null-Values-使用-Lambda-表达式处理空值" class="headerlink" title="Use Lambda expressions to Handle Null Values 使用 Lambda 表达式处理空值"></a>Use Lambda expressions to Handle Null Values 使用 Lambda 表达式处理空值</h2><p>In Java, NullPointerExceptions (NPEs) can often occur when dealing with null values. Lambda expressions can be used to handle null values in a more concise and expressive way, and to prevent <em>NullPointerExceptions</em> from occurring. Here is an example of using Lambda expressions to handle null values when filtering a list of strings:</p><p>在 Java 中，处理空值时经常会出现 <code>NullPointerException（NPE）</code>。可以使用 Lambda 表达式以更简洁、更具表现力的方式处理空值，并防止发生 <em>NullPointerException</em> 异常。下面是一个在过滤字符串列表时使用 Lambda 表达式处理空值的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"apple"</span>, <span class="keyword">null</span>, <span class="string">"banana"</span>, <span class="string">"cherry"</span>, <span class="keyword">null</span>);  </span><br><span class="line">List&lt;String&gt; filteredList = list.stream()  </span><br><span class="line">                                .filter(s -&gt; s != <span class="keyword">null</span>)  </span><br><span class="line">                                .collect(Collectors.toList());  </span><br><span class="line">System.out.println(filteredList);</span><br></pre></td></tr></table></figure><p>In this example, we are using the <em>filter()</em> method of the Stream interface to filter a list of strings. The filter() method takes a Predicate object as input, which is implemented as a Lambda expression in this case. The Lambda expression defines a predicate that tests whether a string is not null.</p><p>在本例中，我们使用 Stream 接口的 <em>filter()</em> 方法过滤字符串列表。filter()方法将一个谓词对象作为输入，在本例中是以 Lambda 表达式的形式实现的。Lambda 表达式定义了一个谓词，用于测试字符串是否为空。</p><p>Note that in this example, we are using the != operator to test for null values. This is because the null value is not equal to any other value, including null itself.</p><p>请注意，在本例中，我们使用 != 操作符来测试空值。这是因为null值不等于任何其他值，包括null值本身。</p><h2 id="Use-Lambda-expressions-to-perform-Parallel-Operations-使用-Lambda-表达式执行并行操作"><a href="#Use-Lambda-expressions-to-perform-Parallel-Operations-使用-Lambda-表达式执行并行操作" class="headerlink" title="Use Lambda expressions to perform Parallel Operations 使用 Lambda 表达式执行并行操作"></a>Use Lambda expressions to perform Parallel Operations 使用 Lambda 表达式执行并行操作</h2><p>Lambda expressions are anonymous functions in Java that can be used to perform a variety of operations, including parallel operations.</p><p>Lambda 表达式是 Java 中的匿名函数（但是细节上和真正的匿名函数不一样），可用于执行各种操作，包括并行操作。</p><blockquote><p>Parallelism refers to the ability to perform multiple operations simultaneously, thereby reducing the amount of time it takes to complete a task. In Java, parallelism can be achieved using the Stream API and lambda expressions.</p><p>并行性是指同时执行多个操作的能力，从而减少完成任务所需的时间。在 Java 中，可以使用流 API 和 lambda 表达式来实现并行性</p></blockquote><p>The Stream API provides a <em>parallelStream()</em> method that allows you to create parallel streams. Streams are collections of objects that can be processed sequentially or in parallel. By default, streams are processed sequentially, but you can use the <em>parallelStream()</em> method to process them in parallel.</p><p>流 API 提供了一个 <em>parallelStream()</em> 方法，允许您创建并行流。</p><p>流是可以按顺序或并行处理的对象集合。默认情况下，流是按顺序处理的，但您可以使用 <em>parallelStream()</em> 方法并行处理它们。</p><p>To use lambda expressions to perform parallel operations, you first need to create a stream using the parallelStream() method. You can then use lambda expressions to define the operations that are performed on the elements of the stream. <strong>The Stream API will automatically split the stream into multiple substreams and distribute them across multiple threads, allowing the operations to be performed in parallel.</strong></p><p>要使用 lambda 表达式执行并行操作，首先需要使用 parallelStream() 方法创建一个流。然后，就可以使用 lambda 表达式定义对流元素执行的操作。 **流 API 会自动将流拆分成多个子流，并将它们分配给多个线程，从而允许并行执行操作。</p><p>Here’s an example of using lambda expressions to perform a parallel operation:</p><p>下面是一个使用 lambda 表达式执行并行操作的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = numbers.parallelStream()  </span><br><span class="line">                .filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>)  </span><br><span class="line">                .mapToInt(n -&gt; n)  </span><br><span class="line">                .sum();</span><br></pre></td></tr></table></figure><h2 id="Use-Lambda-expressions-to-create-Custom-Collectors-使用-Lambda-表达式创建自定义收集器"><a href="#Use-Lambda-expressions-to-create-Custom-Collectors-使用-Lambda-表达式创建自定义收集器" class="headerlink" title="Use Lambda expressions to create Custom Collectors  使用 Lambda 表达式创建自定义收集器"></a>Use Lambda expressions to create Custom Collectors  使用 Lambda 表达式创建自定义收集器</h2><p>A collector is an operation that can be performed on a stream to accumulate the elements of the stream into a final result. Collectors are used with the <em>collect()</em> method of the Stream interface.</p><p>收集器是一种可在流上执行的操作，用于将流的元素累加为最终结果。收集器与流接口的 <em>collect()</em> 方法一起使用。</p><blockquote><p>Java provides a number of built-in collectors that perform common operations like grouping elements, counting elements, and calculating averages. However, you can also create your own custom collectors using lambda expressions.</p><p>Java 提供了许多内置收集器，可执行分组元素、计数元素和计算平均值等常见操作。<br>不过，您也可以使用 lambda 表达式创建自己的自定义收集器。</p></blockquote><p>To create a custom collector using lambda expressions, you need to define a new class that implements the <em>Collector</em> interface. The Collector interface has four methods that you need to implement:</p><p>要使用 lambda 表达式创建自定义收集器，需要定义一个实现 <em>Collector</em> 接口的新类。收集器接口有四个方法需要实现：</p><ul><li><p>The <em>supplier()</em> method returns a function that creates a new mutable result container.</p></li><li><p>The <em>accumulator()</em> method returns a function that adds an element to the result container.</p></li><li><p>The <em>combiner()</em> method returns a function that combines two result containers.</p></li><li><p>The <em>finisher()</em> method returns a function that performs a final transformation on the result container.</p></li><li><p>_supplier()_： 方法返回一个函数，用于创建一个新的可变结果容器。</p></li><li><p>_Accumulator()_：  方法返回一个将元素添加到结果容器的函数。</p></li><li><p>_combiner()_：方法返回一个将两个结果容器组合在一起的函数。</p></li><li><p>_finisher()_： 方法返回一个对结果容器执行最终转换的函数。</p></li></ul><p>Here’s an example of creating a custom collector that calculates the average of a stream of integers:</p><p>下面是一个创建自定义收集器的示例，用于计算整数流的平均值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class AverageCollector implements Collector&lt;Integer, int[], Double&gt; &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> Supplier&lt;<span class="keyword">int</span>[]&gt; supplier() &#123;  </span><br><span class="line">        <span class="keyword">return</span> () -&gt; <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> BiConsumer&lt;<span class="keyword">int</span>[], Integer&gt; accumulator() &#123;  </span><br><span class="line">        <span class="keyword">return</span> (acc, val) -&gt; &#123;  </span><br><span class="line">            acc[<span class="number">0</span>] += val;  </span><br><span class="line">            acc[<span class="number">1</span>]++;  </span><br><span class="line">        &#125;;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> BinaryOperator&lt;<span class="keyword">int</span>[]&gt; combiner() &#123;  </span><br><span class="line">        <span class="keyword">return</span> (acc1, acc2) -&gt; &#123;  </span><br><span class="line">            acc1[<span class="number">0</span>] += acc2[<span class="number">0</span>];  </span><br><span class="line">            acc1[<span class="number">1</span>] += acc2[<span class="number">1</span>];  </span><br><span class="line">            <span class="keyword">return</span> acc1;  </span><br><span class="line">        &#125;;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> Function&lt;<span class="keyword">int</span>[], Double&gt; finisher() &#123;  </span><br><span class="line">        <span class="keyword">return</span> acc -&gt; ((<span class="keyword">double</span>) acc[<span class="number">0</span>]) / acc[<span class="number">1</span>];  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> Collections.emptySet();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In this example, we define a new class called <em>AverageCollector</em> that implements the Collector interface. The <em>supplier()</em> method returns a function that creates a new integer array with two elements to store the sum and count of the elements in the stream. </p><p>在本例中，我们定义了一个名为 <em>AverageCollector</em> 的新类，该类实现了收集器接口。<em>supplier()</em> 方法返回一个函数，用于创建一个包含两个元素的新整数数组，用于存储数据流中元素的总和与计数。</p><p>The accumulator() method returns a function that adds each element to the sum and increments the count. The <em>combiner()</em> method returns a function that combines two integer arrays by adding their corresponding elements. The <em>finisher()</em> method returns a function that calculates the average by dividing the sum by the count. Finally, the <em>characteristics()</em> method returns an empty set because this collector does not have any special characteristics.</p><p>累加器()方法返回一个将每个元素加到总和中并递增计数的函数。<em>combiner()</em> 方法返回一个函数，该函数通过将两个整数数组中的相应元素相加来合并两个数组。<em>finisher()</em> 方法返回一个函数，通过用总和除以计数来计算平均值。最后，<em>characteristics()</em> 方法返回空集，因为该收集器没有任何特殊特征。</p><p>Once you’ve defined your custom collector, you can use it with the collect() method of the Stream interface like this:</p><p>一旦定义了自定义收集器，就可以像这样将其与 Stream 接口的 collect() 方法结合使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> average = numbers.stream()  </span><br><span class="line">                        .collect(<span class="keyword">new</span> AverageCollector());</span><br></pre></td></tr></table></figure><p>In this example, we create a stream of integers and use the collect() method with our custom AverageCollector to calculate the average of the integers in the stream. The lambda expressions we defined in the AverageCollector class are used to perform the accumulation and transformation operations.</p><p>在本例中，我们创建了一个整数流，并使用带有自定义 AverageCollector 的 collect() 方法计算流中整数的平均值。我们在 AverageCollector 类中定义的 lambda 表达式用于执行累加和转换操作。</p><h2 id="Use-Lambda-expressions-to-create-Higher-order-Functions-使用-Lambda-表达式创建高阶函数"><a href="#Use-Lambda-expressions-to-create-Higher-order-Functions-使用-Lambda-表达式创建高阶函数" class="headerlink" title="Use Lambda expressions to create Higher-order Functions 使用 Lambda 表达式创建高阶函数"></a>Use Lambda expressions to create Higher-order Functions 使用 Lambda 表达式创建高阶函数</h2><p>A higher-order function is a function that takes one or more functions as arguments and/or returns a function as its result. Lambda expressions can be used to create functions that take other functions as arguments or return functions as results.</p><p>高阶函数是将一个或多个函数作为参数和/或将一个函数作为结果返回的函数。Lambda 表达式可用于创建将其他函数作为参数或将函数作为结果返回的函数。</p><blockquote><p>To create a higher-order function using lambda expressions, you can define a method that takes a functional interface as a parameter or return value. A functional interface is an interface that has exactly one abstract method and is annotated with the @FunctionalInterface annotation.</p><p>要使用 lambda 表达式创建高阶函数，可以定义一个将功能接口作为参数或返回值的方法。功能接口是一个拥有一个抽象方法并使用 @FunctionalInterface 注解的接口。</p></blockquote><p>Here’s an example of creating a higher-order function that takes a function as an argument:</p><p>下面是一个创建以函数为参数的高阶函数的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span>  </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">BinaryOperator</span>&lt;<span class="title">T</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="function">T <span class="title">apply</span><span class="params">(T t1, T t2)</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">BinaryOperator&lt;T&gt; <span class="title">compose</span><span class="params">(BinaryOperator&lt;T&gt; op1, BinaryOperator&lt;T&gt; op2)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> (x, y) -&gt; op1.apply(op2.apply(x, y), y);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In this example, we define a functional interface called <em>BinaryOperator</em> that has an <em>apply()</em> method that takes two arguments and returns a result. We then define a static method called <em>compose()</em> that takes two BinaryOperator functions as arguments and returns a new BinaryOperator function that composes the two input functions.</p><p>在本例中，我们定义了一个名为 <em>BinaryOperator</em> 的函数接口，它有一个 <em>apply()</em> 方法，该方法接收两个参数并返回一个结果。然后，我们定义了一个名为 <em>compose()</em> 的静态方法，该方法接收两个 <strong>BinaryOperator</strong> 函数作为参数，并返回一个新的 <strong>BinaryOperator</strong> 函数，该函数将两个输入函数合成。</p><p>The <em>compose()</em> method takes two BinaryOperator functions as arguments, op1 and op2. It then returns a new BinaryOperator function that applies op1 to the result of applying op2 to its arguments. The lambda expression (x, y) -&gt; op1.apply(op2.apply(x, y), y) defines the new BinaryOperator function. The first argument of the lambda expression (x) is the result of applying op2 to the original arguments, and the second argument (y) is the second original argument.</p><p><em>compose()</em> 方法将 op1 和 op2 这两个二进制操作符函数作为参数。然后，它返回一个新的二进制操作符函数，该函数将 op1 应用于将 op2 应用于其参数的结果。lambda 表达式<code>(x, y) -&gt; op1.apply(op2.apply(x, y), y)</code> 定义了新的二元运算符函数。lambda 表达式的第一个参数 (x) 是将 op2 应用于原始参数的结果，第二个参数 (y) 是第二个原始参数。</p><p>Here’s an example of using the compose() method to compose two BinaryOperator functions:</p><p>下面是一个使用 <code>compose()</code> 方法组合两个 <code>BinaryOperator</code> 函数的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BinaryOperator&lt;Integer&gt; add = (x, y) -&gt; x + y;  </span><br><span class="line">BinaryOperator&lt;Integer&gt; multiply = (x, y) -&gt; x * y;  </span><br><span class="line"></span><br><span class="line">BinaryOperator&lt;Integer&gt; composed = compose(add, multiply);  </span><br><span class="line"></span><br><span class="line">System.out.println(composed.apply(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// Output: 8</span></span><br></pre></td></tr></table></figure><p>In this example, we define two BinaryOperator functions: add, which adds its two arguments, and multiply, which multiplies its two arguments. We then use the compose() method to create a new BinaryOperator function that first multiplies its arguments and then adds the result. We test the composed function by applying it to the values 2 and 3, which should result in 8.</p><p>在本例中，我们定义了两个 BinaryOperator 函数：add 和 multiply，前者用于将两个参数相加，后者用于将两个参数相乘。然后，我们使用 compose() 方法创建一个新的 BinaryOperator 函数，首先乘以参数，然后将结果相加。我们对组成的函数进行测试，将其应用于数值 2 和 3，结果应为 8。</p><p>Lambda expressions can also be used to create higher-order functions that return functions as results. Here’s an example of creating a higher-order function that returns a UnaryOperator function:</p><p>Lambda 表达式还可用于创建高阶函数，将函数作为结果返回。下面是创建返回 UnaryOperator 函数的高阶函数的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span>  </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UnaryOperator</span>&lt;<span class="title">T</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="function">T <span class="title">apply</span><span class="params">(T t)</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">UnaryOperator&lt;T&gt; <span class="title">addValue</span><span class="params">(T value)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> x -&gt; x + value;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In this example, we define a functional interface called UnaryOperator that has an apply() method that takes one argument and returns a result. We then define a static method called addValue() that takes a value of type T and returns a new UnaryOperator function that adds the value to its argument.</p><p>在本例中，我们定义了一个名为 UnaryOperator 的函数接口，它有一个 apply() 方法，该方法接收一个参数并返回一个结果。然后，我们定义了一个名为 addValue() 的静态方法，该方法接收一个 T 类型的值，并返回一个新的 UnaryOperator 函数，将值添加到其参数中。</p><p>The addValue() method returns a lambda expression that defines the new UnaryOperator function. The lambda expression x -&gt; x + value takes one argument (x) and adds the value to it.</p><p><code>addValue()</code> 方法返回一个 lambda 表达式，该表达式定义了新的 <code>UnaryOperator</code> 函数。lambda 表达式<code>x -&gt; x + value</code> 接收一个参数<code>（x）</code>并将值添加到参数中。</p><p>Here’s an example of using the addValue() method to create a new UnaryOperator function:</p><p>下面是一个使用 <code>addValue()</code> 方法创建新的 <code>UnaryOperator</code> 函数的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UnaryOperator&lt;Integer&gt; add5 = addValue(<span class="number">5</span>);  </span><br><span class="line"></span><br><span class="line">System.out.println(add5.apply(<span class="number">2</span>)); <span class="comment">// Output: 7</span></span><br></pre></td></tr></table></figure><p>In this example, we use the addValue() method to create a new UnaryOperator function that adds 5 to its argument. We assign the result to the add5 variable, which is now a function that adds 5 to its argument. We test the add5 function by applying it to the value 2, which should result in 7.</p><p>在本例中，我们使用 addValue() 方法创建了一个新的 UnaryOperator 函数，将 5 添加到参数中。我们将结果赋值给 add5 变量，它现在是一个将 5 添入其参数的函数。我们对 add5 函数进行测试，将其应用于数值 2，结果应为 7。</p><h2 id="Use-Lambda-expressions-to-create-Closures-使用-Lambda-表达式创建闭包"><a href="#Use-Lambda-expressions-to-create-Closures-使用-Lambda-表达式创建闭包" class="headerlink" title="Use Lambda expressions to create Closures 使用 Lambda 表达式创建闭包"></a>Use Lambda expressions to create Closures 使用 Lambda 表达式创建闭包</h2><p>A closure is a function that can access and modify variables in its enclosing scope. In other words, a closure “closes over” the variables in its enclosing scope and can use them as if they were local variables.</p><p>闭包是一个可以访问和修改其外层作用域中变量的函数。换句话说，闭包 “关闭 “其外层作用域中的变量，并能像使用局部变量一样使用它们。</p><blockquote><p>To create a closure using lambda expressions, you can define a lambda expression that references a variable in its enclosing scope. The lambda expression will then capture the value of the variable at the time the lambda expression is created and use that value whenever it is called.</p><p>要使用 lambda 表达式创建闭包，可以定义一个 lambda 表达式，在其外层作用域中引用一个变量。然后，在创建 lambda 表达式时，lambda 表达式将捕获变量的值，并在调用时使用该值。</p></blockquote><p>Here’s an example of creating a closure using a lambda expression:</p><p>下面是一个使用 lambda 表达式创建闭包的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClosureExample</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">5</span>;  </span><br><span class="line">        Runnable runnable = () -&gt; System.out.println(x);  </span><br><span class="line">        x = <span class="number">10</span>;  </span><br><span class="line">        runnable.run(); <span class="comment">// Output: 10  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In this example, we define a variable x with the value 5. We then define a lambda expression that references x and prints its value. Finally, we change the value of x to 10 and call the lambda expression.</p><p>在本例中，我们定义了一个值为 5 的变量 x。然后，我们定义一个 lambda 表达式，引用 x 并打印其值。最后，我们将 x 的值改为 10 并调用 lambda 表达式。</p><p>When the lambda expression is created, it captures the value of x, which is 5 at the time. When we call the lambda expression, it prints the value of x, which is now 10 because we changed its value after the lambda expression was created. The lambda expression “closes over” the variable x and uses it as if it were a local variable.</p><p>创建 lambda 表达式时，它会捕捉 x 的值，当时的值是 5。当我们调用 lambda 表达式时，它会打印出 x 的值，现在是 10，因为我们在创建 lambda 表达式后更改了它的值。lambda 表达式 “关闭 “了变量 x，并像使用局部变量一样使用它。</p><p>Here’s another example of creating a closure using a lambda expression:</p><p>下面是另一个使用lambda表达式创建闭包的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClosureExample</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);  </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;  </span><br><span class="line">        numbers.forEach(n -&gt; sum += n);  </span><br><span class="line">        System.out.println(sum); <span class="comment">// Output: 15  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In this example, we define a list of integers and a variable sum with the initial value 0. We then use a lambda expression to iterate over the list and add each element to the sum variable. Finally, we print the value of sum.</p><p>在本例中，我们定义了一个整数列表和一个初始值为 0 的变量 sum。然后，我们使用 lambda 表达式遍历列表，并将每个元素添加到 sum 变量中。最后，我们打印 sum 的值。</p><p>The lambda expression “closes over” the variable sum and updates its value each time it is called. This allows us to calculate the sum of the list using a single lambda expression and a single variable, without the need for a separate loop or accumulator.</p><p>lambda 表达式 “关闭 “变量 sum，并在每次调用时更新其值。这样，我们就可以使用单个 lambda 表达式和单个变量计算列表的总和，而无需单独的循环或累加器。</p><h2 id="Use-Lambda-expressions-with-Method-References-在方法引用中使用-Lambda-表达式"><a href="#Use-Lambda-expressions-with-Method-References-在方法引用中使用-Lambda-表达式" class="headerlink" title="Use Lambda expressions with Method References 在方法引用中使用 Lambda 表达式"></a>Use Lambda expressions with Method References 在方法引用中使用 Lambda 表达式</h2><blockquote><p>Method references allow you to refer to an existing method by name instead of defining a new lambda expression. This can make code more concise and readable, especially when working with simple functions.</p><p>方法引用允许你通过通过引用一个现有方法，而不是重新定一个新的函数表达式。这会使得代码更加简洁并且可读，特别是在处理简单函数时。</p></blockquote><p>There are four types of method references in Java:</p><ol><li>Reference to a static method</li><li>Reference to an instance method of a particular object</li><li>Reference to an instance method of an arbitrary object of a particular type</li><li>Reference to a constructor</li></ol><p>Java中有四种方法引用类型：</p><ol><li>静态方法引用</li><li>对特定对象的实例方法的引用</li><li>对特定类型的任意对象的实例方法的引用</li><li>对构造函数的引用</li></ol><blockquote><p>To use a method reference, you can replace the lambda expression with a reference to the method by name. The method reference syntax is similar to the lambda expression syntax, but with the method name and class name instead of the parameter list and arrow.</p><p>使用方法引用，你可以使用引用的方法名称替换Lambda表达式，<strong>方法引用的语法与 lambda 表达式的语法类似</strong>，只是用方法名和类名代替了参数列表和箭头。</p></blockquote><p>Here’s an example of using a method reference to a static method:</p><p>下面是使用静态方法引用的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodReferenceExample</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);  </span><br><span class="line">        numbers.forEach(System.out::println);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In this example, we define a list of integers and use the forEach() method to print each element to the console. Instead of using a lambda expression to define the action, we use a method reference to the static method System.out.println(). The double colon (::) operator is used to indicate that we want to reference a method instead of defining a new lambda expression.</p><p>这个例子中，我们定义一个整型列表，使用<code>forEach()</code>方法打印到控制台，这里不需要使用Lambda表达式，而是直接使用静态方法<code>System.out.println()</code>的方法引用，<strong>双冒号（::）操作符用于表示我们要引用一个方法</strong>，而不是定义一个新的 lambda 表达式</p><p>Here’s an example of using a method reference to an instance method of a particular object:</p><p>下面是一个使用方法引用到特定对象的实例方法的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodReferenceExample</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        List&lt;String&gt; strings = Arrays.asList(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"cherry"</span>);  </span><br><span class="line">        strings.sort(String::compareToIgnoreCase);  </span><br><span class="line">        System.out.println(strings); <span class="comment">// Output: [apple, banana, cherry]  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In this example, we define a list of strings and use the sort() method to sort the list in a case-insensitive manner. Instead of using a lambda expression to define the comparator function, we use a method reference to the compareToIgnoreCase() method of the String class.</p><p>在这个案例中，我们定义字符串列表并且用 <code>sort()</code> 方法以不区分大小写的方式对列表进行排序，我们没有使用 lambda 表达式来定义比较器函数，而是使用了对 String 类的 compareToIgnoreCase() 方法的引用。</p><p>Here’s an example of using a method reference to an instance method of an arbitrary object of a particular type:</p><p>下面是一个示例，说明如何使用方法引用来引用特定类型的任意对象的实例方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodReferenceExample</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        List&lt;String&gt; strings = Arrays.asList(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"cherry"</span>);  </span><br><span class="line">        strings.forEach(String::toUpperCase);  </span><br><span class="line">        System.out.println(strings); <span class="comment">// Output: [apple, banana, cherry]  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here’s an example of using a method reference to a constructor:</p><p>下面是一个将方法引用用于构造函数的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodReferenceExample</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        List&lt;String&gt; strings = Arrays.asList(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"cherry"</span>);  </span><br><span class="line">        List&lt;String&gt; copy = strings.stream()  </span><br><span class="line">                                   .map(String::<span class="keyword">new</span>)  </span><br><span class="line">                                   .collect(Collectors.toList());  </span><br><span class="line">        System.out.println(copy); <span class="comment">// Output: [apple, banana, cherry]  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In this example, we define a list of strings and use the stream() method to create a stream of the strings. We then use the map() method to create a new stream of strings, each of which is created using the String constructor that takes a single argument. This constructor is referenced using a method reference to the String class constructor. Finally, we collect the new stream into a list and print the result.</p><p>在这个例子中，我们定义包含字符串的列表并且使用stream 方法创建一个String 流，接着我们使用map方法创建一个新的String流，每个字符串都是使用String构造函数新创建的，该构造函数只需要一个参数。构造函数使用String类构造函数的方法引用。最后，我们将新的数据流收集到一个列表中并打印结果。</p><h2 id="Use-Lambda-expressions-with-default-methods-in-Interfaces-在接口中使用带有默认方法的-Lambda-表达式"><a href="#Use-Lambda-expressions-with-default-methods-in-Interfaces-在接口中使用带有默认方法的-Lambda-表达式" class="headerlink" title="Use Lambda expressions with default methods in Interfaces 在接口中使用带有默认方法的 Lambda 表达式"></a>Use Lambda expressions with default methods in Interfaces 在接口中使用带有默认方法的 Lambda 表达式</h2><p>Default methods were introduced in Java 8 to allow interfaces to define a default implementation for a method. This allows interfaces to evolve over time without breaking existing implementations.</p><p>Default 默认方法是 Java 8 的新特性之一，主要是允许接口定义默认方法并且实现自己的逻辑，这使得接口可以在不破坏现有实现的情况下随着时间的推移而发展。</p><blockquote><p>Lambda expressions can be used with default methods in interfaces by providing an implementation for the default method in the lambda expression. This allows the lambda expression to be used as an implementation of the interface, even if the interface defines a default method.</p><p><strong>通过在 lambda 表达式中为缺省方法提供实现，lambda 表达式可以与接口中的缺省方法一起使用。</strong> 即使接口定义了缺省方法，也可以将 lambda 表达式用作接口的实现。</p></blockquote><p>Here’s an example of using a lambda expression with a default method in an interface:</p><p>下面是一个使用Lambda表达式和使用静态方法接口的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span>  </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Calculator</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">subtract</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> add(x, -y);  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultMethodExample</span> </span>&#123;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">    Calculator calculator = (x, y) -&gt; x + y;  </span><br><span class="line">    System.out.println(calculator.add(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// Output: 5  </span></span><br><span class="line">    System.out.println(calculator.subtract(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// Output: -1  </span></span><br><span class="line">&#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>In this example, we define a functional interface called Calculator that has an add() method and a default subtract() method. The subtract() method calls the add() method to perform the subtraction.</p><p>上面例子中我们定义<code>Calculator</code>接口和静态方法<code>subtract</code>和接口方法<code>add()</code>,<code>subtract</code>方法内部会调用<code>add()</code>方法实现减法操作。</p><p>We then define a lambda expression that implements the add() method of the Calculator interface. We can use this lambda expression as an implementation of the interface, even though the interface defines a default method.</p><p>我们接着使用Lambda表达式定义一个实现了Calculator 接口的<code>add()</code>方法的实现类，我们可以使用这个lambda表达式作为接口的实现，尽管接口定义了一个<strong>缺省方法</strong>。</p><h2 id="Use-Lambda-expressions-with-the-Optional-Class-与可选类一起使用-Lambda-表达式"><a href="#Use-Lambda-expressions-with-the-Optional-Class-与可选类一起使用-Lambda-表达式" class="headerlink" title="Use Lambda expressions with the Optional Class 与可选类一起使用 Lambda 表达式"></a>Use Lambda expressions with the Optional Class 与可选类一起使用 Lambda 表达式</h2><p>The Optional class was introduced in Java 8 to help prevent null pointer exceptions by providing a container object that may or may not contain a value. Optional provides a set of methods for working with potentially null values in a safer and more concise way.</p><p><strong>Optional</strong> 是Java8 当中引入的类，它提供一个可能包含或者不包含值的容器预防控制针异常，Optional提供了一组方法，用于以更安全、更简洁的方式处理潜在的空值。</p><blockquote><p>Lambda expressions can be used with the Optional class to define custom behavior for cases where a value is present or absent. Optional provides several methods for working with values, including map(), flatMap(), filter(), ifPresent(), and orElse(). These methods can be used with lambda expressions to define custom behavior for these cases.</p><p>Lambda 是可以和 Optional 类一起使用，在值存在或不存在的情况下定义自定义行为，比如map(), flatMap(), filter(), ifPresent(), and orElse() 等方法，可以和 Lambda一起使用</p></blockquote><p>Here’s an example of using a lambda expression with the map() method of the Optional class:</p><p>下面是使用Optional.map() 方法的简单案例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optional = Optional.of(<span class="string">"hello"</span>);  </span><br><span class="line">Optional&lt;Integer&gt; result = optional.map(s -&gt; s.length());  </span><br><span class="line">System.out.println(result.get()); <span class="comment">// Output: 5</span></span><br></pre></td></tr></table></figure><p>In this example, we create an Optional object that contains the string “hello”. We then use the map() method to apply a lambda expression that returns the length of the string. The result of the map() method is an Optional object that contains the result of the lambda expression. We can then use the get() method to retrieve the value from the Optional object and print it to the console.</p><p>例子中创建一个内容为“hello”的Optional对象，接着使用 map() 函数应用一个返回字符串长度的lambda表达式。map() 结果是包含Lambda表达式结果的可选对象，我们使用get() 方法从 Optional 对象中获取值。</p><p>Here’s an example of using a lambda expression with the filter() method of the Optional class:</p><p>下面是使用<code>Optional.filter()</code>的另一个案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optional = Optional.of(<span class="string">"hello"</span>);  </span><br><span class="line">Optional&lt;String&gt; result = optional.filter(s -&gt; s.length() &gt; <span class="number">5</span>);  </span><br><span class="line">System.out.println(result.isPresent()); <span class="comment">// Output: false</span></span><br></pre></td></tr></table></figure><p>In this example, we create an Optional object that contains the string “hello”. We then use the filter() method to apply a lambda expression that filters out strings with length less than or equal to 5. Since “hello” has a length of 5, it does not pass the filter and the resulting Optional object is empty. We can then use the isPresent() method to check whether the Optional object contains a value and print the result to the console.</p><p>例子中创建一个内容为“hello”的Optional对象，接着使用 filter() 函数应用一个<strong>过滤掉</strong>字符串长度小于等于5的值lambda表达式，这时候得到的Optional 对象是为空的，使用 <code>isPresent</code> 方法便可以检查是否包含一个值，最终打印结果到控制台。</p><p>Here’s an example of using a lambda expression with the orElse() method of the Optional class:</p><p>最后是一个<code>orElse()</code>的栗子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optional = Optional.empty();  </span><br><span class="line">String result = optional.orElseGet(() -&gt; <span class="string">"default"</span>);  </span><br><span class="line">System.out.println(result); <span class="comment">// Output: default</span></span><br></pre></td></tr></table></figure><p>In this example, we create an empty Optional object and use the orElseGet() method to provide a default value if the Optional object is empty. We pass a lambda expression that returns the default value “default”. Since the Optional object is empty, the orElseGet() method returns the default value, which we then print to the console.</p><p>这个例子中我们创建一个空的 <strong>Optional</strong> 对象并且使用<code>orElseGet()</code>方法在Optional 内部内容为空的的时候提供一个默认值。我们传递一个 lambda 表达式，返回默认值 “default”。由于 Optional 对象为空，orElseGet() 方法返回默认值，然后我们将其打印到控制台。</p><p><em>Thanks for your Attention! Happy Learning!</em></p><p>感谢您的关注！学习愉快！_</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      Effective Lambda Expressions
    
    </summary>
    
    
      <category term="Java" scheme="https://whitestore.top/categories/Java/"/>
    
    
      <category term="Java" scheme="https://whitestore.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【English】literally 到底是什么意思，为什么美国人老把 literally 挂嘴边？</title>
    <link href="https://whitestore.top/2023/08/10/literallywhy/"/>
    <id>https://whitestore.top/2023/08/10/literallywhy/</id>
    <published>2023-08-10T08:51:14.000Z</published>
    <updated>2023-09-09T00:53:49.932Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>事情的起因是《Who moved my cheese》这本书的一段话：</p><blockquote><p>But when the Cheese story was shared with <strong>literally</strong> everyone in our organization ….</p></blockquote><p>但是，当《奶酪》的故事在我们组织的每个人中流传开来时…. 这里有一个【literally】单词经过查阅之后，发现它的含义基本上都是”按字面上“，这种说法显然说不通，所以它有另一种含义，那就是 <strong>真的</strong>。</p><p>渣渣英语的我，对于这段话的理解是强调<strong>事情本身是事实，实际发生的</strong>，抱着验证的疑问，这里去翻了翻知乎的说法：</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzYyNTE4MDEx" title="https://www.zhihu.com/question/62518011">literally 到底是什么意思，为什么美国人老把 literally 挂嘴边？ - 知乎 (zhihu.com)<i class="fa fa-external-link"></i></span></p><blockquote><p>关于这个单词的讨论挺有意思的</p></blockquote><p>下面是个人对于【literally】单词含义这种奇怪的变化做一个归档整理。</p><a id="more"></a><h1 id="原文含义"><a href="#原文含义" class="headerlink" title="原文含义"></a>原文含义</h1><ol><li>【真的】【简直的】</li><li>【按字面】；【字面上】</li></ol><p>按照中文思维，这个词确实用在一些介绍中：</p><blockquote><p>Meiguo literllay means beautiful conutry</p><ul><li>美国，字面上的意思是「有美丽风景线的国家」。</li></ul></blockquote><h1 id="口语中的各种用法"><a href="#口语中的各种用法" class="headerlink" title="口语中的各种用法"></a>口语中的各种用法</h1><p>1）简直是…</p><p>2）实在是..</p><p>3）真的是…</p><p>4）的确是…</p><h1 id="如何理解"><a href="#如何理解" class="headerlink" title="如何理解"></a>如何理解</h1><p><strong>通俗一点就是「字面上说的这样，没有夸张和虚假成分」= I mean what I said。</strong></p><p>换一种理解就是：「名副其实的」， live up to its name。</p><p><strong>名副其实</strong>，就是literally= really。</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><h2 id="例1：There-are-literally-100-people-lined-up-outside-the-store"><a href="#例1：There-are-literally-100-people-lined-up-outside-the-store" class="headerlink" title="例1：There are literally 100 people lined up outside the store"></a>例1：There are <strong>literally</strong> 100 people lined up outside the store</h2><p>足足有100个人在外面排队</p><h2 id="例2：-She-is-literally-the-woman-i-love-the-most-in-my-life"><a href="#例2：-She-is-literally-the-woman-i-love-the-most-in-my-life" class="headerlink" title="例2： She is literally the woman i love the most in my life"></a>例2： She is <strong>literally</strong> the woman i love the most in my life</h2><p>她真的是我这辈子最爱的人。</p><h2 id="例3：I-literally-stayed-at-home-and-watched-Netflix-all-day-yesterday"><a href="#例3：I-literally-stayed-at-home-and-watched-Netflix-all-day-yesterday" class="headerlink" title="例3：I literally stayed at home and watched Netflix all day yesterday."></a>例3：I literally stayed at home and watched Netflix all day yesterday.</h2><p>昨天我在家呆着看了一天的Netflix。这件事确实发生了，literally表示的是一种<strong>语气加强</strong>，或者是你对这件事的<strong>一种惊讶、不可置信。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Literally 的用法主要分为：</p><ul><li>①表“字面上的”意义；</li><li>②表强调。</li></ul><p>这个常见于出现会让我们 <strong>”really？“</strong> 的场景。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      literally 到底是什么意思
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://whitestore.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://whitestore.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【Java】Exploring the New HTTP Client in Java</title>
    <link href="https://whitestore.top/2023/08/10/httpclientjdk11/"/>
    <id>https://whitestore.top/2023/08/10/httpclientjdk11/</id>
    <published>2023-08-10T08:49:34.000Z</published>
    <updated>2023-09-09T00:53:49.934Z</updated>
    
    <content type="html"><![CDATA[<h1 id="探索-Java-中的新-HTTP-客户端"><a href="#探索-Java-中的新-HTTP-客户端" class="headerlink" title="探索 Java 中的新 HTTP 客户端"></a>探索 Java 中的新 HTTP 客户端</h1><h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFlbGR1bmcuY29tL2phdmEtOS1odHRwLWNsaWVudA==" title="https://www.baeldung.com/java-9-http-client">https://www.baeldung.com/java-9-http-client<i class="fa fa-external-link"></i></span></p><h2 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a><a href="https://www.baeldung.com/java-9-http-client#introduction" target="_blank" rel="noopener"><strong>1. Overview</strong></a></h2><p>In this tutorial, we’ll explore Java 11’s standardization of <strong>HTTP client API that implements HTTP/2 and Web Socket.</strong></p><p>本文讲讨论Java 11 的新HTTP客户端API是如何实现 HTTP/2 和 WebSocket的。</p><p>It aims to replace the legacy <em><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vZW4vamF2YS9qYXZhc2UvMTcvZG9jcy9hcGkvamF2YS5iYXNlL2phdmEvbmV0L0h0dHBVUkxDb25uZWN0aW9uLmh0bWw=" title="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/net/HttpURLConnection.html">HttpUrlConnection<i class="fa fa-external-link"></i></span></em> class that has been present in the JDK since the very early years of Java.</p><p>它旨在取代自 Java 诞生之初就存在于 JDK 中的传统<em><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vZW4vamF2YS9qYXZhc2UvMTcvZG9jcy9hcGkvamF2YS5iYXNlL2phdmEvbmV0L0h0dHBVUkxDb25uZWN0aW9uLmh0bWw=" title="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/net/HttpURLConnection.html">HttpUrlConnection<i class="fa fa-external-link"></i></span></em> 类。</p><a id="more"></a><blockquote><p>It aims to …. 旨在</p></blockquote><p>Until very recently, Java provided only the <em>HttpURLConnection</em> API, which is low-level and isn’t known for being feature-rich and user-friendly.</p><p>在旧版本中，Java 提供 <em>HttpURLConnection</em> API，该 API 是低级的，并不以功能丰富和用户友好而著称。</p><p>Therefore, some widely used third-party libraries were commonly used, such as <span class="exturl" data-url="aHR0cHM6Ly9oYy5hcGFjaGUub3JnL2h0dHBjb21wb25lbnRzLWNsaWVudC1nYS8=" title="https://hc.apache.org/httpcomponents-client-ga/">Apache HttpClient<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly9lY2xpcHNlLmRldi9qZXR0eS9kb2N1bWVudGF0aW9uL2pldHR5LTkvaW5kZXguaHRtbCNodHRwLWNsaWVudC1hcGk=" title="https://eclipse.dev/jetty/documentation/jetty-9/index.html#http-client-api">Jetty<i class="fa fa-external-link"></i></span> and Spring’s <span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFlbGR1bmcuY29tL3Jlc3QtdGVtcGxhdGU=" title="https://www.baeldung.com/rest-template">RestTemplate<i class="fa fa-external-link"></i></span>.</p><p>所以，我们通常都会使用 类似   <span class="exturl" data-url="aHR0cHM6Ly9oYy5hcGFjaGUub3JnL2h0dHBjb21wb25lbnRzLWNsaWVudC1nYS8=" title="https://hc.apache.org/httpcomponents-client-ga/">Apache HttpClient<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly9lY2xpcHNlLmRldi9qZXR0eS9kb2N1bWVudGF0aW9uL2pldHR5LTkvaW5kZXguaHRtbCNodHRwLWNsaWVudC1hcGk=" title="https://eclipse.dev/jetty/documentation/jetty-9/index.html#http-client-api">Jetty<i class="fa fa-external-link"></i></span> 或者 Spring’s <span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFlbGR1bmcuY29tL3Jlc3QtdGVtcGxhdGU=" title="https://www.baeldung.com/rest-template">RestTemplate<i class="fa fa-external-link"></i></span> 这样的第三方库作为替代。</p><h2 id="Further-reading-（相关阅读）"><a href="#Further-reading-（相关阅读）" class="headerlink" title="Further reading:（相关阅读）"></a>Further reading:（相关阅读）</h2><h2 id="Posting-with-Java-HttpClient"><a href="#Posting-with-Java-HttpClient" class="headerlink" title="Posting with Java HttpClient"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFlbGR1bmcuY29tL2phdmEtaHR0cGNsaWVudC1wb3N0" title="https://www.baeldung.com/java-httpclient-post">Posting with Java HttpClient<i class="fa fa-external-link"></i></span></h2><p>From Java 9 onwards, the new <em>HttpClient</em> API provides both a synchronous and asynchronous modern web client. We look at how it can be used to make requests.</p><p>从 Java 9 开始，新的 <em>HttpClient</em> API 提供了<strong>同步</strong>和<strong>异步</strong>的现代 Web 客户端。我们来看看如何使用它来发出请求。</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFlbGR1bmcuY29tL2phdmEtaHR0cGNsaWVudC1wb3N0" title="https://www.baeldung.com/java-httpclient-post">Read more<i class="fa fa-external-link"></i></span> →</p><h2 id="Java-HttpClient-With-SSL"><a href="#Java-HttpClient-With-SSL" class="headerlink" title="Java HttpClient With SSL"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFlbGR1bmcuY29tL2phdmEtaHR0cGNsaWVudC1zc2w=" title="https://www.baeldung.com/java-httpclient-ssl">Java HttpClient With SSL<i class="fa fa-external-link"></i></span></h2><p>Learn how to use the Java HttpClient to connect to HTTPS URLs and also find out how to bypass certificate verification in non-production environments.</p><p>了解如何使用 Java HttpClient 连接 HTTPS URL，以及如何在非生产环境中绕过证书验证。</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFlbGR1bmcuY29tL2phdmEtaHR0cGNsaWVudC1zc2w=" title="https://www.baeldung.com/java-httpclient-ssl">Read more<i class="fa fa-external-link"></i></span> →</p><h2 id="Adding-Parameters-to-Java-HttpClient-Requests"><a href="#Adding-Parameters-to-Java-HttpClient-Requests" class="headerlink" title="Adding Parameters to Java HttpClient Requests"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFlbGR1bmcuY29tL2phdmEtaHR0cGNsaWVudC1yZXF1ZXN0LXBhcmFtZXRlcnM=" title="https://www.baeldung.com/java-httpclient-request-parameters">Adding Parameters to Java HttpClient Requests<i class="fa fa-external-link"></i></span></h2><p>Different examples of HTTPClient core Java.</p><p>HTTPClient core Java 的不同示例。</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFlbGR1bmcuY29tL2phdmEtaHR0cGNsaWVudC1yZXF1ZXN0LXBhcmFtZXRlcnM=" title="https://www.baeldung.com/java-httpclient-request-parameters">Read more<i class="fa fa-external-link"></i></span> →</p><h2 id="2-Background"><a href="#2-Background" class="headerlink" title="2. Background"></a><a href="https://www.baeldung.com/java-9-http-client#introduction-1" target="_blank" rel="noopener"><strong>2. Background</strong></a></h2><p>The change was implemented as a part of JEP 321.</p><p>所有的改变均实现自<strong>JEP 321</strong>。 </p><h3 id="2-1-Major-Changes-as-Part-of-JEP-321"><a href="#2-1-Major-Changes-as-Part-of-JEP-321" class="headerlink" title="2.1. Major Changes as Part of JEP 321"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFlbGR1bmcuY29tL2phdmEtOS1odHRwLWNsaWVudCMxLW1ham9yLWNoYW5nZXMtYXMtcGFydC1vZi1qZXAtMzIx" title="https://www.baeldung.com/java-9-http-client#1-major-changes-as-part-of-jep-321">2.1. Major Changes as Part of JEP 321<i class="fa fa-external-link"></i></span></h3><ol><li>The incubated HTTP API from Java 9 is now officially incorporated into the Java SE API. The new <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vZW4vamF2YS9qYXZhc2UvMTcvZG9jcy9hcGkvamF2YS5uZXQuaHR0cC9qYXZhL25ldC9odHRwL3BhY2thZ2Utc3VtbWFyeS5odG1s" title="https://docs.oracle.com/en/java/javase/17/docs/api/java.net.http/java/net/http/package-summary.html">HTTP APIs<i class="fa fa-external-link"></i></span> can be found in <strong>java.net.HTTP.*</strong></li></ol><p>Java 9 中孵化的 HTTP API 现已正式纳入 Java SE API。新的 <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vZW4vamF2YS9qYXZhc2UvMTcvZG9jcy9hcGkvamF2YS5uZXQuaHR0cC9qYXZhL25ldC9odHRwL3BhY2thZ2Utc3VtbWFyeS5odG1s" title="https://docs.oracle.com/en/java/javase/17/docs/api/java.net.http/java/net/http/package-summary.html">HTTP APIs<i class="fa fa-external-link"></i></span> 可在 <strong>java.net.HTTP.</strong> 中找到。</p><ol start="2"><li>The newer version of the HTTP protocol is designed to improve the overall performance of sending requests by a client and receiving responses from the server. This is achieved by introducing a number of changes such as stream multiplexing, header compression and push promises.</li></ol><p>较新版本的 HTTP 协议旨在提高客户端发送请求和服务器接收响应的整体性能。这是通过引入流<strong>多路复用</strong>、报头压缩和推送承诺来实现的。</p><ol start="3"><li>As of Java 11, <strong>the API is now fully asynchronous (the previous HTTP/1.1 implementation was blocking).</strong> Asynchronous calls are implemented using <em>CompletableFuture</em>.The <em>CompletableFuture</em> implementation takes care of applying each stage once the previous one has finished, so this whole flow is asynchronous.</li></ol><p>从 Java 11 开始，<strong>应用程序接口现在是完全异步的（以前的 HTTP/1.1 实现是阻塞的）。</strong> 异步调用是使用 <em>CompletableFuture</em> 实现的。</p><ol start="4"><li>The new HTTP client API provides a standard way to perform HTTP network operations with support for modern Web features such as HTTP/2, without the need to add third-party dependencies.</li></ol><p>新的 HTTP 客户端 API 提供了执行 HTTP 网络操作的标准方法，支持 HTTP/2 等现代网络功能，无需添加第三方依赖性。</p><ol start="5"><li>The new APIs provide native support for HTTP 1.1/2 WebSocket. The core classes and interface providing the core functionality include:</li></ol><p>新的应用程序接口为 <code>HTTP 1.1/2</code> WebSocket 提供本地支持。提供核心功能的核心类和接口包括</p><ul><li><p>The <em>HttpClient</em> class, <em>java.net.http.HttpClient</em></p></li><li><p>The <em>HttpRequest</em> class, <em>java.net.http.HttpRequest</em></p></li><li><p>The <em>HttpResponse</em>&lt; T &gt; interface, <em>java.net.http.HttpResponse</em></p></li><li><p>The <em>WebSocket</em> interface, <em>java.net.http.WebSocket</em></p></li><li><p><em>HttpClient</em> 类， <em>java.net.http.HttpClient</em> 。</p></li><li><p><em>HttpRequest</em> 类，<em>java.net.http.HttpRequest</em></p></li><li><p>接口<em>HttpResponse</em>&lt; T &gt;,  <em>java.net.http.HttpResponse</em></p></li><li><p><em>WebSocket</em> 接口，<em>java.net.http.WebSocket</em> &lt; T &gt;。</p><h3 id="2-2-Problems-With-the-Pre-Java-11-HTTP-Client"><a href="#2-2-Problems-With-the-Pre-Java-11-HTTP-Client" class="headerlink" title="2.2. Problems With the Pre-Java 11 HTTP Client"></a><a href="https://www.baeldung.com/java-9-http-client#2-problems-with-the-pre-java-11-http-client" target="_blank" rel="noopener"><strong>2.2. Problems With the Pre-Java 11 HTTP Client</strong></a></h3></li></ul><p>The existing <em>HttpURLConnection</em> API and its implementation had numerous problems:</p><p>现有的 <em>HttpURLConnection</em> API 及其实现存在许多问题：</p><ul><li><p>URLConnection API was designed with multiple protocols that are now no longer functioning (FTP, gopher, etc.).</p></li><li><p>The API predates HTTP/1.1 and is too abstract.</p></li><li><p>It works in blocking mode only (i.e., one thread per request/response).</p></li><li><p>It is very hard to maintain.</p></li><li><p>URLConnection API 在设计时使用了多个现已失效的协议（FTP、gopher 等）。</p></li><li><p>该 API 早于 HTTP/1.1，过于抽象。</p></li><li><p>只能在阻塞模式下工作（即每个请求/响应只有一个线程）。</p></li><li><p>很难维护。</p><h2 id="3-HTTP-Client-API-Overview"><a href="#3-HTTP-Client-API-Overview" class="headerlink" title="3. HTTP Client API Overview"></a><a href="https://www.baeldung.com/java-9-http-client#api" target="_blank" rel="noopener"><strong>3. HTTP Client API Overview</strong></a></h2></li></ul><p>Unlike <em>HttpURLConnection</em>, HTTP Client provides synchronous and asynchronous request mechanisms.</p><p>与 <em>HttpURLConnection</em> 不同，HTTP 客户端提供同步和异步请求机制。</p><p>The API consists of three core classes:</p><p>API 由三个核心类组成：</p><ul><li><p><em>HttpRequest</em> represents the request to be sent via the <em>HttpClient</em>.</p></li><li><p><em>HttpClient</em> behaves as a container for configuration information common to multiple requests.</p></li><li><p><em>HttpResponse</em> represents the result of an <em>HttpRequest</em> call.</p></li><li><p><em>HttpRequest</em> 表示要通过 <em>HttpClient</em> 发送的请求。</p></li><li><p><em>HttpClient</em> 是多个请求所共有的配置信息的容器。</p></li><li><p><em>HttpResponse</em> 表示 <em>HttpRequest</em> 调用的结果。</p></li></ul><p>We’ll examine each of them in more details in the following sections. First, let’s focus on a request.</p><p>我们将在下面的章节中对它们逐一进行详细介绍。首先，我们来关注一个请求。</p><h2 id="4-HttpRequest"><a href="#4-HttpRequest" class="headerlink" title="4. HttpRequest"></a><a href="https://www.baeldung.com/java-9-http-client#requests" target="_blank" rel="noopener"><strong>4. <em>HttpRequest</em></strong></a></h2><p><em>HttpRequest</em> is an object that represents the request we want to send. New instances can be created using <em>HttpRequest.Builder.</em></p><p><em>HttpRequest</em> 是一个对象，代表我们要发送的请求。可以使用 <em>HttpRequest.Builder.</em> 创建新实例。</p><p>We can get it by calling <em>HttpRequest.newBuilder()</em>. <em>Builder</em> class provides a bunch of methods that we can use to configure our request.</p><p>我们可以通过调用 <em>HttpRequest.newBuilder()</em> 来获取它。 <em>Builder</em> 类提供了许多方法，我们可以用它们来配置我们的请求。</p><p>We’ll cover the most important ones.</p><p>我们将介绍最重要的几项。</p><p>Note: In JDK 16, there is a new <em>HttpRequest.newBuilder(HttpRequest request, BiPredicate&lt;String,​String&gt; filter)</em> method, which creates a <em>Builder</em> whose initial state is copied from an existing <em>HttpRequest</em>.</p><blockquote><p>注意：在JDK16， 有一个新的 <em>HttpRequest.newBuilder(HttpRequest request, BiPredicate&lt;String,String&gt; filter)</em>  方法，用于创建一个_Builder_，其初始状态是从现有的_HttpRequest_复制而来。</p></blockquote><p>This builder can be used to build an <em>HttpRequest</em>, equivalent to the original, while allowing amendment of the request state prior to construction, for example, removing headers:</p><p>该构建器可用于构建一个 _HttpRequest_，等同于原始请求，同时允许在构建之前修改请求状态，例如删除头信息：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HttpRequest.newBuilder(request, <span class="function"><span class="params">(name, value)</span> -&gt;</span> !name.equalsIgnoreCase(<span class="string">"Foo-Bar"</span>))</span><br></pre></td></tr></table></figure><h3 id="4-1-Setting-URI"><a href="#4-1-Setting-URI" class="headerlink" title="4.1. Setting URI"></a><a href="https://www.baeldung.com/java-9-http-client#1-setting-uri" target="_blank" rel="noopener"><strong>4.1. Setting <em>URI</em></strong></a></h3><p>The first thing we have to do when creating a request is to provide the URL.</p><p>创建请求时，我们要做的第一件事就是提供 URL。</p><p>We can do that in two ways — using the constructor for <em>Builder</em> with <em>URI</em> parameter or calling method <em>uri(URI)</em> on the <em>Builder</em> instance:</p><p>我们可以通过两种方法实现这一目的：使用 <em>URI</em> 参数的 <em>Builder</em> 构造函数，或者调用 <em>Builder</em> 实例上的 <em>uri(URI)</em> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HttpRequest.newBuilder(<span class="keyword">new</span> URI(<span class="string">"https://postman-echo.com/get"</span>))</span><br><span class="line"> </span><br><span class="line">HttpRequest.newBuilder()</span><br><span class="line">  .uri(<span class="keyword">new</span> URI(<span class="string">"https://postman-echo.com/get"</span>))</span><br></pre></td></tr></table></figure><p>The last thing we have to configure to create a basic request is an HTTP method.</p><p>创建基本请求的最后一项配置是 HTTP 方法。</p><h3 id="4-2-Specifying-the-HTTP-Method"><a href="#4-2-Specifying-the-HTTP-Method" class="headerlink" title="4.2. Specifying the HTTP Method"></a><a href="https://www.baeldung.com/java-9-http-client#2-specifying-the-http-method" target="_blank" rel="noopener"><strong>4.2. Specifying the HTTP Method</strong></a></h3><p>We can define the HTTP method that our request will use by calling one of the methods from <em>Builder</em>:</p><p>我们可以通过调用 <em>Builder</em> 中的一个方法来定义请求将使用的 HTTP 方法：</p><ul><li><em>GET()</em></li><li><em>POST(BodyPublisher body)</em></li><li><em>PUT(BodyPublisher body)</em></li><li><em>DELETE()</em></li></ul><p>We’ll cover <em>BodyPublisher</em> in detail, later.</p><p>稍后我们将详细介绍 <em>BodyPublisher</em> 的内容。</p><p>Now let’s just create <strong>a very simple GET request example</strong>:</p><p>现在，让我们创建<strong>个非常简单的 GET 请求示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HttpRequest request = HttpRequest.newBuilder()</span><br><span class="line">  .uri(<span class="keyword">new</span> URI(<span class="string">"https://postman-echo.com/get"</span>))</span><br><span class="line">  .GET()</span><br><span class="line">  .build();</span><br></pre></td></tr></table></figure><p>This request has all parameters required by <em>HttpClient</em>.</p><p>该请求包含 <em>HttpClient</em> 要求的所有参数。</p><p>However, we sometimes need to add additional parameters to our request. Here are some important ones:</p><p>不过，有时我们需要在请求中添加其他参数。下面是一些重要的参数：</p><ul><li><p>The version of the HTTP protocol</p></li><li><p>Headers</p></li><li><p>A timeout</p></li><li><p>HTTP 协议的版本</p></li><li><p>标题</p></li><li><p>超时</p><h3 id="4-3-Setting-HTTP-Protocol-Version"><a href="#4-3-Setting-HTTP-Protocol-Version" class="headerlink" title="4.3. Setting HTTP Protocol Version"></a><a href="https://www.baeldung.com/java-9-http-client#3-setting-http-protocol-version" target="_blank" rel="noopener"><strong>4.3. Setting HTTP Protocol Version</strong></a></h3></li></ul><p>The API fully leverages the HTTP/2 protocol and uses it by default, but we can define which version of the protocol we want to use:</p><p>该应用程序接口完全利用 HTTP/2 协议，并默认使用该协议，但我们可以定义要使用的协议版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HttpRequest request = HttpRequest.newBuilder()</span><br><span class="line">  .uri(<span class="keyword">new</span> URI(<span class="string">"https://postman-echo.com/get"</span>))</span><br><span class="line">  .version(HttpClient.Version.HTTP_2)</span><br><span class="line">  .GET()</span><br><span class="line">  .build();</span><br></pre></td></tr></table></figure><p><strong>Important to mention here is that the client will fall back to, e.g., HTTP/1.1 if HTTP/2 isn’t supported.</strong></p><p><strong>这里需要指出的是，如果不支持 HTTP/2，客户端将退回到 HTTP/1.1 等协议。</strong></p><h3 id="4-4-Setting-Headers"><a href="#4-4-Setting-Headers" class="headerlink" title="4.4. Setting Headers"></a><a href="https://www.baeldung.com/java-9-http-client#4-setting-headers" target="_blank" rel="noopener"><strong>4.4. Setting Headers</strong></a></h3><p>In case we want to add additional headers to our request, we can use the provided builder methods.</p><p>如果我们想在请求中添加其他标头，可以使用提供的构建器方法。</p><p>We can do that by either passing all headers as key-value pairs to the <em>headers()</em> method or by using <em>header()</em> method for the single key-value header:</p><p>为此，我们可以将所有标头作为键值对传递给 <em>headers()</em> 方法，或者使用 <em>header()</em> 方法来处理单个键值标头：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HttpRequest request = HttpRequest.newBuilder()</span><br><span class="line">  .uri(<span class="keyword">new</span> URI(<span class="string">"https://postman-echo.com/get"</span>))</span><br><span class="line">  .headers(<span class="string">"key1"</span>, <span class="string">"value1"</span>, <span class="string">"key2"</span>, <span class="string">"value2"</span>)</span><br><span class="line">  .GET()</span><br><span class="line">  .build();</span><br><span class="line"></span><br><span class="line">HttpRequest request2 = HttpRequest.newBuilder()</span><br><span class="line">  .uri(<span class="keyword">new</span> URI(<span class="string">"https://postman-echo.com/get"</span>))</span><br><span class="line">  .header(<span class="string">"key1"</span>, <span class="string">"value1"</span>)</span><br><span class="line">  .header(<span class="string">"key2"</span>, <span class="string">"value2"</span>)</span><br><span class="line">  .GET()</span><br><span class="line">  .build();</span><br></pre></td></tr></table></figure><p>The last useful method we can use to customize our request is a <em>timeout()</em>.</p><p>我们可以用来定制请求的最后一个有用方法是 <em>timeout()</em> 。</p><h3 id="4-5-Setting-a-Timeout"><a href="#4-5-Setting-a-Timeout" class="headerlink" title="4.5. Setting a Timeout"></a><a href="https://www.baeldung.com/java-9-http-client#5-setting-a-timeout" target="_blank" rel="noopener"><strong>4.5. Setting a Timeout</strong></a></h3><p>Let’s now define the amount of time we want to wait for a response.</p><p>现在我们来定义等待响应的时间。</p><p>If the set time expires, a <em>HttpTimeoutException</em> will be thrown. The default timeout is set to infinity.</p><p>如果设定的时间已过，就会抛出一个 <em>HttpTimeoutException</em> 异常。默认超时设置为无穷大。</p><p>The timeout can be set with the <em>Duration</em> object by calling method <em>timeout()</em> on the builder instance:</p><p>可以通过调用构建器实例上的 <em>timeout()</em> 方法，使用 <em>Duration</em> 对象设置超时时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HttpRequest request = HttpRequest.newBuilder()</span><br><span class="line">  .uri(<span class="keyword">new</span> URI(<span class="string">"https://postman-echo.com/get"</span>))</span><br><span class="line">  .timeout(Duration.of(<span class="number">10</span>, SECONDS))</span><br><span class="line">  .GET()</span><br><span class="line">  .build();</span><br></pre></td></tr></table></figure><h2 id="5-Setting-a-Request-Body"><a href="#5-Setting-a-Request-Body" class="headerlink" title="5. Setting a Request Body"></a><a href="https://www.baeldung.com/java-9-http-client#setting-a-request-body" target="_blank" rel="noopener"><strong>5. Setting a Request Body</strong></a></h2><p>We can add a body to a request by using the request builder methods: <em>POST(BodyPublisher body)</em>, <em>PUT(BodyPublisher body)</em> and <em>DELETE()</em>.</p><p>我们可以使用请求生成器方法为请求添加正文： <em>POST(BodyPublisher body)<em>、</em>PUT(BodyPublisher body)</em>  和 _DELETE()_。</p><p>The new API provides a number of <em>BodyPublisher</em> implementations out-of-the-box that simplify passing the request body:</p><p>新的 API 提供了许多开箱即用的 <em>BodyPublisher</em> 实现，简化了请求正文的传递：</p><ul><li><p><em>StringProcessor</em> – reads body from a <em>String</em>, created with <em>HttpRequest.BodyPublishers.ofString</em></p></li><li><p><em>InputStreamProcessor</em> – reads body from an <em>InputStream</em>, created with <em>HttpRequest.BodyPublishers.ofInputStream</em></p></li><li><p><em>ByteArrayProcessor</em> – reads body from a byte array, created with <em>HttpRequest.BodyPublishers.ofByteArray</em></p></li><li><p><em>FileProcessor</em> – reads body from a file at the given path, created with <em>HttpRequest.BodyPublishers.ofFile</em></p></li><li><p><em>StringProcessor</em> - 从 <em>String</em> 中读取正文，使用 <em>HttpRequest.BodyPublishers.ofString</em> 创建。</p></li><li><p><em>InputStreamProcessor</em> - 从 <em>InputStream</em> 中读取正文，使用 <em>HttpRequest.BodyPublishers.ofInputStream</em> 创建。</p></li><li><p><em>ByteArrayProcessor</em> - 从字节数组中读取正文，使用 <em>HttpRequest.BodyPublishers.ofByteArray</em> 创建。</p></li><li><p><em>FileProcessor</em> - 从指定路径的文件中读取正文，使用 <em>HttpRequest.BodyPublishers.ofFile</em> 创建。</p></li></ul><p>In case we don’t need a body, we can simply pass in an <em>HttpRequest.BodyPublishers.__noBody()</em>:</p><p>如果不需要正文，我们只需传入 <em>HttpRequest.BodyPublishers. __noBody()</em>  即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HttpRequest request = HttpRequest.newBuilder()</span><br><span class="line">  .uri(<span class="keyword">new</span> URI(<span class="string">"https://postman-echo.com/post"</span>))</span><br><span class="line">  .POST(HttpRequest.BodyPublishers.noBody())</span><br><span class="line">  .build();</span><br></pre></td></tr></table></figure><p>Note: In JDK 16, there’s a new <em>HttpRequest.BodyPublishers.concat(BodyPublisher…)</em> method that helps us building a request body from the concatenation of the request bodies published by a sequence of publishers. The request body published by a <em>concatenation publisher</em> is logically equivalent to the request body that would have been published by concatenating all the bytes of each publisher in sequence.</p><blockquote><p>注：在 JDK 16 中，有一个新的 <em>HttpRequest.BodyPublishers.concat(BodyPublisher…)</em> 方法，可以帮助我们通过串联一系列发布者发布的请求体来构建请求体。由 <em>concatenation 发布者</em> 发布的请求正文在逻辑上等同于按顺序连接每个发布者的所有字节后发布的请求正文。</p></blockquote><h3 id="5-1-StringBodyPublisher"><a href="#5-1-StringBodyPublisher" class="headerlink" title="5.1. StringBodyPublisher"></a><a href="https://www.baeldung.com/java-9-http-client#1-stringbodypublisher" target="_blank" rel="noopener"><strong>5.1. <em>StringBodyPublisher</em></strong></a></h3><p>Setting a request body with any <em>BodyPublishers</em> implementation is very simple and intuitive.</p><p>使用任何 <em>BodyPublishers</em> 实现来设置请求正文都非常简单直观。</p><p>For example, if we want to pass a simple <em>String</em> as a body, we can use <em>StringBodyPublishers</em>.</p><p>例如，如果我们想传递一个简单的 <em>String</em> 作为正文，我们可以使用 _StringBodyPublishers_。</p><p>As we already mentioned, this object can be created with a factory method <em>ofString()</em> — it takes just a <em>String</em> object as an argument and creates a body from it:</p><p>正如我们已经提到的，可以使用工厂方法 <em>ofString()</em> 创建该对象 – 该方法只接受一个 <em>String</em> 对象作为参数，并从中创建一个正文：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HttpRequest request = HttpRequest.newBuilder()</span><br><span class="line">  .uri(<span class="keyword">new</span> URI(<span class="string">"https://postman-echo.com/post"</span>))</span><br><span class="line">  .headers(<span class="string">"Content-Type"</span>, <span class="string">"text/plain;charset=UTF-8"</span>)</span><br><span class="line">  .POST(HttpRequest.BodyPublishers.ofString(<span class="string">"Sample request body"</span>))</span><br><span class="line">  .build();</span><br></pre></td></tr></table></figure><h3 id="5-2-InputStreamBodyPublisher"><a href="#5-2-InputStreamBodyPublisher" class="headerlink" title="5.2. InputStreamBodyPublisher"></a><a href="https://www.baeldung.com/java-9-http-client#2-inputstreambodypublisher" target="_blank" rel="noopener"><strong>5.2. <em>InputStreamBodyPublisher</em></strong></a></h3><p>To do that, the <em>InputStream</em> has to be passed as a <em>Supplier</em> (to make its creation lazy), so it’s a little bit different than <em>StringBodyPublishers</em>.</p><p>要做到这一点，必须将 <em>InputStream</em> 作为 <em>Supplier</em> 传递（变为懒加载），因此它与 <em>StringBodyPublishers</em> 有点不同。</p><p>However, this is also quite straightforward:</p><p>不过，这也很简单明了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] sampleData = <span class="string">"Sample request body"</span>.getBytes();</span><br><span class="line">HttpRequest request = HttpRequest.newBuilder()</span><br><span class="line">  .uri(<span class="keyword">new</span> URI(<span class="string">"https://postman-echo.com/post"</span>))</span><br><span class="line">  .headers(<span class="string">"Content-Type"</span>, <span class="string">"text/plain;charset=UTF-8"</span>)</span><br><span class="line">  .POST(HttpRequest.BodyPublishers</span><br><span class="line">   .ofInputStream(() -&gt; <span class="keyword">new</span> ByteArrayInputStream(sampleData)))</span><br><span class="line">  .build();</span><br></pre></td></tr></table></figure><p>Notice how we used a simple <em>ByteArrayInputStream</em> here. Of course, that can be any <em>InputStream</em> implementation.</p><p>请注意我们在这里使用了一个简单的 <em>ByteArrayInputStream</em> 。当然，这可以是任何 <em>InputStream</em> 的实现。</p><h3 id="5-3-ByteArrayProcessor"><a href="#5-3-ByteArrayProcessor" class="headerlink" title="5.3. ByteArrayProcessor"></a><a href="https://www.baeldung.com/java-9-http-client#3-bytearrayprocessor" target="_blank" rel="noopener"><strong>5.3. <em>ByteArrayProcessor</em></strong></a></h3><p>We can also use <em>ByteArrayProcessor</em> and pass an array of bytes as the parameter:</p><p>我们还可以使用 <em>ByteArrayProcessor</em> 并将字节数组作为参数传递：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] sampleData = <span class="string">"Sample request body"</span>.getBytes();</span><br><span class="line">HttpRequest request = HttpRequest.newBuilder()</span><br><span class="line">  .uri(<span class="keyword">new</span> URI(<span class="string">"https://postman-echo.com/post"</span>))</span><br><span class="line">  .headers(<span class="string">"Content-Type"</span>, <span class="string">"text/plain;charset=UTF-8"</span>)</span><br><span class="line">  .POST(HttpRequest.BodyPublishers.ofByteArray(sampleData))</span><br><span class="line">  .build();</span><br></pre></td></tr></table></figure><h3 id="5-4-FileProcessor"><a href="#5-4-FileProcessor" class="headerlink" title="5.4. FileProcessor"></a><a href="https://www.baeldung.com/java-9-http-client#4-fileprocessor" target="_blank" rel="noopener"><strong>5.4. <em>FileProcessor</em></strong></a></h3><p>To work with a File, we can make use of the provided <em>FileProcessor</em>.、</p><p>要处理文件，我们可以使用所提供的 _FileProcessor_。</p><p>Its factory method takes a path to the file as a parameter and creates a body from the content:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HttpRequest request = HttpRequest.newBuilder()</span><br><span class="line">  .uri(<span class="keyword">new</span> URI(<span class="string">"https://postman-echo.com/post"</span>))</span><br><span class="line">  .headers(<span class="string">"Content-Type"</span>, <span class="string">"text/plain;charset=UTF-8"</span>)</span><br><span class="line">  .POST(HttpRequest.BodyPublishers.fromFile(</span><br><span class="line">    Paths.get(<span class="string">"src/test/resources/sample.txt"</span>)))</span><br><span class="line">  .build();</span><br></pre></td></tr></table></figure><p>We’ve covered how to create <em>HttpRequest</em> and how to set additional parameters in it.</p><p>我们已经介绍了如何创建 <em>HttpRequest</em> 以及如何在其中设置附加参数。</p><p>Now it’s time to take a deeper look at <em>HttpClient</em> class, which is responsible for sending requests and receiving responses.</p><p>现在是深入了解 <em>HttpClient</em> 类的时候了，它负责发送请求和接收响应。</p><h2 id="6-HttpClient"><a href="#6-HttpClient" class="headerlink" title="6. HttpClient"></a><a href="https://www.baeldung.com/java-9-http-client#requests-1" target="_blank" rel="noopener"><strong>6. <em>HttpClient</em></strong></a></h2><p>All requests are sent using <em>HttpClient</em>, which can be instantiated using the <em>HttpClient.newBuilder()</em> method or by calling <em>HttpClient.newHttpClient()</em>.</p><p>所有请求都是通过 <em>HttpClient</em> 发送的，可以使用 <em>HttpClient.newBuilder()</em> 方法或调用 <em>HttpClient.newHttpClient()</em> 来实例化 _HttpClient。</p><p>It provides a lot of useful and self-describing methods we can use to handle our request/response.</p><p>它提供了许多有用的自描述方法，我们可以用它们来处理请求/响应。</p><p>Let’s cover some of these here.</p><p>下面我们就来介绍其中的一些方法。</p><h3 id="6-1-Handling-Response-Body"><a href="#6-1-Handling-Response-Body" class="headerlink" title="6.1. Handling Response Body"></a><a href="https://www.baeldung.com/java-9-http-client#1-handling-response-body" target="_blank" rel="noopener"><strong>6.1. Handling Response Body</strong></a></h3><p>Similar to the fluent methods for creating publishers, there are methods dedicated to creating handlers for common body types:</p><p>与创建发布器的流畅方法类似，也有一些方法专门用于为常见的主体类型创建处理程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BodyHandlers.ofByteArray</span><br><span class="line">BodyHandlers.ofString</span><br><span class="line">BodyHandlers.ofFile</span><br><span class="line">BodyHandlers.discarding</span><br><span class="line">BodyHandlers.replacing</span><br><span class="line">BodyHandlers.ofLines</span><br><span class="line">BodyHandlers.fromLineSubscriber</span><br></pre></td></tr></table></figure><p>Pay attention to the usage of the new <em>BodyHandlers</em> factory class.</p><p>请注意新的 <em>BodyHandlers</em> 工厂类的用法。</p><p>Before Java 11, we had to do something like this:</p><p>在 Java 11 之前，我们不得不这样做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandler.asString());</span><br></pre></td></tr></table></figure><p>And we can now simplify it:</p><p>现在我们可以将其简化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HttpResponse&lt;String&gt; response = client.send(request, BodyHandlers.ofString());</span><br></pre></td></tr></table></figure><h3 id="6-2-Setting-a-Proxy"><a href="#6-2-Setting-a-Proxy" class="headerlink" title="6.2. Setting a Proxy"></a><a href="https://www.baeldung.com/java-9-http-client#2-setting-a-proxy" target="_blank" rel="noopener"><strong>6.2. Setting a Proxy</strong></a></h3><p>We can define a proxy for the connection by just calling <em>proxy()</em> method on a <em>Builder</em> instance:</p><p>我们只需在 <em>Builder</em> 实例上调用 <em>proxy()</em> 方法，就能为连接定义一个代理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HttpResponse&lt;String&gt; response = HttpClient</span><br><span class="line">  .newBuilder()</span><br><span class="line">  .proxy(ProxySelector.getDefault())</span><br><span class="line">  .build()</span><br><span class="line">  .send(request, BodyHandlers.ofString());</span><br></pre></td></tr></table></figure><p>In our example, we used the default system proxy.</p><p>在我们的示例中，我们使用了默认的系统代理。</p><h3 id="6-3-Setting-the-Redirect-Policy"><a href="#6-3-Setting-the-Redirect-Policy" class="headerlink" title="6.3. Setting the Redirect Policy"></a><a href="https://www.baeldung.com/java-9-http-client#3-setting-the-redirect-policy" target="_blank" rel="noopener"><strong>6.3. Setting the Redirect Policy</strong></a></h3><p>Sometimes the page we want to access has moved to a different address.</p><p>有时，我们想要访问的页面已经转移到了不同的地址。</p><p>In that case, we’ll receive HTTP status code 3xx, usually with the information about new URI. <strong><em>HttpClient</em> can redirect the request to the new URI automatically if we set the appropriate redirect policy.</strong></p><p>在这种情况下，我们会收到 HTTP 状态代码 <strong>3xx</strong>，其中通常包含有关新 URI 的信息。 <strong>如果我们设置了适当的重定向策略，</strong><em>HttpClient</em> 就能自动将请求重定向到新的 URI。</p><p>We can do it with the <em>followRedirects()</em> method on <em>Builder</em>:</p><p>我们可以通过 <em>Builder</em> 上的 <em>followRedirects()</em> 方法来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HttpResponse&lt;String&gt; response = HttpClient.newBuilder()</span><br><span class="line">  .followRedirects(HttpClient.Redirect.ALWAYS)</span><br><span class="line">  .build()</span><br><span class="line">  .send(request, BodyHandlers.ofString());</span><br></pre></td></tr></table></figure><p>All policies are defined and described in enum <em>HttpClient.Redirect</em>.</p><p>所有策略都在枚举 <em>HttpClient.Redirect</em> 中定义和描述。</p><h3 id="6-4-Setting-Authenticator-for-a-Connection"><a href="#6-4-Setting-Authenticator-for-a-Connection" class="headerlink" title="6.4. Setting Authenticator for a Connection"></a><a href="https://www.baeldung.com/java-9-http-client#4-setting-authenticator-for-a-connection" target="_blank" rel="noopener"><strong>6.4. Setting <em>Authenticator</em> for a Connection</strong></a></h3><p>An <em>Authenticator</em> is an object that negotiates credentials (HTTP authentication) for a connection.</p><p>验证器是一个为连接协商凭证（HTTP 验证）的对象。</p><p>It provides different authentication schemes (such as basic or digest authentication).</p><p>它提供不同的验证方案（如基本验证或摘要验证）。</p><p>In most cases, authentication requires username and password to connect to a server.</p><p>在大多数情况下，身份验证需要用户名和密码才能连接服务器。</p><p>We can use <em>PasswordAuthentication</em> class, which is just a holder of these values:</p><p>我们可以使用 <em>PasswordAuthentication</em> 类，它只是这些值的持有者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HttpResponse&lt;String&gt; response = HttpClient.newBuilder()</span><br><span class="line">  .authenticator(<span class="keyword">new</span> Authenticator() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> PasswordAuthentication <span class="title">getPasswordAuthentication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> PasswordAuthentication(</span><br><span class="line">        <span class="string">"username"</span>, </span><br><span class="line">        <span class="string">"password"</span>.toCharArray());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).build()</span><br><span class="line">  .send(request, BodyHandlers.ofString());</span><br></pre></td></tr></table></figure><p>Here we passed the username and password values as a plaintext. Of course, this would have to be different in a production scenario.</p><p>在这里，我们以明文形式传递用户名和密码值。当然，这在生产场景中必须有所不同。</p><p>Note that not every request should use the same username and password. The <em>Authenticator</em> class provides a number of <em>getXXX</em> (e.g., <em>getRequestingSite()</em>) methods that can be used to find out what values should be provided.</p><blockquote><p>请注意，并非每个请求都应使用相同的用户名和密码。<em>Authenticator</em> 类提供了许多 _getXXX_（例如 _getRequestingSite()_）方法，可用于查找应提供哪些值。</p></blockquote><p>Now we’re going to explore one of the most useful features of new <em>HttpClient</em> — asynchronous calls to the server.</p><p>现在，我们将探索新_HttpClient_最有用的功能之一–<strong>对服务器的异步调用</strong>。</p><h3 id="6-5-Send-Requests-–-Sync-vs-Async"><a href="#6-5-Send-Requests-–-Sync-vs-Async" class="headerlink" title="6.5. Send Requests – Sync vs Async"></a><a href="https://www.baeldung.com/java-9-http-client#5-send-requests---sync-vs-async" target="_blank" rel="noopener"><strong>6.5. Send Requests – Sync vs Async</strong></a></h3><p>New <em>HttpClient</em> provides two possibilities for sending a request to a server:</p><p>新的 <em>HttpClient</em> 提供了两种向服务器发送请求的可能性：</p><ul><li><p><strong><em>send(…)</em> – synchronously</strong> (blocks until the response comes)</p></li><li><p><strong><em>sendAsync(…)</em> – asynchronously</strong> (doesn’t wait for the response, non-blocking)</p></li><li><p><strong><em>send(…)</em>-同步</strong>（阻塞直到响应到来）</p></li><li><p><strong><em>sendAsync(…)</em>-异步</strong>（不等待响应，非阻塞）。</p></li></ul><p>Up until now, the <em>send(.</em>..) method naturally waits for a response:</p><p>到目前为止，<em>send(.</em>..) 方法一直在等待响应：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HttpResponse&lt;String&gt; response = HttpClient.newBuilder()</span><br><span class="line">  .build()</span><br><span class="line">  .send(request, BodyHandlers.ofString());</span><br></pre></td></tr></table></figure><p>This call returns an <em>HttpResponse</em> object, and we’re sure that the next instruction from our application flow will be run only when the response is already here.</p><p>该调用会返回一个 <em>HttpResponse</em> 对象，我们可以确信，只有当响应已经存在时，应用流程的下一条指令才会运行。</p><p>However, it has a lot of drawbacks especially when we are processing large amounts of data.</p><p>不过，这种方法有很多缺点，尤其是在处理大量数据时。</p><p>So, now we can use <em>sendAsync(.</em>..) method — which returns  <em>CompletableFeature&lt; HttpResponse&gt;</em>  — <strong>to process a request asynchronously</strong>:</p><p>因此，现在我们可以使用<em>sendAsync(.</em>..)方法（该方法返回_CompletableFeature&lt; HttpResponse&gt;_）<strong>异步处理请求</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;HttpResponse&lt;String&gt;&gt; response = HttpClient.newBuilder()</span><br><span class="line">  .build()</span><br><span class="line">  .sendAsync(request, HttpResponse.BodyHandlers.ofString());</span><br></pre></td></tr></table></figure><p>The new API can also deal with multiple responses, and stream the request and response bodies:</p><p>新的应用程序接口还可以处理多个响应，并对请求和响应体进行流式处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;URI&gt; targets = Arrays.asList(</span><br><span class="line">  <span class="keyword">new</span> URI(<span class="string">"https://postman-echo.com/get?foo1=bar1"</span>),</span><br><span class="line">  <span class="keyword">new</span> URI(<span class="string">"https://postman-echo.com/get?foo2=bar2"</span>));</span><br><span class="line">HttpClient client = HttpClient.newHttpClient();</span><br><span class="line">List&lt;CompletableFuture&lt;String&gt;&gt; futures = targets.stream()</span><br><span class="line">  .map(target -&gt; client</span><br><span class="line">    .sendAsync(</span><br><span class="line">      HttpRequest.newBuilder(target).GET().build(),</span><br><span class="line">      HttpResponse.BodyHandlers.ofString())</span><br><span class="line">    .thenApply(response -&gt; response.body()))</span><br><span class="line">  .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h3 id="6-6-Setting-Executor-for-Asynchronous-Calls"><a href="#6-6-Setting-Executor-for-Asynchronous-Calls" class="headerlink" title="6.6. Setting Executor for Asynchronous Calls"></a><a href="https://www.baeldung.com/java-9-http-client#6-setting-executor-for-asynchronous-calls" target="_blank" rel="noopener"><strong>6.6. Setting <em>Executor</em> for Asynchronous Calls</strong></a></h3><p>We can also define an <em>Executor</em> that provides threads to be used by asynchronous calls.</p><p>我们还可以定义一个 <em>Executor</em> 来提供线程供异步调用使用。</p><p>This way we can, for example, limit the number of threads used for processing requests:</p><p>例如，这样我们就可以限制用于处理请求的线程数量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;HttpResponse&lt;String&gt;&gt; response1 = HttpClient.newBuilder()</span><br><span class="line">  .executor(executorService)</span><br><span class="line">  .build()</span><br><span class="line">  .sendAsync(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;HttpResponse&lt;String&gt;&gt; response2 = HttpClient.newBuilder()</span><br><span class="line">  .executor(executorService)</span><br><span class="line">  .build()</span><br><span class="line">  .sendAsync(request, HttpResponse.BodyHandlers.ofString());</span><br></pre></td></tr></table></figure><p>By default, the <em>HttpClient</em> uses executor <em>java.util.concurrent.Executors.newCachedThreadPool()</em>.</p><p>默认情况下，<em>HttpClient</em> 使用执行器 _java.util.concurrent.Executors.newCachedThreadPool()_。</p><h3 id="6-7-Defining-a-CookieHandler"><a href="#6-7-Defining-a-CookieHandler" class="headerlink" title="6.7. Defining a CookieHandler"></a><a href="https://www.baeldung.com/java-9-http-client#7-defining-a-cookiehandler" target="_blank" rel="noopener"><strong>6.7. Defining a <em>CookieHandler</em></strong></a></h3><p>With new API and builder, it’s straightforward to set a <em>CookieHandler</em> for our connection. We can use builder method <em>cookieHandler(CookieHandler cookieHandler)</em> to define client-specific <em>CookieHandler</em>.</p><p>有了新的 API 和构建器，为连接设置 <em>CookieHandler</em> 就变得简单易行了。</p><p>我们可以使用构建器方法 <em>cookieHandler(CookieHandler cookieHandler)</em> 来定义客户端特定的 _CookieHandler_。</p><p>Let’s define <em>CookieManager (_a concrete implementation of _CookieHandler</em> that separates the storage of cookies from the policy surrounding accepting and rejecting cookies) that doesn’t allow to accept cookies at all:</p><p>让我们定义  <em>CookieManager_（ _CookieHandler</em> 的具体实现，它将 Cookie 的存储与接受和拒绝 Cookie 的策略分离开来），它完全不接受 Cookie：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HttpClient.newBuilder()</span><br><span class="line">  .cookieHandler(<span class="keyword">new</span> CookieManager(<span class="keyword">null</span>, CookiePolicy.ACCEPT_NONE))</span><br><span class="line">  .build();</span><br></pre></td></tr></table></figure><p>In case our <em>CookieManager</em> allows cookies to be stored, we can access them by checking <em>CookieHandler</em> from our <em>HttpClient</em>:</p><p>如果 <em>CookieManager</em> 允许存储 cookie，我们就可以通过检查 <em>HttpClient</em> 中的 <em>CookieHandler</em> 来访问它们：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((CookieManager) httpClient.cookieHandler().get()).getCookieStore()</span><br></pre></td></tr></table></figure><p>Now let’s focus on the last class from Http API — the <em>HttpResponse</em>.</p><p>现在，让我们来关注 Http API 的最后一个类–_HttpResponse_。</p><h2 id="7-HttpResponse-Object"><a href="#7-HttpResponse-Object" class="headerlink" title="7. HttpResponse Object"></a><a href="https://www.baeldung.com/java-9-http-client#requests-2" target="_blank" rel="noopener"><strong>7. <em>HttpResponse</em> Object</strong></a></h2><p>The <em>HttpResponse</em> class represents the response from the server. It provides a number of useful methods, but these are the two most important:</p><p><em>HttpResponse</em> 类表示来自服务器的响应。它提供了许多有用的方法，但其中最重要的有两个：</p><ul><li><p><em>statusCode()</em> returns status code (type <em>int</em>) for a response (<em>HttpURLConnection</em> class contains possible values).</p></li><li><p><em>body()</em> returns a body for a response (return type depends on the response <em>BodyHandler</em> parameter passed to the <em>send()</em> method).</p></li><li><p><em>statusCode()</em> 返回响应的状态代码（注意类型 <em>int_）（_HttpURLConnection</em> 类包含可能的值）。</p></li><li><p><em>body()</em> 返回响应的正文（返回类型取决于传递给 <em>send()</em> 方法的响应 <em>BodyHandler</em> 参数）。</p></li></ul><p>The response object has other useful methods that we’ll cover such as <em>uri()</em>, <em>headers()</em>, <em>trailers()</em> and <em>version()</em>.</p><p>响应对象还有其他有用的方法，如 <em>uri()<em>、</em>headers()<em>、</em>trailers()</em> 和 _version()_。</p><h3 id="7-1-URI-of-Response-Object"><a href="#7-1-URI-of-Response-Object" class="headerlink" title="7.1. URI of Response Object"></a><a href="https://www.baeldung.com/java-9-http-client#1-uri-of-response-object" target="_blank" rel="noopener"><strong>7.1. <em>URI</em> of Response Object</strong></a></h3><p>The method <em>uri()</em> on the response object returns the <em>URI</em> from which we received the response.</p><p>响应对象上的 <em>uri()</em> 方法会返回我们收到响应的 <em>URI</em> 地址。</p><p>Sometimes it can be different than <em>URI</em> in the request object because a redirection may occur:</p><p>有时它可能与请求对象中的 <em>URI</em> 不同，因为可能会发生重定向：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assertThat(request.uri()</span><br><span class="line">  .toString(), equalTo(<span class="string">"http://stackoverflow.com"</span>));</span><br><span class="line">assertThat(response.uri()</span><br><span class="line">  .toString(), equalTo(<span class="string">"https://stackoverflow.com/"</span>));</span><br></pre></td></tr></table></figure><h3 id="7-2-Headers-from-Response"><a href="#7-2-Headers-from-Response" class="headerlink" title="7.2. Headers from Response"></a><a href="https://www.baeldung.com/java-9-http-client#2-headers-from-response" target="_blank" rel="noopener"><strong>7.2. Headers from Response</strong></a></h3><p>We can obtain headers from the response by calling method <em>headers()</em> on a response object:</p><p>我们可以通过调用响应对象上的 <em>headers()</em> 方法来获取响应的标题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HttpResponse&lt;String&gt; response = HttpClient.newHttpClient()</span><br><span class="line">  .send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line">HttpHeaders responseHeaders = response.headers();</span><br></pre></td></tr></table></figure><p>It returns <em>HttpHeaders</em> object, which represents a read-only view of HTTP Headers.</p><p>它返回 <em>HttpHeaders</em> 对象，该对象表示 HTTP 头信息的只读视图。</p><p>It has some useful methods that simplify searching for headers value.</p><p>它有一些有用的方法，可以简化头信息值的搜索。</p><h3 id="7-3-Version-of-the-Response"><a href="#7-3-Version-of-the-Response" class="headerlink" title="7.3. Version of the Response"></a><a href="https://www.baeldung.com/java-9-http-client#3-version-of-the-response" target="_blank" rel="noopener"><strong>7.3. Version of the Response</strong></a></h3><p>The method <em>version()</em> defines which version of HTTP protocol was used to talk with a server.</p><p>方法 <em>version()</em> 定义了与服务器通信时使用的 HTTP 协议版本。</p><p><strong>Remember that even if we define that we want to use HTTP/2, the server can answer via HTTP/1.1.</strong></p><p><strong>请记住，即使我们定义要使用 HTTP/2，服务器也可以通过 HTTP/1.1 进行应答</strong>。</p><p>The version in which the server answered is specified in the response:</p><p>响应中指定了服务器应答的版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HttpRequest request = HttpRequest.newBuilder()</span><br><span class="line">  .uri(<span class="keyword">new</span> URI(<span class="string">"https://postman-echo.com/get"</span>))</span><br><span class="line">  .version(HttpClient.Version.HTTP_2)</span><br><span class="line">  .GET()</span><br><span class="line">  .build();</span><br><span class="line">HttpResponse&lt;String&gt; response = HttpClient.newHttpClient()</span><br><span class="line">  .send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line">assertThat(response.version(), equalTo(HttpClient.Version.HTTP_1_1));</span><br></pre></td></tr></table></figure><h2 id="8-Handling-Push-Promises-in-HTTP-2"><a href="#8-Handling-Push-Promises-in-HTTP-2" class="headerlink" title="8. Handling Push Promises in HTTP/2"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFlbGR1bmcuY29tL2phdmEtOS1odHRwLWNsaWVudCNoYW5kbGluZy1wdXNoLXByb21pc2VzLWluLWh0dHAy" title="https://www.baeldung.com/java-9-http-client#handling-push-promises-in-http2">8. Handling Push Promises in HTTP/2<i class="fa fa-external-link"></i></span></h2><p>New <em>HttpClient</em> supports push promises through <em>PushPromiseHandler</em> interface_._ </p><p>新的 <em>HttpClient</em> 通过 <em>PushPromiseHandler</em> 接口支持推送承诺。</p><p><strong>It allows the server to “push” content to the client additional resources while requesting the primary resource, saving more roundtrip and as a result improves performance in page rendering.</strong></p><p><strong>它允许服务器在请求主要资源的同时向客户端 “推送 “附加资源内容，从而节省了更多的往返时间，并因此提高了页面渲染的性能。</strong></p><p>It is really the multiplexing feature of HTTP/2 that allows us to forget about resource bundling. For each resource, the server sends a special request, known as a push promise to the client.</p><p>实际上，正是 HTTP/2 的多路复用功能让我们忘记了资源捆绑。对于每个资源，服务器都会向客户端发送一个特殊请求，即推送承诺。</p><p>Push promises received, if any, are handled by the given <em>PushPromiseHandler</em>. A null valued <em>PushPromiseHandler</em> rejects any push promises.</p><p>收到的推送承诺（如果有）将由给定的 <em>PushPromiseHandler</em> 处理。空值_PushPromiseHandler_将拒绝任何推送承诺。</p><p>The <em>HttpClient</em> has an overloaded <strong>sendAsync</strong> method that allows us to handle such promises, as shown below.</p><p>如下所示，<em>HttpClient</em> 有一个重载的 <strong>sendAsync</strong> 方法，允许我们处理此类承诺。</p><p>Let’s first create a <em>PushPromiseHandler</em>:</p><p>让我们先创建一个 <em>PushPromiseHandler</em> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> PushPromiseHandler&lt;String&gt; <span class="title">pushPromiseHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (HttpRequest initiatingRequest, </span><br><span class="line">        HttpRequest pushPromiseRequest, </span><br><span class="line">        Function&lt;HttpResponse.BodyHandler&lt;String&gt;, </span><br><span class="line">        CompletableFuture&lt;HttpResponse&lt;String&gt;&gt;&gt; acceptor) -&gt; &#123;</span><br><span class="line">        acceptor.apply(BodyHandlers.ofString())</span><br><span class="line">            .thenAccept(resp -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">" Pushed response: "</span> + resp.uri() + <span class="string">", headers: "</span> + resp.headers());</span><br><span class="line">            &#125;);</span><br><span class="line">        System.out.println(<span class="string">"Promise request: "</span> + pushPromiseRequest.uri());</span><br><span class="line">        System.out.println(<span class="string">"Promise request: "</span> + pushPromiseRequest.headers());</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Next, let’s use <em>sendAsync</em> method to handle this push promise:</p><p>接下来，让我们使用 <em>sendAsync</em> 方法来处理这个推送承诺：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">httpClient.sendAsync(pageRequest, BodyHandlers.ofString(), pushPromiseHandler())</span><br><span class="line">    .thenAccept(pageResponse -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"Page response status code: "</span> + pageResponse.statusCode());</span><br><span class="line">        System.out.println(<span class="string">"Page response headers: "</span> + pageResponse.headers());</span><br><span class="line">        String responseBody = pageResponse.body();</span><br><span class="line">        System.out.println(responseBody);</span><br><span class="line">    &#125;)</span><br><span class="line">    .join();</span><br></pre></td></tr></table></figure><h2 id="9-Conclusion"><a href="#9-Conclusion" class="headerlink" title="9. Conclusion"></a><a href="https://www.baeldung.com/java-9-http-client#conclusion" target="_blank" rel="noopener"><strong>9. Conclusion</strong></a></h2><p>In this article, we explored the Java 11 <em>HttpClient</em> API that standardized the incubating HttpClient introduced in Java 9 with more powerful changes.</p><p>在本文中，我们探讨了 Java 11 <em>HttpClient</em> API，它对 Java 9 中引入的孵化 HttpClient 进行了标准化，并做出了更强大的更改。</p><p>这篇文章讨论了JDK11全新的HTTP API，</p><p>The complete code used can be found <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2V1Z2VucC90dXRvcmlhbHMvdHJlZS9tYXN0ZXIvY29yZS1qYXZhLW1vZHVsZXMvY29yZS1qYXZhLTEx" title="https://github.com/eugenp/tutorials/tree/master/core-java-modules/core-java-11">over on GitHub<i class="fa fa-external-link"></i></span>.</p><p>使用的完整代码可在 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2V1Z2VucC90dXRvcmlhbHMvdHJlZS9tYXN0ZXIvY29yZS1qYXZhLW1vZHVsZXMvY29yZS1qYXZhLTEx" title="https://github.com/eugenp/tutorials/tree/master/core-java-modules/core-java-11">GitHub<i class="fa fa-external-link"></i></span> 上找到。</p><p>In the examples, we’ve used sample REST endpoints provided by <em><span class="exturl" data-url="aHR0cHM6Ly9wb3N0bWFuLWVjaG8uY29t" title="https://postman-echo.com">https://postman-echo.com<i class="fa fa-external-link"></i></span></em>.</p><p>在示例中，我们使用了 <em><span class="exturl" data-url="aHR0cHM6Ly9wb3N0bWFuLWVjaG8uY29t" title="https://postman-echo.com">https://postman-echo.com<i class="fa fa-external-link"></i></span></em> 提供的 REST 端点示例。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      新HTTPClient API介绍
    
    </summary>
    
    
      <category term="Java" scheme="https://whitestore.top/categories/Java/"/>
    
    
      <category term="Java" scheme="https://whitestore.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】Linux Performance</title>
    <link href="https://whitestore.top/2023/08/10/linuxperformance/"/>
    <id>https://whitestore.top/2023/08/10/linuxperformance/</id>
    <published>2023-08-10T08:48:04.000Z</published>
    <updated>2023-09-09T00:53:49.936Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【Linux】Linux-性能"><a href="#【Linux】Linux-性能" class="headerlink" title="【Linux】Linux 性能"></a>【Linux】Linux 性能</h1><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>干货不是一般的多。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9saW51eHBlcmYuaHRtbA==" title="https://www.brendangregg.com/linuxperf.html">https://www.brendangregg.com/linuxperf.html<i class="fa fa-external-link"></i></span></p><p>This page links to various Linux performance material I’ve created, including the tools maps on the right. These use a large font size to suit slide decks. You can also print them out for your office wall. They show: <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9QZXJmL2xpbnV4X29ic2VydmFiaWxpdHlfdG9vbHMucG5n" title="https://www.brendangregg.com/Perf/linux_observability_tools.png">Linux observability tools<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9QZXJmL2xpbnV4X3N0YXRpY190b29scy5wbmc=" title="https://www.brendangregg.com/Perf/linux_static_tools.png">Linux static performance analysis tools<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9QZXJmL2xpbnV4X2JlbmNobWFya2luZ190b29scy5wbmc=" title="https://www.brendangregg.com/Perf/linux_benchmarking_tools.png">Linux benchmarking tools<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9QZXJmL2xpbnV4X3R1bmluZ190b29scy5wbmc=" title="https://www.brendangregg.com/Perf/linux_tuning_tools.png">Linux tuning tools<i class="fa fa-external-link"></i></span>, and <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9QZXJmL2xpbnV4X29ic2VydmFiaWxpdHlfc2FyLnBuZw==" title="https://www.brendangregg.com/Perf/linux_observability_sar.png">Linux sar<i class="fa fa-external-link"></i></span>. Check the year on the image (bottom right) to see how recent it is.</p><p>本页链接到我制作的各种 Linux 性能材料，包括右侧的工具图。这些地图使用大号字体，适合幻灯片使用。你也可以打印出来贴在办公室墙上。它们显示 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9QZXJmL2xpbnV4X29ic2VydmFiaWxpdHlfdG9vbHMucG5n" title="https://www.brendangregg.com/Perf/linux_observability_tools.png">Linux 可观察性工具<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9QZXJmL2xpbnV4X3N0YXRpY190b29scy5wbmc=" title="https://www.brendangregg.com/Perf/linux_static_tools.png">Linux 静态性能分析工具<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9QZXJmL2xpbnV4X2JlbmNobWFya2luZ190b29scy5wbmc=" title="https://www.brendangregg.com/Perf/linux_benchmarking_tools.png">Linux 基准测试工具<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9QZXJmL2xpbnV4X3R1bmluZ190b29scy5wbmc=" title="https://www.brendangregg.com/Perf/linux_tuning_tools.png">Linux 调试工具<i class="fa fa-external-link"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9QZXJmL2xpbnV4X29ic2VydmFiaWxpdHlfc2FyLnBuZw==" title="https://www.brendangregg.com/Perf/linux_observability_sar.png">Linux sar<i class="fa fa-external-link"></i></span>。请查看图片（右下角）上的年份，了解其最新版本。 </p><a id="more"></a><p>There is also a hi-res diagram combining observability, static performance tuning, and perf-tools/bcc: <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9QZXJmL2xpbnV4X3BlcmZfdG9vbHNfZnVsbC5wbmc=" title="https://www.brendangregg.com/Perf/linux_perf_tools_full.png">png<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9QZXJmL2xpbnV4X3BlcmZfdG9vbHNfZnVsbC5zdmc=" title="https://www.brendangregg.com/Perf/linux_perf_tools_full.svg">svg<i class="fa fa-external-link"></i></span> (see <span class="exturl" data-url="aHR0cHM6Ly93d3cucmVkZGl0LmNvbS9yL2xpbnV4L2NvbW1lbnRzLzR4NHNtdS9saW51eF9wZXJmb3JtYW5jZV90b29sc19mdWxsX3ZlcnNpb25fZHJhZnQv" title="https://www.reddit.com/r/linux/comments/4x4smu/linux_performance_tools_full_version_draft/">discussion<i class="fa fa-external-link"></i></span>), but it is not as complete as the other diagrams. For even more diagrams, see my slide decks below.</p><p>还有一个结合了可观察性、静态性能调优和 <strong>perf-tools/bcc</strong> 的高清图表：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9QZXJmL2xpbnV4X3BlcmZfdG9vbHNfZnVsbC5wbmc=" title="https://www.brendangregg.com/Perf/linux_perf_tools_full.png">png<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9QZXJmL2xpbnV4X3BlcmZfdG9vbHNfZnVsbC5zdmc=" title="https://www.brendangregg.com/Perf/linux_perf_tools_full.svg">svg<i class="fa fa-external-link"></i></span>（见<span class="exturl" data-url="aHR0cHM6Ly93d3cucmVkZGl0LmNvbS9yL2xpbnV4L2NvbW1lbnRzLzR4NHNtdS9saW51eF9wZXJmb3JtYW5jZV90b29sc19mdWxsX3ZlcnNpb25fZHJhZnQv" title="https://www.reddit.com/r/linux/comments/4x4smu/linux_performance_tools_full_version_draft/">讨论<i class="fa fa-external-link"></i></span>），但不如其他图表完整。需更多图表，请参阅下面的幻灯片。</p><p>On this page: <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9saW51eHBlcmYuaHRtbCNUb29scw==" title="https://www.brendangregg.com/linuxperf.html#Tools">Tools<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9saW51eHBlcmYuaHRtbCNEb2N1bWVudGF0aW9u" title="https://www.brendangregg.com/linuxperf.html#Documentation">Documentation<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9saW51eHBlcmYuaHRtbCNUYWxrcw==" title="https://www.brendangregg.com/linuxperf.html#Talks">Talks<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9saW51eHBlcmYuaHRtbCNSZXNvdXJjZXM=" title="https://www.brendangregg.com/linuxperf.html#Resources">Resources<i class="fa fa-external-link"></i></span>.</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9QZXJmL2xpbnV4X3BlcmZfdG9vbHNfZnVsbC5wbmc=" title="https://www.brendangregg.com/Perf/linux_perf_tools_full.png">png<i class="fa fa-external-link"></i></span></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230803143138.png" alt="image.png"></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9QZXJmL2xpbnV4X3BlcmZfdG9vbHNfZnVsbC5zdmc=" title="https://www.brendangregg.com/Perf/linux_perf_tools_full.svg">svg<i class="fa fa-external-link"></i></span>（注意只有部分）</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230803143201.png" alt="image.png"></p><p>在本页中：<strong>Tools</strong>, <strong>Documentation</strong>, <strong>Talks</strong>, <strong>Resources</strong>.</p><h1 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h1><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9wZXJmLmh0bWw=" title="https://www.brendangregg.com/perf.html">perf<i class="fa fa-external-link"></i></span>: perf one-liners, examples, visualizations. （perf 、实例、可视化。）</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9lYnBmLmh0bWw=" title="https://www.brendangregg.com/ebpf.html">eBPF tools<i class="fa fa-external-link"></i></span>: BPF/bcc tracing tools and examples.  （BPF/bcc 跟踪工具和示例）</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JyZW5kYW5ncmVnZy9wZXJmLXRvb2xz" title="https://github.com/brendangregg/perf-tools">perf-tools<i class="fa fa-external-link"></i></span>: Ftrace perf tools (github). （Ftrace perf 工具（github））</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lvdmlzb3IvYmNjI3Rvb2xz" title="https://github.com/iovisor/bcc#tools">bcc<i class="fa fa-external-link"></i></span>: BPF/bcc perf tools (github). （BPF/bcc perf 工具（github））</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lvdmlzb3IvYnBmdHJhY2UjdG9vbHM=" title="https://github.com/iovisor/bpftrace#tools">bpftrace<i class="fa fa-external-link"></i></span>: BPF/bpftrace perf tools (github).（BPF/bpftrace perf 工具（github）。）</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9mbGFtZWdyYXBocy5odG1s" title="https://www.brendangregg.com/flamegraphs.html">Flame Graphs<i class="fa fa-external-link"></i></span>: using <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9GbGFtZUdyYXBocy9jcHVmbGFtZWdyYXBocy5odG1sI3BlcmY=" title="https://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html#perf">perf<i class="fa fa-external-link"></i></span> and other profilers.（使用 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9GbGFtZUdyYXBocy9jcHVmbGFtZWdyYXBocy5odG1sI3BlcmY=" title="https://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html#perf">perf<i class="fa fa-external-link"></i></span> 和其他剖析器。）</li></ul><h1 id="Documentation"><a href="#Documentation" class="headerlink" title="Documentation"></a>Documentation</h1><ul><li><span class="exturl" data-url="aHR0cDovL3RlY2hibG9nLm5ldGZsaXguY29tLzIwMTUvMTEvbGludXgtcGVyZm9ybWFuY2UtYW5hbHlzaXMtaW4tNjBzLmh0bWw=" title="http://techblog.netflix.com/2015/11/linux-performance-analysis-in-60s.html">Linux Performance Analysis in 60,000 Milliseconds<i class="fa fa-external-link"></i></span> shows the first ten commands to use in an investigation (<span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTUtMTItMDMvbGludXgtcGVyZi02MHMtdmlkZW8uaHRtbA==" title="https://www.brendangregg.com/blog/2015-12-03/linux-perf-60s-video.html">video<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9BcnRpY2xlcy9OZXRmbGl4X0xpbnV4X1BlcmZfQW5hbHlzaXNfNjBzLnBkZg==" title="https://www.brendangregg.com/Articles/Netflix_Linux_Perf_Analysis_60s.pdf">PDF<i class="fa fa-external-link"></i></span>). Written by myself and the performance engineering team at Netflix (2015).</li></ul><p><span class="exturl" data-url="aHR0cDovL3RlY2hibG9nLm5ldGZsaXguY29tLzIwMTUvMTEvbGludXgtcGVyZm9ybWFuY2UtYW5hbHlzaXMtaW4tNjBzLmh0bWw=" title="http://techblog.netflix.com/2015/11/linux-performance-analysis-in-60s.html">Linux Performance Analysis in 60,000 Milliseconds<i class="fa fa-external-link"></i></span> 显示了调查中使用的前十个命令（<span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTUtMTItMDMvbGludXgtcGVyZi02MHMtdmlkZW8uaHRtbA==" title="https://www.brendangregg.com/blog/2015-12-03/linux-perf-60s-video.html">视频<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9BcnRpY2xlcy9OZXRmbGl4X0xpbnV4X1BlcmZfQW5hbHlzaXNfNjBzLnBkZg==" title="https://www.brendangregg.com/Articles/Netflix_Linux_Perf_Analysis_60s.pdf">PDF<i class="fa fa-external-link"></i></span>）。由我本人和 Netflix 的性能工程团队撰写（2015 年）。</p><ul><li>My post <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTUtMDMtMDMvcGVyZm9ybWFuY2UtdHVuaW5nLWxpbnV4LWluc3RhbmNlcy1vbi1lYzIuaHRtbA==" title="https://www.brendangregg.com/blog/2015-03-03/performance-tuning-linux-instances-on-ec2.html">Performance Tuning Linux Instances on EC2<i class="fa fa-external-link"></i></span> includes the tunables we’re using at Netflix (2015).</li></ul><p>我的文章 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTUtMDMtMDMvcGVyZm9ybWFuY2UtdHVuaW5nLWxpbnV4LWluc3RhbmNlcy1vbi1lYzIuaHRtbA==" title="https://www.brendangregg.com/blog/2015-03-03/performance-tuning-linux-instances-on-ec2.html">Performance Tuning Linux Instances on EC2<i class="fa fa-external-link"></i></span>包含了我们在 Netflix 使用的可调性（2015 年）。</p><ul><li>A post on <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTctMDgtMDgvbGludXgtbG9hZC1hdmVyYWdlcy5odG1s" title="https://www.brendangregg.com/blog/2017-08-08/linux-load-averages.html">Linux Load Averages: Solving the Mystery<i class="fa fa-external-link"></i></span>, explaining what they are and why they include the uninterruptible sleep state (2017).</li></ul><p>关于[Linux 负载平均值：解开之谜]的帖子(<span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTctMDgtMDgvbGludXgtbG9hZC1hdmVyYWdlcy5odG1sKe+8jOino+mHiuS6huS7gOS5iOaYr+i0n+i9veW5s+Wdh+WAvOS7peWPiuS4uuS7gOS5iOWMheWQq+S4jemXtOaWreedoeecoOeKtuaAge+8iDIwMTc=" title="https://www.brendangregg.com/blog/2017-08-08/linux-load-averages.html)，解释了什么是负载平均值以及为什么包含不间断睡眠状态（2017">https://www.brendangregg.com/blog/2017-08-08/linux-load-averages.html)，解释了什么是负载平均值以及为什么包含不间断睡眠状态（2017<i class="fa fa-external-link"></i></span> 年）。</p><ul><li><p>A <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTYtMDgtMDkvZ2RiLWV4YW1wbGUtbmN1cnNlcy5odG1s" title="https://www.brendangregg.com/blog/2016-08-09/gdb-example-ncurses.html">gdb Debugging Full Example (Tutorial)<i class="fa fa-external-link"></i></span>, including the use of some perf/debugging tools (2016).</p></li><li><p>gdb 调试完整示例（教程）](<span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTYtMDgtMDkvZ2RiLWV4YW1wbGUtbmN1cnNlcy5odG1sKe+8jOWMheaLrOS4gOS6mw==" title="https://www.brendangregg.com/blog/2016-08-09/gdb-example-ncurses.html)，包括一些">https://www.brendangregg.com/blog/2016-08-09/gdb-example-ncurses.html)，包括一些<i class="fa fa-external-link"></i></span> perf/debugging 工具的使用（2016 年）。</p></li><li><p>The book <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9zeXN0ZW1zLXBlcmZvcm1hbmNlLTJuZC1lZGl0aW9uLWJvb2suaHRtbA==" title="https://www.brendangregg.com/systems-performance-2nd-edition-book.html">Systems Performance: Enterprise and the Cloud, 2nd Edition (2020)<i class="fa fa-external-link"></i></span> covers performance analysis methods and Linux tools, including perf, Ftrace, and eBPF.</p></li><li><p>系统性能：企业与云，第 2 版 (2020)](<span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9zeXN0ZW1zLXBlcmZvcm1hbmNlLTJuZC1lZGl0aW9uLWJvb2suaHRtbA==" title="https://www.brendangregg.com/systems-performance-2nd-edition-book.html">https://www.brendangregg.com/systems-performance-2nd-edition-book.html<i class="fa fa-external-link"></i></span>) 一书介绍了性能分析方法和 Linux 工具，包括 perf、Ftrace 和 eBPF。</p></li><li><p>The book <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9icGYtcGVyZm9ybWFuY2UtdG9vbHMtYm9vay5odG1s" title="https://www.brendangregg.com/bpf-performance-tools-book.html">BPF Performance Tools: Linux System and Application Observability<i class="fa fa-external-link"></i></span> tours over 100 eBPF performance analysis tools, while including short summaries of the traditional tools. In a way, this is volume 2, and Systems Performance 2nd Edition is volume 1.</p></li><li><p>BPF 性能工具：Linux 系统和应用程序可观察性](<span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9icGYtcGVyZm9ybWFuY2UtdG9vbHMtYm9vay5odG1s" title="https://www.brendangregg.com/bpf-performance-tools-book.html">https://www.brendangregg.com/bpf-performance-tools-book.html<i class="fa fa-external-link"></i></span>) 一书介绍了 100 多种 eBPF 性能分析工具，同时还包括传统工具的简短摘要。在某种程度上，这本书是第二卷，而《系统性能第二版》是第一卷。</p></li></ul><ul><li><p>Generating flame graphs on Linux using perf &amp; eBPF:<br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9GbGFtZUdyYXBocy9jcHVmbGFtZWdyYXBocy5odG1sI0xpbnV4" title="https://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html#Linux">CPU Flame Graphs<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9GbGFtZUdyYXBocy9vZmZjcHVmbGFtZWdyYXBocy5odG1sI0xpbnV4" title="https://www.brendangregg.com/FlameGraphs/offcpuflamegraphs.html#Linux">Off-CPU Flame Graphs<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9GbGFtZUdyYXBocy9tZW1vcnlmbGFtZWdyYXBocy5odG1sI0xpbnV4" title="https://www.brendangregg.com/FlameGraphs/memoryflamegraphs.html#Linux">Memory Flame Graphs<i class="fa fa-external-link"></i></span></p></li><li><p>使用 perf 和 eBPF 在 Linux 上生成火焰图：<br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9GbGFtZUdyYXBocy9jcHVmbGFtZWdyYXBocy5odG1sI0xpbnV4" title="https://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html#Linux">CPU 火焰图<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9GbGFtZUdyYXBocy9vZmZjcHVmbGFtZWdyYXBocy5odG1sI0xpbnV4" title="https://www.brendangregg.com/FlameGraphs/offcpuflamegraphs.html#Linux">非 CPU 火焰图<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9GbGFtZUdyYXBocy9tZW1vcnlmbGFtZWdyYXBocy5odG1sI0xpbnV4" title="https://www.brendangregg.com/FlameGraphs/memoryflamegraphs.html#Linux">内存火焰图<i class="fa fa-external-link"></i></span></p></li><li><p>Posts about eBPF, bcc, and bpftrace (2015-21):</p></li><li><p>关于 eBPF、bcc 和 bpftrace 的帖子 (2015-21)：</p><p>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTUtMDUtMTUvZWJwZi1vbmUtc21hbGwtc3RlcC5odG1s" title="https://www.brendangregg.com/blog/2015-05-15/ebpf-one-small-step.html">Linux eBPF<i class="fa fa-external-link"></i></span> (2015)<br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTUtMDktMjIvYmNjLWxpbnV4LTQuMy10cmFjaW5nLmh0bWw=" title="https://www.brendangregg.com/blog/2015-09-22/bcc-linux-4.3-tracing.html">bcc: Taming Linux 4.3+ Tracing Superpowers<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTUtMTAtMzEvdGNwY29ubmVjdC10Y3BhY2NlcHQtYmNjLmh0bWw=" title="https://www.brendangregg.com/blog/2015-10-31/tcpconnect-tcpaccept-bcc.html">tcpconnect and tcpaccept for Linux (bcc)<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTYtMDEtMTgvZWJwZi1zdGFjay10cmFjZS1oYWNrLmh0bWw=" title="https://www.brendangregg.com/blog/2016-01-18/ebpf-stack-trace-hack.html">Linux eBPF Stack Trace Hack (bcc)<i class="fa fa-external-link"></i></span> (2016)<br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTYtMDEtMjAvZWJwZi1vZmZjcHUtZmxhbWUtZ3JhcGguaHRtbA==" title="https://www.brendangregg.com/blog/2016-01-20/ebpf-offcpu-flame-graph.html">Linux eBPF Off-CPU Flame Graph (bcc)<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTYtMDItMDEvbGludXgtd2FrZXVwLW9mZndha2UtcHJvZmlsaW5nLmh0bWw=" title="https://www.brendangregg.com/blog/2016-02-01/linux-wakeup-offwake-profiling.html">Linux Wakeup and Off-Wake Profiling (bcc)<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTYtMDItMDUvZWJwZi1jaGFpbmdyYXBoLXByb3RvdHlwZS5odG1s" title="https://www.brendangregg.com/blog/2016-02-05/ebpf-chaingraph-prototype.html">Linux chain graph prototype (bcc)<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTYtMDItMDgvbGludXgtZWJwZi1iY2MtdXByb2Jlcy5odG1s" title="https://www.brendangregg.com/blog/2016-02-08/linux-ebpf-bcc-uprobes.html">Linux eBPF/bcc uprobes<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTYtMDMtMjgvbGludXgtYnBmLWJjYy1yb2FkLWFoZWFkLTIwMTYuaHRtbA==" title="https://www.brendangregg.com/blog/2016-03-28/linux-bpf-bcc-road-ahead-2016.html">Linux BPF/bcc Road Ahead<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTYtMDYtMTQvdWJ1bnR1LXhlbmlhbC1iY2MtYnBmLmh0bWw=" title="https://www.brendangregg.com/blog/2016-06-14/ubuntu-xenial-bcc-bpf.html">Ubuntu Xenial bcc/BPF<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTYtMTAtMDEvbGludXgtYmNjLXNlY3VyaXR5LWNhcGFiaWxpdGllcy5odG1s" title="https://www.brendangregg.com/blog/2016-10-01/linux-bcc-security-capabilities.html">Linux bcc/BPF Tracing Security Capabilities<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTYtMTAtMDQvbGludXgtYmNjLW15c3FsZC1xc2xvd2VyLmh0bWw=" title="https://www.brendangregg.com/blog/2016-10-04/linux-bcc-mysqld-qslower.html">Linux MySQL Slow Query Tracing with bcc/BPF<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTYtMTAtMDYvbGludXgtYmNjLWV4dDRkaXN0LWV4dDRzbG93ZXIuaHRtbA==" title="https://www.brendangregg.com/blog/2016-10-06/linux-bcc-ext4dist-ext4slower.html">Linux bcc/BPF ext4 Latency Tracing<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTYtMTAtMDgvbGludXgtYmNjLXJ1bnFsYXQuaHRtbA==" title="https://www.brendangregg.com/blog/2016-10-08/linux-bcc-runqlat.html">Linux bcc/BPF Run Queue (Scheduler) Latency<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTYtMTAtMTIvbGludXgtYmNjLW5vZGVqcy11c2R0Lmh0bWw=" title="https://www.brendangregg.com/blog/2016-10-12/linux-bcc-nodejs-usdt.html">Linux bcc/BPF Node.js USDT Tracing<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTYtMTAtMTUvbGludXgtYmNjLXRjcHRvcC5odG1s" title="https://www.brendangregg.com/blog/2016-10-15/linux-bcc-tcptop.html">Linux bcc tcptop<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTYtMTAtMjEvbGludXgtZWZmaWNpZW50LXByb2ZpbGVyLmh0bWw=" title="https://www.brendangregg.com/blog/2016-10-21/linux-efficient-profiler.html">Linux 4.9’s Efficient BPF-based Profiler<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTYtMTAtMjcvZHRyYWNlLWZvci1saW51eC0yMDE2Lmh0bWw=" title="https://www.brendangregg.com/blog/2016-10-27/dtrace-for-linux-2016.html">DTrace for Linux 2016<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cDovL3d3dy5zbGlkZXNoYXJlLm5ldC9icmVuZGFuZ3JlZ2cvbGludXgtNHgtdHJhY2luZy10b29scy11c2luZy1icGYtc3VwZXJwb3dlcnM=" title="http://www.slideshare.net/brendangregg/linux-4x-tracing-tools-using-bpf-superpowers">Linux 4.x Tracing Tools: Using BPF Superpowers<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTYtMTEtMzAvbGludXgtYmNjLXRjcGxpZmUuaHRtbA==" title="https://www.brendangregg.com/blog/2016-11-30/linux-bcc-tcplife.html">Linux bcc/BPF tcplife: TCP Lifespans<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTctMDEtMzEvZ29sYW5nLWJjYy1icGYtZnVuY3Rpb24tdHJhY2luZy5odG1s" title="https://www.brendangregg.com/blog/2017-01-31/golang-bcc-bpf-function-tracing.html">Golang bcc/BPF Function Tracing<i class="fa fa-external-link"></i></span> (2017)<br>  <span class="exturl" data-url="aHR0cHM6Ly9vcGVuc291cmNlLmNvbS9hcnRpY2xlLzE3LzExL2JjY2JwZi1wZXJmb3JtYW5jZQ==" title="https://opensource.com/article/17/11/bccbpf-performance">7 BPF tools for performance analysis on Fedora<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTgtMDMtMjIvdGNwLXRyYWNlcG9pbnRzLmh0bWw=" title="https://www.brendangregg.com/blog/2018-03-22/tcp-tracepoints.html">TCP Tracepoints<i class="fa fa-external-link"></i></span> (2018)<br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTgtMDUtMzEvbGludXgtdGNwZHJvcC5odG1s" title="https://www.brendangregg.com/blog/2018-05-31/linux-tcpdrop.html">Linux bcc/eBPF tcpdrop<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTgtMTAtMDgvZHRyYWNlLWZvci1saW51eC0yMDE4Lmh0bWw=" title="https://www.brendangregg.com/blog/2018-10-08/dtrace-for-linux-2018.html">bpftrace (DTrace 2.0) for Linux 2018<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTktMDEtMDEvbGVhcm4tZWJwZi10cmFjaW5nLmh0bWw=" title="https://www.brendangregg.com/blog/2019-01-01/learn-ebpf-tracing.html">Learn eBPF Tracing: Tutorial and Examples<i class="fa fa-external-link"></i></span> (2019)<br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTktMDgtMTkvYnBmdHJhY2UuaHRtbA==" title="https://www.brendangregg.com/blog/2019-08-19/bpftrace.html">A thorough introduction to bpftrace<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTktMTItMDIvYnBmLWEtbmV3LXR5cGUtb2Ytc29mdHdhcmUuaHRtbA==" title="https://www.brendangregg.com/blog/2019-12-02/bpf-a-new-type-of-software.html">BPF: A New Type of Software<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTktMTItMjIvYnBmLXRoZXJlbWluLmh0bWw=" title="https://www.brendangregg.com/blog/2019-12-22/bpf-theremin.html">BPF Theremin, Tetris, and Typewriters<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMjAtMTEtMDQvYnBmLWNvLXJlLWJ0Zi1saWJicGYuaHRtbA==" title="https://www.brendangregg.com/blog/2020-11-04/bpf-co-re-btf-libbpf.html">BPF binaries: BTF, CO-RE, and the future of BPF perf tools<i class="fa fa-external-link"></i></span> (2020)<br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMjEtMDYtMTUvYnBmLWludGVybmFscy5odG1s" title="https://www.brendangregg.com/blog/2021-06-15/bpf-internals.html">USENIX LISA2021 BPF Internals (eBPF)<i class="fa fa-external-link"></i></span> (2021)<br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMjEtMDctMDMvaG93LXRvLWFkZC1icGYtb2JzZXJ2YWJpbGl0eS5odG1s" title="https://www.brendangregg.com/blog/2021-07-03/how-to-add-bpf-observability.html">How To Add eBPF Observability To Your Product<i class="fa fa-external-link"></i></span>  </p></li><li><p>My <span class="exturl" data-url="aHR0cDovL2x3bi5uZXQv" title="http://lwn.net/">lwn.net<i class="fa fa-external-link"></i></span> article <span class="exturl" data-url="aHR0cDovL2x3bi5uZXQvQXJ0aWNsZXMvNjA4NDk3Lw==" title="http://lwn.net/Articles/608497/">Ftrace: The Hidden Light Switch<i class="fa fa-external-link"></i></span> shows a use case for Linux ftrace (Aug, 2014).</p></li><li><p>我的 <span class="exturl" data-url="aHR0cDovL2x3bi5uZXQv" title="http://lwn.net/">lwn.net<i class="fa fa-external-link"></i></span>文章 <span class="exturl" data-url="aHR0cDovL2x3bi5uZXQvQXJ0aWNsZXMvNjA4NDk3Lw==" title="http://lwn.net/Articles/608497/">Ftrace：隐藏的电灯开关<i class="fa fa-external-link"></i></span> 展示了 Linux ftrace 的使用案例（2014 年 8 月）。</p></li><li><p>Posts about ftrace-based perf-tools (2014-5):</p></li><li><p>关于基于 ftrace 的 perf 工具的帖子 (2014-5)：</p><p>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTQtMDctMTYvaW9zbm9vcC1mb3ItbGludXguaHRtbA==" title="https://www.brendangregg.com/blog/2014-07-16/iosnoop-for-linux.html">iosnoop for Linux<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTQtMDctMjMvbGludXgtaW9zbm9vcC1sYXRlbmN5LWhlYXQtbWFwcy5odG1s" title="https://www.brendangregg.com/blog/2014-07-23/linux-iosnoop-latency-heat-maps.html">iosnoop Latency Heat Maps<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTQtMDctMjUvb3BlbnNub29wLWZvci1saW51eC5odG1s" title="https://www.brendangregg.com/blog/2014-07-25/opensnoop-for-linux.html">opensnoop for Linux<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTQtMDctMjgvZXhlY3Nub29wLWZvci1saW51eC5odG1s" title="https://www.brendangregg.com/blog/2014-07-28/execsnoop-for-linux.html">execsnoop for Linux<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTQtMDgtMzAvZnRyYWNlLXRoZS1oaWRkZW4tbGlnaHQtc3dpdGNoLmh0bWw=" title="https://www.brendangregg.com/blog/2014-08-30/ftrace-the-hidden-light-switch.html">ftrace: The Hidden Light Switch<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTQtMDktMDYvbGludXgtZnRyYWNlLXRjcC1yZXRyYW5zbWl0LXRyYWNpbmcuaHRtbA==" title="https://www.brendangregg.com/blog/2014-09-06/linux-ftrace-tcp-retransmit-tracing.html">tcpretrans<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTQtMTItMzEvbGludXgtcGFnZS1jYWNoZS1oaXQtcmF0aW8uaHRtbA==" title="https://www.brendangregg.com/blog/2014-12-31/linux-page-cache-hit-ratio.html">Page Cache Hit Ratio<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTUtMDYtMjgvbGludXgtZnRyYWNlLXVwcm9iZS5odG1s" title="https://www.brendangregg.com/blog/2015-06-28/linux-ftrace-uprobe.html">uprobe: User-Level Dynamic Tracing<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTUtMDctMDMvaGFja2luZy1saW51eC11c2R0LWZ0cmFjZS5odG1s" title="https://www.brendangregg.com/blog/2015-07-03/hacking-linux-usdt-ftrace.html">Hacking Linux USDT<i class="fa fa-external-link"></i></span></p></li></ul><ul><li>Posts about perf-based perf-tools: <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTQtMDctMTAvcGVyZi1oYWNrdG9ncmFtLmh0bWw=" title="https://www.brendangregg.com/blog/2014-07-10/perf-hacktogram.html">perf Hacktogram<i class="fa fa-external-link"></i></span>.</li></ul><p>关于基于 perf 的 perf 工具的帖子</p><ul><li>Posts about perf_events (2014-7):<br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTQtMDYtMjIvcGVyZi1jcHUtc2FtcGxlLmh0bWw=" title="https://www.brendangregg.com/blog/2014-06-22/perf-cpu-sample.html">perf CPU Sampling<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTQtMDYtMjkvcGVyZi1zdGF0aWMtdHJhY2Vwb2ludHMuaHRtbA==" title="https://www.brendangregg.com/blog/2014-06-29/perf-static-tracepoints.html">perf Static Tracepoints<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTQtMDctMDEvcGVyZi1oZWF0LW1hcHMuaHRtbA==" title="https://www.brendangregg.com/blog/2014-07-01/perf-heat-maps.html">perf Heat Maps<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTQtMDctMDMvcGVyZi1jb3VudGluZy5odG1s" title="https://www.brendangregg.com/blog/2014-07-03/perf-counting.html">perf Counting<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTQtMDktMTEvcGVyZi1rZXJuZWwtbGluZS10cmFjaW5nLmh0bWw=" title="https://www.brendangregg.com/blog/2014-09-11/perf-kernel-line-tracing.html">perf Kernel Line Tracing<i class="fa fa-external-link"></i></span>,<br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTUtMDItMjYvbGludXgtcGVyZi1vZmYtY3B1LWZsYW1lLWdyYXBoLmh0bWw=" title="https://www.brendangregg.com/blog/2015-02-26/linux-perf-off-cpu-flame-graph.html">perf Off-CPU Time Flame Graphs<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTUtMDItMjcvbGludXgtcHJvZmlsaW5nLWF0LW5ldGZsaXguaHRtbA==" title="https://www.brendangregg.com/blog/2015-02-27/linux-profiling-at-netflix.html">Linux Profiling at Netflix<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cDovL3RlY2hibG9nLm5ldGZsaXguY29tLzIwMTUvMDcvamF2YS1pbi1mbGFtZXMuaHRtbA==" title="http://techblog.netflix.com/2015/07/java-in-flames.html">Java Mixed-Mode Flame Graphs<i class="fa fa-external-link"></i></span> (<span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9BcnRpY2xlcy9OZXRmbGl4X0phdmFfaW5fRmxhbWVzLnBkZg==" title="https://www.brendangregg.com/Articles/Netflix_Java_in_Flames.pdf">PDF<i class="fa fa-external-link"></i></span>), <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTYtMDQtMzAvbGludXgtcGVyZi1mb2xkZWQuaHRtbA==" title="https://www.brendangregg.com/blog/2016-04-30/linux-perf-folded.html">Linux 4.5 perf folded format<i class="fa fa-external-link"></i></span>,<br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTctMDMtMTYvcGVyZi1zY2hlZC5odG1s" title="https://www.brendangregg.com/blog/2017-03-16/perf-sched.html">perf sched for Linux CPU scheduler analysis<i class="fa fa-external-link"></i></span></li></ul><ul><li><p>A page on <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS93c3MuaHRtbA==" title="https://www.brendangregg.com/wss.html">Working Set Size Estimation<i class="fa fa-external-link"></i></span> for Linux (2018+).</p></li><li><p>A post on <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTgtMDItMDkva3B0aS1rYWlzZXItbWVsdGRvd24tcGVyZm9ybWFuY2UuaHRtbA==" title="https://www.brendangregg.com/blog/2018-02-09/kpti-kaiser-meltdown-performance.html">KPTI/KAISER Meltdown Initial Performance Regressions<i class="fa fa-external-link"></i></span> (2018).</p></li><li><p>In <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTctMDUtMDQvdGhlLXBtY3Mtb2YtZWMyLmh0bWw=" title="https://www.brendangregg.com/blog/2017-05-04/the-pmcs-of-ec2.html">The PMCs of EC2: Measuring IPC<i class="fa fa-external-link"></i></span> I showed the new Performance Monitoring Counter (PMC) support in the AWS EC2 cloud (2017).</p><p>我展示了 AWS EC2 云中新的性能监控计数器（PMC）支持（2017 年）。</p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTctMDUtMDkvY3B1LXV0aWxpemF0aW9uLWlzLXdyb25nLmh0bWw=" title="https://www.brendangregg.com/blog/2017-05-09/cpu-utilization-is-wrong.html">CPU Utilization is Wrong<i class="fa fa-external-link"></i></span>: a post explaining the growing problem of memory stall cycles dominating the %CPU metric (2017).</p></li></ul><p>解释了内存停滞周期主导 %CPU 指标这一日益严重的问题（2017 年）。</p><ul><li>A post about <span class="exturl" data-url="aHR0cDovL3d3dy5icmVuZGFuZ3JlZ2cuY29tL2Jsb2cvMjAxNi0wNi0wOC9saW51eC1oaXN0LXRyaWdnZXJzLmh0bWw=" title="http://www.brendangregg.com/blog/2016-06-08/linux-hist-triggers.html">Linux 4.7 Hist Triggers<i class="fa fa-external-link"></i></span> (2016).</li><li>The blog post <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTQtMDUtMTEvc3RyYWNlLXdvdy1tdWNoLXN5c2NhbGwuaHRtbA==" title="https://www.brendangregg.com/blog/2014-05-11/strace-wow-much-syscall.html">strace Wow Much Syscall<i class="fa fa-external-link"></i></span> discusses strace(1) for production use, and compares it to advanced tracing tools (2014).</li></ul><p>讨论了用于生产的 strace(1)，并将其与高级跟踪工具进行了比较（2014 年）。</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9VU0VtZXRob2QvdXNlLWxpbnV4Lmh0bWw=" title="https://www.brendangregg.com/USEmethod/use-linux.html">USE Method: Linux Performance Checklist<i class="fa fa-external-link"></i></span>; also see the <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS91c2VtZXRob2QuaHRtbA==" title="https://www.brendangregg.com/usemethod.html">USE Method<i class="fa fa-external-link"></i></span> page for the description of this methodology.</li></ul><p>另请参阅 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS91c2VtZXRob2QuaHRtbA==" title="https://www.brendangregg.com/usemethod.html">USE Method<i class="fa fa-external-link"></i></span> 页面，了解该方法的说明。</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9vZmZjcHVhbmFseXNpcy5odG1s" title="https://www.brendangregg.com/offcpuanalysis.html">Off-CPU Analysis Method<i class="fa fa-external-link"></i></span>, where I demonstrate this methodology on Linux.</li></ul><p>我在 Linux 上演示了这种方法。</p><h1 id="Talks"><a href="#Talks" class="headerlink" title="Talks"></a>Talks</h1><p>In rough order of recommended viewing or difficulty, intro to more advanced:</p><p>按推荐观看或难度从入门到高级的大致顺序排列：</p><h2 id="1-Linux-Systems-Performance-USENIX-LISA-2019"><a href="#1-Linux-Systems-Performance-USENIX-LISA-2019" class="headerlink" title="1. Linux Systems Performance (USENIX LISA 2019)"></a>1. Linux Systems Performance (USENIX LISA 2019)</h2><p>This is my summary of Linux systems performance in 40 minutes, covering six facets: observability, methodologies, benchmarking, profiling, tracing, and tuning. It’s intended for everyone as a tour of fundamentals, and some companies have indicated they will use it for new hire training.</p><p>这是我在 40 分钟内对 Linux 系统性能的总结，涵盖六个方面：可观察性、方法、基准测试、剖析、跟踪和调整。它面向所有人，是基础知识的巡礼，一些公司表示将把它用于新员工培训。</p><p>A video of the talk is on <span class="exturl" data-url="aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9jb25mZXJlbmNlL2xpc2ExOS9wcmVzZW50YXRpb24vZ3JlZ2ctbGludXg=" title="https://www.usenix.org/conference/lisa19/presentation/gregg-linux">usenix.org<i class="fa fa-external-link"></i></span> and <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1maEJIdnNpMFFsMCZmZWF0dXJlPWVtYl9sb2dv" title="https://www.youtube.com/watch?v=fhBHvsi0Ql0&feature=emb_logo">youtube<i class="fa fa-external-link"></i></span>, and the slides are on <span class="exturl" data-url="aHR0cHM6Ly93d3cuc2xpZGVzaGFyZS5uZXQvYnJlbmRhbmdyZWdnL2xpc2EyMDE5LWxpbnV4LXN5c3RlbXMtcGVyZm9ybWFuY2U=" title="https://www.slideshare.net/brendangregg/lisa2019-linux-systems-performance">slideshare<i class="fa fa-external-link"></i></span> or as a <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9TbGlkZXMvTElTQTIwMTlfTGludXhfU3lzdGVtc19QZXJmb3JtYW5jZS5wZGY=" title="https://www.brendangregg.com/Slides/LISA2019_Linux_Systems_Performance.pdf">PDF<i class="fa fa-external-link"></i></span><br>讲座视频可在 <span class="exturl" data-url="aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9jb25mZXJlbmNlL2xpc2ExOS9wcmVzZW50YXRpb24vZ3JlZ2ctbGludXg=" title="https://www.usenix.org/conference/lisa19/presentation/gregg-linux">usenix.org<i class="fa fa-external-link"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1maEJIdnNpMFFsMCZmZWF0dXJlPWVtYl9sb2dv" title="https://www.youtube.com/watch?v=fhBHvsi0Ql0&feature=emb_logo">youtube<i class="fa fa-external-link"></i></span> 上观看，幻灯片可在 <span class="exturl" data-url="aHR0cHM6Ly93d3cuc2xpZGVzaGFyZS5uZXQvYnJlbmRhbmdyZWdnL2xpc2EyMDE5LWxpbnV4LXN5c3RlbXMtcGVyZm9ybWFuY2U=" title="https://www.slideshare.net/brendangregg/lisa2019-linux-systems-performance">slideshare<i class="fa fa-external-link"></i></span> 或 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9TbGlkZXMvTElTQTIwMTlfTGludXhfU3lzdGVtc19QZXJmb3JtYW5jZS5wZGY=" title="https://www.brendangregg.com/Slides/LISA2019_Linux_Systems_Performance.pdf">PDF<i class="fa fa-external-link"></i></span> 上观看。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230803144043.png" alt="image.png"></p><p>For a lot more information on observability tools, profiling, and tracing, see the talks that follow.</p><p>有关可观察性工具、剖析和跟踪的更多信息，请参阅后面的讲座。</p><h2 id="2-Linux-Performance-2018-PerconaLive-2018"><a href="#2-Linux-Performance-2018-PerconaLive-2018" class="headerlink" title="2. Linux Performance 2018 (PerconaLive 2018)"></a>2. Linux Performance 2018 (PerconaLive 2018)</h2><p>This was a 20 minute keynote summary of recent changes and features in Linux performance in 2018.</p><p>这是一个 20 分钟的主题演讲，总结了 2018 年 Linux 性能方面的最新变化和功能。</p><p>A video of the talk is on <span class="exturl" data-url="aHR0cHM6Ly95b3V0dS5iZS9zVjNYZnJmanJQbz90PTMwbTUxcw==" title="https://youtu.be/sV3XfrfjrPo?t=30m51s">youtube<i class="fa fa-external-link"></i></span>, and the slides are on <span class="exturl" data-url="aHR0cHM6Ly93d3cuc2xpZGVzaGFyZS5uZXQvYnJlbmRhbmdyZWdnL2xpbnV4LXBlcmZvcm1hbmNlLTIwMTgtcGVyY29uYWxpdmUta2V5bm90ZS05NTUxNjkzNA==" title="https://www.slideshare.net/brendangregg/linux-performance-2018-perconalive-keynote-95516934">slideshare<i class="fa fa-external-link"></i></span> or as a <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9TbGlkZXMvUGVyY29uYTIwMThfTGludXhfUGVyZm9ybWFuY2UucGRm" title="https://www.brendangregg.com/Slides/Percona2018_Linux_Performance.pdf">PDF.<i class="fa fa-external-link"></i></span></p><p>讲座视频可在 <span class="exturl" data-url="aHR0cHM6Ly95b3V0dS5iZS9zVjNYZnJmanJQbz90PTMwbTUxcw==" title="https://youtu.be/sV3XfrfjrPo?t=30m51s">youtube<i class="fa fa-external-link"></i></span> 上观看，幻灯片可在 <span class="exturl" data-url="aHR0cHM6Ly93d3cuc2xpZGVzaGFyZS5uZXQvYnJlbmRhbmdyZWdnL2xpbnV4LXBlcmZvcm1hbmNlLTIwMTgtcGVyY29uYWxpdmUta2V5bm90ZS05NTUxNjkzNA==" title="https://www.slideshare.net/brendangregg/linux-performance-2018-perconalive-keynote-95516934">slideshare<i class="fa fa-external-link"></i></span> 上观看，也可下载 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9TbGlkZXMvUGVyY29uYTIwMThfTGludXhfUGVyZm9ybWFuY2UucGRm" title="https://www.brendangregg.com/Slides/Percona2018_Linux_Performance.pdf">PDF.<i class="fa fa-external-link"></i></span></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230803144100.png" alt="image.png"></p><h2 id="3-Linux-Performance-Tools-Velocity-2015"><a href="#3-Linux-Performance-Tools-Velocity-2015" class="headerlink" title="3. Linux Performance Tools (Velocity 2015)"></a>3. Linux Performance Tools (Velocity 2015)</h2><p>At Velocity 2015, I gave a 90 minute tutorial on Linux performance tools, summarizing performance observability, benchmarking, tuning, static performance tuning, and tracing tools. I also covered performance methodology, and included some live demos. This should be useful for everyone working on Linux systems. If you just saw my PerconaLive2016 talk, then some content should be familiar, but with many extras: I focus a lot more on the tools in this talk.</p><p>在Velocity 2015大会上，我做了90分钟的Linux性能工具教程，总结了性能可观测性、基准测试、调优、静态性能调优和跟踪工具。我还介绍了性能方法论，并包括一些现场演示。这对每个在 Linux 系统上工作的人都很有用。如果您刚刚看过我的 PerconaLive2016 演讲，那么有些内容应该不会陌生，但还有很多额外的内容： 在本讲座中，我更关注工具。</p><p>A video of the talk is on youtube (<span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1GSlc4bkdWNGp4WSZsaXN0PVBMaGhkSU1WaTBvNVJOcmY4RTJkVWlqdkdwcUtMQjlUQ1I=" title="https://www.youtube.com/watch?v=FJW8nGV4jxY&list=PLhhdIMVi0o5RNrf8E2dUijvGpqKLB9TCR">playlist<i class="fa fa-external-link"></i></span>; <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1GSlc4bkdWNGp4WQ==" title="https://www.youtube.com/watch?v=FJW8nGV4jxY">part 1<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj16cnIyblVsbjlLaw==" title="https://www.youtube.com/watch?v=zrr2nUln9Kk">part 2<i class="fa fa-external-link"></i></span>) and the slides are on <span class="exturl" data-url="aHR0cDovL3d3dy5zbGlkZXNoYXJlLm5ldC9icmVuZGFuZ3JlZ2cvdmVsb2NpdHktMjAxNS1saW51eC1wZXJmLXRvb2xz" title="http://www.slideshare.net/brendangregg/velocity-2015-linux-perf-tools">slideshare<i class="fa fa-external-link"></i></span> or as a <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9TbGlkZXMvVmVsb2NpdHkyMDE1X0xpbnV4UGVyZlRvb2xzLnBkZg==" title="https://www.brendangregg.com/Slides/Velocity2015_LinuxPerfTools.pdf">PDF<i class="fa fa-external-link"></i></span>.</p><p>讲座视频可在 youtube 上观看（<span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1GSlc4bkdWNGp4WSZsaXN0PVBMaGhkSU1WaTBvNVJOcmY4RTJkVWlqdkdwcUtMQjlUQ1I=" title="https://www.youtube.com/watch?v=FJW8nGV4jxY&list=PLhhdIMVi0o5RNrf8E2dUijvGpqKLB9TCR">播放列表<i class="fa fa-external-link"></i></span>；<span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1GSlc4bkdWNGp4WQ==" title="https://www.youtube.com/watch?v=FJW8nGV4jxY">第一部分<i class="fa fa-external-link"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj16cnIyblVsbjlLaw==" title="https://www.youtube.com/watch?v=zrr2nUln9Kk">第二部分<i class="fa fa-external-link"></i></span>），幻灯片可在 <span class="exturl" data-url="aHR0cDovL3d3dy5zbGlkZXNoYXJlLm5ldC9icmVuZGFuZ3JlZ2cvdmVsb2NpdHktMjAxNS1saW51eC1wZXJmLXRvb2xz" title="http://www.slideshare.net/brendangregg/velocity-2015-linux-perf-tools">slideshare<i class="fa fa-external-link"></i></span> 或 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9TbGlkZXMvVmVsb2NpdHkyMDE1X0xpbnV4UGVyZlRvb2xzLnBkZg==" title="https://www.brendangregg.com/Slides/Velocity2015_LinuxPerfTools.pdf">PDF<i class="fa fa-external-link"></i></span> 上观看。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230803144135.png" alt="image.png"></p><blockquote><p>幻灯片失效了，视频貌似还有用</p></blockquote><p>This was similar to my <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj0weXlvcmhsNklqTQ==" title="https://www.youtube.com/watch?v=0yyorhl6IjM">SCaLE11x<i class="fa fa-external-link"></i></span> and <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTQtMDgtMjMvbGludXgtcGVyZi10b29scy1saW51eGNvbi1uYS0yMDE0Lmh0bWw=" title="https://www.brendangregg.com/blog/2014-08-23/linux-perf-tools-linuxcon-na-2014.html">LinuxCon<i class="fa fa-external-link"></i></span> talks, however, with 90 minutes I was able to cover more tools and methodologies, making it the most complete tour of the topic I’ve done. I also posted about it on the <span class="exturl" data-url="aHR0cDovL3RlY2hibG9nLm5ldGZsaXguY29tLzIwMTUvMDgvbmV0ZmxpeC1hdC12ZWxvY2l0eS0yMDE1LWxpbnV4Lmh0bWw=" title="http://techblog.netflix.com/2015/08/netflix-at-velocity-2015-linux.html">Netflix Tech Blog<i class="fa fa-external-link"></i></span>.</p><p>这与我的<span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj0weXlvcmhsNklqTQ==" title="https://www.youtube.com/watch?v=0yyorhl6IjM">SCaLE11x<i class="fa fa-external-link"></i></span> 和<span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTQtMDgtMjMvbGludXgtcGVyZi10b29scy1saW51eGNvbi1uYS0yMDE0Lmh0bWw=" title="https://www.brendangregg.com/blog/2014-08-23/linux-perf-tools-linuxcon-na-2014.html">LinuxCon<i class="fa fa-external-link"></i></span> 演讲类似，不过，在 90 分钟的时间里，我可以介绍更多的工具和方法，这是我做过的最完整的一次演讲。我还在 <span class="exturl" data-url="aHR0cDovL3RlY2hibG9nLm5ldGZsaXguY29tLzIwMTUvMDgvbmV0ZmxpeC1hdC12ZWxvY2l0eS0yMDE1LWxpbnV4Lmh0bWw=" title="http://techblog.netflix.com/2015/08/netflix-at-velocity-2015-linux.html">Netflix 技术博客<i class="fa fa-external-link"></i></span> 上发布了相关内容。</p><h2 id="4-How-Netflix-Tunes-EC2-Instances-for-Performance-AWS-re-Invent-2017"><a href="#4-How-Netflix-Tunes-EC2-Instances-for-Performance-AWS-re-Invent-2017" class="headerlink" title="4. How Netflix Tunes EC2 Instances for Performance (AWS re:Invent, 2017)"></a>4. How Netflix Tunes EC2 Instances for Performance (AWS re:Invent, 2017)</h2><p>Instead of performance observability, this talk is about tuning. I begin by providing Netflix background, covering instance types and features in the AWS EC2 cloud, and then talk about Linux kernel tunables and observability.</p><p>本讲座的主题不是性能可观测性，而是调优。首先，我将介绍 Netflix 的背景，涵盖 AWS EC2 云的实例类型和功能，然后谈谈 Linux 内核可调性和可观测性。</p><p>A video of the talk is on <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj04OWZZT28xVjJwQQ==" title="https://www.youtube.com/watch?v=89fYOo1V2pA">youtube<i class="fa fa-external-link"></i></span> and the slides are on <span class="exturl" data-url="aHR0cHM6Ly93d3cuc2xpZGVzaGFyZS5uZXQvYnJlbmRhbmdyZWdnL2hvdy1uZXRmbGl4LXR1bmVzLWVjMi1pbnN0YW5jZXMtZm9yLXBlcmZvcm1hbmNl" title="https://www.slideshare.net/brendangregg/how-netflix-tunes-ec2-instances-for-performance">slideshare<i class="fa fa-external-link"></i></span>:</p><p>讲座视频在 <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj04OWZZT28xVjJwQQ==" title="https://www.youtube.com/watch?v=89fYOo1V2pA">youtube<i class="fa fa-external-link"></i></span> 上，幻灯片在 <span class="exturl" data-url="aHR0cHM6Ly93d3cuc2xpZGVzaGFyZS5uZXQvYnJlbmRhbmdyZWdnL2hvdy1uZXRmbGl4LXR1bmVzLWVjMi1pbnN0YW5jZXMtZm9yLXBlcmZvcm1hbmNl" title="https://www.slideshare.net/brendangregg/how-netflix-tunes-ec2-instances-for-performance">slideshare<i class="fa fa-external-link"></i></span> 上：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230803144210.png" alt="image.png"></p><h2 id="5-Container-Performance-Analysis-DockerCon-2017"><a href="#5-Container-Performance-Analysis-DockerCon-2017" class="headerlink" title="5. Container Performance Analysis (DockerCon, 2017)"></a>5. Container Performance Analysis (DockerCon, 2017)</h2><p>At DockerCon 2017 in Austin, I gave a talk on Linux container performance analysis, showing how to find bottlenecks in the host vs the container, how to profiler container apps, and dig deeper into the kernel.</p><p>在奥斯汀举行的 DockerCon 2017 上，我发表了关于 Linux 容器性能分析的演讲，展示了如何找到主机与容器的瓶颈，如何对容器应用程序进行剖析，以及如何深入挖掘内核。</p><p>A video of the talk is on <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1iSzlBNU9ESWdhYw==" title="https://www.youtube.com/watch?v=bK9A5ODIgac">youtube<i class="fa fa-external-link"></i></span> and the slides are on <span class="exturl" data-url="aHR0cHM6Ly93d3cuc2xpZGVzaGFyZS5uZXQvYnJlbmRhbmdyZWdnL2NvbnRhaW5lci1wZXJmb3JtYW5jZS1hbmFseXNpcw==" title="https://www.slideshare.net/brendangregg/container-performance-analysis">slideshare<i class="fa fa-external-link"></i></span>.</p><p>讲座视频在 <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1iSzlBNU9ESWdhYw==" title="https://www.youtube.com/watch?v=bK9A5ODIgac">youtube<i class="fa fa-external-link"></i></span> 上，幻灯片在 <span class="exturl" data-url="aHR0cHM6Ly93d3cuc2xpZGVzaGFyZS5uZXQvYnJlbmRhbmdyZWdnL2NvbnRhaW5lci1wZXJmb3JtYW5jZS1hbmFseXNpcw==" title="https://www.slideshare.net/brendangregg/container-performance-analysis">slideshare<i class="fa fa-external-link"></i></span> 上。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230803144229.png" alt="image.png"></p><h2 id="6-Broken-Linux-Performance-Tools-SCaLE14x-2016"><a href="#6-Broken-Linux-Performance-Tools-SCaLE14x-2016" class="headerlink" title="6. Broken Linux Performance Tools (SCaLE14x, 2016)"></a>6. Broken Linux Performance Tools (SCaLE14x, 2016)</h2><p>At the Southern California Linux Expo (<span class="exturl" data-url="aHR0cDovL3d3dy5zb2NhbGxpbnV4ZXhwby5vcmcvc2NhbGUvMTR4" title="http://www.socallinuxexpo.org/scale/14x">SCaLE 14x<i class="fa fa-external-link"></i></span>), I gave a talk on Broken Linux Performance Tools. This was a follow-on to my earlier Linux Performance Tools talk originally at SCaLE11x (and more recently at <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9saW51eHBlcmYuaHRtbCNWZWxvY2l0eTIwMTU=" title="https://www.brendangregg.com/linuxperf.html#Velocity2015">Velocity<i class="fa fa-external-link"></i></span> as a tutorial). This broken tools talk was a tour of common problems with Linux system tools, metrics, statistics, visualizations, measurement overhead, and benchmarks. It also includes advice on how to cope (the green “What You Can Do” slides).</p><p>在南加州Linux博览会（<span class="exturl" data-url="aHR0cDovL3d3dy5zb2NhbGxpbnV4ZXhwby5vcmcvc2NhbGUvMTR4" title="http://www.socallinuxexpo.org/scale/14x">SCaLE 14x<i class="fa fa-external-link"></i></span>）上，我做了一个关于破碎的Linux性能工具的演讲。这是我之前在SCaLE11x上发表的Linux性能工具演讲（最近在<span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9saW51eHBlcmYuaHRtbCNWZWxvY2l0eTIwMTU=" title="https://www.brendangregg.com/linuxperf.html#Velocity2015">Velocity<i class="fa fa-external-link"></i></span>上作为教程发表）的后续演讲。这篇 “破损的工具 “演讲讲述了 Linux 系统工具、度量、统计、可视化、测量开销和基准的常见问题。其中还包括应对建议（绿色的 “你能做什么 “幻灯片）。</p><p>A video of the talk is on <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1PUGlvOFYtejAzYw==" title="https://www.youtube.com/watch?v=OPio8V-z03c">youtube<i class="fa fa-external-link"></i></span> and the slides are on <span class="exturl" data-url="aHR0cDovL3d3dy5zbGlkZXNoYXJlLm5ldC9icmVuZGFuZ3JlZ2cvYnJva2VuLWxpbnV4LXBlcmZvcm1hbmNlLXRvb2xzLTIwMTY=" title="http://www.slideshare.net/brendangregg/broken-linux-performance-tools-2016">slideshare<i class="fa fa-external-link"></i></span> or as a <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9TbGlkZXMvU0NBTEUyMDE2X0Jyb2tlbl9MaW51eF9QZXJmb3JtYW5jZV9Ub29scy5wZGY=" title="https://www.brendangregg.com/Slides/SCALE2016_Broken_Linux_Performance_Tools.pdf">PDF<i class="fa fa-external-link"></i></span>.</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230803144249.png" alt="image.png"></p><h2 id="7-Using-Linux-perf-at-Netflix-Kernel-Recipes-2017"><a href="#7-Using-Linux-perf-at-Netflix-Kernel-Recipes-2017" class="headerlink" title="7. Using Linux perf at Netflix (Kernel Recipes, 2017)"></a>7. Using Linux perf at Netflix (Kernel Recipes, 2017)</h2><p>At <span class="exturl" data-url="aHR0cHM6Ly9rZXJuZWwtcmVjaXBlcy5vcmcvZW4vMjAxNy90YWxrcy9wZXJmLWluLW5ldGZsaXgv" title="https://kernel-recipes.org/en/2017/talks/perf-in-netflix/">Kernel Recipes 2017<i class="fa fa-external-link"></i></span> I gave an updated talk on Linux perf at Netflix, focusing on getting CPU profiling and flame graphs to work. This talk includes a crash course on perf_events, plus gotchas such as fixing stack traces and symbols when profiling Java, Node.js, VMs, and containers.</p><p>在 <span class="exturl" data-url="aHR0cHM6Ly9rZXJuZWwtcmVjaXBlcy5vcmcvZW4vMjAxNy90YWxrcy9wZXJmLWluLW5ldGZsaXgv" title="https://kernel-recipes.org/en/2017/talks/perf-in-netflix/">Kernel Recipes 2017<i class="fa fa-external-link"></i></span> 上，我发表了关于 Netflix Linux perf 的最新演讲，重点是如何让 CPU 剖析和火焰图发挥作用。本讲座包括 perf_events 的速成课程，以及在剖析 Java、Node.js、虚拟机和容器时修复堆栈跟踪和符号等疑难问题。</p><p>A video of the talk is on <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1VVk0zV1g4THEyaw==" title="https://www.youtube.com/watch?v=UVM3WX8Lq2k">youtube<i class="fa fa-external-link"></i></span> and the slides are on <span class="exturl" data-url="aHR0cHM6Ly93d3cuc2xpZGVzaGFyZS5uZXQvYnJlbmRhbmdyZWdnL2tlcm5lbC1yZWNpcGVzLTIwMTctdXNpbmctbGludXgtcGVyZi1hdC1uZXRmbGl4" title="https://www.slideshare.net/brendangregg/kernel-recipes-2017-using-linux-perf-at-netflix">slideshare<i class="fa fa-external-link"></i></span>:</p><p>讲座视频在 <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1VVk0zV1g4THEyaw==" title="https://www.youtube.com/watch?v=UVM3WX8Lq2k">youtube<i class="fa fa-external-link"></i></span> 上，幻灯片在 <span class="exturl" data-url="aHR0cHM6Ly93d3cuc2xpZGVzaGFyZS5uZXQvYnJlbmRhbmdyZWdnL2tlcm5lbC1yZWNpcGVzLTIwMTctdXNpbmctbGludXgtcGVyZi1hdC1uZXRmbGl4" title="https://www.slideshare.net/brendangregg/kernel-recipes-2017-using-linux-perf-at-netflix">slideshare<i class="fa fa-external-link"></i></span> 上：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230803144318.png" alt="image.png"></p><p>There’s also an older version of this talk from 2015, which I’ve <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTUtMDItMjcvbGludXgtcHJvZmlsaW5nLWF0LW5ldGZsaXguaHRtbA==" title="https://www.brendangregg.com/blog/2015-02-27/linux-profiling-at-netflix.html">posted<i class="fa fa-external-link"></i></span> about. To learn more about flame graphs, see my <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9mbGFtZWdyYXBocy5odG1sI1ByZXNlbnRhdGlvbg==" title="https://www.brendangregg.com/flamegraphs.html#Presentation">flame graphs presentation<i class="fa fa-external-link"></i></span>.</p><p>这个讲座还有一个 2015 年的旧版本，我已经<span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTUtMDItMjcvbGludXgtcHJvZmlsaW5nLWF0LW5ldGZsaXguaHRtbA==" title="https://www.brendangregg.com/blog/2015-02-27/linux-profiling-at-netflix.html">发布<i class="fa fa-external-link"></i></span>了。要了解有关火焰图的更多信息，请参阅我的 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9mbGFtZWdyYXBocy5odG1sI1ByZXNlbnRhdGlvbg==" title="https://www.brendangregg.com/flamegraphs.html#Presentation">火焰图演示<i class="fa fa-external-link"></i></span>。</p><h2 id="8-Give-me-15-minutes-and-I’ll-change-your-view-of-Linux-tracing-LISA-2016"><a href="#8-Give-me-15-minutes-and-I’ll-change-your-view-of-Linux-tracing-LISA-2016" class="headerlink" title="8. Give me 15 minutes and I’ll change your view of Linux tracing (LISA, 2016)"></a>8. Give me 15 minutes and I’ll change your view of Linux tracing (LISA, 2016)</h2><p>I gave this demo at USENIX/LISA 2016, showing ftrace, perf, and bcc/BPF. A video is on <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1Hc01zM244Q0I2Zw==" title="https://www.youtube.com/watch?v=GsMs3n8CB6g">youtube<i class="fa fa-external-link"></i></span> (sorry, the sound effects are a bit too loud):.</p><p>我在 USENIX/LISA 2016 上做了这个演示，展示了 ftrace、perf 和 bcc/BPF。视频在 <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1Hc01zM244Q0I2Zw==" title="https://www.youtube.com/watch?v=GsMs3n8CB6g">youtube<i class="fa fa-external-link"></i></span>（抱歉，音效有点大）：。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230803144334.png" alt="image.png"></p><p>This was the first part of a longer talk on Linux 4.x Tracing Tools: Using BPF Superpowers. See the full <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1VbU9VM0kzNlQyVQ==" title="https://www.youtube.com/watch?v=UmOU3I36T2U">talk video<i class="fa fa-external-link"></i></span> and <span class="exturl" data-url="aHR0cDovL3d3dy5zbGlkZXNoYXJlLm5ldC9icmVuZGFuZ3JlZ2cvbGludXgtNHgtdHJhY2luZy10b29scy11c2luZy1icGYtc3VwZXJwb3dlcnM=" title="http://www.slideshare.net/brendangregg/linux-4x-tracing-tools-using-bpf-superpowers">talk slides<i class="fa fa-external-link"></i></span>.</p><p>这是关于 Linux 4.x 跟踪工具的长篇演讲的第一部分： 使用 BPF 超强功能。请参阅完整的 <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1VbU9VM0kzNlQyVQ==" title="https://www.youtube.com/watch?v=UmOU3I36T2U">讲座视频<i class="fa fa-external-link"></i></span> 和 <span class="exturl" data-url="aHR0cDovL3d3dy5zbGlkZXNoYXJlLm5ldC9icmVuZGFuZ3JlZ2cvbGludXgtNHgtdHJhY2luZy10b29scy11c2luZy1icGYtc3VwZXJwb3dlcnM=" title="http://www.slideshare.net/brendangregg/linux-4x-tracing-tools-using-bpf-superpowers">讲座幻灯片<i class="fa fa-external-link"></i></span>。</p><h2 id="9-Performance-analysis-superpowers-with-Linux-eBPF-O’Reilly-Velocity-2017"><a href="#9-Performance-analysis-superpowers-with-Linux-eBPF-O’Reilly-Velocity-2017" class="headerlink" title="9. Performance analysis superpowers with Linux eBPF (O’Reilly Velocity, 2017)"></a>9. Performance analysis superpowers with Linux eBPF (O’Reilly Velocity, 2017)</h2><p>This talk covers using enhanced BPF (aka eBPF) features added to the Linux 4.x series for performance analysis, observability, and debugging. The front-end used in this talk is bcc (BPF compiler collection), an open source project that provides BPF interfaces and a collection of tools.</p><p>本讲座将介绍如何使用 Linux 4.x 系列新增的增强型 BPF（又称 eBPF）功能进行性能分析、可观察性和调试。本讲座中使用的前端是 bcc（BPF 编译器集合），它是一个提供 BPF 接口和工具集合的开源项目。</p><p>A video of the talk is on <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1iajNxZEVEYkNENA==" title="https://www.youtube.com/watch?v=bj3qdEDbCD4">youtube<i class="fa fa-external-link"></i></span>, and the slides are on <span class="exturl" data-url="aHR0cHM6Ly93d3cuc2xpZGVzaGFyZS5uZXQvYnJlbmRhbmdyZWdnL3ZlbG9jaXR5LTIwMTctcGVyZm9ybWFuY2UtYW5hbHlzaXMtc3VwZXJwb3dlcnMtd2l0aC1saW51eC1lYnBm" title="https://www.slideshare.net/brendangregg/velocity-2017-performance-analysis-superpowers-with-linux-ebpf">slideshare<i class="fa fa-external-link"></i></span> or as a <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9TbGlkZXMvVmVsb2NpdHkyMDE3X0JQRl9zdXBlcnBvd2Vycy5wZGY=" title="https://www.brendangregg.com/Slides/Velocity2017_BPF_superpowers.pdf">PDF<i class="fa fa-external-link"></i></span>.</p><p>讲座视频在 <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1iajNxZEVEYkNENA==" title="https://www.youtube.com/watch?v=bj3qdEDbCD4">youtube<i class="fa fa-external-link"></i></span> 上，幻灯片在 <span class="exturl" data-url="aHR0cHM6Ly93d3cuc2xpZGVzaGFyZS5uZXQvYnJlbmRhbmdyZWdnL3ZlbG9jaXR5LTIwMTctcGVyZm9ybWFuY2UtYW5hbHlzaXMtc3VwZXJwb3dlcnMtd2l0aC1saW51eC1lYnBm" title="https://www.slideshare.net/brendangregg/velocity-2017-performance-analysis-superpowers-with-linux-ebpf">slideshare<i class="fa fa-external-link"></i></span> 或 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9TbGlkZXMvVmVsb2NpdHkyMDE3X0JQRl9zdXBlcnBvd2Vycy5wZGY=" title="https://www.brendangregg.com/Slides/Velocity2017_BPF_superpowers.pdf">PDF<i class="fa fa-external-link"></i></span> 上。</p><h2 id="10-Linux-Performance-Analysis-New-Tools-and-Old-Secrets-ftrace-LISA-2014"><a href="#10-Linux-Performance-Analysis-New-Tools-and-Old-Secrets-ftrace-LISA-2014" class="headerlink" title="10. Linux Performance Analysis: New Tools and Old Secrets (ftrace) (LISA 2014)"></a>10. Linux Performance Analysis: New Tools and Old Secrets (ftrace) (LISA 2014)</h2><p>At USENIX LISA 2014, I gave a talk on the new ftrace and perf_events tools I’ve been developing: the <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JyZW5kYW5ncmVnZy9wZXJmLXRvb2xz" title="https://github.com/brendangregg/perf-tools">perf-tools<i class="fa fa-external-link"></i></span> collection on github, which mostly uses ftrace: a tracer that has been built into the Linux kernel for many years, but few have discovered (practically a secret).</p><p>在 2014 年的 USENIX LISA 大会上，我发表了关于我一直在开发的新 ftrace 和 perf_events 工具的演讲：github 上的 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JyZW5kYW5ncmVnZy9wZXJmLXRvb2xz" title="https://github.com/brendangregg/perf-tools">perf-tools<i class="fa fa-external-link"></i></span> 套件，其中大部分使用了 ftrace：这是一个内置于 Linux 内核多年的跟踪器，但很少有人发现它（实际上是一个秘密）。</p><p>A video of the talk is on <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1SNElLZU1RaE0wWQ==" title="https://www.youtube.com/watch?v=R4IKeMQhM0Y">youtube<i class="fa fa-external-link"></i></span>, and the slides are on <span class="exturl" data-url="aHR0cDovL3d3dy5zbGlkZXNoYXJlLm5ldC9icmVuZGFuZ3JlZ2cvbGludXgtcGVyZm9ybWFuY2UtYW5hbHlzaXMtbmV3LXRvb2xzLWFuZC1vbGQtc2VjcmV0cw==" title="http://www.slideshare.net/brendangregg/linux-performance-analysis-new-tools-and-old-secrets">slideshare<i class="fa fa-external-link"></i></span> or as a <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9TbGlkZXMvTElTQTIwMTRfTGludXhQZXJmQW5hbHlzaXNOZXdUb29scy5wZGY=" title="https://www.brendangregg.com/Slides/LISA2014_LinuxPerfAnalysisNewTools.pdf">PDF<i class="fa fa-external-link"></i></span>. In a <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTUtMDMtMTcvdXNlbml4LWxpc2EtMjAxNC1saW51eC1mdHJhY2UtcGVyZi10b29scy5tYXJrZG93bg==" title="https://www.brendangregg.com/blog/2015-03-17/usenix-lisa-2014-linux-ftrace-perf-tools.markdown">post<i class="fa fa-external-link"></i></span> about this talk, I included some more screenshots of these tools in action.</p><p>演讲视频在 <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1SNElLZU1RaE0wWQ==" title="https://www.youtube.com/watch?v=R4IKeMQhM0Y">youtube<i class="fa fa-external-link"></i></span> 上，幻灯片在 <span class="exturl" data-url="aHR0cDovL3d3dy5zbGlkZXNoYXJlLm5ldC9icmVuZGFuZ3JlZ2cvbGludXgtcGVyZm9ybWFuY2UtYW5hbHlzaXMtbmV3LXRvb2xzLWFuZC1vbGQtc2VjcmV0cw==" title="http://www.slideshare.net/brendangregg/linux-performance-analysis-new-tools-and-old-secrets">slideshare<i class="fa fa-external-link"></i></span> 或 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9TbGlkZXMvTElTQTIwMTRfTGludXhQZXJmQW5hbHlzaXNOZXdUb29scy5wZGY=" title="https://www.brendangregg.com/Slides/LISA2014_LinuxPerfAnalysisNewTools.pdf">PDF<i class="fa fa-external-link"></i></span> 上。在一篇关于本讲座的<span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTUtMDMtMTcvdXNlbml4LWxpc2EtMjAxNC1saW51eC1mdHJhY2UtcGVyZi10b29scy5tYXJrZG93bg==" title="https://www.brendangregg.com/blog/2015-03-17/usenix-lisa-2014-linux-ftrace-perf-tools.markdown">帖子<i class="fa fa-external-link"></i></span>中，我还附上了这些工具的截图。</p><h2 id="11-Performance-Checklists-for-SREs-SREcon-2016"><a href="#11-Performance-Checklists-for-SREs-SREcon-2016" class="headerlink" title="11. Performance Checklists for SREs (SREcon, 2016)"></a>11. Performance Checklists for SREs (SREcon, 2016)</h2><p>At <span class="exturl" data-url="aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9jb25mZXJlbmNlL3NyZWNvbjE2L3Byb2dyYW0=" title="https://www.usenix.org/conference/srecon16/program">SREcon 2016 Santa Clara<i class="fa fa-external-link"></i></span>, I gave the closing talk on performance checklists for SREs (Site Reliability Engineers). The later half of this talk included Linux checklists for incident performance response. These may be useful whether you’re analyzing Linux performance in a hurry or not.</p><p>在<span class="exturl" data-url="aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9jb25mZXJlbmNlL3NyZWNvbjE2L3Byb2dyYW0=" title="https://www.usenix.org/conference/srecon16/program">SREcon 2016 Santa Clara<i class="fa fa-external-link"></i></span>上，我做了关于站点可靠性工程师（SRE）性能检查表的闭幕演讲。演讲的后半部分包括用于事件性能响应的 Linux 检查单。无论您是否在匆忙中分析 Linux 性能，这些清单都可能很有用。</p><p>A video of the talk is on <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj16eENXWE5pZ0RwQQ==" title="https://www.youtube.com/watch?v=zxCWXNigDpA">youtube<i class="fa fa-external-link"></i></span> and <span class="exturl" data-url="aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9jb25mZXJlbmNlL3NyZWNvbjE2L3Byb2dyYW0vcHJlc2VudGF0aW9uL2dyZWdn" title="https://www.usenix.org/conference/srecon16/program/presentation/gregg">usenix<i class="fa fa-external-link"></i></span>, and the slides are on <span class="exturl" data-url="aHR0cDovL3d3dy5zbGlkZXNoYXJlLm5ldC9icmVuZGFuZ3JlZ2cvc3JlY29uLTIwMTYtcGVyZm9ybWFuY2UtY2hlY2tsaXN0cy1mb3Itc3Jlcw==" title="http://www.slideshare.net/brendangregg/srecon-2016-performance-checklists-for-sres">slideshare<i class="fa fa-external-link"></i></span> and as a <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9TbGlkZXMvU1JFY29uXzIwMTZfcGVyZl9jaGVja2xpc3RzLnBkZg==" title="https://www.brendangregg.com/Slides/SREcon_2016_perf_checklists.pdf">PDF<i class="fa fa-external-link"></i></span>. I included the checklists in a <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTYtMDUtMDQvc3JlY29uMjAxNi1wZXJmLWNoZWNrbGlzdHMtZm9yLXNyZXMuaHRtbA==" title="https://www.brendangregg.com/blog/2016-05-04/srecon2016-perf-checklists-for-sres.html">blog post<i class="fa fa-external-link"></i></span>.</p><p>讲座视频在 <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj16eENXWE5pZ0RwQQ==" title="https://www.youtube.com/watch?v=zxCWXNigDpA">youtube<i class="fa fa-external-link"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9jb25mZXJlbmNlL3NyZWNvbjE2L3Byb2dyYW0vcHJlc2VudGF0aW9uL2dyZWdn" title="https://www.usenix.org/conference/srecon16/program/presentation/gregg">usenix<i class="fa fa-external-link"></i></span> 上，幻灯片在 <span class="exturl" data-url="aHR0cDovL3d3dy5zbGlkZXNoYXJlLm5ldC9icmVuZGFuZ3JlZ2cvc3JlY29uLTIwMTYtcGVyZm9ybWFuY2UtY2hlY2tsaXN0cy1mb3Itc3Jlcw==" title="http://www.slideshare.net/brendangregg/srecon-2016-performance-checklists-for-sres">slideshare<i class="fa fa-external-link"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9TbGlkZXMvU1JFY29uXzIwMTZfcGVyZl9jaGVja2xpc3RzLnBkZg==" title="https://www.brendangregg.com/Slides/SREcon_2016_perf_checklists.pdf">PDF<i class="fa fa-external-link"></i></span> 上。我在一篇<span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTYtMDUtMDQvc3JlY29uMjAxNi1wZXJmLWNoZWNrbGlzdHMtZm9yLXNyZXMuaHRtbA==" title="https://www.brendangregg.com/blog/2016-05-04/srecon2016-perf-checklists-for-sres.html">博文<i class="fa fa-external-link"></i></span>中附上了核对表。  </p><h2 id="Resources-相关资源"><a href="#Resources-相关资源" class="headerlink" title="Resources 相关资源"></a>Resources 相关资源</h2><p>Other resources (not by me) I’d recommend for the topic of Linux performance:</p><p>关于 Linux 性能主题，我想推荐的其他资源（不是我写的）：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1ja2FydkdKRThRYw==" title="https://www.youtube.com/watch?v=ckarvGJE8Qc">Performance analysis &amp; tuning of Red Hat Enterprise Linux - 2015 Red Hat Summit<i class="fa fa-external-link"></i></span> (video 2hrs): this is a great and in-depth tour of Linux performance tuning that should be largely applicable to all Linux distros.</li></ul><p><span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1ja2FydkdKRThRYw==" title="https://www.youtube.com/watch?v=ckarvGJE8Qc">红帽企业 Linux 的性能分析与调优 - 2015 红帽峰会<i class="fa fa-external-link"></i></span>(视频 2 小时）：这是一次深入浅出的 Linux 性能调整之旅，在很大程度上适用于所有 Linux 发行版。</p><p> <strong>(视频 2 小时）：这是一次深入浅出的 Linux 性能调整之旅，在很大程度上适用于所有 Linux 发行版。</strong></p><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5zbGlkZXNoYXJlLm5ldC9EYXJrU3RhclN3b3JkL2luc3RydW1lbnRhdGlvbg==" title="http://www.slideshare.net/DarkStarSword/instrumentation">Linux Instrumentation<i class="fa fa-external-link"></i></span>: slides from a great talk in June 2010 by Ian Munsie, which summarizes the different Linux tracers very well. If you’re trying to understand all the tracers and frameworks, this is worth studying (keeping in mind it’s from 2010).</li></ul><p>这是 Ian Munsie 于 2010 年 6 月发表的精彩演讲的幻灯片，其中很好地总结了不同的 Linux 跟踪器。如果您正试图了解所有跟踪器和框架，那么这篇文章值得一读（请注意这是 2010 年的文章）。</p><ul><li><span class="exturl" data-url="aHR0cDovL2p2bnMuY2Ev" title="http://jvns.ca/">Julia Evans blog<i class="fa fa-external-link"></i></span> has many posts about many topics, including performance tools.</li></ul><p>有许多关于性格讨论等问题的帖子，包括性能工具。</p><ul><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuc3Rnb2xhYnMubmV0L3NlYXJjaC9sYWJlbC9saW51eA==" title="http://blog.stgolabs.net/search/label/linux">Davidlohr Bueso’s<i class="fa fa-external-link"></i></span> Linux performance posts.</li></ul><p>Linux 性能讨论文章。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      Linux性能
    
    </summary>
    
    
      <category term="Linux" scheme="https://whitestore.top/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://whitestore.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【Java】BIO源码分析和改造（GraalVM JDK 11.0.19）</title>
    <link href="https://whitestore.top/2023/07/27/biosocketstart/"/>
    <id>https://whitestore.top/2023/07/27/biosocketstart/</id>
    <published>2023-07-27T03:43:47.000Z</published>
    <updated>2023-09-09T00:54:05.258Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>本文介绍网络IO编程的入门部分，Java 的传统BIO Socket编程源码分析，了解如何将BIO阻塞行为<code>accept()</code> 和 <code>read()</code> 改造为非阻塞行为，并且将结合Linux文档介绍其中的机制，文档中描述了如何处理<code>Socket</code>的<code>accept</code>，对比Java的Socket实现代码，基本可以发现和Linux行为基本一致。</p><p>废话不多说，我们直接开始。</p><h1 id="draw-io-文件"><a href="#draw-io-文件" class="headerlink" title="draw.io 文件"></a>draw.io 文件</h1><p>本文涉及的个人源码分析绘图均由 <code>draw.io</code> 绘制，源文件如下：</p><p>链接：<span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMUZIQVl0NEF4V2gwRGQ0cWkySktaTFE/cHdkPXFzbWc=" title="https://pan.baidu.com/s/1FHAYt4AxWh0Dd4qi2JKZLQ?pwd=qsmg">https://pan.baidu.com/s/1FHAYt4AxWh0Dd4qi2JKZLQ?pwd=qsmg <i class="fa fa-external-link"></i></span><br>提取码：qsmg </p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230717073204.png" alt="image.png"></p><a id="more"></a><h1 id="什么是Socket？"><a href="#什么是Socket？" class="headerlink" title="什么是Socket？"></a>什么是Socket？</h1><p>Socket起源于Unix的一种通信机制，中文通常叫他“套接字”，代表了网络IP和端口，可以看作是通信过程的一个“句柄”。</p><p>Socket 也可以理解为网络编程当中的API，编程语言提供了对应的API实现方式，电脑上的网络应用程序也是通过“套接字”完成网络请求接受与应答。</p><p>总而言之：<strong>Socket是应用层与TCP/IP协议族通信的中间软件抽象层</strong>。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230705110036.png" alt="Socket是应用层与TCP/IP协议族通信的中间软件抽象层"></p><blockquote><p>图片来源：<span class="exturl" data-url="aHR0cHM6Ly93d3cudG9wZ29lci5jb20vJUU3JUJEJTkxJUU3JUJCJTlDJUU3JUJDJTk2JUU3JUE4JThCL3NvY2tldCVFNyVCQyU5NiVFNyVBOCU4Qi9zb2NrZXQlRTUlOUIlQkUlRTglQTclQTMuaHRtbA==" title="https://www.topgoer.com/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/socket%E7%BC%96%E7%A8%8B/socket%E5%9B%BE%E8%A7%A3.html">socket图解 · Go语言中文文档 (topgoer.com)<i class="fa fa-external-link"></i></span></p></blockquote><h1 id="阻塞式IO模型"><a href="#阻塞式IO模型" class="headerlink" title="阻塞式IO模型"></a>阻塞式IO模型</h1><p>在 <strong>《UNIX Network Programming》</strong> 一书当中，用UDP传输的案例模拟了阻塞式的IO模型，这个模型的概念和Java BIO的阻塞模型类似。</p><p>下面函数中应用进程在调用 <code>recvfrom</code> 之后就开始系统调用并且进行阻塞，等待内核把数据准备并且复制完成之后才得到结果，或者等待过程中发生错误返回。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230411212436.png" alt="阻塞式IO模型"></p><p>从图片可以看到，在内核工作的整个过程中应用进程无法做其他任何操作。</p><h1 id="BIO-通信模型"><a href="#BIO-通信模型" class="headerlink" title="BIO 通信模型"></a>BIO 通信模型</h1><p>我们把上面的阻塞IO模型转为IO通信模型，结果如下：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230705103727.png" alt="BIO 通信模型"></p><p>BIO对于每一个客户端进行阻塞等待接收连接，同一个时间只能处理一个Socket请求，并且在构建完成之后通常会分配一个Thread线程为其进行服务。</p><h1 id="BIO-阻塞案例代码"><a href="#BIO-阻塞案例代码" class="headerlink" title="BIO 阻塞案例代码"></a>BIO 阻塞案例代码</h1><h2 id="BioClientSocket"><a href="#BioClientSocket" class="headerlink" title="BioClientSocket"></a>BioClientSocket</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> *  BioClientSocket 客户端 Socket实现  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Xander  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> v1.0.0  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Package</span> : com.zxd.interview.niosource.bio  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> : BioClientSocket 客户端 Socket实现  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Create</span> on : 2023/7/5 09:52  </span></span><br><span class="line"><span class="comment"> **/</span><span class="meta">@Slf</span>4j  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BioClientSocket</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initBIOClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;  </span><br><span class="line">        BufferedReader reader = <span class="keyword">null</span>;  </span><br><span class="line">        BufferedWriter writer = <span class="keyword">null</span>;  </span><br><span class="line">        Socket socket = <span class="keyword">null</span>;  </span><br><span class="line">        String inputContent;  </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));  </span><br><span class="line">            socket = <span class="keyword">new</span> Socket(host, port);  </span><br><span class="line">            writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(socket.getOutputStream()));  </span><br><span class="line">            log.info(<span class="string">"clientSocket started: "</span> + stringNowTime());  </span><br><span class="line">            <span class="keyword">while</span> (((inputContent = reader.readLine()) != <span class="keyword">null</span>) &amp;&amp; count &lt; <span class="number">2</span>) &#123;  </span><br><span class="line">                inputContent = stringNowTime() + <span class="string">": 第"</span> + count + <span class="string">"条消息: "</span> + inputContent + <span class="string">"\n"</span>;  </span><br><span class="line">                writer.write(inputContent);<span class="comment">//将消息发送给服务端  </span></span><br><span class="line">                writer.flush();  </span><br><span class="line">                count++;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                socket.close();  </span><br><span class="line">                reader.close();  </span><br><span class="line">                writer.close();  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">stringNowTime</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);  </span><br><span class="line">        <span class="keyword">return</span> format.format(<span class="keyword">new</span> Date());  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        BioClientSocket client = <span class="keyword">new</span> BioClientSocket();  </span><br><span class="line">        client.initBIOClient(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>);  </span><br><span class="line">    &#125;<span class="comment">/**  </span></span><br><span class="line"><span class="comment">     运行结果：  </span></span><br><span class="line"><span class="comment">     clientSocket started: 2023-07-05 10:26:05  </span></span><br><span class="line"><span class="comment">     7978987     797898     tyuytu     */</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="BioServerSocket"><a href="#BioServerSocket" class="headerlink" title="BioServerSocket"></a>BioServerSocket</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * ServerSocket 实现  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Xander  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> v1.0.0  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Package</span> : com.zxd.interview.niosource.bio  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> : ServerSocket 实现  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Create</span> on : 2023/7/5 09:48  </span></span><br><span class="line"><span class="comment"> **/</span><span class="meta">@Slf</span>4j  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BioServerSocket</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initBIOServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;  </span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">null</span>;<span class="comment">//服务端Socket  </span></span><br><span class="line">        Socket socket = <span class="keyword">null</span>;<span class="comment">//客户端socket  </span></span><br><span class="line">        BufferedReader reader = <span class="keyword">null</span>;  </span><br><span class="line">        String inputContent;  </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(port);  </span><br><span class="line">           log.info(stringNowTime() + <span class="string">": serverSocket started"</span>);  </span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </span><br><span class="line">                socket = serverSocket.accept();  </span><br><span class="line">               log.info(stringNowTime() + <span class="string">": id为"</span> + socket.hashCode() + <span class="string">"的Clientsocket connected"</span>);  </span><br><span class="line">                reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));  </span><br><span class="line">                <span class="keyword">while</span> ((inputContent = reader.readLine()) != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                   log.info(<span class="string">"收到id为"</span> + socket.hashCode() + <span class="string">"  "</span> + inputContent);  </span><br><span class="line">                    count++;  </span><br><span class="line">                &#125;  </span><br><span class="line">               log.info(<span class="string">"id为"</span> + socket.hashCode() + <span class="string">"的Clientsocket "</span> + stringNowTime() + <span class="string">"读取结束"</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="keyword">if</span>(Objects.nonNull(reader))&#123;  </span><br><span class="line">  </span><br><span class="line">                    reader.close();  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">if</span>(Objects.nonNull(socket))&#123;  </span><br><span class="line">  </span><br><span class="line">                    socket.close();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">    &#125;<span class="comment">/**  </span></span><br><span class="line"><span class="comment">     运行结果：  </span></span><br><span class="line"><span class="comment">     10:25:57.731 [main] INFO com.zxd.interview.niosource.bio.BioServerSocket - 2023-07-05 10:25:57: serverSocket started  </span></span><br><span class="line"><span class="comment">     10:26:08.442 [main] INFO com.zxd.interview.niosource.bio.BioServerSocket - 2023-07-05 10:26:08: id为161960012的Clientsocket connected  </span></span><br><span class="line"><span class="comment">     10:26:29.356 [main] INFO com.zxd.interview.niosource.bio.BioServerSocket - 收到id为161960012  2023-07-05 10:26:26: 第0条消息: 7978987  </span></span><br><span class="line"><span class="comment">     10:26:34.409 [main] INFO com.zxd.interview.niosource.bio.BioServerSocket - 收到id为161960012  2023-07-05 10:26:34: 第1条消息: 797898  </span></span><br><span class="line"><span class="comment">     10:26:38.298 [main] INFO com.zxd.interview.niosource.bio.BioServerSocket - id为161960012的Clientsocket 2023-07-05 10:26:38读取结束  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">stringNowTime</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);  </span><br><span class="line">        <span class="keyword">return</span> format.format(<span class="keyword">new</span> Date());  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        BioServerSocket server = <span class="keyword">new</span> BioServerSocket();  </span><br><span class="line">        server.initBIOServer(<span class="number">8888</span>);  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BIO 阻塞模型中，需要关注的代码主要是这几个：</p><ul><li><code>serverSocket = new ServerSocket(port);</code></li><li><code>socket = serverSocket.accept();</code></li><li><code>socket = new Socket(host, port);</code></li></ul><p>从代码中可以看出，客户端在获取Socket建立连接后，通过系统输入输出流完成读写IO操作，服务端则通过系统缓冲流Buffer来提高读写效率。 </p><h1 id="ServerSocket-中-bind-解读"><a href="#ServerSocket-中-bind-解读" class="headerlink" title="ServerSocket 中 bind 解读"></a>ServerSocket 中 bind 解读</h1><p>在具体的解读之前，先看下整个调用的大致流程图。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230706174016.png" alt="ServerSocket 中 bind 解读"></p><p>由于是<code>ServerSocket</code>服务端先启动，这里先对<code>bind</code>操作进行解读，<code>bind</code>操作是在本机的某个端口和IP地址上进行listen监听。</p><p>在bind成功之后，服务端进入<code>accept</code>阻塞等待，此时客户端Socket请求此地址将会进行Socket连接绑定。</p><p>我们从<code>ServerSocket</code>的初始化代码作为入口进行介绍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.net.ServerSocket#ServerSocket(int)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServerSocket</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(port, <span class="number">50</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServerSocket</span><span class="params">(<span class="keyword">int</span> port, <span class="keyword">int</span> backlog, InetAddress bindAddr)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    setImpl();</span><br><span class="line">    <span class="comment">// 检查端口是否越界</span></span><br><span class="line">    <span class="comment">// 0xFFFF = 15 * 16^3 + 15 * 16^2 + 15 * 16^1 + 15 * 16^0 = **65535**</span></span><br><span class="line">    <span class="keyword">if</span> (port &lt; <span class="number">0</span> || port &gt; <span class="number">0xFFFF</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"Port value out of range: "</span> + port);</span><br><span class="line">    <span class="keyword">if</span> (backlog &lt; <span class="number">1</span>)</span><br><span class="line">        backlog = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 核心部分</span></span><br><span class="line">        bind(<span class="keyword">new</span> InetSocketAddress(bindAddr, port), backlog);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(SecurityException e) &#123;</span><br><span class="line">        close();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">        close();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>setImpl();</code>这个方法我们先暂时放到一边，我们简单扫一下其他代码。</p><p>在上面的案例代码当中，我们传入的<code>ip</code>和<code>port</code>都处在合法的范围内，Socket规定的端口范围是<strong>0 - 65525</strong>，超过这个范围不允许进行<code>bind</code>。</p><p>上面代码的核心逻辑是<code>bind(xxx)</code>这一段操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind(<span class="keyword">new</span> InetSocketAddress(bindAddr, port), backlog);</span><br></pre></td></tr></table></figure><h2 id="new-InetSocketAddress-bindAddr-port"><a href="#new-InetSocketAddress-bindAddr-port" class="headerlink" title="new InetSocketAddress(bindAddr, port)"></a>new InetSocketAddress(bindAddr, port)</h2><p>在<code>bind</code>方法调用之前，<code>ServerSocket</code>会先构建 <strong>InetSocketAddress</strong> 对象。<strong>InetSocketAddress</strong>对象构建实际为<strong>InetSocketAddressHolder</strong>包装类。包装类的作用是可以防止<code>IP</code>和<code>Port</code>等敏感字段的外部篡改。</p><p>此外从代码可以看到，构建对象会对于<code>IP</code>和<code>Port</code>进行二次检查，如果IP地址不存在，会给一个默认值（通常是<code>0.0.0.0</code> ）。</p><blockquote><p>Creates a socket address from an IP address and a port number.<br>    A valid port value is between 0 and 65535. A port number of zero will let the system pick up an ephemeral port in a bind operation.|<br>    根据IP地址和端口号创建Socket地址。有效的端口值介于0和65535之间。端口号为0时，系统将在绑定操作中使用短暂端口。</p></blockquote><p><strong>InetSocketAddressHolder</strong> 对象构建完成之后，接着就进入到核心的<code>bind(SocketAddress endpoint, int backlog)</code>内部代码。</p><h2 id="bind-SocketAddress-endpoint-int-backlog"><a href="#bind-SocketAddress-endpoint-int-backlog" class="headerlink" title="bind(SocketAddress endpoint, int backlog)"></a>bind(SocketAddress endpoint, int backlog)</h2><p><strong>java.net.ServerSocket#bind(java.net.SocketAddress, int)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Binds the ServerSocket to a specific address (IP address and port number).</span></span><br><span class="line"><span class="comment">将ServerSocket绑定到一个特定的地址（IP地址和端口号）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">If the address is null, then the system will pick up an ephemeral port and a valid local address to bind the socket.</span></span><br><span class="line"><span class="comment">如果地址为空，那么系统会选取一个短暂的端口和一个有效的本地地址来绑定套接字。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(SocketAddress endpoint, <span class="keyword">int</span> backlog)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// Socket是否已经被关闭</span></span><br><span class="line">        <span class="keyword">if</span> (isClosed())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Socket is closed"</span>);</span><br><span class="line">        <span class="comment">// 判断是否已经绑定</span></span><br><span class="line">        <span class="keyword">if</span> (!oldImpl &amp;&amp; isBound())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Already bound"</span>);</span><br><span class="line">        <span class="keyword">if</span> (endpoint == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 如果地址为空，给一个默认地址</span></span><br><span class="line">            endpoint = <span class="keyword">new</span> InetSocketAddress(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (!(endpoint <span class="keyword">instanceof</span> InetSocketAddress))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unsupported address type"</span>);</span><br><span class="line">        <span class="comment">// 类型强转为 InetSocketAddress</span></span><br><span class="line">        InetSocketAddress epoint = (InetSocketAddress) endpoint;</span><br><span class="line">        <span class="comment">// 如果地址已经被占用了</span></span><br><span class="line">        <span class="keyword">if</span> (epoint.isUnresolved())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Unresolved address"</span>);</span><br><span class="line">        <span class="keyword">if</span> (backlog &lt; <span class="number">1</span>)</span><br><span class="line">          backlog = <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SecurityManager security = System.getSecurityManager();</span><br><span class="line">            <span class="keyword">if</span> (security != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 端口进行安全检查</span></span><br><span class="line">                security.checkListen(epoint.getPort());</span><br><span class="line">            getImpl().bind(epoint.getAddress(), epoint.getPort());</span><br><span class="line">            getImpl().listen(backlog);</span><br><span class="line">            bound = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(SecurityException e) &#123;</span><br><span class="line">            bound = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">            bound = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>bind 方法是将 <strong>ServerSocket</strong> 绑定到一个特定的地址（IP地址和端口号）， 如果地址为空，那么系统会选取一个临时端口和有效的本地地址来绑定 ServerSocket。</p><p>跳过不需要关注的校验代码，在·<code>try</code> 中有三行比较重要的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getImpl().bind(epoint.getAddress(), epoint.getPort());  </span><br><span class="line">getImpl().listen(backlog);  </span><br><span class="line">bound = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p>这里的代码初步理解是获取一个<code>impl</code>对象，绑定地址和端口，调用<code>listen</code>方法传递<code>backlog</code>。</p><p><code>backlog</code>这个值的作用可以看下面的地址，这里整理文章内容大致理解：</p><ul><li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubGludXhqb3VybmFsLmNvbS9maWxlcy9saW51eGpvdXJuYWwuY29tL2xpbnV4am91cm5hbC9hcnRpY2xlcy8wMjMvMjMzMy8yMzMzczIuaHRtbA==" title="https://www.linuxjournal.com/files/linuxjournal.com/linuxjournal/articles/023/2333/2333s2.html">Linux Network Programming, Part 1 (linuxjournal.com)<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMDQ4NzQ2MDU=" title="https://zhuanlan.zhihu.com/p/104874605">详解socket中的backlog 参数 - 知乎 (zhihu.com)<i class="fa fa-external-link"></i></span></p></li></ul><p><code>backlog</code>主要是和<code>Socket</code>有关。在Socket编程中<strong>listen函数的第二个参数为backlog</strong>，用于服务器编程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">listen</span>(sock, backlog);</span><br></pre></td></tr></table></figure><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230706114407.png" alt="TCP 握手"></p><p>在TCP 三次握手当中，LISTEN 状态的服务端 Socket 收到 SYN，会建立一个 <strong>SYN_REVD</strong> 的连接，<strong>SYN_REVD</strong> 是一个半连接状态，只有在收到客户端的ACK之后才会进入<strong>ESTABLISHED</strong>，也就是说三次握手的过程必然会经历<strong>SYN_REVD</strong>和<strong>ESTABLISHED</strong>两个状态。</p><p>针对这两个状态，不同的操作系统有不同实现，<strong>在 FressBSD 中 backlog 就是描述状态为 SYN_REVD 和 ESTABLISHED 的所有连接最大数量</strong>。</p><p>在 Linux 系统当中，使用两个队列 <strong>syn queue</strong>和 <strong>accept queue</strong>，这两个队列分别存储状态为<strong>SYN_REVD</strong>和状态为<strong>ESTABLISHED</strong>的连接，<strong>Llinux2.2及以后，backlog表示accept queue的大小</strong>，而syn queue大小由 <code>/proc/sys/net/ipv4/tcp_max_syn_backlog</code>配置。</p><p>可以看到backlog的值直接影响了建立连接的效率。上面代码中<code>backlog=50</code>，可以认为 accept queue 的容量为 50。</p><p><code>listen</code>方法执行完成之后，此时将设置<code>bound = true</code>，代码执行到此处说明<code>Socket</code>绑定成功了。</p><p>现在我们回过头看<code>getImpl().bind(epoint.getAddress(), epoint.getPort());</code>这块代码工作。</p><h2 id="setImpl"><a href="#setImpl" class="headerlink" title="setImpl()"></a>setImpl()</h2><p>介绍<code>getImpl()</code>的前提是我们要知道如何<code>set</code>的，具体代码位于构造方法中一行不起眼的<code>setImpl()</code>操作。</p><p><strong>java.net.ServerSocket#setImpl</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (factory != <span class="keyword">null</span>) &#123;</span><br><span class="line">            impl = factory.createSocketImpl();</span><br><span class="line">            checkOldImpl();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// No need to do a checkOldImpl() here, we know it's an up to date</span></span><br><span class="line">            <span class="comment">// SocketImpl!</span></span><br><span class="line">            impl = <span class="keyword">new</span> SocksSocketImpl();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (impl != <span class="keyword">null</span>)</span><br><span class="line">            impl.setServerSocket(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注意，在第一次初始化的时候，<code>SocketImplFactory</code>是没有被初始化过的，所以走的是<code>else</code>分支，具体工作是为内部的成员变量 <code>SocketImpl</code>进行初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * The implementation of this Socket. */</span></span><br><span class="line"><span class="keyword">private</span> SocketImpl impl;</span><br></pre></td></tr></table></figure><p><code>SocksSocketImpl</code> 初始化之后，将会设置它的成员变量<code>ServerSocket</code>为<code>this</code>引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (impl != <span class="keyword">null</span>)  </span><br><span class="line">    impl.setServerSocket(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>这里的处理工作很简单，分别是初始化 <strong>SocksSocketImpl</strong> ，把当前对象实例的this引用传递给这个初始化的 <strong>SocksSocketImpl</strong> 的成员变量（这时候自身的引用逸出了）。</p><p>了解<code>setImpl</code>之后，下面这里我们再看看 <code>getImpl()</code> 干了啥。</p><h2 id="getImpl"><a href="#getImpl" class="headerlink" title="getImpl()"></a>getImpl()</h2><p><strong>java.net.ServerSocket#getImpl</strong></p><p>代码内容也比较简单，首先检查<code>SocketImpl</code>是否创建，第一次连接这里为<code>false</code>，此时会进入<code>createImpl()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Get the SocketImpl attached to this socket, creating it if necessary.</span></span><br><span class="line"><span class="comment">获取连接到此套接字的SocketImpl，如果有必要，可以创建它。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">SocketImpl <span class="title">getImpl</span><span class="params">()</span> <span class="keyword">throws</span> SocketException </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (!created)  </span><br><span class="line">        createImpl();  </span><br><span class="line">    <span class="keyword">return</span> impl;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>createImpl()</code>当中，通常 <strong>SocketImpl</strong> 已经在构造器初始化完成，这里直接更新 <code>created</code> 状态即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createImpl</span><span class="params">()</span> <span class="keyword">throws</span> SocketException </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (impl == <span class="keyword">null</span>)  </span><br><span class="line">        setImpl();  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        impl.create(<span class="keyword">true</span>);  </span><br><span class="line">        created = <span class="keyword">true</span>;  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(e.getMessage());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>setImpl()</code> 和 <code>getImpl()</code>方法配合，可以确定 <strong>SocketImpl</strong> 在使用的时候一定是被初始化完成的。</p><h3 id="SocketImpl-bind-epoint-getAddress-epoint-getPort"><a href="#SocketImpl-bind-epoint-getAddress-epoint-getPort" class="headerlink" title="SocketImpl.bind(epoint.getAddress(), epoint.getPort())"></a>SocketImpl.bind(epoint.getAddress(), epoint.getPort())</h3><p>下面再来看看它是如何进行下面两项关键操作的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getImpl().bind(epoint.getAddress(), epoint.getPort());  </span><br><span class="line">getImpl().listen(backlog);</span><br></pre></td></tr></table></figure><p>在之前的初始化代码中，<code>InetAddress</code>对象初始化设置了<code>IP</code>和<code>Port</code>等参数，现在委托 <strong>SocketImpl</strong>执行具体<code>bind</code>操作。</p><p><strong>java.net.AbstractPlainSocketImpl#bind</strong></p><p><code>bind</code>方法是同步的，一开始需要先获取到<code>fdLock</code>锁，然后判断是否满足<code>Socket</code>绑定条件，如果满足则利用钩子(<code>NetHooks</code>) 对象进行前置TCP绑定。</p><blockquote><p>注意，个人发现<code>NetHooks.beforeTcpBind(fd, address, lport);</code>方法发现在<strong>JDK11</strong>之中是一个<strong>空方法</strong>，而<strong>JDK8</strong>当中会有一段<code>provider.implBeforeTcpBind(fdObj, address, port);</code>的调用。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(InetAddress address, <span class="keyword">int</span> lport)</span>  </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"><span class="comment">// 获取 fdLock 锁</span></span><br><span class="line">   <span class="keyword">synchronized</span> (fdLock) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (!closePending &amp;&amp; (socket == <span class="keyword">null</span> || !socket.isBound())) &#123;  </span><br><span class="line">            NetHooks.beforeTcpBind(fd, address, lport);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 是否链接本地地址</span></span><br><span class="line">    <span class="keyword">if</span> (address.isLinkLocalAddress()) &#123;  </span><br><span class="line">        address = IPAddressUtil.toScopedAddress(address);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 关键</span></span><br><span class="line">    socketBind(address, lport);  </span><br><span class="line">    <span class="comment">// 服务端和客户端的Socket走不同的 if 判断</span></span><br><span class="line">    <span class="keyword">if</span> (socket != <span class="keyword">null</span>)  </span><br><span class="line">        socket.setBound();  </span><br><span class="line">    <span class="keyword">if</span> (serverSocket != <span class="keyword">null</span>)  </span><br><span class="line">        serverSocket.setBound();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加锁部分和核心逻辑无太多干系，我们跳过细枝末节，看<code>socketBind(address, lport);</code>这部分代码。</p><blockquote><p>fdLock 锁作用：注释说明它用于在增加/减少<strong>fdUseCount</strong>时锁定。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* lock when increment/decrementing fdUseCount */</span>  </span><br><span class="line"><span class="comment">// 在增加/减少fdUseCount时锁定</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Object fdLock = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><h3 id="PlainSocketImpl-socketBind-InetAddress-address-int-port"><a href="#PlainSocketImpl-socketBind-InetAddress-address-int-port" class="headerlink" title="PlainSocketImpl#socketBind(InetAddress address, int port)"></a>PlainSocketImpl#socketBind(InetAddress address, int port)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">socketBind</span><span class="params">(InetAddress address, <span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> nativefd = checkAndReturnNativeFD();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (address == <span class="keyword">null</span>)  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"inet address argument is null."</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 目前IPv4地址已经分配完毕，所以优先用 IPV6的，并且不支持 IPV4 </span></span><br><span class="line">    <span class="keyword">if</span> (preferIPv4Stack &amp;&amp; !(address <span class="keyword">instanceof</span> Inet4Address))  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Protocol family not supported"</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 核心操作</span></span><br><span class="line">    bind0(nativefd, address, port, useExclusiveBind);  </span><br><span class="line">    <span class="comment">// 如果是之前 InetAddress 为空默认初始化的端口为0，则重新随机分配一个端口</span></span><br><span class="line">    <span class="keyword">if</span> (port == <span class="number">0</span>) &#123;  </span><br><span class="line">        localport = localPort0(nativefd);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        localport = port;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">this</span>.address = address;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>socketBind(address, lport);</code>方法调用，最后绑定操作为JVM的底层C++操作<code>bind0</code>。</p><p><code>bind0</code>属于比较底层的代码，这里我们就不继续探究了，如果读者好奇，可以阅读 <code>HotSpot</code> 的开源实现代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">bind0</span><span class="params">(<span class="keyword">int</span> fd, InetAddress localAddress, <span class="keyword">int</span> localport,  </span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">boolean</span> exclBind)</span>  </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><p>从整体上看，上面这一整个<code>bind</code>操作都是同步完成的，主要逻辑是先做一系列检查，之后调用底层的JVM方法完成<code>Socket</code>绑定。</p><h2 id="画图小结"><a href="#画图小结" class="headerlink" title="画图小结"></a>画图小结</h2><p>笔者通过个人理解画了一幅图，主要描述了 <code>bind</code> 操作大致的逻辑，可以看到很多地方都和<code>JVM</code>的底层C++代码打交道。</p><blockquote><p>有必要说明一下，BIO毕竟是 Java1.0 出来的玩意，看源码我们要抓大放小，后续的JDK提案中，有人提出要收拾这个老古董=-=。</p></blockquote><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230707151128.png" alt="ServerSocket的bind"></p><blockquote><p> 从图中也可以看出，要完成Socket连接构建，必须要获得文件描述符。</p></blockquote><h1 id="ServerSocket中accept解读"><a href="#ServerSocket中accept解读" class="headerlink" title="ServerSocket中accept解读"></a>ServerSocket中accept解读</h1><p><code>ServerSocket</code>的<code>accpet</code>是如何阻塞获取连接的？</p><p><code>accept</code>方法的作用是询问操作系统是否有收到新的<code>Socket</code>套接字信息，操作过程在操作系统底层调用实现上都是 <strong>同步</strong>的。</p><p>操作系统从<code>Socket</code>中没有<code>Socket</code>连接进来怎么办？根据Linux的<code>accept</code>文档描述，以及Java注释的JavaDoc文档描述，都明确说明此时会在底层操作系统<strong>阻塞</strong> 。</p><h2 id="java-net-ServerSocket-accept"><a href="#java-net-ServerSocket-accept" class="headerlink" title="java.net.ServerSocket#accept"></a>java.net.ServerSocket#accept</h2><p>我们从代码层面看看 <code>accept</code> 方法干了啥。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Listens for a connection to be made to this socket and accepts it. The method blocks until a connection is made.</span></span><br><span class="line"><span class="comment">监听并接受与此套接字的连接。该方法会阻塞，直到有一个连接被建立。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">A new Socket s is created and, if there is a security manager, the security manager's checkAccept method is called with s.getInetAddress().getHostAddress() and s.getPort() as its arguments to ensure the operation is allowed. This could result in a SecurityException.</span></span><br><span class="line"><span class="comment">一个新的Socket s被创建，如果有一个安全管理器，安全管理器的checkAccept方法被调用，参数是s.getInetAddress().getHostAddress()和s.getPort()，以确保该操作被允许。这可能会导致一个SecurityException。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Socket <span class="title">accept</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (isClosed())  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Socket is closed"</span>);  </span><br><span class="line">    <span class="keyword">if</span> (!isBound())  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Socket is not bound yet"</span>);  </span><br><span class="line">    Socket s = <span class="keyword">new</span> Socket((SocketImpl) <span class="keyword">null</span>);  </span><br><span class="line">    implAccept(s);  </span><br><span class="line">    <span class="keyword">return</span> s;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java Doc 说明了<code>accept()</code>会进行阻塞，这里疑问比较大的点可能是<code>Socket s = new Socket((SocketImpl) null);</code>，这行代码为什么又要新建一个<code>Socket</code>？带着疑问我们继续看<code>implAccept(s);</code>方法。</p><h2 id="java-net-ServerSocket-implAccept"><a href="#java-net-ServerSocket-implAccept" class="headerlink" title="java.net.ServerSocket#implAccept"></a>java.net.ServerSocket#implAccept</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Subclasses of ServerSocket use this method to override accept() to return their own subclass of socket. So a FooServerSocket will typically hand this method an empty FooSocket. On return from implAccept the FooSocket will be connected to a client.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">ServerSocket的子类使用这个方法来覆盖accept()（的行为），以返回他们自己的socket子类。比如一个FooServerSocket通常会将一个空的FooSocket交给这个方法。从 implAccept 返回时，FooSocket 将被连接到一个客户端。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">implAccept</span><span class="params">(Socket s)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">    SocketImpl si = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">    <span class="comment">// 判断新对象 Socketimpl 是否设置</span></span><br><span class="line">        <span class="keyword">if</span> (s.impl == <span class="keyword">null</span>)  </span><br><span class="line">          s.setImpl();  </span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">            s.impl.reset();  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// si 指向 Socket 对象的 impl </span></span><br><span class="line">        si = s.impl; </span><br><span class="line">        <span class="comment">// Socket 对象的 impl 引用 暂时置空</span></span><br><span class="line">        s.impl = <span class="keyword">null</span>;  </span><br><span class="line">        <span class="comment">// impl 地址和文件描述符初始化</span></span><br><span class="line">        si.address = <span class="keyword">new</span> InetAddress();  </span><br><span class="line">        si.fd = <span class="keyword">new</span> FileDescriptor();  </span><br><span class="line">        <span class="comment">// getImpl() 获取的是 ServerSocket 的 impl，注意不是 Socket的</span></span><br><span class="line"><span class="comment">// 4. 调用 ServerSocket 持有的 SocksSocketImpl 对象完成底层操作系统的 accept 操作</span></span><br><span class="line">        getImpl().accept(si);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// raw fd has been set </span></span><br><span class="line"><span class="comment">// 原始fd已被设置  </span></span><br><span class="line">        SocketCleanable.register(si.fd);    </span><br><span class="line"><span class="comment">// 安全检查</span></span><br><span class="line">        SecurityManager security = System.getSecurityManager();  </span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            security.checkAccept(si.getInetAddress().getHostAddress(),  </span><br><span class="line">                                 si.getPort());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">    <span class="comment">// 如果出现底层IO异常，则s.impl = si;把之前临时置空的引用给重置回来</span></span><br><span class="line">        <span class="keyword">if</span> (si != <span class="keyword">null</span>)  </span><br><span class="line">            si.reset();  </span><br><span class="line">        s.impl = si;  </span><br><span class="line">        <span class="keyword">throw</span> e;  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException e) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (si != <span class="keyword">null</span>)  </span><br><span class="line">            si.reset();  </span><br><span class="line">        s.impl = si;  </span><br><span class="line">        <span class="keyword">throw</span> e;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 把之前临时置空的引用给重置回来</span></span><br><span class="line">    s.impl = si;  </span><br><span class="line">    s.postAccept();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码首先进入一个<code>if</code>判断，检查 <code>new Socket</code> 新对象的<strong>Socketimpl</strong>是否设置，如果为空则就设置，如果不为空，则<code>reset()</code> 重置。</p><p>毫无疑问，这里是刚刚初始化的<code>Socket</code>，此时<strong>Socket.Socketimpl</strong> 肯定是没有设置的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s.impl == <span class="keyword">null</span>)  </span><br><span class="line">  s.setImpl();  </span><br><span class="line"><span class="keyword">else</span> &#123;  </span><br><span class="line">s.impl.reset();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首次进入代码通常就是走<code>if</code>分支。<code>Socket.setImpl</code> 这个方法和<code>ServerSocket</code>的<code>setImpl</code>非常像，<code>new Socket</code> 新对象会为自己的 <strong>SocketImpl</strong> 成员对象进行初始化。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230707160516.png" alt="SocketImpl"></p><p>至此，我们画图理解代码操作逻辑：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230707161437.png" alt="accept 操作分析"></p><p>接下来是一些有点”绕“的操作，建议读者边调试边跟着图示理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. si 指向 Socket 对象的 impl </span></span><br><span class="line">si = s.impl; </span><br><span class="line"><span class="comment">// 2. Socket 对象的 impl引用 暂时置空</span></span><br><span class="line">s.impl = <span class="keyword">null</span>;  </span><br><span class="line"><span class="comment">// 3. impl 地址和文件描述符初始化</span></span><br><span class="line">si.address = <span class="keyword">new</span> InetAddress();  </span><br><span class="line">si.fd = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line"><span class="comment">// getImpl() 获取的是 ServerSocket 的 impl，注意不是 Socket的</span></span><br><span class="line"><span class="comment">// 4. 调用 ServerSocket 持有的 SocksSocketImpl 对象完成底层操作系统的 accept 操作</span></span><br><span class="line">getImpl().accept(si);  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line"><span class="comment">// 假设此时 accept 获取到连接</span></span><br><span class="line">s.impl = si;</span><br></pre></td></tr></table></figure><blockquote><p>这里吐槽下老外这种变量命名给规则，啥<code>si</code>呀<code>s</code>，a，b，c，d 的，不画图很容易绕进去。</p></blockquote><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230707163648.png" alt="ServerSocket 中 accepet 解读"></p><p>格外强调下， <code>getImpl()</code> 的 <strong>impl对象</strong>和 <code>si.impl</code> 对象并不是同一个，这些代码内容非常像但是属于不同的类，切记不要混淆。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230707163430.png" alt="实例对象对比"></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230707163500.png" alt="实例对象对比"></p><p>代码最后有必定会执行的 <code>s.impl = si;</code>操作（因为之前暂时把引用“脱钩”了），如果是异常的<code>si</code>还会进行额外的<code>reset</code>重置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.impl = si;</span><br></pre></td></tr></table></figure><p>这里回答一下之前遗留的问题，<code>Socket s = new Socket((SocketImpl) null);</code>这行代码为什么又要新建一个Socket？</p><p>我们观察上面绘制的操作图，<code>s.impl = null;</code>的执行，此时Socket对象和这个<code>SocketImpl</code>暂时”失去关联“，这个时候确保哪怕<code>new Socket</code>对象绑定失败，此时对于<code>SocketImpl</code>来说根本是无感知的。</p><p>换句话说，如果失败了<code>Socket</code>会完全重置，好像什么都没有发送过，而如果成功了，此时把引用“接回去”，必然得到的可用的<code>Socket</code>。</p><blockquote><p>这里给一个不恰当的比喻，当年诸葛亮草船借箭，如果有碰到没有借箭的船，极端一点是不是就可以直接”烧了“不要了，而如果“接”到箭自然需要回港“卸货‘”，对于吴国来说，它们只看到“成功”借到箭的船只。</p></blockquote><p>执行<code>getImpl().accept(si);</code>方法之后，我们在<strong>AbstractPlainSocketImpl</strong>找到<strong>accept</strong>方法。我</p><h3 id="java-net-AbstractPlainSocketImpl-accept"><a href="#java-net-AbstractPlainSocketImpl-accept" class="headerlink" title="java.net.AbstractPlainSocketImpl#accept"></a>java.net.AbstractPlainSocketImpl#accept</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Accepts connections.</span></span><br><span class="line"><span class="comment">接受连接</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(SocketImpl s)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">    acquireFD();  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        socketAccept(s);  </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">        releaseFD();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>accept</code>调用<code>acquireFD();</code>获取并且植入文件描述符号，加锁获取之后会把<strong>fdUseCount</strong> 的计数器值+1，表示有一个新增的<code>Socket</code>连接。</p><blockquote><p>加锁保证 fdUseCount  计数是线程安全的</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// "Acquires" and returns the FileDescriptor for this impl</span></span><br><span class="line"><span class="comment">// - "获取 "并返回该植入物的文件描述符。</span></span><br><span class="line"><span class="function">FileDescriptor <span class="title">acquireFD</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">synchronized</span> (fdLock) &#123;  </span><br><span class="line">        fdUseCount++;  </span><br><span class="line">        <span class="keyword">return</span> fd;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="java-net-PlainSocketImpl-socketAccept"><a href="#java-net-PlainSocketImpl-socketAccept" class="headerlink" title="java.net.PlainSocketImpl#socketAccept"></a>java.net.PlainSocketImpl#socketAccept</h3><p>不同的操作系统实现不同，这里仅以个人看到的<strong>JDK11</strong>版本源码为例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">socketAccept</span><span class="params">(SocketImpl s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">int</span> nativefd = checkAndReturnNativeFD();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"socket is null"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> newfd = -<span class="number">1</span>;</span><br><span class="line">InetSocketAddress[] isaa = <span class="keyword">new</span> InetSocketAddress[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (timeout &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">newfd = accept0(nativefd, isaa);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">configureBlocking(nativefd, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">waitForNewConnection(nativefd, timeout);</span><br><span class="line">newfd = accept0(nativefd, isaa);</span><br><span class="line"><span class="keyword">if</span> (newfd != -<span class="number">1</span>) &#123;</span><br><span class="line">configureBlocking(newfd, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">configureBlocking(nativefd, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Update (SocketImpl)s' fd */</span></span><br><span class="line">fdAccess.set(s.fd, newfd);</span><br><span class="line"><span class="comment">/* Update socketImpls remote port, address and localport */</span></span><br><span class="line">InetSocketAddress isa = isaa[<span class="number">0</span>];</span><br><span class="line">s.port = isa.getPort();</span><br><span class="line">s.address = isa.getAddress();</span><br><span class="line">s.localport = localport;</span><br><span class="line"><span class="keyword">if</span> (preferIPv4Stack &amp;&amp; !(s.address <span class="keyword">instanceof</span> Inet4Address))</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Protocol family not supported"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只关心下面这部分代码，方法中首先判断 <strong>timeout</strong> 是否小于等于<strong>0</strong>（如果没有设置，那么默认就是 0），如果是则走<code>accept0(nativefd, isaa)</code>方法。</p><p>前面反复提到的，<code>accept</code>操作核心实现这是下面的 <code>native accept0</code> 方法，具体操作是：</p><p><strong>在操作系统层面检查<code>bind</code>的端口上是否有客户端数据接入，如果没有则一直阻塞等待</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (timeout &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">newfd = accept0(nativefd, isaa);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">configureBlocking(nativefd, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">waitForNewConnection(nativefd, timeout);</span><br><span class="line">newfd = accept0(nativefd, isaa);  </span><br><span class="line"><span class="keyword">if</span> (newfd != -<span class="number">1</span>) &#123;</span><br><span class="line">configureBlocking(newfd, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">configureBlocking(nativefd, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// &lt;4&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">accept0</span><span class="params">(<span class="keyword">int</span> fd, InetSocketAddress[] isaa)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><p>因为操作系统层面的阻塞需要影响到应用程序级别阻塞？显然<code>accept0(nativefd, isaa)</code>的操作系统层面阻塞是无 法避免的。</p><p>仔细观察代码，上面的代码分支提供了另外一种选择， <strong>timeout</strong> 的值设置大于0的值，此时<strong>程序会在等到我们设置的时间后返回</strong>，并且只会阻塞设置的这个时间量的值（单位毫秒）。</p><blockquote><p>注意，这里的 <strong>newfd</strong> 如果是 -1，表示底层没有任何数据返回，在Linux的文档中也有对应的介绍。</p></blockquote><h3 id="java-net-ServerSocket-setSoTimeout"><a href="#java-net-ServerSocket-setSoTimeout" class="headerlink" title="java.net.ServerSocket#setSoTimeout"></a>java.net.ServerSocket#setSoTimeout</h3><p>既然不阻塞的关键参数是<strong>timeout</strong> ， 接下来我们看下 <strong>timeout</strong> 值要如何设置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Enable/disable SO_TIMEOUT with the specified timeout, in milliseconds. With this option set to a non-zero timeout, a call to accept() for this ServerSocket will block for only this amount of time. If the timeout expires, a java.net.SocketTimeoutException is raised, though the ServerSocket is still valid. The option must be enabled prior to entering the blocking operation to have effect. The timeout must be &gt; 0. A timeout of zero is interpreted as an infinite timeout.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">启用/禁用SO_TIMEOUT，指定超时时间，单位为毫秒。在这个选项被设置为非零超时的情况下，对这个ServerSocket的accept()的调用将只阻塞这个时间量。如果超时过后，会引发java.net.SocketTimeoutException，尽管ServerSocket仍然有效。该选项必须在进入阻塞操作之前启用才能生效。超时必须大于0。超时为0会被解释为无限期超时。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setSoTimeout</span><span class="params">(<span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> SocketException </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (isClosed())  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Socket is closed"</span>);  </span><br><span class="line">    getImpl().setOption(SocketOptions.SO_TIMEOUT, timeout);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单明了，<strong>java.net.SocketOptions#setOption</strong> 方法最终调用的是<code>java.net.AbstractPlainSocketImpl#setOption()</code>。</p><h3 id="java-net-AbstractPlainSocketImpl-setOption"><a href="#java-net-AbstractPlainSocketImpl-setOption" class="headerlink" title="java.net.AbstractPlainSocketImpl#setOption"></a>java.net.AbstractPlainSocketImpl#setOption</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOption</span><span class="params">(<span class="keyword">int</span> opt, Object val)</span> <span class="keyword">throws</span> SocketException </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (isClosedOrPending()) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Socket Closed"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">boolean</span> on = <span class="keyword">true</span>;  </span><br><span class="line">    <span class="keyword">switch</span> (opt) &#123;  </span><br><span class="line"><span class="keyword">case</span> SO_LINGER:  </span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">    <span class="keyword">case</span> SO_TIMEOUT:  </span><br><span class="line">        <span class="keyword">if</span> (val == <span class="keyword">null</span> || (!(val <span class="keyword">instanceof</span> Integer)))</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Bad parameter for SO_TIMEOUT"</span>);</span><br><span class="line">            <span class="keyword">int</span> tmp = ((Integer) val).intValue();</span><br><span class="line">            <span class="keyword">if</span> (tmp &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout &lt; 0"</span>);</span><br><span class="line">            timeout = tmp;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TCP_NODELAY:  </span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    <span class="keyword">case</span> SO_RCVBUF:  </span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    <span class="keyword">case</span> SO_KEEPALIVE:  </span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;  </span><br><span class="line">    socketSetOption(opt, on, val);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了方便阅读，这里把其他的代码都删除了，只保留传参部分。</p><p>可以看到，这里仅仅是将<code>setOption</code>里面传入的<code>timeout</code>值，设置到了<code>AbstractPlainSocketImpl</code>的全局变量<code>timeout</code>。</p><h2 id="画图小结-1"><a href="#画图小结-1" class="headerlink" title="画图小结"></a>画图小结</h2><p>个人认为整个<code>accept()</code>操作比较”恶心“（个人观点）的是几个引用的赋值变化上面，暂时”解绑“的目的是在进行底层Socket连接的时候，如果<code>Socket</code>出现异常也没有影响，此时<code>Socket</code>持有的引用也是<code>null</code>，可以无阻碍的重新进行下一次Socket连接。</p><p>换句话说，<strong>整个Socket要么对接成功，要么就是重置回没对接之前的状态可以进行下一次尝试，保证ServerSocket会收到一个没有任何异常的Socket连接</strong>。</p><p>最后再看一眼图：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230707175534.png" alt="accept 操作总结"></p><h1 id="改造并实现accept的非阻塞实现"><a href="#改造并实现accept的非阻塞实现" class="headerlink" title="改造并实现accept的非阻塞实现"></a>改造并实现accept的非阻塞实现</h1><p>在进行案例程序的改造之前，必须要先理解<strong>同步、异步、阻塞、非阻塞</strong>这几个概念。</p><p>这个概念在之前的笔记中 [[《跟闪电侠学Netty》阅读笔记 - 开篇入门Netty]] 【洗衣机案例理解阻塞非阻塞，同步异步概念】这一部分提到过，[[【Java】《2小时搞定多线程》个人笔记]] 中又一次对于这几个概念做了个区分。</p><p>区分<strong>同步</strong>和<strong>异步</strong>的关键点是<strong>被调用方的行为</strong>，没有得到结果之前，服务端不返回任何结果，那么操作就是同步的。</p><p>如果没有得到结果之前，服务器可以返回结果，比如给一个<strong>句柄</strong>，通过这个句柄可以在未来某个时间点之后获得结果，那么操作就是<strong>异步</strong>的。</p><blockquote><p>这个句柄可以对应Java 并发编程的 <strong>Future</strong> 的概念</p></blockquote><p>再举个例子，比如说前面的<code>accept0</code>是<strong>应用程序调用操作系统</strong>，在Linux中就是访问系统内核，此时这一整块逻辑处理是选择”<strong>永久等待一个客户端连接</strong>“，符合 <strong>没有得到结果之前，服务端不返回任何结果</strong> 这种情况，所以它是<strong>同步</strong>的。</p><p>区分阻塞和非阻塞的关键点则是 <strong>对于调用者而言的服务端状态*</strong>，比如我们站在线程状态的角度，阻塞对应 <strong>Blocking</strong>，非阻塞此时应该对应<strong>Running</strong>正常执行。再比如站在<strong>线程发出请求</strong>之后请求方的角度，阻塞和非阻塞分别对应<strong>waiting</strong>和<strong>No waiting</strong>。</p><p>理解同步异步阻塞和非阻塞之后，下面来尝试改造相关代码<code>accept</code>的阻塞问题，实现方式很简单，那就是设置 ** <strong>timeout</strong> ** ， 然后在异常处理上<code>continue</code>重试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * accept 超时时间设置  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SO_TIMEOUT = <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * NIO 改写</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> NIO 改写</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> port</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xander</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/7/12 10:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initNioServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">ServerSocket serverSocket = <span class="keyword">null</span>;<span class="comment">//服务端Socket</span></span><br><span class="line">Socket socket = <span class="keyword">null</span>;<span class="comment">//客户端socket</span></span><br><span class="line">BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">String inputContent;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line"><span class="comment">// 1. 需要设置超时时间，会等待设置的时间之后再进行返回</span></span><br><span class="line">serverSocket.setSoTimeout(SO_TIMEOUT);</span><br><span class="line">log.info(stringNowTime() + <span class="string">": serverSocket started"</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">// 2. 如果超时没有获取，这里会抛出异常，这里的处理策略是不处理异常</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">socket = serverSocket.accept();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SocketTimeoutException e) &#123;</span><br><span class="line"><span class="comment">//运行到这里表示本次accept是没有收到任何数据的，服务端的主线程在这里可以做一些其他事情</span></span><br><span class="line">log.info(<span class="string">"now time is: "</span> + stringNowTime());</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">log.info(stringNowTime() + <span class="string">": id为"</span> + socket.hashCode() + <span class="string">"的Clientsocket connected"</span>);</span><br><span class="line">reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line"><span class="keyword">while</span> ((inputContent = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">log.info(<span class="string">"收到id为"</span> + socket.hashCode() + <span class="string">"  "</span> + inputContent);</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">log.info(<span class="string">"id为"</span> + socket.hashCode() + <span class="string">"的Clientsocket "</span> + stringNowTime() + <span class="string">"读取结束"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(Objects.nonNull(reader))&#123;</span><br><span class="line"></span><br><span class="line">reader.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(Objects.nonNull(socket))&#123;</span><br><span class="line"></span><br><span class="line">socket.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">/**运行结果：</span></span><br><span class="line"><span class="comment">     10:40:49.272 [main] INFO com.zxd.interview.niosource.bio.BioServerSocket - 2023-07-12 10:40:49: serverSocket started</span></span><br><span class="line"><span class="comment">     10:40:52.826 [main] INFO com.zxd.interview.niosource.bio.BioServerSocket - now time is: 2023-07-12 10:40:52</span></span><br><span class="line"><span class="comment">     10:40:54.830 [main] INFO com.zxd.interview.niosource.bio.BioServerSocket - now time is: 2023-07-12 10:40:54</span></span><br><span class="line"><span class="comment">     10:40:56.837 [main] INFO com.zxd.interview.niosource.bio.BioServerSocket - now time is: 2023-07-12 10:40:56</span></span><br><span class="line"><span class="comment">     10:40:58.840 [main] INFO com.zxd.interview.niosource.bio.BioServerSocket - now time is: 2023-07-12 10:40:58</span></span><br><span class="line"><span class="comment">     10:41:00.849 [main] INFO com.zxd.interview.niosource.bio.BioServerSocket - now time is: 2023-07-12 10:41:00</span></span><br><span class="line"><span class="comment">     10:41:02.852 [main] INFO com.zxd.interview.niosource.bio.BioServerSocket - now time is: 2023-07-12 10:41:02</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><p>设置了<strong>timeout</strong>之后，<code>accept</code> 方法每次都会在间隔指定时间之后被唤醒一次，如果没有收到连接就会抛出异常，我们的处理方式是吞掉异常并且重新<code>accept</code>，这样就实现了类似非阻塞的效果。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p> Socket 当中 <code>getInputStream()</code> 的方法解析以及后续的<code>read</code>操作结构图如下。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230712151156.png" alt="Socket.getInputStream()"></p><h1 id="Socket-中的-getInputStream-方法解析"><a href="#Socket-中的-getInputStream-方法解析" class="headerlink" title="Socket 中的 getInputStream() 方法解析"></a>Socket 中的 getInputStream() 方法解析</h1><p>实现了非阻塞的<code>accept</code>之后，再来看下另一个会产生阻塞的方法，那就是<code>Socket.getInputStream</code>，这个方法在Socket连接，服务端在<code>read()</code> 读取数据的时候会进行调用。</p><p><strong>java.net.Socket#getInputStream</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">返回该socket的输入流。</span></span><br><span class="line"><span class="comment">如果该套接字有一个关联的通道，那么生成的输入流会将其所有操作委托给该通道。如果通道处于非阻塞模式，那么输入流的读操作将抛出java.nio.channel.IllegalBlockingModeException。</span></span><br><span class="line"><span class="comment">在异常情况下，底层连接可能会被远程主机或网络软件中断（例如在TCP连接中的连接重置）。当网络软件检测到连接断开时，返回的输入流会出现以下情况：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isClosed())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Socket is closed"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!isConnected())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Socket is not connected"</span>);</span><br><span class="line">        <span class="keyword">if</span> (isInputShutdown())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Socket input is shutdown"</span>);</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            is = AccessController.doPrivileged(</span><br><span class="line">                <span class="keyword">new</span> PrivilegedExceptionAction&lt;&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> InputStream <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> impl.getInputStream();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.security.PrivilegedActionException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (IOException) e.getException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> is;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面通过<code>AccessController</code>进行授权，<code>run</code>方法中调用<strong>java.net.AbstractPlainSocketImpl#getInputStream</strong>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">    <span class="keyword">synchronized</span> (fdLock) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (isClosedOrPending())  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Socket Closed"</span>);  </span><br><span class="line">        <span class="keyword">if</span> (shut_rd)  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Socket input is shutdown"</span>);  </span><br><span class="line">        <span class="keyword">if</span> (socketInputStream == <span class="keyword">null</span>)  </span><br><span class="line">            socketInputStream = <span class="keyword">new</span> SocketInputStream(<span class="keyword">this</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> socketInputStream;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，代码中创建了 <strong>SocketInputStream</strong> 对象，并且会将当前<code>AbstractPlainSocketImpl</code>对象传进去（这个对象实际就是 <strong>SocksSocketImpl</strong> ）。</p><p><code>read</code>读数据的时候，则会调用如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> read(b, off, length, impl.getTimeout());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> length, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EOF already encountered</span></span><br><span class="line"><span class="keyword">if</span> (eof) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// connection reset</span></span><br><span class="line"><span class="keyword">if</span> (impl.isConnectionReset()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Connection reset"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bounds check</span></span><br><span class="line"><span class="keyword">if</span> (length &lt;= <span class="number">0</span> || off &lt; <span class="number">0</span> || length &gt; b.length - off) &#123;</span><br><span class="line"><span class="keyword">if</span> (length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"length == "</span> + length</span><br><span class="line">+ <span class="string">" off == "</span> + off + <span class="string">" buffer length == "</span> + b.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// acquire file descriptor and do the read</span></span><br><span class="line"><span class="comment">// 获取文件描述符并进行读取</span></span><br><span class="line">FileDescriptor fd = impl.acquireFD();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">n = socketRead(fd, b, off, length, timeout);</span><br><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ConnectionResetException rstExc) &#123;</span><br><span class="line">impl.setConnectionReset();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">impl.releaseFD();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we get here we are at EOF, the socket has been closed,</span></span><br><span class="line"><span class="comment"> * or the connection has been reset.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (impl.isClosedOrPending()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Socket closed"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (impl.isConnectionReset()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Connection reset"</span>);</span><br><span class="line">&#125;</span><br><span class="line">eof = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点关注下面这一行代码，这里在读取的时候同样传递了 <strong>timeout</strong> 参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n = socketRead(fd, b, off, length, timeout);</span><br></pre></td></tr></table></figure><p><strong>socketRead</strong> 方法会调用 <strong>native</strong> 的 <code>socketRead0</code> 方法，<strong>timeout</strong> 代表了读取的超时时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">socketRead0</span><span class="params">(FileDescriptor fd,  </span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len,  </span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> timeout)</span>  </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><p><strong>timeout</strong> 参数源于前面的<code>new SocketInputStream(this)</code>（也就是 <strong>AbstractPlainSocketImpl</strong> 对象）中的<strong>this</strong>引用<code>impl.getTimeout()</code>，这个参数的作用是指定<code>read</code>的超时时间，超时之后没有结果抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serverSocket.setSoTimeout(SO_TIMEOUT);</span><br></pre></td></tr></table></figure><p>了解<code>read</code>方法中<code>timeout</code>的作用之后，我们便可以着手改造代码了，具体的改造部分个人放到后文单独的 <code>titile</code> 进行说明，方便后续回顾。</p><p>此外，这里经过仔细考虑，判断这部分代码读者很有可能会存在理解误区，误以为此处的 <strong>AbstractPlainSocketImpl</strong> 属于 <strong>ServerSocket</strong>，实际上它属于 <strong>Socket</strong>，也就是说我们设置的 <code>timeout</code> 是设置到 <strong>Socket</strong> 的 <strong>AbstractPlainSocketImpl</strong> 。</p><p>最为简单的证明方法是先在  <strong>java.net.Socket#setImpl</strong> 中打上断点，在启动BIO的服务端之后，立即启动客户端，具体的Debug断点如下：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230712160311.png" alt="Socket 的 setImpl"></p><p>通过单步调试，我们在<strong>BioServerSocket</strong> 中看到两个对象是不一样的。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230712160613.png" alt="BioServerSocket"></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230712160628.png" alt="对象对比"></p><p>为什么不一样呢？这里需要回顾前面的【ServerSocket中accept 解读】这一部分的操作。这里把重要操作标记了一下：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230712161314.png" alt="ServerSocket中accept解读可能的理解误区1"></p><p>这里复习之前提到的内容，在<strong>accept();</strong> 中为了确保Socket连接是正确并且可用的，每次都会<code>new Socket()</code>，而这里的<code>SocksSocketImpl</code> 是属于 <strong>Socket</strong> 的成员变量。</p><p>在进行Socket套接字连接之前会先判断是否初始化，如果初始化没有就先进行初始化（具体可以看红框框的位置）。</p><p>如果还是理解不了，那么只能再次寄出另一张杀手锏图了：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230712163105.png" alt="ServerSocket中accept解读可能的理解误2"></p><h1 id="实现-Socket-中的-read-方法非阻塞"><a href="#实现-Socket-中的-read-方法非阻塞" class="headerlink" title="实现 Socket 中的 read 方法非阻塞"></a>实现 Socket 中的 read 方法非阻塞</h1><p><strong>AbstractPlainSocketImpl</strong>实现<code>socketRead</code>方法非阻塞，具体做法其实就是使用 <strong>AbstractPlainSocketImpl</strong> 传入了 <strong>timeout</strong> 参数，实现 <strong>SocketInputStream</strong> 非阻塞<code>read</code>。</p><p>表面上看上去 <strong>read</strong> 方法是非阻塞的，实际上这里存在一个明显的 <strong>误区</strong>，那就是在<code>socket = serverSocket.accept();</code>这一段代码中，服务端构建出 <code>Socket</code> 连接之后，客户端和服务端交互是通过独立的<code>Socket</code>对象完成IO读写的。</p><p>然而在第一次改造过后，实际上还有两点不易察觉的问题：</p><p>（1）服务端<code>read</code>的非阻塞轮询效率非常低，基本上是“一核繁忙、多核围观”的情况。</p><p>（2）第一次改造设置的是设定的是<strong>ServerSocket级别</strong>的<strong>SocksSocketImpl</strong>的timeout。每个新的客户端进来都是新的Socket连接，每个Socket又有各自的 <strong>SocksSocketImpl</strong>，这里<strong>客户端连接所产生新的Socket</strong>的<strong>timeout</strong>是没有做设置的，换句话说，服务端针对每个Socket的<code>read</code>依然是完全阻塞。</p><p>前文提到，在BIO非阻塞同步模型中，我们虽然没法解决 系统底层”同步” 问题，但是我们可以让“非阻塞”这一块更为优化合理和更为高效。</p><p>第一个问题的解决策略是启动<strong>多线程</strong>以非阻塞<code>read()</code>方式轮询，这样做的另一点好处是，某个Socket读写压力大并不会影响CPU 切到其他线程的正常工作。</p><p>解决第二点问题，我们需要为<strong>每个新的Socket</strong>设置 <strong>timeout</strong>。</p><p>解决上面两个问题，真正BIO非阻塞实现才算是真正成立，下面我们来看下第二版代码优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. NIO 改写，accept 非阻塞</span></span><br><span class="line"><span class="comment">     * 2. 实现 read() 同样非阻塞</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> port</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> xander</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2023/7/12 16:38</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initNioAndNioReadServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">null</span>;<span class="comment">//服务端Socket</span></span><br><span class="line">        Socket socket = <span class="keyword">null</span>;<span class="comment">//客户端socket</span></span><br><span class="line">        BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">        ExecutorService threadPool = Executors.newCachedThreadPool();</span><br><span class="line">        String inputContent;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">            <span class="comment">// 1. 需要设置超时时间，会等待设置的时间之后再进行返回</span></span><br><span class="line">            serverSocket.setSoTimeout(SO_TIMEOUT);</span><br><span class="line">            log.info(stringNowTime() + <span class="string">": serverSocket started"</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 2. 如果超时没有获取，这里会抛出异常，这里的处理策略是不处理异常</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket = serverSocket.accept();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SocketTimeoutException e) &#123;</span><br><span class="line">                    <span class="comment">//运行到这里表示本次accept是没有收到任何数据的，服务端的主线程在这里可以做一些其他事情</span></span><br><span class="line">                    log.info(<span class="string">"now time is: "</span> + stringNowTime());</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 3. 拿到Socket 之后，应该使用线程池新开线程方式处理客户端连接，提高CPU利用率。</span></span><br><span class="line">                Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ClientSocketThread(socket));</span><br><span class="line">                threadPool.execute(thread);</span><br><span class="line"><span class="comment">//                log.info(stringNowTime() + ": id为" + socket.hashCode() + "的Clientsocket connected");</span></span><br><span class="line"><span class="comment">//                reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                while ((inputContent = reader.readLine()) != null) &#123;</span></span><br><span class="line"><span class="comment">//                    log.info("收到 id为" + socket.hashCode() + "  " + inputContent);</span></span><br><span class="line"><span class="comment">//                    count++;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//                log.info("id为" + socket.hashCode() + "的Clientsocket " + stringNowTime() + "读取结束");</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (Objects.nonNull(reader)) &#123;</span><br><span class="line">                    reader.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (Objects.nonNull(socket)) &#123;</span><br><span class="line"></span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 改写 客户端 Socket 连接为单独线程处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ClientSocketThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SO_TIMEOUT = <span class="number">2000</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SLEEP_TIME = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Socket socket;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ClientSocketThread</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">            String inputContent;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.setSoTimeout(SO_TIMEOUT);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SocketException e1) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">while</span> ((inputContent = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            log.info(<span class="string">"收到id为"</span> + socket.hashCode() + <span class="string">"  "</span> + inputContent);</span><br><span class="line">                            count++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="comment">//执行到这里表示read方法没有获取到任何数据，线程可以执行一些其他的操作</span></span><br><span class="line">                        log.info(<span class="string">"Not read data: "</span> + stringNowTime());</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//执行到这里表示读取到了数据，我们可以在这里进行回复客户端的工作</span></span><br><span class="line">                    log.info(<span class="string">"id为"</span> + socket.hashCode() + <span class="string">"的Clientsocket "</span> + stringNowTime() + <span class="string">"读取结束"</span>);</span><br><span class="line">                    Thread.sleep(SLEEP_TIME);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (Objects.nonNull(reader)) &#123;</span><br><span class="line">                        reader.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (Objects.nonNull(socket)) &#123;</span><br><span class="line">                        socket.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>经过上面的改造，我们基本把 BIO 同步阻塞的工作方式更新为 <strong>同步非阻塞</strong>的工作方式，核心是对于 <code>read()</code>以及服务端接收新连接的<code>accept()</code>设置<code>timeout</code>参数。</p><p>在外部处理上，通过<code>while(true)</code> 加上“吞异常”方式，结合<code>Thread.sleep()</code>的套路实现“非阻塞”定期<code>accept</code>。</p><p>当然，我们也可以看到，通过线程池每次都构建新线程的方式，在连接比较少的时候是比较高效的，但是一旦连接暴增，理论上JVM虽然可以构建非常多线程，实际上CPU肯定是吃不消，多线程“空轮询”判断的方式也十分浪费CPU资源，多线程切换起来更是雪上加霜。</p><blockquote><p>基于BIO的种种弊端，Sun 在JDK1.4 提供了 NIO 来解决上面的几点问题。</p></blockquote><h1 id="native-accept方法在Linux运作解读"><a href="#native-accept方法在Linux运作解读" class="headerlink" title="native accept方法在Linux运作解读"></a>native <code>accept</code>方法在Linux运作解读</h1><p><span class="exturl" data-url="aHR0cHM6Ly9saW51eC5kaWUubmV0L21hbi8yL2FjY2VwdA==" title="https://linux.die.net/man/2/accept">accept(2): accept connection on socket - Linux man page (die.net)<i class="fa fa-external-link"></i></span></p><p>原始文档相关解读：[[【Linux】accept(2) - Linux man page]]，下面的内容基本为文档的翻译和理解介绍。</p><p><code>accept()</code>本地方法，我们可以来试着看一看Linux这块的相关解读：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd,struct sockaddr *addr,socklen_t *addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p><code>accept()</code>系统调用主要用在基于连接的套接字类型，比如<strong>SOCK_STREAM</strong>和<strong>SOCK_SEQPACKET</strong>。它提取出所监听套接字的等待连接队列中第一个连接请求，<strong>创建一个新的套接字</strong>，并返回指向该套接字的文件描述符。新建立的套接字不在监听状态，原来所监听的套接字也不受该系统调用的影响。</p><p><strong>备注：新建立的套接字准备发送<code>send()</code>和接收数据<code>recv()</code>。</strong></p><p><strong>sockfd</strong>，作用是 利用系统调用<code>socket()</code>建立的套接字描述符，通过<code>bind()</code>绑定到一个本地地址(一般为服务器的套接字)，并且通过<code>listen()</code>一直在监听连接；</p><p><strong>addr</strong>, 指向<code>struct sockaddr</code>的指针，该结构用通讯层服务器对等套接字的地址(一般为客户端地址)填写，返回地址<code>addr</code>的确切格式由套接字的地址类别(比如TCP或UDP)决定；</p><p>若<code>addr</code>为NULL，没有有效地址填写，这种情况下，addrlen也不使用，应该置为NULL；</p><p><strong>备注：addr是个指向局部数据结构sockaddr_in的指针，这就是要求接入的信息本地的套接字(地址和指针)。</strong></p><p><code>addrlen</code>， 代表一个值结果参数，调用函数必须初始化为包含addr所指向结构大小的数值，函数返回时包含对等地址(一般为服务器地址)的实际数值；</p><p><strong>备注：addrlen是个局部整形变量，设置为<code>sizeof(struct sockaddr_in)</code>。</strong></p><p>如果队列中没有等待的连接，套接字也没有被标记为Non-blocking，accept()会阻塞调用函数直到连接出现；如果套接字被标记为Non-blocking，队列中也没有等待的连接，accept()返回错误<strong>EAGAIN</strong>或<strong>EWOULDBLOCK</strong>。</p><p><strong>备注：一般来说accept()为阻塞函数，当监听socket调用accept()时，它先到自己的receive_buf中查看是否有连接数据包；若有，把数据拷贝出来，删掉接收到的数据包，创建新的socket与客户发来的地址建立连接；若没有，就阻塞等待；</strong></p><p>为了在套接字中有到来的连接时得到通知，可以使用<strong>select()</strong> 或<strong>poll()</strong>。当尝试建立新连接时，系统发送一个可读事件，然后调用<code>accept()</code>为该连接获取套接字。另一种方法是，当套接字中有连接到来时设定套接字发送SIGIO信号。</p><p>返回值成功时，返回非负整数，该整数是接收到套接字的描述符；<strong>出错时会返回－1</strong>，相应地设定全局变量error。</p><p>所以，在Java部分的源码里（<strong>java.net.ServerSocket#accept</strong>）会new 一个Socket出来，方便连接后拿到的新Socket的文件描述符的信息给设定到我们new出来的这个Socket 上来，这点在<code>java.net.PlainSocketImpl#socketAccept</code>中看到的尤为明显，读者可以回顾相关源码。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文一开始介绍了Bio Socket的基本代码，接着从<code>ServerSocket</code>的<code>bind</code>方法解读，通过图文结合的方式介绍了源码如何处理，整个<code>bind</code>操作过程中有许多<code>native</code>层调用，所以Socket的代码调试是非常麻烦的。</p><p>介绍完<code>bind</code>之后，我们接着介绍了<code>ServerSocket</code>中<code>accept</code>方法，并且介绍了<code>accept</code> 方法的阻塞问题实际上和底层的操作系统行为有关，并且通过画图的方式理解<code>accept</code>中Socket连接比较“绕”的操作。</p><p>最后，文章的后半部分介绍了如何改造<code>accept</code>以及客户端的<code>Socket</code>连接解决非阻塞问题IO，最后我们介绍了  <code>native accept</code>方法在Linux运作，主要内容为Linux的相关文档理解。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>理解Socket的非阻塞操作有助于理解 NIO的Channel和Buffer的概念，实际上从我们的Demo代码可以看到Channel和非阻塞的BIO思路比较类似，而BufferReader缓冲流则贴合了 Buffer 的概念。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubGludXhqb3VybmFsLmNvbS9maWxlcy9saW51eGpvdXJuYWwuY29tL2xpbnV4am91cm5hbC9hcnRpY2xlcy8wMjMvMjMzMy8yMzMzczIuaHRtbA==" title="https://www.linuxjournal.com/files/linuxjournal.com/linuxjournal/articles/023/2333/2333s2.html">Linux Network Programming, Part 1 (linuxjournal.com)<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMDQ4NzQ2MDU=" title="https://zhuanlan.zhihu.com/p/104874605">详解socket中的backlog 参数 - 知乎 (zhihu.com)<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTAzNzUxMTc4NzgwNjg2" title="https://juejin.cn/post/6844903751178780686">BIO到NIO源码的一些事儿之BIO - 掘金 (juejin.cn)<i class="fa fa-external-link"></i></span></p><h2 id="CachedThreadPool的工作原理"><a href="#CachedThreadPool的工作原理" class="headerlink" title="CachedThreadPool的工作原理"></a>CachedThreadPool的工作原理</h2><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,  </span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS, <span class="comment">//60s </span></span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）corePoolSize = 0，maximumPoolSize = 最大值（无限大），keepAliveTime = 60s，workQueue = <strong>SynchronousQueue</strong></p><p>（2）<strong>SynchronousQueue</strong>（实际上没有存储数据的空闲，是用来做多线程通信之间的协调作用的）。一开始提交一个任务过来，要求线程池里<strong>必须有一个线程对应可以处理这个任务</strong>，但是此时一个线程都没有，poolSize &gt;= corePoolSize , workQueue已经满了，poolSize &lt; maximumPoolSize（最大值），直接就会<strong>创建一个新的线程来处理这个任务</strong>。</p><blockquote><p>这样的效果也就是来一个任务就开一个线程，无界，无限开新线程，线程过多容易导致JVM的压力过大甚至直接崩溃。这也是为什么阿里巴巴规范禁掉这个方法的直接原因，容易误用。</p></blockquote><p>（3）如果短期内有大量的任务都涌进来，实际上是走一个直接提交的思路，对每个任务，如果没法找到一个空闲的线程来处理它，那么就会立即创建一个新的线程出来，来处理这个新提交的任务</p><p>（4）短时间内，如果大量的任务涌入，可能会导致瞬间创建出来几百个线程，几千个线程，是不固定的。</p><p>（5）但是当这些线程工作完一段时间之后，就会处于空闲状态，就会看超过60s的空闲，就会直接将空闲的线程给释放掉。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      网络IO编程
    
    </summary>
    
    
      <category term="Java" scheme="https://whitestore.top/categories/Java/"/>
    
    
      <category term="Java" scheme="https://whitestore.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Java】Generics in Java</title>
    <link href="https://whitestore.top/2023/07/27/genericjava/"/>
    <id>https://whitestore.top/2023/07/27/genericjava/</id>
    <published>2023-07-27T03:32:00.000Z</published>
    <updated>2023-09-09T00:53:49.935Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><p><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BzYWxpdGhhY2hhdGh1cmFuZ2E5NC9nZW5lcmljcy1pbi1qYXZhLTNjNzkxNTU1ZTkyNA==" title="https://medium.com/@salithachathuranga94/generics-in-java-3c791555e924">Generics in Java. It’s all about type safety | by Salitha Chathuranga | Medium<i class="fa fa-external-link"></i></span></p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>It’s all about type safety。</p><p>所有内容都是关于线程安全。</p><p><img src="https://miro.medium.com/v2/resize:fit:875/1*77SYONEADgKEPiyVPqUb-A.png" alt=""></p><p>Hi all!!!</p><p>I thought of writing a widely used but less discussed topic in Java. That is <strong>Generics</strong>! We use it, but majority of the developers don’t know about it as I have experienced.</p><p>本次编写的有关内容是讨论较少主题，“<strong>泛型</strong>”，实际上我们经常使用（实际上天天都在用），但是大部分人并不了解。</p><p>Let me clear this…have you ever used List or <strong>ArrayList</strong> in Java? Most probably, answer should be YES. Right? Without collections, we can’t even think of an easy way of handling data. So, do you remember how we define an ArrayList?</p><p>让我澄清一下……您在Java中使用过List或<strong>ArrayList</strong>吗？答案很可能是 “是”。对不对？如果没有集合，我们甚至无法想象处理数据的简单方法。那么，你还记得我们是如何定义ArrayList的吗？</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// with Generics</span></span><br></pre></td></tr></table></figure><p>This is the way we declare it. So, we have used generics. 😃 Here, <code>_&lt;Integer&gt;</code>_ is the Generic we passed. That is a Type. After we create list like this, you can <strong>only add integers</strong> to the list.</p><p>在上面的例子中我们在泛型中指定<code>&lt;Integer&gt;</code>，之后我们创建的List<strong>只能添加</strong>整型类型数据。</p><p>You may remember, if we define the list like below, we would be able to add any type of data which is extended from Object super class, to the list.</p><p>如果我们在定义List的时候不指定任何泛型，我们可以添加任意类型的数据，这些数据是从对象超类中扩展出来的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List numbers = <span class="keyword">new</span> ArrayList(); <span class="comment">// without Generics</span></span><br></pre></td></tr></table></figure><p>We can achieve Type Safety for this List, after we add generics.</p><p>为了实现类型安全，之后我们可以添加泛型。</p><p><strong>Generics</strong> means <strong>parameterized types.</strong> Java let us to create a single class, interface, and method that can be used with different types of data(objects) within the Generics domain.</p><p>泛型也叫参数化类型，Java允许我们创建单一的类、接口和方法，这些类、接口和方法可用于泛型域内的不同类型的数据（对象）。</p><p><strong>Advantages in Generics would be:</strong></p><p>泛型的优点如下：</p><ul><li>Code Reusability — we can use a common code with multiple object types</li></ul><p>代码复用性：我们可以使用通用代码包含多种不同对象类型。</p><ul><li>Compile-time Type Checking — Java will check the generics code at the compile time against errors</li></ul><p>编译时期的类型检查：实现Java在编译时期进行类型检查。</p><ul><li>Type Safety — we can restrict adding unnecessary data</li></ul><p>类型安全：可以限制添加不必要的数据</p><ul><li>Usage in Collections — Collections need object types to deal with data</li></ul><p>集合中使用：集合需要对象类型的数据，泛型可以更好的控制。</p><p><em>Let’s take and example to explain why we need Generics..</em></p><p>下面举个栗子介绍为什么需要泛型。</p><p>Imagine you have to print Numbers and Texts using a printer class. Printer has a method that accepts the data while creating it.</p><p>想象一下你需要数字或者文本类型的打印机对象，打印机在创建时有一个接受数据的方法。</p><p>In traditional way, we will have to creat 2 classes since we have 2 types of data: Number(Integer) and Text(String).</p><p>按照传统的方式，我们会创建两个对象，根据需要的打印机类型构建字符串和整型（打印机）对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextPrinter</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String data;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TextPrinter</span><span class="params">(String data)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.data = data;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"print::: "</span> + data);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberPrinter</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer data;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumberPrinter</span><span class="params">(Integer data)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.data = data;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"print::: "</span> + data);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>How to use:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsMain</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        NumberPrinter numberPrinter = <span class="keyword">new</span> NumberPrinter(<span class="number">5</span>);  </span><br><span class="line">        numberPrinter.print(); <span class="comment">// output = print::: 5  </span></span><br><span class="line">        TextPrinter textPrinter = <span class="keyword">new</span> TextPrinter(<span class="string">"Hello"</span>);  </span><br><span class="line">        textPrinter.print();   <span class="comment">// output = print::: Hello  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>You can see we have <strong>code duplication</strong>! Data type is the only difference here!</p><p>你会发现这里有重复代码，这里仅仅是对象类型不同。</p><p>We can simply use a Printer with a Generic here. Then we will only have 1 Printer! 😎</p><p>只需要非常简单的添加一个泛型，</p><p>Let’s deep dive into Generics and see how we achieve this… 😎</p><p>让我们深入了解泛型，看看如何实现这一点…… </p><h1 id="Create-a-Generic-创建通用型"><a href="#Create-a-Generic-创建通用型" class="headerlink" title="Create a Generic 创建通用型"></a>Create a Generic 创建通用型</h1><p>I’m taking the above simple example and will show how to create a <strong>Generic</strong> Printer.</p><p>我将以上面的简单示例来说明如何创建一个<strong>通用</strong>打印机。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Printer</span>&lt;<span class="title">T</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T data;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Printer</span><span class="params">(T data)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.data = data;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"print::: "</span> + data);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>How to use:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Printer&lt;Integer&gt; integerPrinter = <span class="keyword">new</span> Printer&lt;&gt;(<span class="number">5</span>);  </span><br><span class="line">integerPrinter.print();   <span class="comment">// output = print::: 5  </span></span><br><span class="line">  </span><br><span class="line">Printer&lt;String&gt; stringPrinter = <span class="keyword">new</span> Printer&lt;&gt;(<span class="string">"Hello"</span>);  </span><br><span class="line">stringPrinter.print();   <span class="comment">// output = print::: Hello  </span></span><br><span class="line">  </span><br><span class="line">Printer&lt;Double&gt; doublePrinter = <span class="keyword">new</span> Printer&lt;&gt;(<span class="number">45.34</span>);  </span><br><span class="line">doublePrinter.print();   <span class="comment">// output = print::: 45.34  </span></span><br><span class="line">  </span><br><span class="line">Printer&lt;Long&gt; longPrinter = <span class="keyword">new</span> Printer&lt;&gt;(<span class="number">5L</span>);  </span><br><span class="line">longPrinter.print();z    <span class="comment">// output = print::: 5</span></span><br></pre></td></tr></table></figure><p>Now we only have 1 class! It accepts a Type. Here, T is used to denote the Type as a common standard. We can even create printer objects for other data types also like Double/Long. <strong>Code reusability</strong> is achieved in style. 😎</p><p>现在我们只需要一个类就可以完成构建两种不同类型的打印机，这里的 T 表示作为通用标准的类型，我们甚至可以把这个T改为  Double/Long 类型，最终实现了 “代码重用性” 的风格。</p><p>We can create Generic classes which accepts more than 1 type. Look at the below example. It accepts an Integer and a String both.</p><p>我们可以创建接受多种类型的通用类。请看下面的示例，它同时接受一个整数和一个字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiPrinter</span>&lt;<span class="title">T</span>, <span class="title">V</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T data1;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> V data2;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MultiPrinter</span><span class="params">(T data1, V data2)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.data1 = data1;  </span><br><span class="line">        <span class="keyword">this</span>.data2 = data2;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"print::: "</span> + data1 + <span class="string">" : "</span> + data2);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MultiPrinter&lt;Integer, String&gt; multiPrinter = <span class="keyword">new</span> MultiPrinter&lt;&gt;(<span class="number">5</span>, <span class="string">"Hello"</span>);  </span><br><span class="line">multiPrinter.print(); <span class="comment">// output = print::: 5 : Hello</span></span><br></pre></td></tr></table></figure><p><strong>Java Type Naming conventions</strong></p><ul><li>E — Element (used in Collections)</li><li>K — Key (Used in Map)</li><li>N — Number</li><li>T — Type</li><li>V — Value (Used in Map)</li><li>S, U, V etc. — 2nd, 3rd, 4th types</li></ul><p><strong>Java类型命名规则</strong></p><ul><li>E - 元素（在集合中使用）</li><li>K - 键（在地图中使用）</li><li>N - 数字</li><li>T - 类型</li><li>V - 值（在映射中使用）</li><li>S、U、V 等 - 第二、第三、第四类型</li></ul><h1 id="Bounded-Generics-有限泛型"><a href="#Bounded-Generics-有限泛型" class="headerlink" title="Bounded Generics 有限泛型"></a>Bounded Generics 有限泛型</h1><p>This is an advanced version of Generics. We can restrict more and achieve <strong>more type safety</strong> with bounded Generics.</p><p>这是泛型的高级版本。通过有界泛型，我们可以限制更多，实现<strong>多的类型安全</strong>。</p><p>Let’s say we have an <strong>AnimalPrinter</strong> class which can only print animal details. No other objects are allowed to be used with it. How to achieve this?</p><p>假设我们有一个<strong>AnimalPrinter</strong>类，它只能打印动物的详细信息。不允许使用其他对象。如何实现？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String color;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer age;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name, String color, Integer age)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">        <span class="keyword">this</span>.color = color;  </span><br><span class="line">        <span class="keyword">this</span>.age = age;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> color;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> age;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">        Animal animal = (Animal) o;  </span><br><span class="line">        <span class="keyword">return</span> Objects.equals(name, animal.name) &amp;&amp; Objects.equals(color, animal.color) &amp;&amp; Objects.equals(age, animal.age);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, color, age);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String name, String color, Integer age)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">super</span>(name, color, age);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String name, String color, Integer age)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">super</span>(name, color, age);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalPrinter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Animal</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T animalData;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AnimalPrinter</span><span class="params">(T animalData)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.animalData = animalData;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Name::: "</span> + animalData.getName());  </span><br><span class="line">        System.out.println(<span class="string">"Color::: "</span> + animalData.getColor());  </span><br><span class="line">        System.out.println(<span class="string">"Age::: "</span> + animalData.getAge());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In this class, T extends Animal part does the job! We have limited our generic for Dog and Cat!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AnimalPrinter&lt;Cat&gt; animalPrinter1 = <span class="keyword">new</span> AnimalPrinter&lt;&gt;(<span class="keyword">new</span> Cat(<span class="string">"Jim"</span>, <span class="string">"brown"</span>, <span class="number">2</span>));  </span><br><span class="line">animalPrinter1.print();  </span><br><span class="line">AnimalPrinter&lt;Dog&gt; animalPrinter2 = <span class="keyword">new</span> AnimalPrinter&lt;&gt;(<span class="keyword">new</span> Dog(<span class="string">"Rocky"</span>, <span class="string">"black"</span>, <span class="number">5</span>));  </span><br><span class="line">animalPrinter2.print();</span><br></pre></td></tr></table></figure><p>If we try to define the printer with another Object type, compiler will complain like this =&gt; <em>“Type parameter ‘java.lang.Object’ is not within its bound; should extend ‘generics.Animal’</em></p><p>如果我们尝试使用其他对象类型定义打印机，编译器将发出如下警告 =&gt; <em>“类型参数’java.lang.Object’不在其绑定范围内；应该扩展’generics.Animal’</em>“。</p><h1 id="Multiple-Bounds-多重边界"><a href="#Multiple-Bounds-多重边界" class="headerlink" title="Multiple Bounds 多重边界"></a>Multiple Bounds 多重边界</h1><p>Let’s say we want to add some more features to the Printer generic. We can achieve it like this.</p><p>比方说，我们想为打印机通用程序添加更多的功能。我们可以这样实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalPrinter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Animal</span> &amp; <span class="title">Serializable</span>&gt; </span>&#123;  </span><br><span class="line">    ..................  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>I have provided Serializable functionality using Serializable interface. There are important things to remember here.</p><ul><li>We must implement interface in our child classes(Cat and Dog).</li><li>Class should come first and the &amp; and interface.</li><li>Only 1 class can be extended since Java does not support multiple inheritance.</li></ul><p>我使用Serializable接口提供了Serializable功能。这里有一些重要的事情需要记住。</p><ul><li>我们必须在子类（Cat和Dog）中实现接口。</li><li>类应该放在前面，然后是 <strong>&amp;</strong> 和 <strong>接口</strong>。</li><li>由于Java不支持多重继承，所以只能扩展一个类。</li></ul><h1 id="Wildcards-With-Generics-通用通配符"><a href="#Wildcards-With-Generics-通用通配符" class="headerlink" title="Wildcards With Generics 通用通配符"></a>Wildcards With Generics 通用通配符</h1><p>Wildcards are represented by the question mark <em>?</em> in Java, and we use them to refer to an unknown type. This can be used as a parameter type with Generics. Then it will accept any type. I have used a List of any object as a method argument using wild card, in the below code.</p><p>通配符在Java中用问号 <em>?</em> 表示，我们用它来代指<strong>未知类型</strong>。通配符在Java中用问号 <em>?</em> ，然后它将接受任何类型。在下面的代码中，我使用通配符将任意对象的List作为方法参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(List&lt; ?&gt; list)</span> </span>&#123;  </span><br><span class="line">    System.out.println(list);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">printList(  </span><br><span class="line">    Arrays.asList(  </span><br><span class="line">        <span class="keyword">new</span> Cat(<span class="string">"Jim"</span>, <span class="string">"brown"</span>, <span class="number">2</span>),  </span><br><span class="line">        <span class="keyword">new</span> Dog(<span class="string">"Rocky"</span>, <span class="string">"black"</span>, <span class="number">5</span>)  </span><br><span class="line">    )  </span><br><span class="line">);  </span><br><span class="line">printList(Arrays.asList(<span class="number">50</span>, <span class="number">60</span>));  </span><br><span class="line">printList(Arrays.asList(<span class="number">50.45</span>, <span class="number">60.78</span>));  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// output:  </span></span><br><span class="line"><span class="comment">// [generics.Cat@b1fa3959, generics.Dog@62294cd9]  </span></span><br><span class="line"><span class="comment">// [50, 60]  </span></span><br><span class="line"><span class="comment">// [50.45, 60.78]</span></span><br></pre></td></tr></table></figure><p>List can be of any type now!!!</p><p>List 现在可以是任意类型的。</p><p>1️⃣ <strong>Upper Bounded Wild Cards</strong></p><p>1️⃣ <strong>上界通配符</strong></p><p>Consider this example:</p><p>考虑下面的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAnimals</span><span class="params">(List&lt;Animal&gt; animals)</span> </span>&#123;  </span><br><span class="line">      animals.forEach(Animal::eat);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If we imagine a subtype of <em>Animal</em>, such as a <em>Dog</em>, we can’t use this method with a list of <em>Dog</em>, even though <em>Dog</em> is a subtype of <em>Animal</em>. We can do this with a wild card.</p><p>如果我们想象一个 <em>Animal</em> 的子类型，例如 <em>Dog</em> ，我们就不能在 <em>Dog</em> 的列表中使用这个方法，尽管 <em>Dog</em> 是 <em>Animal</em> 的子类型。</p><p>我们可以使用通配符来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAnimals</span><span class="params">(List&lt;? extends Animal&gt; animals)</span> </span>&#123;  </span><br><span class="line">    ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now this method works with type <strong><em>Animal</em></strong> and all <strong><em>its subtypes</em></strong>.</p><p>现在该方法适用于 <strong><em>Animal</em></strong>  类型和所有 <strong><em>子类型</em></strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">printAnimals(  </span><br><span class="line">    Arrays.asList(  </span><br><span class="line">        <span class="keyword">new</span> Cat(<span class="string">"Jim"</span>, <span class="string">"brown"</span>, <span class="number">2</span>),  </span><br><span class="line">        <span class="keyword">new</span> Dog(<span class="string">"Rocky"</span>, <span class="string">"black"</span>, <span class="number">5</span>)  </span><br><span class="line">    )  </span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>This is called an <strong>upper-bounded wildcard</strong>, where type <strong><em>Animal</em></strong> is the upper bound.</p><p>这被称为 <strong>上界通配符</strong> ，其中 <strong><em>Animal</em></strong> 类型是上界。</p><p>2️⃣ <strong>Lower Bounded Wild Cards</strong></p><p>2️⃣ <strong>下限通配符</strong></p><p>We can also specify wildcards with a lower bound, where the unknown type has to be a <strong>super type of the specified type</strong>. Lower bounds can be specified using the <strong><em>super</em></strong> keyword followed by the specific type.</p><p>我们还可以指定带有下限的通配符，其中未知类型必须是指定类型的 <strong>超类型</strong> 。可以使用 <strong><em>super</em></strong> 关键字指定下限，后面跟上特定的类型。</p><p>Example:</p><p>举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addIntegers</span><span class="params">(List&lt;? <span class="keyword">super</span> Integer&gt; list)</span></span>&#123;  </span><br><span class="line">    list.add(<span class="keyword">new</span> Integer(<span class="number">70</span>));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Generic-Methods-通用方法"><a href="#Generic-Methods-通用方法" class="headerlink" title="Generic Methods 通用方法"></a>Generic Methods 通用方法</h1><p>Imagine we need a method which takes different data types and do something. We can create a Generic method for this and reuse it.</p><p>想象一下，我们需要一个接收不同数据类型的方法来做一些事情。我们可以为此创建一个通用方法并重复使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(T data)</span> </span>&#123;  </span><br><span class="line">    System.out.println(data);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">call(<span class="string">"hello"</span>);  </span><br><span class="line">call(<span class="number">45</span>);  </span><br><span class="line">call(<span class="number">15.67</span>);  </span><br><span class="line">call(<span class="number">5L</span>);  </span><br><span class="line">call(<span class="keyword">new</span> Dog(<span class="string">"Rocky"</span>, <span class="string">"black"</span>, <span class="number">5</span>));  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/* output:  </span></span><br><span class="line"><span class="comment">    hello  </span></span><br><span class="line"><span class="comment">    45  </span></span><br><span class="line"><span class="comment">    15.67  </span></span><br><span class="line"><span class="comment">    5  </span></span><br><span class="line"><span class="comment">    generics.Dog@62294cd9  </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>If we want to return data instead of VOID, we can do that also.</p><p>如果我们想返回数据而不是VOID，我们也可以这样做。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getData</span><span class="params">(T data)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> data;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">System.out.println(getData(<span class="string">"Test"</span>));   <span class="comment">// output: Test</span></span><br></pre></td></tr></table></figure><p>We can accept multiple data types also in a generic method.</p><p>我们也可以在泛型方法中接受多种数据类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, V&gt; <span class="function"><span class="keyword">void</span> <span class="title">getMultiData</span><span class="params">(T data1, V data2)</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"data 1: "</span> + data1);  </span><br><span class="line">    System.out.println(<span class="string">"data 2: "</span> + data2);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">getMultiData(<span class="number">50</span>, <span class="string">"Shades of Grey"</span>);</span><br></pre></td></tr></table></figure><p>I think I have covered almost all the things to be learnt in Generics. So, this would be an ideal article for you to practice Generics in Java. ❤️</p><p>我认为已经覆盖了泛型使用的大部分场景. 因此，这将是您练习Java泛型的理想文章。❤️</p><p>I will bring you another Java stuff next time.</p><p>下次我会给您带来另一款Java产品。</p><p>Bye guys! 🙌</p><p>再见 🙌</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      java中使用
    
    </summary>
    
    
      <category term="Java" scheme="https://whitestore.top/categories/Java/"/>
    
    
      <category term="Java" scheme="https://whitestore.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【周报】20230717 - 20230723 个人周报</title>
    <link href="https://whitestore.top/2023/07/27/weeonotes20230723/"/>
    <id>https://whitestore.top/2023/07/27/weeonotes20230723/</id>
    <published>2023-07-27T03:28:39.000Z</published>
    <updated>2023-09-09T00:53:49.937Z</updated>
    
    <content type="html"><![CDATA[<p>#周报</p><h2 id="进步"><a href="#进步" class="headerlink" title="进步"></a>进步</h2><ul><li>Apach Curator 文章第二篇【<img src="https://progress-bar.dev/100/" alt="进度">】</li><li>阅读文章和笔记记录：【个人成长】你的技术成长战略是什么？【<img src="https://progress-bar.dev/100/" alt="进度">】</li><li>【笔记】笔记分类的思考：来自Obsidian社区（临时笔记归档）【<img src="https://progress-bar.dev/100/" alt="进度">】<ul><li>零碎笔记记录</li></ul></li><li>《手写Mybatis》第一章脱稿自己实现相关代码【<img src="https://progress-bar.dev/100/" alt="进度">】<ul><li>基础完成，发现书中部分代码运行有误。</li></ul></li><li>《手写Mybatis》第二章阅读和实战【<img src="https://progress-bar.dev/100/" alt="进度">】</li><li>《手写Mybatis》第三章阅读和实战【<img src="https://progress-bar.dev/100/" alt="进度">】</li><li>《手写Mybatis》第四章阅读和实战【<img src="https://progress-bar.dev/100/" alt="进度">】</li><li>整理星球收藏的优质资料和主题，归档到自己的笔记【<img src="https://progress-bar.dev/100/" alt="进度">】</li><li>过去的部分笔记同步到各个平台【<img src="https://progress-bar.dev/100/" alt="进度">】</li><li>个人博客标签和分类重新整理【<img src="https://progress-bar.dev/100/" alt="进度">】</li><li>星球笔记第一篇【<img src="https://progress-bar.dev/100/" alt="进度">】</li><li>Postgresql 源码安装方式如何实现开机自启笔记归档 【<img src="https://progress-bar.dev/100/" alt="进度">】</li></ul><a id="more"></a><h1 id="未完成"><a href="#未完成" class="headerlink" title="未完成"></a>未完成</h1><ul><li>星球笔记二篇【<img src="https://progress-bar.dev/40/" alt="进度">】</li><li>《Who Moved My Cheese》生词笔记归档【<img src="https://progress-bar.dev/40/" alt="进度">】</li><li>多级缓存专栏笔记【<img src="https://progress-bar.dev/50/" alt="进度">】</li><li>英文博客Lambda表达式翻译【<img src="https://progress-bar.dev/50/" alt="进度">】</li><li>手写Mybaits【5/ 16】【<img src="https://progress-bar.dev/30/" alt="进度">】</li><li></li></ul><h1 id="不足-改进措施"><a href="#不足-改进措施" class="headerlink" title="不足/改进措施"></a>不足/改进措施</h1><ol><li>手写Mybatis 部分章节过于纠结，需要加快学习进度。</li></ol><p>改进：部分不关键代码不再反复重写，重点编写不理解部分。多看下Mybatis的源码是如何处理的。</p><ol start="2"><li>多级缓存专栏学习进度比较慢</li></ol><p>改进：敲代码实战耗时不固定，规定固定的学习时间，挤时间完成。</p><ol start="3"><li>英文学习安排比较随意</li></ol><p>改进：固定时间段学习。</p><ol start="4"><li>学习时刻三心二意</li></ol><p>改进：以前的倒计时改为正计时，使用滴答清单，走神的时候暂停结算专注时间。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul><li>逛漫展发现新大陆，有点想出COS了，哈哈</li><li>工作需求慢慢堆积上来了，连续学习时间逐渐被切割了</li><li>本周以撸Mybatis源码为主，从不懂到理解如何设计ORM框架，很有意思，顺带回忆很久之前敲过的工具方法。</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      个人周报汇总
    
    </summary>
    
    
      <category term="周报" scheme="https://whitestore.top/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="周报" scheme="https://whitestore.top/tags/%E5%91%A8%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>【健康】你的坐姿真的正確嗎？</title>
    <link href="https://whitestore.top/2023/07/27/sittingposition/"/>
    <id>https://whitestore.top/2023/07/27/sittingposition/</id>
    <published>2023-07-27T03:26:16.000Z</published>
    <updated>2023-09-09T00:53:49.937Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>今天早上閑逛YTB的時候，偶然發現推送的一個討論坐姿的視頻，看完之後才知道，原來自己很多日常認爲“對”的事情都是錯的。</p><blockquote><p>特意搞成繁體可以在閲讀上增加一點障礙，讓記憶更深刻一點點。</p></blockquote><a id="more"></a><h1 id="視頻和下載"><a href="#視頻和下載" class="headerlink" title="視頻和下載"></a>視頻和下載</h1><p>下面視頻是本文核心，必看！</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1pdXEzWXNGRW9IWQ==" title="https://www.youtube.com/watch?v=iuq3YsFEoHY"># 坐姿打直腰反而錯了?其實這只是代償!<i class="fa fa-external-link"></i></span></p><p>下面這個視頻是一些拉伸動作，我仔細看了下，都是可以在辦辦公室坐著就可以完成的，動作也不會很“尷尬”，挺不錯的。</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1UOGNqcG5xd2o0QSZ0PTM5N3M=" title="https://www.youtube.com/watch?v=T8cjpnqwj4A&t=397s"># 緩解腰痠的10分鐘小運動！久坐族必看！｜詹珞瑤 物理治療師 Veronica Rehab<i class="fa fa-external-link"></i></span></p><p>當然，下面還有個糾正“富貴包”的問題，這個視頻建議先養成良好的坐姿習慣之後，再去嘗試日常生活做“康復動作”，否則損害速度遠遠快於的“保健”速度。</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1mSnl3RGIta3hRMA==" title="https://www.youtube.com/watch?v=fJywDb-kxQ0"># 這個習慣害你烏龜頸！脖子前傾該怎麼辦？<i class="fa fa-external-link"></i></span></p><p>如果沒有科技，那麽可以看我下載下來的視頻：</p><blockquote><p>链接：<span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMTIyZmwtWnN2c3BFeFh4R2tyc0NFVWc/cHdkPWVxZ3M=" title="https://pan.baidu.com/s/122fl-ZsvspExXxGkrsCEUg?pwd=eqgs">https://pan.baidu.com/s/122fl-ZsvspExXxGkrsCEUg?pwd=eqgs <i class="fa fa-external-link"></i></span><br>   提取码：eqgs </p></blockquote><p>下面是評論區關於坐姿視頻的筆記，挺不錯的。</p><h1 id="好的坐姿的三個原則"><a href="#好的坐姿的三個原則" class="headerlink" title="好的坐姿的三個原則"></a>好的坐姿的三個原則</h1><ol><li>坐在坐骨上（臀部那两块硬骨头）</li><li>腳踩到地板</li><li>屁股比膝蓋高一點或等高</li></ol><h1 id="常見的錯誤坐姿"><a href="#常見的錯誤坐姿" class="headerlink" title="常見的錯誤坐姿"></a>常見的錯誤坐姿</h1><ol><li><p><strong>膝蓋比屁股高</strong>：</p><p>  腰椎會變成彎曲的狀態，讓腰部難以承受</p></li><li><p><strong>坐姿前傾</strong>：<br>  重量壓在大腿上面，導致大腿肌群緊繃發炎及骨盆前傾，進而產生各種腰痠背痛的問題。</p></li><li><p><strong>半躺半坐</strong>：<br>  是對腰部很傷的習慣，因為上半身的重量是放在腰椎上面，腰部承受比較多的負擔後使腰椎痠痛。此坐姿容易久坐，導致腰椎或薦椎發炎或受傷。</p></li><li><p><strong>身體靠一邊</strong>：<br>  容易出現手麻腳麻的問題</p></li></ol><h1 id="坐着要不要”绷直“？"><a href="#坐着要不要”绷直“？" class="headerlink" title="坐着要不要”绷直“？"></a>坐着要不要”绷直“？</h1><p>我們坐著時，<strong>只要正常放鬆就好了</strong>。當特別把腰給打直時，代表肌肉已經在收縮了，此时脊椎是”反弓“状态，腰部是要出力的久了之後，肌肉就開始慢性發炎。</p><p>真正的「直」是<strong>放輕鬆的坐</strong>，後挺的話腰其實是「反折的」。反折久了會刺激到神經，導致痠痛麻變的更嚴重。</p><p>如果想要靠著椅背時，要在後面去墊一個<strong>直立的枕頭</strong>（不能是市面常见的半高形状），讓坐時的「後傾角度」減少，讓坐的時候不會那麼後躺，讓力量放在坐骨上面。</p><h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p> <strong>一個好的坐姿就是讓你在坐著的時候，把你的重量放在屁股上（也就是坐骨上），就可以讓你坐再久都不會痠痛。</strong></p><h1 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h1><p><strong>❗如果覺得坐成對的姿勢，反而會讓你的腰很痠甚至有點坐立難安的話，通常代表你的腰部或是臀部那邊已經有點問題了！</strong></p><p>建議去找物理治療師或醫生把問題治療好，再回頭把坐姿改好，才真正讓腰部保持健康。</p><h1 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h1><p>看完視頻之後，立馬把我的半高坐掉頭，把“平”的那一面墊到背上了。最大收穫是坐椅子最好臀部高於膝蓋一點點，保持正確的姿勢有助於保護腰部。</p><p>當然，定期站立時必要的，坐姿正確僅僅是很小一部分。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      坐姿正确
    
    </summary>
    
    
      <category term="其他" scheme="https://whitestore.top/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="其他" scheme="https://whitestore.top/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】What Is dev shm And Its Practical Usage</title>
    <link href="https://whitestore.top/2023/07/27/devshmread/"/>
    <id>https://whitestore.top/2023/07/27/devshmread/</id>
    <published>2023-07-27T03:21:58.000Z</published>
    <updated>2023-09-09T00:53:49.936Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY3liZXJjaXRpLmJpei90aXBzL3doYXQtaXMtZGV2c2htLWFuZC1pdHMtcHJhY3RpY2FsLXVzYWdlLmh0bWw=" title="https://www.cyberciti.biz/tips/what-is-devshm-and-its-practical-usage.html">What Is /dev/shm And Its Practical Usage - nixCraft (cyberciti.biz)<i class="fa fa-external-link"></i></span></p><a id="more"></a><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><strong>/dev/shm</strong> is nothing but implementation of traditional <strong>shared memory</strong> concept. </p><p><strong>/dev/shm</strong>只不过是传统<strong>共享内存</strong>概念的实现。</p><p>It is an efficient means of passing data between programs.</p><p>它是一种在程序间传递数据的有效方法。</p><p>One program will create a memory portion, which other processes (if permitted) can access.</p><p>一个程序将创建一个内存部分，其他进程（如果允许）可以访问该部分。</p><p>This will result into speeding up things on Linux.  </p><p>这将（意味着）加快 Linux 的运行速度。 </p><p>shm / shmfs is also known as tmpfs, which is a common name for a temporary file storage facility on many Unix-like operating systems. </p><p><code>shm / shmfs</code> 也称为 <code>tmpfs</code>，是许多类 <code>Unix</code> 操作系统中临时文件存储设备的通用名称。</p><p>It is intended to appear as a mounted file system, but one which uses virtual memory instead of a persistent storage device.</p><p><code>tmpfs</code> 的内容是显示已加载的文件系统、但是<strong>使用的是用户虚拟内存而不是一个永久存储设备</strong>。</p><p>If you type the mount command you will see /dev/shm as a tempfs file system. </p><p>如果键入挂载命令，就会看到 <code>/dev/shm</code> 作为 <code>tempfs</code> 文件系统。</p><p>Therefore, it is a file system, which keeps all files in virtual memory. </p><p>因此，（<code>/dev/shm</code>）<strong>它是一个将所有文件保存在虚拟内存中的文件系统</strong>。</p><p>Everything in tmpfs is temporary in the sense that no files will be created on your hard drive.</p><p>注意，所有在<code>tmpfs</code>中发生的事情都是临时的，不会在硬盘上创建任何文件。</p><p>If you unmount a tmpfs instance, everything stored therein is lost. </p><p><strong>如果你卸载一个tmpfs 实例，它内部的所有存储内容都将丢失。</strong></p><p>By default almost all Linux distros configured to use /dev/shm:  </p><p>默认情况下，几乎所有 Linux 发行版都配置使用<code>/dev/shm</code>：</p><p>比如你使用下面的命令。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ df -h</span><br></pre></td></tr></table></figure><p>Sample outputs:</p><p>输出示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Filesystem            Size  Used Avail Use% Mounted on</span><br><span class="line">&#x2F;dev&#x2F;mapper&#x2F;wks01-root</span><br><span class="line">                      444G   70G  351G  17% &#x2F;</span><br><span class="line">tmpfs                 3.9G     0  3.9G   0% &#x2F;lib&#x2F;init&#x2F;rw</span><br><span class="line">udev                  3.9G  332K  3.9G   1% &#x2F;dev</span><br><span class="line">tmpfs                 3.9G  168K  3.9G   1% &#x2F;dev&#x2F;shm</span><br><span class="line">&#x2F;dev&#x2F;sda1             228M   32M  184M  15% &#x2F;boot</span><br></pre></td></tr></table></figure><h2 id="Nevertheless-where-can-I-use-dev-shm-但是，在哪里可以使用-dev-shm？"><a href="#Nevertheless-where-can-I-use-dev-shm-但是，在哪里可以使用-dev-shm？" class="headerlink" title="Nevertheless, where can I use /dev/shm? 但是，在哪里可以使用 /dev/shm？"></a>Nevertheless, where can I use /dev/shm? 但是，在哪里可以使用 /dev/shm？</h2><p>You can use /dev/shm to improve the performance of application software such as Oracle or overall Linux system performance.</p><p>您可以使用 /dev/shm 来提高 Oracle 等应用软件的性能或 Linux 系统的整体性能。</p><p>On heavily loaded system, it can make tons of difference. </p><p>在负载较重的系统中，它可以产生巨大的差异。</p><p>For example VMware workstation/server can be optimized to improve your Linux host’s performance (i.e. improve the performance of your virtual machines).</p><p>例如，可以对 VMware 工作站/服务器进行优化，以提高 Linux 主机的性能（即提高虚拟机的性能）。</p><p>In this example, remount /dev/shm with 8G size as follows:</p><p>比如下面这个例子，重新挂载 8G 大小的 /dev/shm，如下所示：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -o remount,size=8G /dev/shm</span><br></pre></td></tr></table></figure><p>To be frank, if you have more than 2GB RAM + multiple Virtual machines, this hack always improves performance. </p><p>坦率地说，<strong>如果你有超过 2GB 内存和多个虚拟机，这个黑客程序总能提高性能。</strong></p><p>In this example, you will give you tmpfs instance on /disk2/tmpfs which can allocate 5GB RAM/SWAP in 5K inodes and it is only accessible by root:</p><p>在本例中，你将在 <code>/disk2/tmpfs</code> 上创建一个 tmpfs 实例，它可以在 5K inodes 中分配 5GB RAM/SWAP，并且只能由 root 访问：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t tmpfs -o size=5G,nr_inodes=5k,mode=700 tmpfs /disk2/tmpfs</span><br></pre></td></tr></table></figure><p>Where,</p><p>命令解释：</p><ul><li><p><strong>-o opt1,opt2</strong> : Pass various options with a -o flag followed by a comma separated string of options. In this examples, I used the following options:</p></li><li><p><strong>-o opt1,opt2</strong> ： 使用 -o 标志传递各种选项，后跟逗号分隔的选项字符串。在本例中，我使用了以下选项：</p><ul><li><p><strong>remount</strong> : Attempt to remount an already-mounted filesystem. In this example, remount the system and increase its size.</p></li><li><p><strong>remount</strong> : 尝试重新挂载已挂载的文件系统。在此示例中，重新挂载系统并增大其大小。</p></li><li><p><strong>size=8G or size=5G</strong> : Override default maximum size of the /dev/shm filesystem. he size is given in bytes, and rounded up to entire pages.<br>覆盖 /dev/shm 文件系统的默认最大大小。大小以字节为单位，四舍五入为整页。</p><p>The default is half of the memory.<br>  默认值为内存的一半。</p><p>The size parameter also accepts a suffix % to limit this tmpfs instance to that percentage of your pysical RAM: the default, when neither size nor nr_blocks is specified, is size=50%.<br>size 参数也接受后缀 %，用于将此 tmpfs 实例限制为实际内存的该百分比：<strong>当既未指定 size 也未指定 nr_blocks 时，默认值为 size=50%</strong>。</p><p>In this example it is set to 8GiB or 5GiB. The tmpfs mount options for sizing ( size, nr_blocks, and nr_inodes) accept a suffix k, m or g for Ki, Mi, Gi (binary kilo, mega and giga) and can be changed on remount.<br>在本例中，它被设置为 8GiB 或 5GiB。tmpfs 挂载选项的大小（size、nr_block 和 nr_inodes）接受 Ki、Mi、Gi（二进制千、兆和千兆）的后缀 k、m 或 g，并可在重新挂载时更改。</p></li><li><p><strong>nr_inodes=5k</strong> : </p></li><li><p>The maximum number of inodes for this instance. The default is half of the number of your physical RAM pages, or (on a machine with highmem) the number of lowmem RAM pages, whichever is the lower.<br>此实例的最大 inodes 数量。默认值是物理 RAM 页数的一半，或（在使用高内存的机器上）低内存 RAM 页数的一半，以较低者为准。</p></li><li><p><strong>mode=700</strong> : Set initial permissions of the root directory.<br>设置根目录的初始权限。</p></li><li><p><strong>tmpfs</strong> : Tmpfs is a file system which keeps all files in virtual memory.<br>Tmpfs 是一种将所有文件保存在虚拟内存中的文件系统。</p></li></ul></li></ul><h2 id="How-do-I-restrict-or-modify-size-of-dev-shm-permanently-如何永久限制或修改-dev-shm-的大小？"><a href="#How-do-I-restrict-or-modify-size-of-dev-shm-permanently-如何永久限制或修改-dev-shm-的大小？" class="headerlink" title="How do I restrict or modify size of /dev/shm permanently?如何永久限制或修改 /dev/shm 的大小？"></a>How do I restrict or modify size of /dev/shm permanently?如何永久限制或修改 /dev/shm 的大小？</h2><p>You need to add or modify entry in /etc/fstab file so that system can read it after the reboot. Edit, /etc/fstab as a root user, enter:  </p><p>您需要添加或修改 <code>/etc/fstab</code> 文件中的配置，以便系统能在重启后读取它。以根用户身份编辑 <code>/etc/fstab</code>，输入  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/fstab</span><br></pre></td></tr></table></figure><p>Append or modify <code>/dev/shm</code> entry as follows to set size to 8G</p><p>添加或修改 <code>/dev/shm</code> 条目如下，将大小设置为 8G</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">none      /dev/shm        tmpfs   defaults,size=8G        0 0</span><br></pre></td></tr></table></figure><p>Save and close the file. For the changes to take effect immediately remount /dev/shm:  </p><p>保存并关闭文件。要使更改立即生效，请重新挂载 <code>/dev/shm</code>：  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -o remount /dev/shm</span><br></pre></td></tr></table></figure><p>Verify the same:  </p><p>验证是否一致：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure><h1 id="Recommend-readings"><a href="#Recommend-readings" class="headerlink" title="Recommend readings:"></a>Recommend readings:</h1><h1 id="推荐读物："><a href="#推荐读物：" class="headerlink" title="推荐读物："></a>推荐读物：</h1><ul><li><p>See man pages of mount regarding tmpfs options.</p></li><li><p>Details regarding tmpfs is available in <span class="exturl" data-url="aHR0cHM6Ly93d3cuY3liZXJjaXRpLmJpei9maWxlcy9saW51eC1rZXJuZWwvRG9jdW1lbnRhdGlvbi9maWxlc3lzdGVtcy90bXBmcy50eHQ=" title="https://www.cyberciti.biz/files/linux-kernel/Documentation/filesystems/tmpfs.txt">/usr/share/doc/kernel-doc-/Documentation/filesystems/tmpfs.txt<i class="fa fa-external-link"></i></span> file.</p></li><li><p>有关 tmpfs 选项，请参阅 mount 的手册。</p></li><li><p>有关 tmpfs 的详细信息，请参阅 <span class="exturl" data-url="aHR0cHM6Ly93d3cuY3liZXJjaXRpLmJpei9maWxlcy9saW51eC1rZXJuZWwvRG9jdW1lbnRhdGlvbi9maWxlc3lzdGVtcy90bXBmcy50eHQ=" title="https://www.cyberciti.biz/files/linux-kernel/Documentation/filesystems/tmpfs.txt">/usr/share/doc/kernel-doc-/Documentation/filesystems/tmpfs.txt<i class="fa fa-external-link"></i></span> 文件。</p></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      /dev/shm使用和实现
    
    </summary>
    
    
      <category term="Linux" scheme="https://whitestore.top/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://whitestore.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【Java】关于 AccessController.doPrivileged 方法的个人理解</title>
    <link href="https://whitestore.top/2023/07/16/doPrivileged/"/>
    <id>https://whitestore.top/2023/07/16/doPrivileged/</id>
    <published>2023-07-16T09:39:37.000Z</published>
    <updated>2023-07-16T09:40:58.800Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p><strong>AccessController.doPrivileged</strong> 这个方法调用通常存在于JDK的一些源码中，但是查阅相关资料介绍大差不差，比较难理解，这里简单整理资料做一个笔记，待日后有更深层次实践和理解之后回顾。</p><blockquote><p>当然更多情况这个方法的作用大概率会被遗忘，不过根据英文单词一知半解也无伤大雅。</p></blockquote><h1 id="什么是特权访问？"><a href="#什么是特权访问？" class="headerlink" title="什么是特权访问？"></a>什么是特权访问？</h1><p>从<code>Privileged</code>单词，个人联想到有关Java的安全管理的知识点，于是上网做了个科普。</p><p>在Java中执行应用程序分为<strong>本地执行</strong>和<strong>远程执行</strong>。本地代码调用执行是访问安全的，因为它受限于机器的JVM，同样它也可以获取JVM并且可以访问一切本地资源。而远程代码则不同，它基于<strong>沙箱机制</strong>，只能访问限定在JVM特定的运行范围中的资源。</p><p>与其说是“授权”，不如说是在JVM中进行一些敏感操作的时候，实际上还需要一层“黑盒”来加限制。Java的安全管理基本上可以理解为JVM的<strong>防火墙</strong>，运行一些“可接受”的操作，但是禁止“越权”访问。</p><a id="more"></a><h1 id="AccessController-doPrivileged-源码注释解读"><a href="#AccessController-doPrivileged-源码注释解读" class="headerlink" title="AccessController.doPrivileged 源码注释解读"></a><code>AccessController.doPrivileged</code> 源码注释解读</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Performs the specified PrivilegedExceptionAction with privileges enabled. The action is performed with all of the permissions possessed by the caller's protection domain.</span></span><br><span class="line"><span class="comment">If the action's run method throws an unchecked exception, it will propagate through this method.</span></span><br><span class="line"><span class="comment">Note that any DomainCombiner associated with the current AccessControlContext will be ignored while the action is performed.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@CallerSensitive</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> &lt;T&gt; T  </span><br><span class="line">    doPrivileged(PrivilegedExceptionAction&lt;T&gt; action)  </span><br><span class="line">    <span class="keyword">throws</span> PrivilegedActionException;</span><br></pre></td></tr></table></figure><p>在<strong>启用权限的情况下执行</strong>指定的<code>PrivilegedExceptionAction</code>。</p><p>该操作以<strong>调用者的保护域</strong>所拥有的所有权限执行。如果该操作的运行方法抛出一个未选中的异常，该异常将通过该方法传播。</p><p>请注意，在执行该操作时，与当前<code>AccessControlContext</code>关联的<code>DomainCombiner</code>将被忽略。</p><p>这一段比较难理解的地方是我们需要弄清楚<strong>拥有特权的调用者具体指的是什么？</strong> 所以我们再看看看一下 <code>java.security.AccessController</code> 整个类的<strong>JavaDoc</strong>:  </p><blockquote><p>A caller can be marked as being “privileged” (see doPrivileged and below). When making access control decisions, the checkPermission method stops checking if it reaches a caller that was marked as “privileged” via a doPrivileged call without a context argument (see below for information about a context argument). If that caller’s domain has the specified permission, no further checking is done and checkPermission returns quietly, indicating that the requested access is allowed. If that domain does not have the specified permission, an exception is thrown, as usual. </p></blockquote><p>其中提到的<strong>no further checking is done</strong>的意思是指<strong>stack中的checking</strong> ，也就是JVM中的栈帧，他被封装在虚拟机栈的不同线程的栈内存当中。</p><p>下面举个具体的例子方便更好理解：</p><p>假如一个TestService2，文件操作在1，stack为（1,2,3为checking顺序）  </p><p>3 . file:/D:/Workspaces/ExchangeConnect_V2_Trunk_Maven_workspace/ServiceCentre/bin/*  </p><p>2 . file:/c:/TestService-1.0.jar  </p><ol><li>file:/c:/TestService2-1.0.jar  </li></ol><p>此时 checking顺序为  <strong>1-&gt;2-&gt;3</strong>。</p><ol><li><p>如果<code>doPrivileged</code>是在2中调用，那么1,2需要具有权限，3不再进行检查 。</p></li><li><p>如果<code>doPrivileged</code>是在1中调用，那么1需要具有权限，2,3不再进行检查 。</p></li></ol><p>注意：  </p><ol><li>这里容易理解错误的地方是<strong>checking顺序</strong>，例如一个调用链 MethodA-&gt;MethodB-&gt;MethodC（这里的3个方法需要在3个不同的ProtectionDomain中），doPrivileged 在 MethodB 中，很容易理解成<strong>检查A,B而不检查C</strong>，实际上stack中检查顺序为<strong>C-&gt;B-&gt;A</strong>，也就是<strong>检查C,B而不检查A</strong>  </li></ol><blockquote><p>JVM 虚拟机栈的栈帧是先进后出的结构。 </p></blockquote><ol start="2"><li><strong>ServiceCentre</strong> 不需要太多权限，而Service就需要使用doPrivileged来避免受到ServiceCentre的权限限制（如果service有足够的权限），<strong>Equinox</strong>中有很多这样的例子（Equinox扮演Service的角色）。</li></ol><h1 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h1><p><code>AccessController.doPrivileged</code>是一个在<code>AccessController</code>类中的静态方法。调用这个方法之后意味着它的代码主体可以享受”privileged(特权)”。</p><p>也就是说如果一个应用开启了安全管理，其他应用想要访问一些<strong>授权方法</strong>时，必须使用<strong>doPrivileged方法开启特权</strong>才行。</p><h1 id="什么时候使用？"><a href="#什么时候使用？" class="headerlink" title="什么时候使用？"></a>什么时候使用？</h1><p>基本上属于看完就忘的一个东西，除了在JDK源码中对于一些敏感操作进行保护之外，很难看到使用场景。</p><p>不过在<code>StackFlow</code>上还是有大佬给出了自己的看法，具体可以看下面这个帖子：</p><p><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjIzMzc2MS93aGVuLXNob3VsZC1hY2Nlc3Njb250cm9sbGVyLWRvcHJpdmlsZWdlZC1iZS11c2Vk" title="https://stackoverflow.com/questions/2233761/when-should-accesscontroller-doprivileged-be-used">https://stackoverflow.com/questions/2233761/when-should-accesscontroller-doprivileged-be-used<i class="fa fa-external-link"></i></span></p><blockquote><p>Imagine you’ve built an application that provides a number of services to pluggable modules. So your app and its services are trusted code. The pluggable modules, however, are not necessarily trusted and are loaded in their own class loaders (and have their own protection domains).</p></blockquote><p>设想您构建了一个应用程序，为可插拔模块提供大量服务。因此，您的应用程序及其服务都是可信代码。然而，可插拔模块并不一定是可信的，它们被加载到自己的类加载器中（并且有自己的保护域）。</p><blockquote><p>When a pluggable module invokes a service, you are implementing custom security checks (“does pluggable module X have permission to use this service”). But the service itself might require some core Java permission (read a system property, write to a file, etc). The code that requires these permissions is wrapped in a doPrivileged() so that the insufficient permissions from the untrusted pluggable modules are effectively ignored - only the privileges of your trusted services module apply.</p></blockquote><p>当可插拔模块调用服务时，您需要执行自定义的安全检查（”可插拔模块X是否有权限使用该服务”）。但服务本身可能需要一些核心 Java 权限（读取系统属性、写入文件等）。</p><p><strong>需要这些权限的代码被封装在 doPrivileged() 中，这样就可以有效地忽略来自不信任的可插拔模块的不充分权限</strong> - 只有信任的服务模块的权限才适用。</p><h1 id="写到最后"><a href="#写到最后" class="headerlink" title="写到最后"></a>写到最后</h1><p>结合上面的内容，我们基本可以做一个总结：对于需要一些需要利用敏感资源进行网络交互场景，有时候会出现 <strong>没有访问权限</strong>的情况，这时候需要用<code>doPrivileged()</code>包裹相关操作代码来获取权限。</p><p>这个方法最常用和最红熟悉的使用场景，是Socket当中获取IO流的时候，此时的线程需要受到封装保护和授权。</p><p><strong>java.net.Socket#getInputStream</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (isClosed())  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Socket is closed"</span>);  </span><br><span class="line">    <span class="keyword">if</span> (!isConnected())  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Socket is not connected"</span>);  </span><br><span class="line">    <span class="keyword">if</span> (isInputShutdown())  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Socket input is shutdown"</span>);  </span><br><span class="line">    InputStream is = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        is = AccessController.doPrivileged(  </span><br><span class="line">            <span class="keyword">new</span> PrivilegedExceptionAction&lt;&gt;() &#123;  </span><br><span class="line">                <span class="function"><span class="keyword">public</span> InputStream <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">                    <span class="keyword">return</span> impl.getInputStream();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;);  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.security.PrivilegedActionException e) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> (IOException) e.getException();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> is;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><h2 id="什么时候使用AccessController-doPrivileged？"><a href="#什么时候使用AccessController-doPrivileged？" class="headerlink" title="什么时候使用AccessController.doPrivileged？"></a>什么时候使用AccessController.doPrivileged？</h2><p><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjIzMzc2MS93aGVuLXNob3VsZC1hY2Nlc3Njb250cm9sbGVyLWRvcHJpdmlsZWdlZC1iZS11c2Vk" title="https://stackoverflow.com/questions/2233761/when-should-accesscontroller-doprivileged-be-used">https://stackoverflow.com/questions/2233761/when-should-accesscontroller-doprivileged-be-used<i class="fa fa-external-link"></i></span></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      特权访问的相关内容
    
    </summary>
    
    
      <category term="Java" scheme="https://whitestore.top/categories/Java/"/>
    
    
      <category term="Java" scheme="https://whitestore.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Spring】Spring 事务机制的个人总结</title>
    <link href="https://whitestore.top/2023/07/14/spring-total/"/>
    <id>https://whitestore.top/2023/07/14/spring-total/</id>
    <published>2023-07-14T02:44:26.000Z</published>
    <updated>2023-07-16T06:28:09.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【Spring】Spring-事务机制的个人总结"><a href="#【Spring】Spring-事务机制的个人总结" class="headerlink" title="【Spring】Spring 事务机制的个人总结"></a>【Spring】Spring 事务机制的个人总结</h1><h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><p>​    Spring的事务机制虽然已经有非常多的资料介绍了，但是实际使用的时候还是常常栽坑里，相信这是大部分程序员的目前或者曾经的使用感受，所以这篇文章将会做一个完整的总结，用理论结合实际的代码实战的方式来弄懂Spring事务的机制到底应该如何使用以及内部是如何进行设计的。</p><p>​    在介绍正文之前，希望这篇教程不单单是能让读者避开Spring事务的陷阱，更多的是希望能够从Spring的事务设计上锻炼自己的架构思维，如果你一开始完全不懂，可以像我一样进行一比一复刻用在<strong>自己的开源工具或者项目上</strong>，不要管为什么这么设计，只管模仿再去思考，多想想自己用起来有什么便利性，然后再反推思考。</p><p>​    另外如果你完全不懂JDBC或者数据库的话，这篇文章可能就不太适合你看了，笔者也并不想浪费读者时间，可以看看下面这本老外写的JDBC入门文档，粗略翻了一下发现还是挺适合新手的，顺带磨练下英语阅读水平（实在不行还有谷歌娘兜底不是）：</p><blockquote><p>《jdbc》（简单粗暴的名字）</p><p>链接：<span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMUNPVmlzeTlEeUpSNXVqOWhzQjRXb1E=" title="https://pan.baidu.com/s/1COVisy9DyJR5uj9hsB4WoQ">https://pan.baidu.com/s/1COVisy9DyJR5uj9hsB4WoQ<i class="fa fa-external-link"></i></span><br>提取码：x5tz<br>–来自百度网盘超级会员V7的分享</p></blockquote><p>如果觉得文章写得不错，欢迎点赞收藏支持一波。</p><a id="more"></a><h2 id="最好的资料"><a href="#最好的资料" class="headerlink" title="最好的资料"></a>最好的资料</h2><p>​    最好的博客永远是官方文档，建议了解Spring事务事务之前多读几遍：（版本 5.3.14）</p><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnNwcmluZy5pby9zcHJpbmctZnJhbWV3b3JrL2RvY3MvY3VycmVudC9yZWZlcmVuY2UvaHRtbC9kYXRhLWFjY2Vzcy5odG1sI3NwcmluZy1kYXRhLXRpZXI=" title="https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#spring-data-tier">https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#spring-data-tier<i class="fa fa-external-link"></i></span></p><p>​    另外官方文档在事务这一节的最后推荐了两个扩展资料，这里也一并推荐：</p><blockquote><p>有关 Spring Framework 的事务支持的更多信息，请参阅：</p><p><strong><span class="exturl" data-url="aHR0cHM6Ly93d3cuaW5mb3dvcmxkLmNvbS9hcnRpY2xlLzIwNzc5NjMvZGlzdHJpYnV0ZWQtdHJhbnNhY3Rpb25zLWluLXNwcmluZy0td2l0aC1hbmQtd2l0aG91dC14YS5odG1s" title="https://www.infoworld.com/article/2077963/distributed-transactions-in-spring--with-and-without-xa.html">Spring 中的分布式事务<i class="fa fa-external-link"></i></span></strong>：分布式事务极具影响力的一篇文章，也是了解分布式事务一篇必读文，带和不带 XA 的一个 JavaWorld 演示，其中 Spring 的 <code>David Syer</code> 将指导您了解 Spring 应用程序中分布式事务的七种模式，其中三种带 XA，其他四种不带。</p><p>这里还找到一篇翻译：<a href="https://github.com/wangfeishsh/baocy/blob/master/distributed-transactions-in-spring-with-and-without-xa.md" target="_blank" rel="noopener"><strong>distributed-transactions-in-spring-with-and-without-xa.md</strong></a></p><p><strong>Java Transaction Design Strategies</strong> 是 InfoQ 提供的一本书，它对 Java 中的事务提供了节奏明快的介绍。 它还包含有关如何通过 Spring Framework 和 EJB3 配置和使用事务的并行示例。</p><p>书籍资源链接: <span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMVoxVmRUWnhPOUxMcm9sWHhLTGEzTEE=" title="https://pan.baidu.com/s/1Z1VdTZxO9LLrolXxKLa3LA">https://pan.baidu.com/s/1Z1VdTZxO9LLrolXxKLa3LA<i class="fa fa-external-link"></i></span> 提取码: hads </p></blockquote><h1 id="二、事务介绍"><a href="#二、事务介绍" class="headerlink" title="二、事务介绍"></a>二、事务介绍</h1><p>首先我们需要大致了解什么是事务，一句话概括就是：<strong>一组操作要么全部一起执行，要么全部的不执行</strong>。</p><h2 id="（1）事务特性（ACID-）"><a href="#（1）事务特性（ACID-）" class="headerlink" title="（1）事务特性（ACID ）"></a>（1）事务特性（ACID ）</h2><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20220103215722.png" alt=""></p><p>​    事务通常有下面的四种特性：</p><ul><li><strong>一致性</strong>：一致性保证事务的操作前后数据都正确的。</li><li><strong>原子性</strong>：事务是操作的最小单位，每一个事务要么全部成功，要么全部失败。</li><li><strong>隔离性</strong>：隔离性需要保证不同的事务之间不会互相干扰。</li><li><strong>持久性</strong>：事务提交之后数据将会永久生效并且保存。</li></ul><p>​    这四种特性虽然简单但是真要记住确实有些难，为了方便记忆我们用一些案例进行联想记忆，也可以按照自己容易记忆的方式联想记忆：</p><blockquote><p>​    首先，数据需要保证操作前的结果和操作后的结果一致，比如银行卡余额有1000元要往银行卡充值2000，充值完成之后我们看到的数据就是3000否则就还是1000元，所以<strong>一致性</strong>是首先需要保证的。</p><p>然后假设此时余额还是1000元，此时扣除500元，充值1000元，如果成功最后余额一定是1500元，需要保证两个操作同时完成，要么同时不完成，这就是<strong>原子性</strong>，原子性可以看做是保证多次连续操作的一致。</p><p>接下来是<strong>隔离性</strong>，隔离性比较好理解，你在ATM机器操作的时候如果进行充值，这中间的所有数据都是只有你可以见的，1000块钱存进去看到的结果一定是2000块钱而不是最后变成500块钱（不然这你绝对要报警了）。</p><p>最后事务一定是需要保证安全的，所以所有的事务只要成功就能<strong>永久生效</strong>，不受突然断电任何情况的影响，但是持久性依赖具体数据库的实现，当这是多数数据库的主要保证。</p></blockquote><h2 id="（2）并发事务的存在的问题"><a href="#（2）并发事务的存在的问题" class="headerlink" title="（2）并发事务的存在的问题"></a>（2）并发事务的存在的问题</h2><p>​    并发事务存在几个常见的问题，那就是<strong>脏读，不可重复读，幻读</strong>，<strong>丢失回滚（第一类事务丢失），丢失修改（第二类事务丢失）</strong>，这里需要小心区分<strong>不可重复读</strong>和<strong>幻读</strong>这两种情况差异。</p><p>​    1. <strong>脏读</strong>：最简单的话理解就是读到了其他事务没有提交的数据，也就是读到了未提交的数据，所以这个数据不管是否正确，其执行结果可能是不正确。</p><p>​    2. <strong>不可重复读</strong>：不可重复读针对当前事务读取到其他事务修改或者删除的数据，比如当前事务之前读取数据行为20，但是后一次读取却变成了30，数据和之前不重复了，所以就是不可重复读，但是需要注意不可重复读并不是一个十分严重的问题，这取决于数据库所以这也是为什么有不少数据库不设置默认级别为这个级别其中一个原因。</p><ol start="3"><li><strong>幻读</strong>：幻读和不可重复读最大的区别是读到了其他事务提交的<strong>新增</strong>数据，就好像当前事务读取数据出现了幻觉，之前读取出来的值和后一次读出来的值的内容不一致。</li><li><strong>丢失修改</strong>（第二类事务丢失）：有一种情况丢失修改，丢失修改指的是两个事务同时提交事务覆盖同一份数据的情况，不管事务A成功还是事务B成功，最后总会有一方修改的数据是失效的。</li><li><strong>丢失回滚</strong>（第一类事务丢失）：丢失回滚指A事务提交了，但是B事务事务回滚了，当A提交成功但是B因为回滚事务回滚了A的数据，这时候对于A来说事务就算是丢失了。</li></ol><h2 id="（3）事务的隔离级别"><a href="#（3）事务的隔离级别" class="headerlink" title="（3）事务的隔离级别"></a>（3）事务的隔离级别</h2><p>​    事务的隔离级别就是来解决并发事务问题的，需要注意的是下面介绍的内容并不是所有的数据库都支持（也可能支持但是只支持一部分），如果无特殊说明默认为Mysql。</p><ul><li><strong>READ UNCOMMITTED（读未提交）</strong>：对应脏读的模式，会读到其他事务没有提交的数据，几乎无数据安全和可靠性的保证。</li><li><strong>READ COMMITTED（读已提交）</strong>：事务会读取已提交的数据，也是大多数数据库的默认隔离级别。但是读到已提交的数据存在读到其他事务提交的新增数据的情况，所以会存在可重复读的情况。</li><li><strong>PEPEATABLE READ（可重复读）</strong>：这个级别是MySQL的默认隔离级别，它解决了脏读的问题，同时也保证了同一个事务多次读取同样的记录是一致的，但这个级别还是会出现幻读的情况。幻读是指当一个事务A读取某一个范围的数据时，另一个事务B在这个范围插入行，A事务再次读取这个范围的数据时，会产生幻行。特别说明：<strong>InnoDB和XtraDB存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）解决了幻读问题，它使用间隙锁（next-key locking）锁定查询涉及的行和索引中的间隙，防止幻影行的插入</strong>。</li><li><strong>SERIALIZABLE（可串行化）</strong>：这个事务是最高的隔离级别，它强制事务串行执行，避免了幻读问题。简单来说，SERIALIZABLE会在读取的每一行数据上都加锁，所以可能会导致大量的超时和锁竞争</li></ul><h2 id="（4）设置和回滚到保存点"><a href="#（4）设置和回滚到保存点" class="headerlink" title="（4）设置和回滚到保存点"></a>（4）设置和回滚到保存点</h2><p>​    注意保存点和事务的隔离级别一样，依赖于具体的数据库是否支持。保存点使用方式是在当前事务中通过<code>Connection.setSavepoint</code>设置一个<code>Savepoint</code>对象，利用<code>Connection.rollback</code>方法进行回滚，同时接受一个<code>Savepoint</code>参数。可以理解为一个存档，存档之后，可以回滚到指定存档点，这里用一个网上的sql案例简单理解，下面的案例重点关注：<code>ROLLBACK TO SAVEPOINT s1;</code>和<code>SAVEPOINT s1;</code>和<code>SAVEPOINT s2;</code>这几条语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">回滚事务到保存点。</span><br><span class="line"></span><br><span class="line"><span class="comment">--删除表bonus_2017。</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> bonus_2017;</span><br><span class="line"><span class="comment">--创建表bonus_2017。</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> bonus_2017(staff_id <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>, staff_name <span class="built_in">CHAR</span>(<span class="number">50</span>), job <span class="built_in">VARCHAR</span>(<span class="number">30</span>), bonus <span class="built_in">NUMBER</span>);</span><br><span class="line"><span class="comment">--向表bonus_2017中insert记录1。</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> bonus_2017(staff_id, staff_name, job, bonus) <span class="keyword">VALUES</span>(<span class="number">23</span>,<span class="string">'limingwang'</span>,<span class="string">'developer'</span>,<span class="number">5000</span>);</span><br><span class="line"><span class="comment">--提交事务。</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="comment">--设置保存点s1。</span></span><br><span class="line"><span class="keyword">SAVEPOINT</span> s1;</span><br><span class="line"><span class="comment">--向表bonus_2017中insert记录2。</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> bonus_2017(staff_id, staff_name, job, bonus) <span class="keyword">VALUES</span>(<span class="number">24</span>,<span class="string">'liyuyu'</span>,<span class="string">'tester'</span>,<span class="number">7000</span>);</span><br><span class="line"><span class="comment">--设置保存点s2。</span></span><br><span class="line"><span class="keyword">SAVEPOINT</span> s2;</span><br><span class="line"><span class="comment">--查询表bonus_2017的数据。</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> bonus_2017;</span><br><span class="line"></span><br><span class="line">STAFF_ID     STAFF_NAME                                         JOB                            BONUS           </span><br><span class="line"><span class="comment">------------ -------------------------------------------------- ------------------------------ ----------------------------------------</span></span><br><span class="line">23           limingwang                                          developer                         5000                 </span><br><span class="line">24           liyuyu                                              tester                        7000                 </span><br><span class="line"></span><br><span class="line">2 rows fetched.</span><br><span class="line"><span class="comment">--回滚到保存点s1。</span></span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> <span class="keyword">SAVEPOINT</span> s1;</span><br><span class="line"><span class="comment">--查询表bouns_2017的数据。</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> bonus_2017;</span><br><span class="line"></span><br><span class="line">STAFF_ID     STAFF_NAME                                         JOB                            BONUS           </span><br><span class="line"><span class="comment">------------ -------------------------------------------------- ------------------------------ ----------------------------------------</span></span><br><span class="line">23           limingwang                                          developer                         5000                 </span><br><span class="line"></span><br><span class="line">1 rows fetched.</span><br></pre></td></tr></table></figure><h1 id="三、Spring事务介绍"><a href="#三、Spring事务介绍" class="headerlink" title="三、Spring事务介绍"></a>三、Spring事务介绍</h1><h2 id="（1）Spring事务是啥？"><a href="#（1）Spring事务是啥？" class="headerlink" title="（1）Spring事务是啥？"></a>（1）Spring事务是啥？</h2><p>​    Spring的事务可以看做是在spring对于不同数据库的操作细节的一种封装和掩盖，通过三个核心的组件来完成整个事务的控制，这三个组件分别是：</p><ul><li><strong>PlatformTransactionManager：</strong> （平台）事务管理器</li><li><strong>TransactionDefinition：</strong> 事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)</li><li><strong>TransactionStatus：</strong> 事务运行状态</li></ul><p>​    spring事务在进行操作的时候通过自定义了七种不同的事务等级来完成事务提交回滚等一系列的操作，这里先卖个关子。</p><h2 id="（2）事务设计"><a href="#（2）事务设计" class="headerlink" title="（2）事务设计"></a>（2）事务设计</h2><p>​    我们稍微扩展介绍一下上面三个组件的内容：</p><ul><li><strong>PlatformTransactionManager：</strong> （平台）事务管理器，定义了事务的通用接口，最主要的实现抽象类为：AbstractPlatformTransactionManager，如前面所说，他定了事务操作的模板方法，由子类实现具体的事务细节，比如回滚，提交事务，设置参数等操作。</li><li><strong>TransactionDefinition：</strong> 事务定义信息，可以看作是一个事连接务的属性和配置，事务属性分为下面五种：<ul><li><strong>事务隔离级别</strong>：事务隔离几倍并不是所有的数据库都支持，并且部分数据库由于存储引擎的不同也可能不支持。</li><li><strong>传播行为</strong>：传播行为有七种，默认级别为：<strong>PROPAGATION_REQUIRED</strong>。</li><li><strong>事务超时</strong>：指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。</li><li><strong>回滚规则</strong>：规定了当前的事务会在什么情况下进行回滚，默认情况是按照运行时异常进行回滚，也可以设置指定某些异常不进行回滚，但是需要注意指定异常类必须是Throwable的子类。</li><li><strong>是否只读</strong>：事务的只读属性是指对事务性资源进行只读操作或者是读写操作</li></ul></li><li><strong>TransactionStatus：</strong> 事务运行状态，可以看做是一个新的事务对象，此接口包含了下面的内容</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionStatus</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isNewTransaction</span><span class="params">()</span></span>; <span class="comment">// 是否是新的事物</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasSavepoint</span><span class="params">()</span></span>; <span class="comment">// 是否有恢复点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRollbackOnly</span><span class="params">()</span></span>;  <span class="comment">// 设置为只回滚</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRollbackOnly</span><span class="params">()</span></span>; <span class="comment">// 是否为只回滚</span></span><br><span class="line">    <span class="keyword">boolean</span> isCompleted; <span class="comment">// 是否已完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="（3）实现形式"><a href="#（3）实现形式" class="headerlink" title="（3）实现形式"></a>（3）实现形式</h2><p>​    Spring事务有两种实现形式，关于实现形式将会在后文进行详细的讲解：</p><ol><li><strong>编程式模式</strong>：硬编码，也可以称之为手动模式，其实可以看作对于jdbc做了一层封装，一般使用 <strong>TransactionTemplate</strong> 模板对象进行事务的相关操作。</li><li><strong>声明式模式</strong>：特点是使用<strong>@Transactional</strong> 注解完成切面的事务注入。其底层使用的是aop和动态代理。</li></ol><blockquote><p>spring的事务是对于aop和动态代理的设计模式的教科书实现，如果对于Spring源代码比较棘手的可以从Spring的事务开始了解，如果看不懂那就需要补补aop和动态代理的功课了。</p></blockquote><p>下面我们分别来看看编程式事务和声明式事务的实现方式。</p><h2 id="（4）事务的传播级别"><a href="#（4）事务的传播级别" class="headerlink" title="（4）事务的传播级别"></a>（4）事务的传播级别</h2><p>​    Spring的事务传播级别主要是下面的七种，关于事务传播的部分细节会在声明式事务的“理解事务传播级别”介绍，同时实战部分会通过一些简单的案例来看一下不同传播级别的效果，这里可以先大致浏览一遍，关于事务传播的具体案例操作将会在实战部分进行详细的阐述。</p><table><thead><tr><th>特点</th><th>传播级别</th><th>说明</th></tr></thead><tbody><tr><td>支持当前事务的情况：</td><td>TransactionDefinition.PROPAGATION_REQUIRED</td><td>如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</td></tr><tr><td>支持当前事务的情况：</td><td>TransactionDefinition.PROPAGATION_SUPPORTS</td><td>如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</td></tr><tr><td>支持当前事务的情况：</td><td>TransactionDefinition.PROPAGATION_MANDATORY</td><td>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</td></tr><tr><td>不支持当前事务的情况：</td><td>TransactionDefinition.PROPAGATION_REQUIRES_NEW</td><td>创建一个新的事务，如果当前存在事务，则把当前事务挂起。</td></tr><tr><td>不支持当前事务的情况：</td><td>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</td><td>以非事务方式运行，如果当前存在事务，则把当前事务挂起。</td></tr><tr><td>不支持当前事务的情况：</td><td>TransactionDefinition.PROPAGATION_NEVER</td><td>以非事务方式运行，如果当前存在事务，则抛出异常。</td></tr><tr><td>其他情况</td><td>TransactionDefinition.PROPAGATION_NESTED</td><td>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</td></tr></tbody></table><h2 id="（5）Spring事务和传统的区别"><a href="#（5）Spring事务和传统的区别" class="headerlink" title="（5）Spring事务和传统的区别"></a>（5）Spring事务和传统的区别</h2><p>​    Spring事务和传统事务区别如下：</p><ol><li>不需要捕获SQLException，Spring会自动捕获异常并且转为相关的RuntimeException并且进行回滚。</li><li>通过Spring事务管理，可以极大化的减少配置，并且可以将事务委托为Spring进行管理。</li><li>传统事务会产生大量的侵入式代码，并且切换数据库对系统也是毁灭性打击。</li></ol><h2 id="（6）设计思路（个人理解）"><a href="#（6）设计思路（个人理解）" class="headerlink" title="（6）设计思路（个人理解）"></a>（6）设计思路（个人理解）</h2><p>​    设计思路部分是个人看完了Spring事务之后的一些思考补充，可以跳过。</p><p>​    上面简单的介绍了spring事务的大致特点，以及介绍了传统事务的特性以及并发事务的问题。</p><p>下面来看一下Spring是如何设计自己的事务的，这里读者可以停留下来思考一下，如果你是Spring事务的设计者，你会如何设计？这有利于你更深入的了解和巩固关于Spring事务的相关知识，这里大致说下个人的思考思路：</p><p>首先操作层面来看根据事务的特性，由于事务是多个连续的原子操作，所以肯定需要<strong>开启和提交事务</strong>这两个步骤。这是第一点。</p><p>然后我们在中途肯定需要对事务设置一些自己设置的属性，并且<strong>通过这些属性控制事务是否是只读的，不允许修改，控制是否允许使用事务</strong>等等，这是第二点。</p><p>我们需要考虑不用的数据库要如何兼容，也就是<strong>数据源要如何进行管理？</strong> 这时候肯定会想肯定分发给不同的数据源通过抽象事务管理器进行控制，同时会发现无论是回滚还是提交事务这些方法都是通用的，只是在数据库供应商底层的实现方式不同的而已，所以这里可以使用策略模式把事务的操作分发给具体的数据源实现，这是第三点。</p><p>有共同的方法所以需要使用 <strong>模板方法</strong>的模式控制抽象和模板方法的不同细节，提高代码复用性，这是第四点，模板方法并不算特别难。</p><p>如何实现嵌套事务的回滚，多线程访问的时候如何保持线程的隔离呢？这里我们最常想到的是<strong>ThreadLoacal</strong>，但是TheadLocal本身有点弱，我们是不是应该封装一下？这是第五点</p><p>所以最后我们从最顶层的抽象来看，完成一个事务其实只需要三个操作：<strong>1. 根据配置获取事务，2.执行操作，3. 提交或者回滚事务</strong>。其实归根结底，一个事务的底层抽象就是这三个动作，我们所有的事务设计都是围绕这三步来展开，这是最后一点，但是确实最复杂和抽象的。</p><p>看到这里你当然会说Spring的事务设计肯定怎么会才这么点，肯定比这个复杂多了，真正设计的时候肯定还会出现新的问题，并且有更加完善的架构。</p><p>我只能说在学习源码之前，脑子一定要有一套自己的思路，哪怕是错的也无所谓，静下心来看看设计者是如何思考的对照自己的思路进行纠正，否则很容易会被代码细节牵着走。</p><h1 id="四、编程式事务"><a href="#四、编程式事务" class="headerlink" title="四、编程式事务"></a>四、编程式事务</h1><p>​    编程式事务仅仅作为声明式事务的底层实现了解，现在基本不会用直接使用编程式事务，我们需要重点了解的部分在于核心的事务组件<strong>事务管理器</strong>。</p><h2 id="（1）实现方式"><a href="#（1）实现方式" class="headerlink" title="（1）实现方式"></a>（1）实现方式</h2><p>​    为了理解事务管理器，我们不得不啰嗦一下编程式事务的实现和使用方式，在代码中通常有下面两种实现方式：</p><ul><li>第一种：使用<strong>TransactionTemplate</strong>的模板类进行相关操作。</li><li>第二种：使用<strong>PlatformTransactionManager</strong> 控制事务的处理。</li></ul><p>那么哪一种方式更常用的？</p><p>其实两种方式<strong>都什么人用</strong>（嘿嘿，被我带进去了吧），因为声明式事务和他们相比方便一万倍，但是编程式事务是声明式事务的实现基础，所以我们不得静下心来不好好聊聊他是如何实现的。</p><h2 id="（2）配置方式"><a href="#（2）配置方式" class="headerlink" title="（2）配置方式"></a>（2）配置方式</h2><p>​    配置方式一般不怎么需要记忆，但是有时候会有奇葩的面试官会问这个东西看你有没有实际用过，其实多数情况都是不熟悉，所以这里列一个大致的模板：</p><blockquote><p>配置方式只有很老的项目才会这么干，强烈不建议去使用这种方式做配置。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置c3po连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注入属性值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/xxxxx"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"xxx"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"xxxxx"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 编程式事务管理 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置事务管理器，必须是 PlatformTransactionManager 所支持的实现类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSourceTransactionManager"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注入dataSource --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置事务管理器模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionTemplate"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"org.springframework.transaction.support.TransactionTemplate"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注入真正进行事务管理的事务管理器,name必须为 transactionManager否则无法注入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"transactionManager"</span> <span class="attr">ref</span>=<span class="string">"dataSourceTransactionManager"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>小贴士：注意和声明式的配置方式区分。</p></blockquote><h2 id="（3）PlatformTransactionManager"><a href="#（3）PlatformTransactionManager" class="headerlink" title="（3）PlatformTransactionManager"></a>（3）PlatformTransactionManager</h2><h3 id="集成方式"><a href="#集成方式" class="headerlink" title="集成方式"></a>集成方式</h3><p>​    这里最快的处理方式是构建一个Spring boot web项目进行引入和直接使用，因为<strong>Spring在4.2版本之后SpringBoot项目可以不加任何注解添加事务支持（默认配置）</strong>，如果不知道如何操作，可以参考下面的步骤：</p><blockquote><p>快速搭建一个SpringBoot项目：</p><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMDM1NDA0ODY=" title="https://zhuanlan.zhihu.com/p/103540486">Spring Boot快速搭建项目 - 知乎 (zhihu.com)<i class="fa fa-external-link"></i></span></p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- MYSQL --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Spring Boot JDBC --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    为了观察事务的操作，这里构建一张实验表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`admin`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`password`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">2</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb3;</span><br></pre></td></tr></table></figure><p>​    快速编写一个单元测试来验证事务是否生效：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单元测试</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TransactionTemplateTest</span>()</span>&#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> ProgrammaticTrasaction programmaticTrasaction;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 使用TransactionTemplate 进行事务处理</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transactionTemplateTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    programmaticTrasaction.insert();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProgrammaticTrasaction</span> </span>&#123;</span><br><span class="line"><span class="comment">// 异常触发开关</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> EXCEPTION_FLAG = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TransactionTemplate transactionTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 1. 构建事务管理器，同时使用系统的数据源进行设置</span></span><br><span class="line">        PlatformTransactionManager platformTransactionManager = <span class="keyword">new</span> DataSourceTransactionManager(Objects.requireNonNull(jdbcTemplate.getDataSource()));</span><br><span class="line">        <span class="comment">// 2. 配置事务的属性，比如事务的隔离级别，事务的超时时间以及隔离方式等等</span></span><br><span class="line">        TransactionDefinition transactionDefinition = <span class="keyword">new</span> DefaultTransactionDefinition();</span><br><span class="line">        <span class="comment">// 3. 开启事务，通过默认的事务属性配置，调用platformTransactionManager.getTransaction开启事务操作，此时获取到事务的状态 TransactionStatus</span></span><br><span class="line">        TransactionStatus transaction = platformTransactionManager.getTransaction(transactionDefinition);</span><br><span class="line">        <span class="comment">// 4. 执行和事务有关操作，这里用新增作为处理</span></span><br><span class="line">        System.err.println(<span class="string">"查询数据列表"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.err.println(jdbcTemplate.queryForList(<span class="string">"select * from admin"</span>));</span><br><span class="line">            <span class="comment">// 注意，jdbctemplate 把所有对于数据的改动操作统一为 update 操作，而查询则以 query 开头</span></span><br><span class="line">            jdbcTemplate.update(<span class="string">"insert into admin (id, username, password) values (51, '老王', '123')"</span>);</span><br><span class="line">            jdbcTemplate.update(<span class="string">"insert into admin (id, username, password) values (21, '老张', '222')"</span>);</span><br><span class="line">            <span class="comment">// 5. 提交事务</span></span><br><span class="line">            platformTransactionManager.commit(transaction);</span><br><span class="line">            <span class="comment">// 6. 手动抛出异常进行回滚</span></span><br><span class="line">          <span class="comment">//if(EXCEPTION_FLAG)&#123;</span></span><br><span class="line">            <span class="comment">//  throw new RuntimeException("手动抛出异常");</span></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 6. 我们需要使用事务管理器的rollback方法回滚整个事务</span></span><br><span class="line">            System.err.println(<span class="string">"异常：触发事务回滚"</span>);</span><br><span class="line">            platformTransactionManager.rollback(transaction);</span><br><span class="line">        &#125;</span><br><span class="line">        System.err.println(<span class="string">"插入数据之后"</span>);</span><br><span class="line">        System.err.println(jdbcTemplate.queryForList(<span class="string">"select * from admin"</span>));</span><br><span class="line"></span><br><span class="line">    &#125;<span class="comment">/*运行结果：</span></span><br><span class="line"><span class="comment">    第一次执行</span></span><br><span class="line"><span class="comment">    查询数据列表</span></span><br><span class="line"><span class="comment">    [&#123;id=1, username=admin, password=123456&#125;]</span></span><br><span class="line"><span class="comment">    插入数据之后</span></span><br><span class="line"><span class="comment">    [&#123;id=1, username=admin, password=123456&#125;, &#123;id=21, username=老张, password=222&#125;, &#123;id=51, username=老王, password=123&#125;]</span></span><br><span class="line"><span class="comment">    第二次执行：</span></span><br><span class="line"><span class="comment">    查询数据列表</span></span><br><span class="line"><span class="comment">    [&#123;id=1, username=admin, password=123456&#125;, &#123;id=21, username=老张, password=222&#125;, &#123;id=51, username=老王, password=123&#125;]</span></span><br><span class="line"><span class="comment">    触发事务回滚</span></span><br><span class="line"><span class="comment">    插入数据之后</span></span><br><span class="line"><span class="comment">[&#123;id=1, username=admin, password=123456&#125;, &#123;id=21, username=老张, password=222&#125;, &#123;id=51, username=老王, password=123&#125;]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    上面的代码看起来和我们编写模板代码操作没什么区别，其实spring 为我们做好了不少的准备和繁琐的基础工作，下面我们对spring事务的核心代码分析一波。</p><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><p>​    下面是从网络上找到的一张关于编程式事务的接口图，比较形象的说明了Spring事务的整体设计，后续声明式事务和各种模板操作类其实都是基于下面这个结构的扩展：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220902105321.png" alt=""></p><p>​    <strong>PlatformTransactionManager 事务管理器</strong></p><p>​    首先我们来看下事务管理器接口的结构图，这里需要注意的是<strong>TransactionManager</strong> 这个接口是一个标记接口，标记为Spring的事务管理接口，其他所有的对象要介入spring的事务必须实现此标记接口（当然通常是实现PlatformTransactionManager接口，或者扩展抽象的默认事务管理器实现）。</p><blockquote><p>提示：不同spring版本类图可能会有区别。</p></blockquote><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220902105414.png" alt=""></p><p>​    下面是PlatformTransactionManager 事务管理器接口，也是spring事务管理机制的核心接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> <span class="keyword">extends</span> <span class="title">TransactionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   开启一个新的事务</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(@Nullable TransactionDefinition definition)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   提交一个事务</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   事务回滚</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从类图可以看到，这里存在许多的实现类，这里我们挑几个比较常见的类进行介绍：</p><ul><li><strong>JtaTransactionManager</strong> ：jta事务管理器，继承自一个抽象的事务管理实现，如果你需要使用分布式的事务管理进行操作，可以使用这个事务管理器，当然多数情况它派不上用场。</li></ul><blockquote><p>小贴士：</p><p>​    <strong>JPA是啥玩意？</strong>JPA本身是一个规范，基于此规范实现的产品有：Hibernate, Eclipselink, Toplink, Spring Data JPA, etc等，其中最典型的实现是ORM的鼻祖Hibernate。如果想要更多了解JPA，可以看看这篇客：<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTAzODIyNDIzNDA4NjQ3" title="https://juejin.cn/post/6844903822423408647">什么是JPA？Java Persistence API简介<i class="fa fa-external-link"></i></span>。</p><p>​    <strong>JTA又是啥玩意？</strong>注意不要和JPA搞混了，JTA指的是允许应用程序执行<strong>分布式事务管理</strong> ，在两个或多个网络计算机资源上访问并且更新数据，JDBC驱动程序的加入JTA支持极大地增强了数据访问能力，如果对于JTA细节和规范了解，可以看文章最开头的博客，这里不再过多介绍。</p></blockquote><ul><li><strong>DataSourceTransactionManager</strong> ：如果使用了数据源进行操作，比如使用了jdbcTemplate，mybatis这种框架的时候需要使用此事务管理器。</li><li><strong>CciLocalTransactionManager</strong> ：CCI （Common Client Interface）是应用程序用来与连接器交互并与EIS通信的接口。同样还为本地事务划界提供了API，Spring提供CCI的支持主要是为了同价通用的资源和事务管理工具，但是其实用的十分少。</li></ul><p><strong>Spring是如何获取事务的？</strong></p><p>​    如何让Spring获取不同数据源的事务的呢？核心在于事务管理器的一个默认实现<strong>AbstractPlatformTransactionManager</strong> 类，默认实现了获取事务的抽象逻辑，将具体的获取逻辑分发到，下面为方法<code>org.springframework.transaction.support.AbstractPlatformTransactionManager#getTransaction</code>方法的执行流程：</p><ol><li>检查是否传递事务属性TransactionDefinition，如果没有则使用默认配置。</li><li>以DataSourceTransactionManager数据源为例，通过<code>DataSourceTransactionManager#doGetTransaction()</code>方法，构建一个事务对象，同时设置相关的属性，通过TransactionSynchronizationManager#getResource() <strong>同步</strong>获取ConnectionHolder（连接器）对象 ，<code>TransactionSynchronizationManager.getResource()</code>方法比较关键，Spring将连接器统一配置在一个NamedThreadLocal的全局线程共享资源当中，同时由于key有可能是一个动态的代理对象，所以key的获取会尝试解包动态代理来获取实际目标对象或者直接使用透明代理两种形式，当NamedThreadLocal中配置的连接器被获取到则进行返回（此时会额外检查当前线程是否还存在连接器存在于全局变量中，如果不存在则移除当前的线程资源释放内存）。</li><li>之后到代码逻辑较为简单，通过事务属性对象TransactionDefinition 进行事务的传播机制判断，然后便是熟悉的开启事务和执行sql以及返回结果等等一系列操作的模板代码，这里结合了策略和模板的设计模式，代码都比较好懂。</li><li>在提交事务最后有一步比较特殊，在事务提交之后如果发现当前的连接是一个新的连接，则会调用<strong>TransactionSynchronizationManager#bindResource</strong>  将当前的连接器进行绑定，这样可以保证同一线程内传播的是同一个事务。</li></ol><p>​    下面是获取事务的抽象方法，下面是关于获取事务方法的细节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> TransactionStatus <span class="title">getTransaction</span><span class="params">(@Nullable TransactionDefinition definition)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否传递事务属性TransactionDefinition，如果没有则使用默认配置。</span></span><br><span class="line">TransactionDefinition def = (definition != <span class="keyword">null</span> ? definition : TransactionDefinition.withDefaults());</span><br><span class="line"><span class="comment">// 由具体的数据源获取一个事务，比较常用的是</span></span><br><span class="line">Object transaction = doGetTransaction();</span><br><span class="line"><span class="keyword">boolean</span> debugEnabled = logger.isDebugEnabled();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isExistingTransaction(transaction)) &#123;</span><br><span class="line"><span class="comment">// 检查当前是否已经存在事务，则根据事务的传播等级进行判断，新建事务或者抛出异常等处理</span></span><br><span class="line"><span class="keyword">return</span> handleExistingTransaction(def, transaction, debugEnabled);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查事务超时时间是否设置 </span></span><br><span class="line"><span class="keyword">if</span> (def.getTimeout() &lt; TransactionDefinition.TIMEOUT_DEFAULT) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> InvalidTimeoutException(<span class="string">"Invalid transaction timeout"</span>, def.getTimeout());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果没有发现事务，则检查是否事务传播级别异常</span></span><br><span class="line"><span class="keyword">if</span> (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(</span><br><span class="line"><span class="string">"No existing transaction found for transaction marked with propagation 'mandatory'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||</span><br><span class="line">def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||</span><br><span class="line">def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">SuspendedResourcesHolder suspendedResources = suspend(<span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">logger.debug(<span class="string">"Creating new transaction with name ["</span> + def.getName() + <span class="string">"]: "</span> + def);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 开启事务</span></span><br><span class="line"><span class="keyword">return</span> startTransaction(def, transaction, debugEnabled, suspendedResources);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">resume(<span class="keyword">null</span>, suspendedResources);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 创建“空”事务：没有实际事务，但可能是同步的。</span></span><br><span class="line"><span class="keyword">if</span> (def.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(<span class="string">"Custom isolation level specified but no actual transaction initiated; "</span> +</span><br><span class="line"><span class="string">"isolation level will effectively be ignored: "</span> + def);</span><br><span class="line">&#125;</span><br><span class="line">            </span><br><span class="line"><span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line"><span class="keyword">return</span> prepareTransactionStatus(def, <span class="keyword">null</span>, <span class="keyword">true</span>, newSynchronization, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    最后我们把上面的描述简化为伪代码的形式进行解释：</p><blockquote><p>DataSource 事务对象，代表一个ConnectionHolder，用作 DataSourceTransactionManager 的事务对象。</p><p>小知识：如果Springboot没有配置数据源，默认会使用一个叫做 HikariPool的数据源，这个配置<strong>在2.0之后为默认值</strong>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用threadlocal 绑定一个全局共享的全局变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources =</span><br><span class="line">      <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Transactional resources"</span>);</span><br><span class="line"></span><br><span class="line">DataSource dataSource = platformTransactionManager.getDataSource();</span><br><span class="line"><span class="comment">// 下面为事务管理器获取细节 ====&gt;</span></span><br><span class="line"><span class="comment">// 从全局共享变量获取当前线程对应的资源池</span></span><br><span class="line">Map map = resources.get();</span><br><span class="line"><span class="comment">// actualKey =&gt; 为实际的对象（aop为实际对象）</span></span><br><span class="line">ConnectionHolder localConnectionHolder = resources.get(actualKey, map.get(actualKey));</span><br><span class="line"><span class="keyword">if</span>(map.isEmpty())&#123;</span><br><span class="line"><span class="comment">// 额外检查当前线程是否还存在连接器存在于全局变量中，如果不存在则移除当前的线程资源释放，避免被释放的线程对象堆积在共享资源</span></span><br><span class="line">  resources.remove();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置手动提交事务</span></span><br><span class="line">localConnectionHolder.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">map.put(datasource,connection);</span><br><span class="line">resources.set(map);</span><br><span class="line"><span class="comment">// &lt;==========</span></span><br></pre></td></tr></table></figure><p>​    再一次强调整个spring事务的核心部分是AbstractPlatformTransactionManager，它定义了spring获取事务的绝大多数的公用逻辑，而具体关于获取，提交，回滚等等细节则需要由子类的具体事务管理器进行实现。</p><p>​    最后，编程式事务在以前使用还是十分常见的（因为也没有别的工具），只不过spring推出注解式的声明式事务太好用了才逐渐淡出了视野，但是学习这些内容有助于更好的理解spring是如何实现注解式事务的，因为核心实现还是通过事务管理器来完成。</p><blockquote><p>小贴士：看到这里建议休息一下整理一下思路，出去倒杯水回来慢慢接着看。</p></blockquote><h2 id="（4）TransactionTemplate"><a href="#（4）TransactionTemplate" class="headerlink" title="（4）TransactionTemplate"></a>（4）TransactionTemplate</h2><p>​    现在我们来看下第二种方式TransactionTemplate，第二种方式其实是对于纯手动形式的进一步封装，我们可以发现事务管理器的模板代码其实可以省出开启事务和提交事务和回滚的步骤，这些步骤依然会出现大量的模板代码，并且客户端也不喜欢手动开启和关闭事务，Spring针对此进行改进出现了<strong>TransactionTemplate</strong> 事务的模板方法类，下面我们根据一个实际的运行代码来讲解一下它的用法：</p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 1.2 不需要使用事务管理器，而是直接在transactionTemplate内部集成</span></span><br><span class="line">        <span class="comment">// 3. 区别点，这里使用了transactionTemplate进行事务的开启和控制，下面介绍他的两种主要使用方式</span></span><br><span class="line">        <span class="comment">// 3.1  transactionTemplate.executeWithoutResult(Consumer&lt;TransactionStatus&gt; action)：</span></span><br><span class="line">        <span class="comment">// 没有返回值的，需传递一个Consumer对象，在accept方法中做业务操作。（类似切面）</span></span><br><span class="line">        <span class="comment">// 3.2 &lt;T&gt; T execute(TransactionCallback&lt;T&gt; action)：有返回值的，需要传递一个TransactionCallback对象，在doInTransaction方法中做业务操作</span></span><br><span class="line">        <span class="comment">// 调用execute方法或者executeWithoutResult方法执行完毕之后，事务管理器会自动提交事务或者回滚事务。</span></span><br><span class="line">        <span class="comment">// 事务在什么情况下会进行回滚？需要满足下面的条件：</span></span><br><span class="line">        <span class="comment">// （1）transactionStatus.setRollbackOnly();将事务状态标注为回滚状态</span></span><br><span class="line">        <span class="comment">// （2）execute方法或者executeWithoutResult方法内部抛出异常</span></span><br><span class="line">        <span class="comment">//  什么时候事务会提交？</span></span><br><span class="line">        <span class="comment">//  方法没有异常 &amp;&amp; 未调用过transactionStatus.setRollbackOnly();</span></span><br><span class="line">        System.err.println(<span class="string">"事务处理前"</span>);</span><br><span class="line">        System.err.println(jdbcTemplate.queryForList(<span class="string">"select * from admin"</span>));</span><br><span class="line">        <span class="comment">// 第一种使用方式</span></span><br><span class="line">        transactionTemplate.executeWithoutResult(transactionStatus -&gt; &#123;</span><br><span class="line">            jdbcTemplate.update(<span class="string">"update admin set username ='test2'  where id = '51'"</span>);</span><br><span class="line"></span><br><span class="line">            jdbcTemplate.update(<span class="string">"update admin set username ='test2',password='1111'  where id = '21'"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 第二种使用方式</span></span><br><span class="line">        DefaultTransactionStatus execute = (DefaultTransactionStatus) transactionTemplate.execute((TransactionCallback&lt;Object&gt;) status -&gt; &#123;</span><br><span class="line">            jdbcTemplate.update(<span class="string">"update admin set username ='test2'  where id = '51'"</span>);</span><br><span class="line"></span><br><span class="line">            jdbcTemplate.update(<span class="string">"update admin set username ='test2',password='1111'  where id = '21'"</span>);</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.err.println(<span class="string">"事务处理后"</span>);</span><br><span class="line">        System.err.println(jdbcTemplate.queryForList(<span class="string">"select * from admin"</span>));</span><br><span class="line">    &#125;<span class="comment">/*运行结果：</span></span><br><span class="line"><span class="comment">        事务处理前</span></span><br><span class="line"><span class="comment">        [&#123;id=1, username=admin, password=123456&#125;, &#123;id=21, username=老张, password=222&#125;, &#123;id=51, username=老王, password=123&#125;]</span></span><br><span class="line"><span class="comment">        事务处理后</span></span><br><span class="line"><span class="comment">        [&#123;id=1, username=admin, password=123456&#125;, &#123;id=21, username=test2, password=1111&#125;, &#123;id=51, username=test2, password=123&#125;]</span></span><br><span class="line"><span class="comment">    */</span></span><br></pre></td></tr></table></figure><p>​    可以看到，使用<strong>TransactionTemplate</strong>  的方式缩减了很多代码，我们不需要关心事务开启和提交的细节，只需要关心事务的处理操作即可。</p><h3 id="源码解析-1"><a href="#源码解析-1" class="headerlink" title="源码解析"></a>源码解析</h3><p>​    下面按照同样源码来解释一下这个操作的大致处理流程，这里可能会感觉我擦这么神奇，不用事务管理器，也不需要设置属性了，那要怎么设置属性？ 其实只不过是把所有的工作交给<strong>TransactionTemplate</strong> 去做了，为了验证我们可以对比<strong>DefaultTransactionDefinition</strong> 和<strong>TransactionTemplate</strong> 中的方法，可以发现他们的方法基本一致。（其实<strong>TransactionTemplate</strong> 就是继承了<strong>DefaultTransactionDefinition</strong> ）。多数情况下我们通过@Configuration注入Bean的方式，为全局的TransactionTemplate设置一些默认配置。</p><blockquote><p>其实从个人角度来看这里使用继承的方式实现spring相关的事务配置并不是很好，而是使用一个配置构造器完成配置的中转或者使用组合TransactionDefinition的方式比较恰当。</p></blockquote><p><strong>DefaultTransactionDefinition</strong> ：</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20211229220810.png" alt=""></p><p><strong>TransactionTemplate</strong> ：</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20211229220833.png" alt=""></p><p>​    下面我们再来看下它的类图，可以看到他在扩展事务属性类的基础上实现了新的接口：TransactionOpration，这也是一个关键接口，另外<strong>TransactionTemplate</strong> 可以进行事务的各种操作的原因是它内部组合了PlatformTransactionManager的对象，所以所有的事务管理实际上还是通过PlatformTransactionManager对象进行管理的，换汤不换药：</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20211229220848.png" alt=""></p><p>​    下面是TransactionOperations的方法签名，注意Spring5对于这个接口做过改动和扩展，旧版本的包可能内容不同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TransactionOperations</span></span>&#123;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 带返回值的方法</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(TransactionCallback&lt;T&gt; action)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  jdk8 的接口默认方法,不带返回值的使用方式</span></span><br><span class="line"><span class="comment">  <span class="doctag">@since</span>：5.2</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">executeWithoutResult</span><span class="params">(Consumer&lt;TransactionStatus&gt; action)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">execute(status -&gt; &#123;</span><br><span class="line">action.accept(status);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">返回 TransactionOperations 接口的实现，该接口在没有实际事务的情况下执行给定的 TransactionCallback。通常在测试的时候使用：该行为相当于在没有实际事务 (PROPAGATION_SUPPORTS) 和没有同步 (SYNCHRONIZATION_NEVER) 的情况下使用事务管理器运行。</span></span><br><span class="line"><span class="comment">  对于具有实际事务处理的 TransactionOperations 实现，将 TransactionTemplate 与适当的 PlatformTransactionManager 一起使用。</span></span><br><span class="line"><span class="comment">  <span class="doctag">@since</span>：5.2</span></span><br><span class="line"><span class="comment">  <span class="doctag">@see</span>：</span></span><br><span class="line"><span class="comment">  TransactionDefinition.PROPAGATION_SUPPORTS, </span></span><br><span class="line"><span class="comment">  AbstractPlatformTransactionManager.SYNCHRONIZATION_NEVER, </span></span><br><span class="line"><span class="comment">  TransactionTemplate</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> TransactionOperations <span class="title">withoutTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> WithoutTransactionOperations.INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    再来看一下<strong>TransactionTemplate</strong> ，代码相对简单，相信读者只要了解原始的事务操作模板方法就可以看懂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">说明：</span></span><br><span class="line"><span class="comment">  在事务中执行给定回调对象指定的操作。允许返回在事务中创建的结果对象，</span></span><br><span class="line"><span class="comment">  即域对象或域对象的集合。回调抛出的 RuntimeException 被视为强制回滚的异常。</span></span><br><span class="line"><span class="comment">  这样的异常会传播到模板的调用者。</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">  action - 指定事务操作的回调对象</span></span><br><span class="line"><span class="comment">  返回：</span></span><br><span class="line"><span class="comment">    回调返回的结果对象，如果没有，则为 null</span></span><br><span class="line"><span class="comment">    抛出：</span></span><br><span class="line"><span class="comment">      TransactionException - 在初始化、回滚或系统错误的情况下</span></span><br><span class="line"><span class="comment">      RuntimeException - 由 TransactionCallback 抛出</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(TransactionCallback&lt;T&gt; action)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">  <span class="comment">// 检查当前是否存在事务管理器（不允许为空）</span></span><br><span class="line">    Assert.state(<span class="keyword">this</span>.transactionManager != <span class="keyword">null</span>, <span class="string">"No PlatformTransactionManager set"</span>);</span><br><span class="line">  <span class="comment">// 如果当前事务管理器支持自动回调处理，则使用事务管理器自动回调方法的实现，CallbackPreferringPlatformTransactionManager 类扩展自PlatformTransactionManager，公开了在事务中执行给定回调的方法。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.transactionManager <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager) &#123;</span><br><span class="line">      <span class="keyword">return</span> ((CallbackPreferringPlatformTransactionManager) <span class="keyword">this</span>.transactionManager).execute(<span class="keyword">this</span>, action);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不支持自动回调，则转入到传统的处理模式，这部分代码和原始的事务管理操作类似</span></span><br><span class="line">      TransactionStatus status = <span class="keyword">this</span>.transactionManager.getTransaction(<span class="keyword">this</span>);</span><br><span class="line">      T result;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 核心部分，使用action的函数式调用实现内部的事务处理</span></span><br><span class="line">        result = action.doInTransaction(status);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">        <span class="comment">// 如何出现 RuntimeException 或者 错误 回滚</span></span><br><span class="line">        rollbackOnException(status, ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">         <span class="comment">// 异常则根据事务级别进行回滚</span></span><br><span class="line">        rollbackOnException(status, ex);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(ex, <span class="string">"TransactionCallback threw undeclared checked exception"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果没有出现异常，则正常提交</span></span><br><span class="line">      <span class="keyword">this</span>.transactionManager.commit(status);</span><br><span class="line">      <span class="comment">// 返回事务执行的结果</span></span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>​    了解带返回值execute方法之后，我们来了解一下不带返回值的方法<code>executeWithoutResult()</code>，它的实现代码就更为简洁了，从最新版本的代码可以看到其实后续的版本有做函数式表达式重构，所以如果jdk版本比较低可能出现不兼容的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">在事务中执行给定 Runnable 指定的操作。</span></span><br><span class="line"><span class="comment">如果需要从回调中返回一个对象或从回调中访问 TransactionStatus，可以改用 execute(TransactionCallback)。</span></span><br><span class="line"><span class="comment">这样的变体类似于使用 TransactionCallbackWithoutResult 但具有针对常见情况的简化签名 - 并且可以方便地与 Java 8 lambda 表达式一起使用。</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">action - 指定事务操作的 Runnable</span></span><br><span class="line"><span class="comment">抛出：</span></span><br><span class="line"><span class="comment">TransactionException - 在初始化、回滚或系统错误的情况下</span></span><br><span class="line"><span class="comment">RuntimeException - 如果由 Runnable 抛出</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">executeWithoutResult</span><span class="params">(Consumer&lt;TransactionStatus&gt; action)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">    execute(status -&gt; &#123;</span><br><span class="line">      action.accept(status);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="（5）小结"><a href="#（5）小结" class="headerlink" title="（5）小结"></a>（5）小结</h2><p>​    最后我们来小结一波上面的内容，这一节开始我们了解了传统编程式事务的操作，可以看到虽然Spring已经封装开启和关闭事务的细节，也封装了关于JDBC操作的模板代码，但是我们如果使用编程式事务还是会产生大量的侵入式代码，这也不符合单一职责的原则。</p><p>编程式事务实现的几个特点：</p><ol><li>事务的传播机制基于<code>AbstractPlatformTransactionManager#getTransaction()</code>方法，通过不同的事务传播等级设置进行事务的管理。</li><li>为了保证同一个线程使用的连接资源的一致性，Spring使用了<code>ThreadLocal</code>作为全局共享变量的存储，实现线程之间的事务隔离，同时防止并发事务的问题。</li><li><strong>TransactionTemplate</strong>  可以看作是对于<code>PlatformTransactionManager</code> 事务管理器的二次封装并且扩展了回调式的事务操作。</li></ol><p>​    再次强调花费大量篇幅介绍并不是说推荐大家使用，而是使用编程式事务更有助于我们了解声明式事务的使用，下面我们来了解一下声明式事务的使用。</p><h1 id="五、声明式事务"><a href="#五、声明式事务" class="headerlink" title="五、声明式事务"></a>五、声明式事务</h1><p>​    声明式事务的使用就十分简单易懂了，就是我们熟悉的<code>@Transactional</code>注解，做到了不侵入的添加和去除事务管理支持，声明式事务的实现使用了AOP，本质其实就是在执行被注解的事务方法前进行拦截操作，声明式事务有如下的优缺点：</p><p>​    优点： 简单快速注入事务，无需改动任何业务代码。</p><p>​    缺点：和spring aop的缺点一致，<strong>只能针对方法级别进行事务控制</strong> ，并且只能通过Spring代理对象才能使用声明式事务，如果自己new对象接入事务这样做是不会生效的（切记），具有一定的局限性。</p><h2 id="（1）如何使用？"><a href="#（1）如何使用？" class="headerlink" title="（1）如何使用？"></a>（1）如何使用？</h2><p>​    不同的项目配置方式不同，需要针对具体的项目环境使用，目前主流是使用微服务，这里其实更加推荐使用@Bean类配置的方式注入事务管理的相关功能，比如配置事务管理器。如果你是SpringBoot并且版本比较新，那就非常简单了，直接加注解使用即可。</p><blockquote><p>小贴士：如果你使用的是springboot2.0之后的项目，并且如果在依赖里面有<strong>spring-data-*</strong>或者 <strong>spring-tx</strong>事务有关的依赖，则默认会开启声明式事务。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">  <span class="title">public</span> <span class="title">void</span> <span class="title">testAdd</span>() </span>&#123;</span><br><span class="line">      <span class="comment">//dosomething</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>​    但是如果Spring Boot的版本比较低或者一些比较旧的项目，则需要手动开启一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySpringConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">txManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dosomething 可以自己配置事一些事务管理器的配置。</span></span><br><span class="line">        <span class="keyword">return</span> yourTxManager; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    顺带一提，如果我们想要在注解的方法里面使用编程式的TransactionAspectSupport类里面的方法手动回滚事务，可以使用下面的方法进行回滚（但是建议不要这么使用）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createCourseDefaultRatingProgramatic</span><span class="params">(Course course)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       courseDao.create(course);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 手动回滚</span></span><br><span class="line">       TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Transactional注解介绍"><a href="#Transactional注解介绍" class="headerlink" title="@Transactional注解介绍"></a>@Transactional注解介绍</h3><p>​    我们来看一下关于<code>@Tralsactional</code>拥有哪些配置：</p><ul><li>value：别名，指定使用的事务管理器的Bean</li><li>transactionManager：指定事务的限定符值。可用于确定目标事务管理器，匹配特定 TransactionManager bean 定义的限定符值（或 bean 名称）。</li><li><strong>propagation：用于指定事务的传播级别，核心和常用属性</strong></li><li>isolation：事务的隔离级别，如果没有特殊指定，则默认按照数据库的级别</li><li>timeout：代表当前事务的超时时间（以秒为单位），默认为底层事务系统的默认超时时间（注意代码给了1秒的默认值）。专为与 <code>Propagation.REQUIRED</code>或 <code>Propagation.REQUIRES_NEW</code> 一起使用而设计，需要注意的是<strong>仅适用于新启动的事务</strong>。</li><li>readOnly：默认为false，如果设置为true，则只运行执行非update操作，如果碰到Update的操作反而会抛出异常。此配置方式有利于提高事务执行效率，如果不需要update相关事务，可以将此设置为true。</li><li>rollbackFor：根据指定的Class异常类进行回滚，如果没有设置，默认为运行时异常，但是需要注意必须是able的子类。</li><li>rollbackForClassName：必须是able的子类完全限定类名的子字符串，目前不支持通配符。例如，<code>ServletException</code>的值将匹配 <code>javax.servlet.ServletException</code> 及其子类。</li><li>noRollbackFor：和rollbackFor刚好相反。</li><li>noRollbackForClassName：和rollbackForClassName刚好相反。</li></ul><p>​    如果在多个地方使用了相同的注解，但是我们又不想总是复制粘贴大量的重复注解配置的时候，有一种方式是使用自定义注解的方式，这里简单了解即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Transactional</span>(transactionManager = <span class="string">"order"</span>, label = <span class="string">"causal-consistency"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> OrderTx &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Transactional</span>(transactionManager = <span class="string">"account"</span>, label = <span class="string">"retryable"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AccountTx &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="监听器绑定事件"><a href="#监听器绑定事件" class="headerlink" title="监听器绑定事件"></a>监听器绑定事件</h3><p>​    监听器事务绑定事件需要<strong>Spring4.2以上才支持</strong>，需要<strong>Spring4.2以上才支持</strong>，需要<strong>Spring4.2以上才支持</strong>，很重要，所以特意强调三遍。通常情况下使用<code>@EventListener</code>注解注册常规事件侦听器。如果需要将其绑定到事务也可以用<code>@TransactionalEventListener</code>，这样可以实现监听器的事务操作。</p><p>​    下面是官方提供的案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TransactionalEventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleOrderCreatedEvent</span><span class="params">(CreationEvent&lt;Order&gt; creationEvent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    @TransactionalEventListener这个注解有个比较特殊的熟悉就是<code>phase</code>这个属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TransactionPhase <span class="title">phase</span><span class="params">()</span> <span class="keyword">default</span> TransactionPhase.AFTER_COMMIT</span>;</span><br></pre></td></tr></table></figure><p>​    这个属性支持事务绑定到指定的阶段，包含下面几个级别：</p><ul><li><p>BEFORE_COMMIT</p></li><li><p>AFTER_COMMIT（默认）</p></li><li><p>AFTER_ROLLBACK</p></li><li><p>AFTER_COMPLETION</p></li></ul><p>​    监听器使用事务的场景个人目前没有碰到，所以这里仅仅根据官方文档简单翻译介绍了一番。</p><h3 id="JTA的集成"><a href="#JTA的集成" class="headerlink" title="JTA的集成"></a>JTA的集成</h3><p>​    如果需要集成JTA，那么配置文件不能使用某一特定的资源，而是需要配合JNDI同时配合<strong>JtaTransactionManager</strong>事务管理器进行全局的事务管理，下面我们来看一下配置的方式。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:jee</span>=<span class="string">"http://www.springframework.org/schema/jee"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/jee</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/jee/spring-jee.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">jee:jndi-lookup</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">jndi-name</span>=<span class="string">"jdbc/jpetstore"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"txManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.transaction.jta.JtaTransactionManager"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- other &lt;bean/&gt; definitions here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    </p><h3 id="和-JPA-Hibernate-的集成"><a href="#和-JPA-Hibernate-的集成" class="headerlink" title="和 JPA/Hibernate 的集成"></a>和 JPA/Hibernate 的集成</h3><p>​    注意不要眼花了，上节说的是<strong>JTA</strong>，这一节讲述的是ORM相关的JPA，关于他们的概念这里不再赘述，如果你的数据库使用的是JPA，使用声明式事务可以避免一个比较核心的问题，下面是代码的案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SessionFactory sessionFactory; <span class="comment">// (1)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 开启连接</span></span><br><span class="line">        Session session = sessionFactory.openSession(); <span class="comment">// (2)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启一个JPA的事务</span></span><br><span class="line">        session.beginTransaction();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行一个insert操作</span></span><br><span class="line">        session.save(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交事务</span></span><br><span class="line">        session.getTransaction().commit();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这样的代码会出现下面两个严重的问题：</p><ul><li>Hibernate 不知道 Spring 的 <code>@Transactional</code> 注释。</li><li>Spring 的 <code>@Transactional</code>对 Hibernate 的事务一无所知。</li></ul><p>​    如果我们使用声明式事务就不会出现上面的情况，Spring会在事务启动的时候，会自动切换到<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnNwcmluZy5pby9zcHJpbmctZnJhbWV3b3JrL2RvY3MvY3VycmVudC9qYXZhZG9jLWFwaS9vcmcvc3ByaW5nZnJhbWV3b3JrL29ybS9oaWJlcm5hdGU1L0hpYmVybmF0ZVRyYW5zYWN0aW9uTWFuYWdlci5odG1s" title="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/orm/hibernate5/HibernateTransactionManager.html">HibernateTransactionManager<i class="fa fa-external-link"></i></span> 或<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnNwcmluZy5pby9zcHJpbmctZnJhbWV3b3JrL2RvY3MvY3VycmVudC9qYXZhZG9jLWFwaS9vcmcvc3ByaW5nZnJhbWV3b3JrL29ybS9qcGEvSnBhVHJhbnNhY3Rpb25NYW5hZ2VyLmh0bWw=" title="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/orm/jpa/JpaTransactionManager.html">JpaTransactionManager<i class="fa fa-external-link"></i></span>（如果通过 JPA使用 Hibernate），HibernateTransactionManager 会确保这两种会话形式合并为同一个，这里也体现了一个非常常见的适配器模式的思路。</p><h3 id="响应式事务"><a href="#响应式事务" class="headerlink" title="响应式事务"></a>响应式事务</h3><p>​    响应式事务目前依然属于一个比较新颖的东西，也是Spring的未来主攻方向，极限编程的思想比较有意思，但是从目前环境来看使用频率比较低，所以此文就不再进行扩展讲述。</p><blockquote><p>还有更多的集成和使用方式可以参阅官方的文档，文章篇幅有限不能面面俱到。</p></blockquote><h2 id="（2）配置方式-1"><a href="#（2）配置方式-1" class="headerlink" title="（2）配置方式"></a>（2）配置方式</h2><p>​    声明式事务的配置方式有四种，其中最常使用的是注解的方式进行事务处理。</p><ol><li><strong>TransactionInterceptor</strong>  ：使用TransactionInterceptor 拦截器的方式，这种方式虽然不推荐使用，但是对于理解spring事务是有一定帮助的，感兴趣可以阅读一下这个类。</li><li><strong>基于AspectJ的XML方式</strong>（&lt;tx&gt;和&lt;aop&gt;标签）：不需要改动类，在XML文件中配置好即可，比如下面提供了一个事务的配置模板，同样是基于切面aop进行拦截增加事务的。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 数据源 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 通知 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 传播行为 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"save*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"insert*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"delete*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"update*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"find*"</span> <span class="attr">propagation</span>=<span class="string">"SUPPORTS"</span> <span class="attr">read-only</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"get*"</span> <span class="attr">propagation</span>=<span class="string">"SUPPORTS"</span> <span class="attr">read-only</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 切面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span></span></span><br><span class="line"><span class="tag"><span class="attr">pointcut</span>=<span class="string">"execution(* service.*.*(..))"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>基于事务代理工厂的Bean进行配置</strong>：比如下面配置了一个代理工厂的Bean - <strong>TransactionProxyFactoryBean</strong>，这种方式在以前是Spring推荐的方式，配置方式也比较古老，并且早在Spring2.0就不推荐使用了。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  .....</span><br><span class="line">      </span><br><span class="line">    <span class="comment">&lt;!-- 事务管理器 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myTracnsactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">&lt;!-- 事务代理工厂 --&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 生成事务代理对象 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"serviceProxy"</span> <span class="attr">class</span>=<span class="string">"org.springframework.transaction.interceptor.TransactionProxyFactoryBean"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"transactionManager"</span> <span class="attr">ref</span>=<span class="string">"myTracnsactionManager"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"target"</span> <span class="attr">ref</span>=<span class="string">"buyStockService"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"transactionAttributes"</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span>  </span><br><span class="line">                <span class="comment">&lt;!-- 主要 key 是方法     </span></span><br><span class="line"><span class="comment">                    ISOLATION_DEFAULT  事务的隔离级别  </span></span><br><span class="line"><span class="comment">                    PROPAGATION_REQUIRED  传播行为  </span></span><br><span class="line"><span class="comment">                --&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"add*"</span>&gt;</span>ISOLATION_DEFAULT,PROPAGATION_REQUIRED<span class="tag">&lt;/<span class="name">prop</span>&gt;</span>  </span><br><span class="line">                <span class="comment">&lt;!-- -Exception 表示发生指定异常回滚，+Exception 表示发生指定异常提交 --&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"buyStock"</span>&gt;</span>ISOLATION_DEFAULT,PROPAGATION_REQUIRED,-BuyStockException<span class="tag">&lt;/<span class="name">prop</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">          </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line">.....</span><br></pre></td></tr></table></figure><ol start="4"><li>最后就是常见<strong>使用@Transactional注解的方式进行配置</strong>，如果SpringBoot可以配合<code>@EnableTransactionManagement</code>直接引入事务，@Transactional可以配置在某个类上，也可以配置在方法上，但是同样依赖AOP同时只支持方法级的事务控制而不支持代码块级的事务控制。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(isolation=Isolation.DEFAULT,propagation=Propagation.REQUIRED,rollbackFor=BuyStockException<span class="class">.<span class="keyword">class</span>)</span></span><br></pre></td></tr></table></figure><h2 id="（3）理解事务传播级别"><a href="#（3）理解事务传播级别" class="headerlink" title="（3）理解事务传播级别"></a>（3）理解事务传播级别</h2><p>​    在上文我们提到了通过事务属性对象TransactionDefinition 进行事务的传播机制判断，这里我们接着来看一下事务的传播机制的类型，事务的传播级别在前文已经提到过了这里我们再回顾一下：</p><table><thead><tr><th>特点</th><th>传播级别</th><th>说明</th></tr></thead><tbody><tr><td>支持当前事务的情况：</td><td>TransactionDefinition.PROPAGATION_REQUIRED</td><td>如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</td></tr><tr><td>支持当前事务的情况：</td><td>TransactionDefinition.PROPAGATION_SUPPORTS</td><td>如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</td></tr><tr><td>支持当前事务的情况：</td><td>TransactionDefinition.PROPAGATION_MANDATORY</td><td>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</td></tr><tr><td>不支持当前事务的情况：</td><td>TransactionDefinition.PROPAGATION_REQUIRES_NEW</td><td>创建一个新的事务，如果当前存在事务，则把当前事务挂起。</td></tr><tr><td>不支持当前事务的情况：</td><td>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</td><td>以非事务方式运行，如果当前存在事务，则把当前事务挂起。</td></tr><tr><td>不支持当前事务的情况：</td><td>TransactionDefinition.PROPAGATION_NEVER</td><td>以非事务方式运行，如果当前存在事务，则抛出异常。</td></tr><tr><td>其他情况</td><td>TransactionDefinition.PROPAGATION_NESTED</td><td>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</td></tr></tbody></table><p>​    <strong>理解 <code>PROPAGATION_REQUIRED</code>：</strong></p><p>​    PROPAGATION_REQUIRED 如果不存在事务，就新建事务，如果出现嵌套的事务就会参与外层的事务而不会再新建。 这是同一线程内公共调用的十分方便的默认设置（例如委托给多个存储库方法的服务外观，其中所有底层资源都必须参与服务级别事务），同时基本能对付绝大多数的业务系统。</p><blockquote><p>讨论：这里讨论一下Spring官方文档和源码说明的“冲突”，默认情况下，如果出现嵌套事务，会默认采用已有事务，这样针对内部新建的事务会默认<strong>忽略事务隔离级别、超时值或只读标志（如果有）</strong>。 如果希望在内部事务采用不同隔离级别时候被外部事务拒绝并且抛出异常，可以考虑将事务管理器上的 <strong>validateExistingTransactions</strong> 标志切换为 true。</p><p>​    其实这种说法和源代码来看其实不是特别吻合，实际上如果设置validateExistingTransactions为false，会发现事务将继续执行，即使隔离级别与请求的不同，会按照外部事务的优先级执行，这样其实就导致了事务配置只看一份文件的情况，具体可以参考下面这一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isValidateExistingTransaction()) &#123;</span><br><span class="line"><span class="keyword">if</span> (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) &#123;</span><br><span class="line">I</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 如果设置了只读但是当前事务没有只读，则抛出异常</span></span><br><span class="line"><span class="keyword">if</span> (!definition.isReadOnly()) &#123;</span><br><span class="line"><span class="keyword">if</span> (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(<span class="string">"Participating transaction with definition ["</span> +</span><br><span class="line">definition + <span class="string">"] is not marked as read-only but existing transaction is"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没有则同步构建一个空事务</span></span><br></pre></td></tr></table></figure></blockquote><p>​    最后再补一张官方的图：</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20211230171527.png" alt=""></p><p>​    </p><p>​    <strong>理解 <code>PROPAGATION_REQUIRES_NEW</code>：</strong></p><p>​    <code>PROPAGATION_REQUIRES_NEW</code>与 相比<code>PROPAGATION_REQUIRED</code>，<strong>始终为每个受影响的事务范围使用独立的事务</strong>，从不参与外部范围的现有事务。每一个事务资源都是独立的，因此可以独立提交或回滚，外部事务同样不受内部事务回滚状态的影响，内部事务的锁在完成后立即释放。这样一个独立的内部事务也可以声明自己的隔离级别、超时和只读设置，<strong>而不继承外部事务的特性</strong>。</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20211230171507.png" alt=""></p><p>​    </p><p>​    <strong>理解 <code>PROPAGATION_NESTED</code>：</strong></p><p>​    <code>PROPAGATION_NESTED</code>使用了保存点的方式。嵌套事务意味着可以实现部分事务的回滚，但是嵌套的内部事务不会影响外部事务的执行。<strong>注意这个设置仅适用于 JDBC 资源事务</strong>，源码里面也有解释，可以参阅 Spring 的<a href="https://docs.spring.io/spring-framework/docs/5.3.14/javadoc-api/org/springframework/jdbc/datasource/DataSourceTransactionManager.html" target="_blank" rel="noopener"><code>DataSourceTransactionManager</code></a>。</p><h2 id="（3）源码解析"><a href="#（3）源码解析" class="headerlink" title="（3）源码解析"></a>（3）源码解析</h2><p>​    声明式事务要比编程式事务复杂不少，这一部分的代码不会深入讲解AOP的部分，同时由于使用了SpringBoot自动注入的特性这里也尽量不过度深入讲述，下面我们从两个部分来分析声明式式的内部操作流程：</p><ol><li>自动配置注入</li><li>注解拦截解析</li></ol><h3 id="自动配置注入"><a href="#自动配置注入" class="headerlink" title="自动配置注入"></a>自动配置注入</h3><p>​    首先来啃啃第一块大骨头。我们先从一个SpringApplication的注解开始开始，上文提到过SpringBoot新版本中如果碰到事务的相关依赖，会自动接入Spring的事务控制，我们可以通过注解@EnableTransaction进行排查，发现内部存在一个@EnableAutoConfiguration，Spring启动的时候，会扫描源代码包根路径下面一个叫做<code>spring.factories</code>的文件，在大约127行位置有一个<code>org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration</code>的配置，在这个配置下面中有一个<code>TransactionAutoConfiguration</code>的配置，当容器启动的时候会自动根据配置扫描相关的包载入相关的bean。最后从事务自动注入的注解内，可以从下面的截图看到一些熟悉的影子，这里不再重复解释。</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20211231151719.png" alt=""></p><p>​    接着我们再回过头看一下@EnableTransaction注解内部的内容，这里使用了@Import注入了TransactionManagementConfigurationSelector，这个类的作用是根据导入 @Configuration 类上的 EnableTransactionManagement.mode() 的值选择应使用 AbstractTransactionManagementConfiguration 的哪个实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import</span>(TransactionManagementConfigurationSelector<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableTransactionManagement</span></span></span><br></pre></td></tr></table></figure><p>​    我们可以从下面的代码看到，这里提供了两种代理方式，一种是根据JDK的代理模式，另一种是根据AspectJ的代理默认，Spring在默认情况下会优先选择JDK的代理，如果没有才会选择AspectJ的代理（总觉得Spring作者对于Aop总有一种遗憾和执念），如果读者想知道在哪里配置的，可以看看<code>org.springframework.scheduling.annotation.EnableAsync#mode</code>中存在一个默认的JDK代理配置，在下面的代码中可以到走JDK的代理注入了两个类<code>AutoProxyRegistrar.class</code>和<code>ProxyTransactionManagementConfiguration.class</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AdviceMode <span class="title">mode</span><span class="params">()</span> <span class="keyword">default</span> AdviceMode.PROXY</span>;</span><br><span class="line"></span><br><span class="line">-----分割线----</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">根据选择的代理模式生成不同的代理器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> String[] selectImports(AdviceMode adviceMode) &#123;</span><br><span class="line"><span class="keyword">switch</span> (adviceMode) &#123;</span><br><span class="line">        <span class="comment">// 默认都会走JDK的代理</span></span><br><span class="line"><span class="keyword">case</span> PROXY:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> String[] &#123;AutoProxyRegistrar<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(),</span></span><br><span class="line"><span class="class"><span class="title">ProxyTransactionManagementConfiguration</span>.<span class="title">class</span>.<span class="title">getName</span>()&#125;</span>;</span><br><span class="line">        <span class="comment">// 如果选择ApectJ，可以参考下面的代码</span></span><br><span class="line"><span class="keyword">case</span> ASPECTJ:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> String[] &#123;determineTransactionAspectClass()&#125;;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AutoProxyRegistrar.class</code>：</p><p>​    这个类直译就是自动代理注册器，它是一个后置处理器，负责给容器中注册一个InfrastructureAdvisorAutoProxyCreator，InfrastructureAdvisorAutoProxyCreator，利用后置处理器机制在对象创建以后，对对象进行包装，返回一个代理对象(增强器)，代理对象执行方法，利用拦截器链进行调用，下面是关于注册器的部分代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> candidateFound = <span class="keyword">false</span>;</span><br><span class="line">Set&lt;String&gt; annTypes = importingClassMetadata.getAnnotationTypes();</span><br><span class="line"><span class="keyword">for</span> (String annType : annTypes) &#123;</span><br><span class="line">      <span class="comment">// 解析和获取注解信息</span></span><br><span class="line">AnnotationAttributes candidate = AnnotationConfigUtils.attributesFor(importingClassMetadata, annType);</span><br><span class="line"><span class="keyword">if</span> (candidate == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">Object mode = candidate.get(<span class="string">"mode"</span>);</span><br><span class="line">Object proxyTargetClass = candidate.get(<span class="string">"proxyTargetClass"</span>);</span><br><span class="line"><span class="keyword">if</span> (mode != <span class="keyword">null</span> &amp;&amp; proxyTargetClass != <span class="keyword">null</span> &amp;&amp; AdviceMode<span class="class">.<span class="keyword">class</span> </span>== mode.getClass() &amp;&amp;</span><br><span class="line">Boolean<span class="class">.<span class="keyword">class</span> </span>== proxyTargetClass.getClass()) &#123;</span><br><span class="line">        <span class="comment">// 校验是否设置开启代理，如果配置则查看是否为JDK代理</span></span><br><span class="line">candidateFound = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (mode == AdviceMode.PROXY) &#123;</span><br><span class="line">          <span class="comment">// 核心代码，如果有必要就创建一个自动代理创建器</span></span><br><span class="line">AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry);</span><br><span class="line"><span class="keyword">if</span> ((Boolean) proxyTargetClass) &#123;</span><br><span class="line">            <span class="comment">// 强制将自动代理创建器绑定到用户代理</span></span><br><span class="line">AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    接着进入方法<code>AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry);</code>的内部实现<code>org.springframework.aop.config.AopConfigUtils#registerOrEscalateApcAsRequired</code>方法，AopConfigUtils这个工具类为AOP动态代理类创建器的主要负责工具：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerOrEscalateApcAsRequired</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">Class&lt;?&gt; cls, BeanDefinitionRegistry registry, @Nullable Object source)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 断言是否存在Bean，BeanDefinitionRegistry就是Spring容器中Bean的实际存在形式</span></span><br><span class="line">Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line"><span class="comment">// 注册器先判断是否有注入org.springframework.aop.config.internalAutoProxyCreator</span></span><br><span class="line"><span class="keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;</span><br><span class="line">BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line"><span class="keyword">if</span> (!cls.getName().equals(apcDefinition.getBeanClassName())) &#123;</span><br><span class="line">        <span class="comment">// 这里根据优先级获取，第一次进来的时候是肯定没有注入的</span></span><br><span class="line"><span class="keyword">int</span> currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());</span><br><span class="line"><span class="keyword">int</span> requiredPriority = findPriorityForClass(cls);</span><br><span class="line"><span class="keyword">if</span> (currentPriority &lt; requiredPriority) &#123;</span><br><span class="line">apcDefinition.setBeanClassName(cls.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以看作是将InfrastructureAdvisorAutoProxyCreator包装成RootBeanDefinition</span></span><br><span class="line">RootBeanDefinition beanDefinition = <span class="keyword">new</span> RootBeanDefinition(cls);</span><br><span class="line">beanDefinition.setSource(source);</span><br><span class="line">beanDefinition.getPropertyValues().add(<span class="string">"order"</span>, Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">    <span class="comment">// 核心部分：注入bean到ioc到容器当中，名字就是 org.springframework.aop.config.internalAutoProxyCreator</span></span><br><span class="line">registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);</span><br><span class="line"><span class="keyword">return</span> beanDefinition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    我们知道了InfrastructureAdvisorAutoProxyCreator这个类是如何集成到IOC容器之后，发现这个类属于一个下属的实现子类，我们通过继承链向上找到父类：AbstractAutoProxyCreator，这个类名字翻译过来是<strong>抽象自动代理创建器</strong>，他的作用是如果 bean 被子类标识为代理，则使用配置的拦截器创建代理，这里可以看作代理的生产者和执行者之间的解耦，核心代码如下部分：</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20220102161325.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(@Nullable Object bean, String beanName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line">        <span class="comment">// 是否必要进行增强包装处理</span></span><br><span class="line"><span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    内部的代码逻辑就不过多展开了，总结InfrastructureAdvisorAutoProxyCreator作用就是：<strong>利用后置处理器机制在对象创建以后，对对象进行包装，返回一个代理对象(增强器)，代理对象执行方法，最后利用拦截器链进行调用。</strong></p><blockquote><p>Tips：这部分代码需要对于Spring IOC和AOP的实现底层掌握比较牢固才能彻底理解，建议阅读卡死之后不要死犟，可以补补其他的模块实现之后再来啃下事务是如何集成到IOC和AOP的。</p></blockquote><h3 id="注解拦截解析"><a href="#注解拦截解析" class="headerlink" title="注解拦截解析"></a>注解拦截解析</h3><p>​    我们大致了解了自动配置自动配置是如何注入到Spring IOC之后，我们接着来看下Spring是如何实现事务的注解拦截解析的，也就是@Transactional注解的解析过程，上文说过，注解拦截器调用这里不再啰嗦，这里回到前文的对象<code>ProxyTransactionManagementConfiguration</code>也就是代理配置管理器开始，这里读者可能有疑问这个类那里突然冒出来的，这里给个提示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> PROXY:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> String[] &#123;AutoProxyRegistrar<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(),</span></span><br><span class="line"><span class="class">                     <span class="title">ProxyTransactionManagementConfiguration</span>.<span class="title">class</span>.<span class="title">getName</span>()&#125;</span>;</span><br></pre></td></tr></table></figure><p>​    下面截取了部分代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(name = TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME)</span><br><span class="line"><span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanFactoryTransactionAttributeSourceAdvisor <span class="title">transactionAdvisor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  TransactionAttributeSource transactionAttributeSource, TransactionInterceptor transactionInterceptor)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  BeanFactoryTransactionAttributeSourceAdvisor advisor = <span class="keyword">new</span> BeanFactoryTransactionAttributeSourceAdvisor();</span><br><span class="line">  <span class="comment">// 向切面中注入注解解析器,专门来解析事务注解的</span></span><br><span class="line">  advisor.setTransactionAttributeSource(transactionAttributeSource);</span><br><span class="line">  <span class="comment">// 向切面中注入事务的拦截器,专门来拦截方法,包括事务的提交以及回滚操作</span></span><br><span class="line">  advisor.setAdvice(transactionInterceptor);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.enableTx != <span class="keyword">null</span>) &#123;</span><br><span class="line">    advisor.setOrder(<span class="keyword">this</span>.enableTx.&lt;Integer&gt;getNumber(<span class="string">"order"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> advisor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    接着我们看一下被注入的属性：<code>TransactionAttributeSource</code>，这个类用于处理注解的属性和相关内容，也是注解解析器，这个类拥有很多的实现子类，因为是注解解析器，这里我们直接看：</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20220102163759.png" alt=""></p><p>​    部分代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationTransactionAttributeSource</span><span class="params">(<span class="keyword">boolean</span> publicMethodsOnly)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.publicMethodsOnly = publicMethodsOnly;</span><br><span class="line"><span class="keyword">if</span> (jta12Present || ejb3Present) &#123;</span><br><span class="line"><span class="keyword">this</span>.annotationParsers = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">      <span class="comment">// spring注解解析器</span></span><br><span class="line"><span class="keyword">this</span>.annotationParsers.add(<span class="keyword">new</span> SpringTransactionAnnotationParser());</span><br><span class="line"><span class="keyword">if</span> (jta12Present) &#123;</span><br><span class="line">        <span class="comment">// jta解析起</span></span><br><span class="line"><span class="keyword">this</span>.annotationParsers.add(<span class="keyword">new</span> JtaTransactionAnnotationParser());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ejb3Present) &#123;</span><br><span class="line">        <span class="comment">// ejb3的解析器</span></span><br><span class="line"><span class="keyword">this</span>.annotationParsers.add(<span class="keyword">new</span> Ejb3TransactionAnnotationParser());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 使用spring注解解析器</span></span><br><span class="line"><span class="keyword">this</span>.annotationParsers = Collections.singleton(<span class="keyword">new</span> SpringTransactionAnnotationParser());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用org.springframework.transaction.annotation.SpringTransactionAnnotationParser#parseTransactionAnnotation方法，内部部分代码如下：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTransactionAnnotationParser</span> <span class="keyword">implements</span> <span class="title">TransactionAnnotationParser</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">parseTransactionAnnotation</span><span class="params">(AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">RuleBasedTransactionAttribute rbta = <span class="keyword">new</span> RuleBasedTransactionAttribute();</span><br><span class="line"></span><br><span class="line">Propagation propagation = attributes.getEnum(<span class="string">"propagation"</span>);</span><br><span class="line">rbta.setPropagationBehavior(propagation.value());</span><br><span class="line">Isolation isolation = attributes.getEnum(<span class="string">"isolation"</span>);</span><br><span class="line">rbta.setIsolationLevel(isolation.value());</span><br><span class="line">rbta.setTimeout(attributes.getNumber(<span class="string">"timeout"</span>).intValue());</span><br><span class="line">rbta.setReadOnly(attributes.getBoolean(<span class="string">"readOnly"</span>));</span><br><span class="line">rbta.setQualifier(attributes.getString(<span class="string">"value"</span>));</span><br><span class="line"></span><br><span class="line">List&lt;RollbackRuleAttribute&gt; rollbackRules = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; rbRule : attributes.getClassArray(<span class="string">"rollbackFor"</span>)) &#123;</span><br><span class="line">rollbackRules.add(<span class="keyword">new</span> RollbackRuleAttribute(rbRule));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (String rbRule : attributes.getStringArray(<span class="string">"rollbackForClassName"</span>)) &#123;</span><br><span class="line">rollbackRules.add(<span class="keyword">new</span> RollbackRuleAttribute(rbRule));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; rbRule : attributes.getClassArray(<span class="string">"noRollbackFor"</span>)) &#123;</span><br><span class="line">rollbackRules.add(<span class="keyword">new</span> NoRollbackRuleAttribute(rbRule));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (String rbRule : attributes.getStringArray(<span class="string">"noRollbackForClassName"</span>)) &#123;</span><br><span class="line">rollbackRules.add(<span class="keyword">new</span> NoRollbackRuleAttribute(rbRule));</span><br><span class="line">&#125;</span><br><span class="line">rbta.setRollbackRules(rollbackRules);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> rbta;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    上面的代码比较好理解，就是对于注解的内部进行解析和封装。接着我们看一下是拦截器TransactionAspectSupport，这个拦截器实现了MethodInterceptor接口，标志为他是一个方法的拦截器，核心方法是内部的invoke()方法。</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20211227223244.png" alt=""></p><p>​    内部的invoke()方法内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">   <span class="comment">// 计算出目标类：可能是&#123;@code null&#125;。 TransactionAttributeSource 应该传递目标类以及方法，这可能来自接口。</span></span><br><span class="line">   Class&lt;?&gt; targetClass = (invocation.getThis() != <span class="keyword">null</span> ? AopUtils.getTargetClass(invocation.getThis()) : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 适配方法执行</span></span><br><span class="line">   <span class="keyword">return</span> invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    接着进入核心的适配方法<code>invokeWithinTransaction</code>，代码比较多，这里截取部分代码介绍：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">invokeWithinTransaction</span><span class="params">(Method method, @Nullable Class&lt;?&gt; targetClass,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> InvocationCallback invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果事务属性为空，则该方法是非事务性的（就是非事务方式执行）</span></span><br><span class="line">TransactionAttributeSource tas = getTransactionAttributeSource();</span><br><span class="line"><span class="keyword">final</span> TransactionAttribute txAttr = (tas != <span class="keyword">null</span> ? tas.getTransactionAttribute(method, targetClass) : <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">final</span> TransactionManager tm = determineTransactionManager(txAttr);</span><br><span class="line"><span class="comment">// 如果当前的注册器是响应式的，则按照响应式的方式处理</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.reactiveAdapterRegistry != <span class="keyword">null</span> &amp;&amp; tm <span class="keyword">instanceof</span> ReactiveTransactionManager) &#123;</span><br><span class="line"><span class="comment">// .......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PlatformTransactionManager ptm = asPlatformTransactionManager(tm);</span><br><span class="line"><span class="keyword">final</span> String joinpointIdentification = methodIdentification(method, targetClass, txAttr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (txAttr == <span class="keyword">null</span> || !(ptm <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line"><span class="comment">// 使用 getTransaction 和 commit/rollback 调用进行事务划分。</span></span><br><span class="line">TransactionInfo txInfo = createTransactionIfNecessary(ptm, txAttr, joinpointIdentification);</span><br><span class="line"></span><br><span class="line">Object retVal;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 这是环绕通知，调用拦截链中的下一个拦截器。 实际会调用目标对象。</span></span><br><span class="line">retVal = invocation.proceedWithInvocation();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="comment">// 目标方法调用失败</span></span><br><span class="line">completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 事务的后续清理操作</span></span><br><span class="line">cleanupTransactionInfo(txInfo);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">if</span> (retVal != <span class="keyword">null</span> &amp;&amp; vavrPresent &amp;&amp; VavrDelegate.isVavrTry(retVal)) &#123;</span><br><span class="line"><span class="comment">// 如果符合回滚规则则进行回滚</span></span><br><span class="line">TransactionStatus status = txInfo.getTransactionStatus();</span><br><span class="line"><span class="keyword">if</span> (status != <span class="keyword">null</span> &amp;&amp; txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line">retVal = VavrDelegate.evaluateTryFailure(retVal, txAttr, status);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 未出现异常,也获取事务管理器则进行事务的提交</span></span><br><span class="line">commitTransactionAfterReturning(txInfo);</span><br><span class="line"><span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// .......</span></span><br></pre></td></tr></table></figure><p>​    </p><h1 id="六、Spring事务实战"><a href="#六、Spring事务实战" class="headerlink" title="六、Spring事务实战"></a>六、Spring事务实战</h1><h2 id="（1）介绍"><a href="#（1）介绍" class="headerlink" title="（1）介绍"></a>（1）介绍</h2><p>​    为了防止读者误解，这里提前介绍一下本次实验操作的Spring版本和数据库版本：</p><ul><li>spring-boot：5.2.8</li><li>mysql：5.7</li></ul><p>下面我们进入实际部分，实战部分主要针对事务比较常见的使用：</p><ul><li>事务不生效的一些“坑”，以及如何规避或者如何解决。</li><li>不同事务的传播机制在实际代码中的效果。</li><li>大事务的问题，以及相关的处理方法。</li></ul><h2 id="（2）事务不生效的一些坑"><a href="#（2）事务不生效的一些坑" class="headerlink" title="（2）事务不生效的一些坑"></a>（2）事务不生效的一些坑</h2><p>​    首先来看一下事务不生效的一些坑，同样我们一开始需要构建一张表作为测试：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t_trans_test`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`amount`</span> <span class="built_in">decimal</span>(<span class="number">16</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb3;</span><br></pre></td></tr></table></figure><p>​    这里构建两条数据，分别表示两个人的余额：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`transaction_tb`</span>.<span class="string">`t_trans_test`</span> (<span class="string">`id`</span>, <span class="string">`name`</span>, <span class="string">`amount`</span>) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'用户A'</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`transaction_tb`</span>.<span class="string">`t_trans_test`</span> (<span class="string">`id`</span>, <span class="string">`name`</span>, <span class="string">`amount`</span>) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">'用户B'</span>, <span class="number">500</span>);</span><br></pre></td></tr></table></figure><h3 id="1-非事务方法调用事务方法"><a href="#1-非事务方法调用事务方法" class="headerlink" title="1.  非事务方法调用事务方法"></a>1.  非事务方法调用事务方法</h3><p>​    如果在一个非事务的方法内部调用一个事务的方法，无论是否加注解，会发现抛出异常的时候会事务不回滚的情况，也是最常见的情况，如下代码所描述的，假设我们用A给B转钱，A-100和B+100，如果在B中加入事务注解，但是A没有加，则会发现A的操作是没有回滚的：</p><blockquote><p>提示：这样的操作仅作演示，工作中扣款和充值绝对不是这样操作的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 随机异常触发flag</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> EXCEPTIN_FLAG = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事务失效的第一种情况：非事务方法调用事务方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">// 放开下面的注解即正常</span></span><br><span class="line"><span class="comment">// @Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nonTransactionUseTrasaction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"发起转账"</span>);</span><br><span class="line">        jdbcTemplate.update(<span class="string">"update t_trans_test set amount=amount-100 where name='用户A'"</span>);</span><br><span class="line">        innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">void</span> <span class="title">innerMethod</span>()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"接受转账"</span>);</span><br><span class="line">        <span class="keyword">if</span>(EXCEPTIN_FLAG)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"转账失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        jdbcTemplate.update(<span class="string">"update t_trans_test set amount=amount+100 where name='用户B'"</span>);</span><br><span class="line">    &#125;<span class="comment">/*运行结果：</span></span><br><span class="line"><span class="comment">    =========== 运行前数据准备重置数据 ========</span></span><br><span class="line"><span class="comment">    发起转账</span></span><br><span class="line"><span class="comment">    接受转账</span></span><br><span class="line"><span class="comment">    ====== 运行后查询操作结果 ======</span></span><br><span class="line"><span class="comment">    &#123;id=1, name=用户A, amount=900&#125;</span></span><br><span class="line"><span class="comment">    &#123;id=2, name=用户B, amount=500&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br></pre></td></tr></table></figure><p>​    解决方式：</p><p>​    解决方式有两种，一种是我们在事务A的上面增加一个回滚的注解，这个无需过多解释，但是如果有时候我们想让事务在一个内部的方法里面让事务的范围锁定在想要的方法。</p><p>最常见的一种方式是“注入自己”，还有一种方式是<strong>先允许获取Spring的代理对象，然后通过获取Spring的代理对象完成操作</strong>。</p><p>此外在spring5.0之后的版本又增加了新的获取方式，比如spring-test有<code>AopTestUtils</code>来获取，下面我们汇总一下这些方法，如果读者感兴趣可以实际验证一遍：</p><ul><li>注入“自己”。丑陋又笨，但是又快又有效。</li><li>使用`AopContext.currentProxy()``。</li><li>注入<code>ApplicationContext</code>，获取代理对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//    @Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nonTransactionUseTrasaction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"发起转账"</span>);</span><br><span class="line"><span class="comment">//        jdbcTemplate.update("update t_trans_test set amount=amount-100 where name='用户A'");</span></span><br><span class="line">        <span class="comment">// 第一种，常见方式：注入自己</span></span><br><span class="line"><span class="comment">//        transactionTestService.innerMethod();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用代理对象方式 ：AopContext.currentProxy()</span></span><br><span class="line"><span class="comment">//        TransactionTestService transactionTestService = (TransactionTestService) AopContext.currentProxy();</span></span><br><span class="line"><span class="comment">//        transactionTestService.innerMethod();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三种方法，注入 ApplicationContext</span></span><br><span class="line"><span class="comment">//        TransactionTestService transactionTestService = (TransactionTestService) applicationContext.getBean("transactionTestService");</span></span><br><span class="line"><span class="comment">//        transactionTestService.innerMethod();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 补充 - 获取Class: AopUtils.getTargetClass(yourObjectInstance);</span></span><br><span class="line"><span class="comment">//       AopUtils.getTargetClass(yourServiceClass);</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">protected</span> <span class="title">void</span> <span class="title">innerMethod</span>()</span>&#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">"update t_trans_test set amount=amount-100 where name='用户A'"</span>);</span><br><span class="line">        System.out.println(<span class="string">"接受转账"</span>);</span><br><span class="line">        <span class="keyword">if</span>(EXCEPTIN_FLAG)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"转账失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        jdbcTemplate.update(<span class="string">"update t_trans_test set amount=amount+100 where name='用户B'"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>还有更多方法欢迎讨论。 </p><h3 id="2-抛出不被回滚的异常"><a href="#2-抛出不被回滚的异常" class="headerlink" title="2. 抛出不被回滚的异常"></a>2. 抛出不被回滚的异常</h3><p>​    这也是非常常见的情况，所以很多时候建议使用注解就加上一个<code>rollBackFor</code>，哪怕使用默认的规则也建议标记一下，因为很多时候小小的疏忽就是埋雷。</p><p>比如下面的方法虽然抛出异常，但是可以发现最终数据是没有回滚的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抛出不被处理的异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional</span>(rollbackFor = RuntimeException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">void</span> <span class="title">throwErrorException</span>() <span class="title">throws</span> <span class="title">SQLException</span> </span>&#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">"update t_trans_test set amount=amount-100 where name='用户A'"</span>);</span><br><span class="line">        System.out.println(<span class="string">"接受转账"</span>);</span><br><span class="line">        <span class="keyword">if</span>(EXCEPTIN_FLAG)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"转账失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        jdbcTemplate.update(<span class="string">"update t_trans_test set amount=amount+100 where name='用户B'"</span>);</span><br><span class="line">    &#125;<span class="comment">/*运行结果：</span></span><br><span class="line"><span class="comment">    ========== 运行前数据准备重置数据 ========</span></span><br><span class="line"><span class="comment">    没有抛出支持回滚的异常测试</span></span><br><span class="line"><span class="comment">    接受转账</span></span><br><span class="line"><span class="comment">    ====== 运行后查询操作结果 ======</span></span><br><span class="line"><span class="comment">    &#123;id=1, name=用户A, amount=900&#125;</span></span><br><span class="line"><span class="comment">    &#123;id=2, name=用户B, amount=500&#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    */</span></span><br></pre></td></tr></table></figure><h3 id="3-“吞异常”"><a href="#3-“吞异常”" class="headerlink" title="3. “吞异常”"></a>3. “吞异常”</h3><p>​    吞异常也是常见的，很多时候会发现忘记抛出异常，当然实际情况没有那么明显，更多是在捕获异常之后没有抛出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不抛出异常，导致不回滚</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">void</span> <span class="title">nonThrowException</span>()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"发起转账"</span>);</span><br><span class="line">        jdbcTemplate.update(<span class="string">"update t_trans_test set amount=amount-1100 where name='用户A'"</span>);</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(<span class="string">"select * from t_trans_test where name='用户A'"</span>);</span><br><span class="line">        Map&lt;String, Object&gt; stringObjectMap = maps.get(<span class="number">0</span>);</span><br><span class="line">        BigDecimal amount = <span class="keyword">new</span> BigDecimal(stringObjectMap.get(<span class="string">"amount"</span>).toString());</span><br><span class="line">        <span class="keyword">if</span>(amount.compareTo(BigDecimal.ZERO) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            log.error(<span class="string">"余额不支持扣款"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">/*运行结果：</span></span><br><span class="line"><span class="comment">    =========== 运行前数据准备重置数据 ========</span></span><br><span class="line"><span class="comment">    没有抛出异常测试</span></span><br><span class="line"><span class="comment">    发起转账</span></span><br><span class="line"><span class="comment">    : 余额不支持扣款</span></span><br><span class="line"><span class="comment">    ====== 运行后查询操作结果 ======</span></span><br><span class="line"><span class="comment">    &#123;id=1, name=用户A, amount=-100&#125;</span></span><br><span class="line"><span class="comment">    &#123;id=2, name=用户B, amount=500&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br></pre></td></tr></table></figure><blockquote><p>偷偷埋下宝藏，日后惊艳全场？更多时候建议把抓到的异常像是抓到了定时炸弹。</p></blockquote><h3 id="4-数据库引擎不支持"><a href="#4-数据库引擎不支持" class="headerlink" title="4. 数据库引擎不支持"></a>4. 数据库引擎不支持</h3><p>​    这种情况绝大多数基本不会碰到，但是如果真遇到的时候确实很难想到，这里我们可以直接把表改了之后试了一下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t_trans_test <span class="keyword">ENGINE</span>=MyISAM;</span><br></pre></td></tr></table></figure><p>Mysql低版本的时候默认创建表就是用的MyISAM存储引擎，所以不要认为这种低级错误还会有人犯么？我只能说<strong>有，还不少</strong>。</p><p>​    修改表之后再进行前面的操作就会发现无论如何操作，最后都是没有办法回滚事务。</p><h3 id="5-非“公有”方法"><a href="#5-非“公有”方法" class="headerlink" title="5. 非“公有”方法"></a>5. 非“公有”方法</h3><p>​    这个相信几乎不会犯错（大概），因为如果你将一个事务注解放到一个不是public方法上，部分编辑器比如IDEA会直接提示的，比如idea提示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Methods annotated with &#39;@Transactional&#39; must be overridable</span><br></pre></td></tr></table></figure><p>如果你没看到那根红线，=-=那只能自求多福了。</p><p>一定要注意<strong>必须是public</strong>，非要问为什么，可以问问反射和动态代理。</p><p>有的同学可能会说<strong>那我IDEA设置成 Protected或者默认不加任何东西，IDEA也没报错但是也没回滚呀</strong>，我只能说楼下没单杠可以去体育场……</p><h2 id="（3）事务传播特性实战"><a href="#（3）事务传播特性实战" class="headerlink" title="（3）事务传播特性实战"></a>（3）事务传播特性实战</h2><p>​    下面又是事务的一个重点，也是必须要掌握的一个重点，那就是关于事务隔离级别在代码中的实际使用效果，下面我们将所有的情况都试验一遍：</p><table><thead><tr><th>特点</th><th>传播级别</th><th>说明</th></tr></thead><tbody><tr><td>支持当前事务的情况：</td><td>TransactionDefinition.PROPAGATION_REQUIRED</td><td>如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</td></tr><tr><td>支持当前事务的情况：</td><td>TransactionDefinition.PROPAGATION_SUPPORTS</td><td>如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</td></tr><tr><td>支持当前事务的情况：</td><td>TransactionDefinition.PROPAGATION_MANDATORY</td><td>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</td></tr><tr><td>不支持当前事务的情况：</td><td>TransactionDefinition.PROPAGATION_REQUIRES_NEW</td><td>创建一个新的事务，如果当前存在事务，则把当前事务挂起。</td></tr><tr><td>不支持当前事务的情况：</td><td>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</td><td>以非事务方式运行，如果当前存在事务，则把当前事务挂起。</td></tr><tr><td>不支持当前事务的情况：</td><td>TransactionDefinition.PROPAGATION_NEVER</td><td>以非事务方式运行，如果当前存在事务，则抛出异常。</td></tr><tr><td>其他情况</td><td>TransactionDefinition.PROPAGATION_NESTED</td><td>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</td></tr></tbody></table><h3 id="1-PROPAGATION-REQUIRED"><a href="#1-PROPAGATION-REQUIRED" class="headerlink" title="1. PROPAGATION_REQUIRED"></a>1. PROPAGATION_REQUIRED</h3><p>​    这个级别表示：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这意味如果存在嵌套的事务操作，默认会以最外层的事务的为准，这里可以验证一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1。 TransactionDefinition.PROPAGATION_REQUIRED 测试</span></span><br><span class="line"><span class="comment">     * 不同隔离级别调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//TransactionDefinition.PROPAGATION_REQUIRED</span></span><br><span class="line">    <span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>, <span class="title">propagation</span> </span>= Propagation.REQUIRED)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">required</span><span class="params">()</span></span>&#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">"update t_trans_test set amount=amount-100 where name='用户A'"</span>);</span><br><span class="line">        transactionTestService.requiredInner();</span><br><span class="line">        <span class="keyword">if</span>(EXCEPTIN_FLAG)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span>  RuntimeException(<span class="string">"回滚事务"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">/*运行结果：</span></span><br><span class="line"><span class="comment">    =========== 运行前数据准备重置数据 ========</span></span><br><span class="line"><span class="comment">    ====== 运行后查询操作结果 ======</span></span><br><span class="line"><span class="comment">    &#123;id=1, name=用户A, amount=1000&#125;</span></span><br><span class="line"><span class="comment">    &#123;id=2, name=用户B, amount=500&#125;</span></span><br><span class="line"><span class="comment">    java.lang.RuntimeException: 回滚事务</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// 注意这样使用会抛出异常</span></span><br><span class="line"><span class="comment">//    @Transactional(rollbackFor = RuntimeException.class, propagation = Propagation.NEVER)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requiredInner</span><span class="params">()</span></span>&#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">"update t_trans_test set amount=amount+100 where name='用户B'"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    从运行结果可以看出，如果在外层抛出事务的异常，哪怕内部的方法看似已经直接，最终结果依然会回滚，这也是十分常用的一种方式，所以被Spring设置这个级别为默认级别也可以理解。</p><h3 id="2-PROPAGATION-SUPPORTS"><a href="#2-PROPAGATION-SUPPORTS" class="headerlink" title="2. PROPAGATION_SUPPORTS"></a>2. PROPAGATION_SUPPORTS</h3><p>​    如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。这种方式也好理解，就是有我就使用事务，没有我就该咋样咋样，比较随性的方式，和TransactionDefinition.PROPAGATION_REQUIRED最大区别就是在没有事务的时候不会主动创建。</p><p>​    这里我们来看一个比较奇怪的现象，读者可以思考一下为什么会出现下面的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * Propagation.SUPPORTS 测试</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>, <span class="title">propagation</span> </span>= Propagation.SUPPORTS)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">required</span><span class="params">()</span></span>&#123;</span><br><span class="line">  jdbcTemplate.update(<span class="string">"update t_trans_test set amount=amount-100 where name='用户A'"</span>);</span><br><span class="line">  transactionTestService.requiredInner();</span><br><span class="line">  <span class="keyword">if</span>(EXCEPTIN_FLAG)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span>  RuntimeException(<span class="string">"回滚事务"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="comment">/*运行结果：</span></span><br><span class="line"><span class="comment">    =========== 运行前数据准备重置数据 ========</span></span><br><span class="line"><span class="comment">    ====== 运行后查询操作结果 ======</span></span><br><span class="line"><span class="comment">    &#123;id=1, name=用户A, amount=900&#125;</span></span><br><span class="line"><span class="comment">    &#123;id=2, name=用户B, amount=600&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    java.lang.RuntimeException: 回滚事务</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requiredInner</span><span class="params">()</span></span>&#123;</span><br><span class="line">  jdbcTemplate.update(<span class="string">"update t_trans_test set amount=amount+100 where name='用户B'"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    从上面的代码可以看到，我们将事务的传播特性改变之后，发现无论是外部还是内部哪怕都抛出了异常，都没有进行回滚也就是说当前 的代码是没有使用事务的！！！如果我们需要让他们在同一个事务里面，可以做如下调整，下面的代码经过调整之后，在内部的事务中发现外层是存在事务的，所以他会加入到外层的事务当中，但是此时如果把外层的注解去掉，会发现它依然会非事务方式执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">     * 2。 Propagation.SUPPORTS 测试</span></span><br><span class="line"><span class="comment">     * 3。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">void</span> <span class="title">required</span>()</span>&#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">"update t_trans_test set amount=amount-100 where name='用户A'"</span>);</span><br><span class="line">        transactionTestService.requiredInner();</span><br><span class="line">        <span class="keyword">if</span>(EXCEPTIN_FLAG)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span>  RuntimeException(<span class="string">"回滚事务"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">/*运行结果：</span></span><br><span class="line"><span class="comment">    修复之后：</span></span><br><span class="line"><span class="comment">    =========== 运行前数据准备重置数据 ========</span></span><br><span class="line"><span class="comment">    ====== 运行后查询操作结果 ======</span></span><br><span class="line"><span class="comment">    &#123;id=1, name=用户A, amount=1000&#125;</span></span><br><span class="line"><span class="comment">    &#123;id=2, name=用户B, amount=500&#125;</span></span><br><span class="line"><span class="comment">    java.lang.RuntimeException: 回滚事务</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>, <span class="title">propagation</span> </span>= Propagation.SUPPORTS)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requiredInner</span><span class="params">()</span></span>&#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">"update t_trans_test set amount=amount+100 where name='用户B'"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    可以看到这个传播级别使用比较容易犯错的，所以如果有必要使用的时候一定要手动抛出异常自己测试一下。</p><h3 id="3-PROPAGATION-MANDATORY"><a href="#3-PROPAGATION-MANDATORY" class="headerlink" title="3. PROPAGATION_MANDATORY"></a>3. PROPAGATION_MANDATORY</h3><p>​    这个级别比较简单粗暴，意思就是必须要有失误，否则我就报错，这里我们简单修改一下上一个小节的传播级别即可看到效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">     * Propagation.SUPPORTS 测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">// @Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">required</span><span class="params">()</span></span>&#123;</span><br><span class="line">  jdbcTemplate.update(<span class="string">"update t_trans_test set amount=amount-100 where name='用户A'"</span>);</span><br><span class="line">  transactionTestService.requiredInner();</span><br><span class="line">  <span class="keyword">if</span>(EXCEPTIN_FLAG)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span>  RuntimeException(<span class="string">"回滚事务"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="comment">/*运行结果：</span></span><br><span class="line"><span class="comment">    org.springframework.transaction.IllegalTransactionStateException: No existing transaction found for transaction marked with propagation 'mandatory'</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>, <span class="title">propagation</span> </span>= Propagation.MANDATORY)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requiredInner</span><span class="params">()</span></span>&#123;</span><br><span class="line">  jdbcTemplate.update(<span class="string">"update t_trans_test set amount=amount+100 where name='用户B'"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-PROPAGATION-NOT-SUPPORTED"><a href="#4-PROPAGATION-NOT-SUPPORTED" class="headerlink" title="4. PROPAGATION_NOT_SUPPORTED"></a>4. PROPAGATION_NOT_SUPPORTED</h3><p>​    创建一个新的事务，如果当前存在事务，则把当前事务挂起。这种级别设置意思是说内部的嵌套事务是独立的，如果内部存在失误则单独开启一个事务操作，但是我们实际操作之后发现居然报错了，抛出了一个CannotAcquireLockException的异常，这个异常搜索之后发现是数据库的数据行死锁了，为什么会死锁？这里建议读者可以先自己思考一下然后搜索下答案，这里就直接说了，这里涉及mysql的update机制，一个update的操作使用的是排他锁，此时按照当前的传播级别设置会出现事务挂起，但是挂起的时候锁是不会释放的，所以在内部方法执行的时候由于一直拿不到锁导致等待超时报错了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     PROPAGATION_NOT_SUPPORTED 测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">void</span> <span class="title">required</span>()</span>&#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">"update t_trans_test set amount=amount-100 where name='用户A'"</span>);</span><br><span class="line">        transactionTestService.requiredInner();</span><br><span class="line">        <span class="keyword">if</span>(EXCEPTIN_FLAG)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span>  RuntimeException(<span class="string">"回滚事务"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">/*运行结果：</span></span><br><span class="line"><span class="comment">  ====== 运行后查询操作结果 ======</span></span><br><span class="line"><span class="comment">  &#123;id=1, name=用户A, amount=1000&#125;</span></span><br><span class="line"><span class="comment">  &#123;id=2, name=用户B, amount=500&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    org.springframework.dao.CannotAcquireLockException: StatementCallback; SQL [update t_trans_test set amount=amount+100 where name='用户B']; Lock wait timeout exceeded; try restarting transaction; nested exception is com.mysql.cj.jdbc.exceptions.MySQLTransactionRollbackException: Lock wait timeout exceeded; try restarting transaction</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>, <span class="title">propagation</span> </span>= Propagation.NOT_SUPPORTED)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requiredInner</span><span class="params">()</span></span>&#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">"update t_trans_test set amount=amount+100 where name='用户B'"</span>);</span><br><span class="line">        <span class="keyword">if</span>(EXCEPTIN_FLAG)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span>  RuntimeException(<span class="string">"回滚事务"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    这里我们通过调整事务的执行操作顺序之后，可以看到在内部的事务回滚了，但是外部的事务没有回滚，这也意味着内部的事务回滚之后外部的事务直接失效了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">void</span> <span class="title">required</span>()</span>&#123;</span><br><span class="line">  transactionTestService.requiredInner();</span><br><span class="line">  jdbcTemplate.update(<span class="string">"update t_trans_test set amount=amount-100 where name='用户A'"</span>);</span><br><span class="line">  <span class="keyword">if</span>(EXCEPTIN_FLAG)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span>  RuntimeException(<span class="string">"回滚事务"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="comment">/*运行结果：</span></span><br><span class="line"><span class="comment">    =========== 运行前数据准备重置数据 ========</span></span><br><span class="line"><span class="comment">    ====== 运行后查询操作结果 ======</span></span><br><span class="line"><span class="comment">    &#123;id=1, name=用户A, amount=1000&#125;</span></span><br><span class="line"><span class="comment">    &#123;id=2, name=用户B, amount=600&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    java.lang.RuntimeException: 回滚事务</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>, <span class="title">propagation</span> </span>= Propagation.NOT_SUPPORTED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requiredInner</span><span class="params">()</span></span>&#123;</span><br><span class="line">  jdbcTemplate.update(<span class="string">"update t_trans_test set amount=amount+100 where name='用户B'"</span>);</span><br><span class="line">  <span class="keyword">if</span>(EXCEPTIN_FLAG)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span>  RuntimeException(<span class="string">"回滚事务"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-PROPAGATION-NEVER"><a href="#5-PROPAGATION-NEVER" class="headerlink" title="5. PROPAGATION_NEVER"></a>5. PROPAGATION_NEVER</h3><p>​    意思是不能有事务，有事务还会报错，这种情况就不演示了，用注解还不如不用注解，脱裤子放屁，目前个人没看到这个注解的实际使用场景。</p><h3 id="6-PROPAGATION-NESTED"><a href="#6-PROPAGATION-NESTED" class="headerlink" title="6. PROPAGATION_NESTED"></a>6. PROPAGATION_NESTED</h3><p>​    如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于<code>TransactionDefinition.PROPAGATION_REQUIRED</code>。</p><h1 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h1><p>​    这篇文章的内容比较多，Spring的事务在现在看来算是比较基础的东西，实际看代码发现并不是特别难，如果对于设计模式比较熟基本能看懂Spring的设计，下面我们来总结一下这篇文章的大致内容。</p><p>​    事务介绍：在文章的开始我们介绍了数据库事务的概念，事务是数据库是否流行的关键，事务的特性ACID，并发事务的问题，事务的主要四个隔离级别，以及简单介绍了事务中保存点的使用，这些是事务最为基础的内容，也是我们了解Spring事务的基础知识。</p><p>​    Spring事务：Spring 的事务在设计的考虑到了不同数据源以及多数据源的事务管理，在一开始我们重点列举了Spring事务的三个核心组件，将一个事务操作抽象为三个操作，获取连接，创建提交事务，回滚事务，这和上面提到的事务操作和特性和相吻合的。接着在事务隔离级别的基础上，Spring 设计了特性也就是事务的传播级别来实现不同的事务特性，在最后可以看一下整个S print设计的思路。</p><p>​    介绍完Spring的事务之后，开始介绍编程式事务的实现方式和声明式事务的实现方式，同时从源码的角度简单介绍了一下事务设计的核心，比如线程之间的事务隔离是通过ThreadLocal进行存储和隔离的，这也是实现嵌套事务的时候使用同一个事务的核心部分，介绍完编程式事务之后介绍了事务的核心声明式事务的，声明式的事务架构要比编程式事务复杂不少，需要更多的时间消化，并且需要一定的IOC容器和自动配置注入的知识才能看懂。</p><p>​    在最后的实战部分，我们总计了事务不生效的一些坑，和事务传播特性的一次实战，基本上把Spring事务注解基本使用场景列举了一下。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>​    主要的时间花费在阅读和理解源代码，不知道有多少人可以坚持到最后的，如果文章有任何建议或者错误欢迎指出。</p><h1 id="巨人的肩膀"><a href="#巨人的肩膀" class="headerlink" title="巨人的肩膀"></a>巨人的肩膀</h1><ol><li>如何使用原始的方式进行事务管理：<span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xNjk3MjIx" title="https://cloud.tencent.com/developer/article/1697221">https://cloud.tencent.com/developer/article/1697221<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubWFyY29iZWhsZXIuY29tL2d1aWRlcy9zcHJpbmctdHJhbnNhY3Rpb24tbWFuYWdlbWVudC10cmFuc2FjdGlvbmFsLWluLWRlcHRo" title="https://www.marcobehler.com/guides/spring-transaction-management-transactional-in-depth">Spring Transaction Management: @Transactional In-Depth<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxODAwMTc1Mg==" title="https://segmentfault.com/a/1190000018001752">Spring源码分析：声明式事务梳理<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubWRuaWNlLmNvbS93cml0aW5nL2I0Njk2ZGNjYzljMDRjZjY4NmFlZjUwYWM4NWIzYjUw" title="https://www.mdnice.com/writing/b4696dccc9c04cf686aef50ac85b3b50">Spring声明式事务源码探究<i class="fa fa-external-link"></i></span></li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      Spring事务机制个人总结
    
    </summary>
    
    
      <category term="Spring" scheme="https://whitestore.top/categories/Spring/"/>
    
    
      <category term="Spring" scheme="https://whitestore.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>《跟闪电侠学Netty》阅读笔记 - 聊天系统实现</title>
    <link href="https://whitestore.top/2023/07/11/nettychatimpl/"/>
    <id>https://whitestore.top/2023/07/11/nettychatimpl/</id>
    <published>2023-07-11T08:50:48.000Z</published>
    <updated>2023-07-16T06:24:10.829Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>本部分整合聊天系统有关的章节，内容主要是介绍关键功能的实现逻辑和部分代码实现为主，建议读者先看看作者的博客项目，切换到不同的分支看看各个细节功能如何实现。这里仅仅记录一些个人学习过程的重点部分。</p><h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubXVidS5jb20vZG9jLzFkdW5OXzdMdXps" title="https://www.mubu.com/doc/1dunN_7Luzl">https://www.mubu.com/doc/1dunN_7Luzl<i class="fa fa-external-link"></i></span></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/%E3%80%8A%E8%B7%9F%E9%97%AA%E7%94%B5%E4%BE%A0%E5%AD%A6Netty%E3%80%8B%20-%20%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0.png" alt="《跟闪电侠学Netty》 - 聊天系统实现.png"></p><h1 id="项目代码"><a href="#项目代码" class="headerlink" title="项目代码"></a>项目代码</h1><p>作者的仓库代码地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpZ2h0bmluZ01hbi9mbGFzaC1uZXR0eQ==" title="https://github.com/lightningMan/flash-netty">https://github.com/lightningMan/flash-netty<i class="fa fa-external-link"></i></span></p><a id="more"></a><h1 id="通信协议设计和自定义编解码实现"><a href="#通信协议设计和自定义编解码实现" class="headerlink" title="通信协议设计和自定义编解码实现"></a>通信协议设计和自定义编解码实现</h1><h2 id="什么是通信协议？"><a href="#什么是通信协议？" class="headerlink" title="什么是通信协议？"></a>什么是通信协议？</h2><p>基于TCP通信均为二进制协议，底层都是通过字节进行传输的。在通信协议当中规定数据传输的每一个字节含义。</p><h2 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h2><ol><li>客户端转换数据为二进制。  </li><li>网络传输给服务端。</li><li>服务端根据协议规则读取二进制数据。  </li><li>服务端处理数据返回响应结果给客户端。  </li></ol><h2 id="聊天系统的通信协议数据对象设计"><a href="#聊天系统的通信协议数据对象设计" class="headerlink" title="聊天系统的通信协议数据对象设计"></a>聊天系统的通信协议数据对象设计</h2><p>在聊天系统当中通信协议的设计如下。</p><h3 id="4字节魔数"><a href="#4字节魔数" class="headerlink" title="4字节魔数"></a>4字节魔数</h3><p>比如Java的字节码<code>CafeBabe</code>，用于快速识别是否自定义协议，也可以方便快速提取数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAGIC_NUMBER = <span class="number">0x12345678</span>;</span><br></pre></td></tr></table></figure><h3 id="1-字节版本号"><a href="#1-字节版本号" class="headerlink" title="1 字节版本号"></a>1 字节版本号</h3><p>类似TCP的IPV4还是IPV6。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 协议版本  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="meta">@JSONField</span>(deserialize = <span class="keyword">false</span>, serialize = <span class="keyword">false</span>)  </span><br><span class="line"><span class="keyword">private</span> Byte version = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="1-字节序列化算法"><a href="#1-字节序列化算法" class="headerlink" title="1 字节序列化算法"></a>1 字节序列化算法</h3><p>使用1个字节来标识算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 序列化算法定义  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SerializerAlgorithm</span> </span>&#123;  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * json 序列化  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">byte</span> JSON = <span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-字节指令"><a href="#1-字节指令" class="headerlink" title="1 字节指令"></a>1 字节指令</h3><p>一个字节最多表示256种指令。注意在设计上指令和版本号进行绑定关联，实现不同版本之间的指令兼容，提高程序的健壮性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Packet</span> </span>&#123;  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 协议版本  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="meta">@JSONField</span>(deserialize = <span class="keyword">false</span>, serialize = <span class="keyword">false</span>)  </span><br><span class="line">    <span class="keyword">private</span> Byte version = <span class="number">1</span>;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@JSONField</span>(serialize = <span class="keyword">false</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Byte <span class="title">getCommand</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4字节数据长度"><a href="#4字节数据长度" class="headerlink" title="4字节数据长度"></a>4字节数据长度</h3><p>数据长度是必要的，主要用于字节流这种连续不断的数据形式进行切割。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byteBuf.writeInt(bytes.length);</span><br></pre></td></tr></table></figure><blockquote><p>int 基本数据类型在Java中默认占4个字节，这4个字节用来存储字节数组的长度。</p></blockquote><h3 id="N字节数据"><a href="#N字节数据" class="headerlink" title="N字节数据"></a>N字节数据</h3><p>数据部分。</p><h2 id="如何实现JAVA对象二进制互相转化？"><a href="#如何实现JAVA对象二进制互相转化？" class="headerlink" title="如何实现JAVA对象二进制互相转化？"></a>如何实现JAVA对象二进制互相转化？</h2><p>所谓互转对应了网络 Socket IO 的<code>input/output</code>中的数据转化部分，实体数据转为字节流这个过程我们通常叫做<strong>编码</strong>，反之则是解码。</p><p>无论是编码还是解码，都是依赖Netty自定义的 <strong>MessageToMessageCodec</strong>实现。聊天系统的编码和解码工作都是依赖 <strong>PacketCodecHandler</strong> 完成的。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PacketCodecHandler</span> <span class="keyword">extends</span> <span class="title">MessageToMessageCodec</span>&lt;<span class="title">ByteBuf</span>, <span class="title">Packet</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> PacketCodecHandler INSTANCE = <span class="keyword">new</span> PacketCodecHandler();  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">PacketCodecHandler</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf byteBuf, List&lt;Object&gt; out)</span> </span>&#123;  </span><br><span class="line">        out.add(PacketCodec.INSTANCE.decode(byteBuf));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Packet packet, List&lt;Object&gt; out)</span> </span>&#123;  </span><br><span class="line">        ByteBuf byteBuf = ctx.channel().alloc().ioBuffer();  </span><br><span class="line">        PacketCodec.INSTANCE.encode(byteBuf, packet);  </span><br><span class="line">        out.add(byteBuf);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义逻辑处理器，在 Netty Server 中需要注册到 <strong>pipeline</strong> 当中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">    NioEventLoopGroup boosGroup = <span class="keyword">new</span> NioEventLoopGroup();  </span><br><span class="line">    NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">final</span> ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();  </span><br><span class="line">    serverBootstrap  </span><br><span class="line">            .group(boosGroup, workerGroup)  </span><br><span class="line">            .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)  </span></span><br><span class="line"><span class="class">            .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_BACKLOG</span>, 1024)  </span></span><br><span class="line"><span class="class">            .<span class="title">childOption</span>(<span class="title">ChannelOption</span>.<span class="title">SO_KEEPALIVE</span>, <span class="title">true</span>)  </span></span><br><span class="line"><span class="class">            .<span class="title">childOption</span>(<span class="title">ChannelOption</span>.<span class="title">TCP_NODELAY</span>, <span class="title">true</span>)  </span></span><br><span class="line"><span class="class">            .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">NioSocketChannel</span>&gt;() </span>&#123;  </span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> </span>&#123;  </span><br><span class="line">                <span class="comment">//......</span></span><br><span class="line">                    ch.pipeline().addLast(PacketCodecHandler.INSTANCE); </span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    bind(serverBootstrap, PORT);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里解释下为什么<code>PacketCodecHandler</code>要被注解标记为“<strong>Sharable</strong>”，因为编码和解码可能在多个<code>handler</code>中用到，为了提高效率，这里通过共享减少实例的创建。</p><blockquote><p>下文也会介绍这个单例模式的优化点。</p></blockquote><p>带着疑问我们再看看<code>@ChannelHandler.Sharable</code>这个注解的源码解释。</p><blockquote><p>Indicates that the same instance of the annotated ChannelHandler can be added to one or more ChannelPipelines multiple times without a race condition.<br>    If this annotation is not specified, you have to create a new handler instance every time you add it to a pipeline because it has unshared state such as member variables.<br>    This annotation is provided for documentation purpose, just like the JCIP annotations </p></blockquote><p>上面的内容翻译过来就是：</p><p>被注解的<code>Sharable</code>的同一个<strong>ChannelHandler</strong>实例，可以被多次添加到一个或多个<code>ChannelPipeline</code>中，并且可以确保不会出现竞争情况。如果没有指定这个注解，那么每次就创建新的Channel都需要使用新的Handler实例。在有不共享的状态，如成员变量时候，就不能用这个注解。</p><p>简单来说<code>@ChannelHandler.Sharable</code>实现了Netty中的”Bean”单例和共享。</p><h2 id="实战部分"><a href="#实战部分" class="headerlink" title="实战部分"></a>实战部分</h2><h3 id="数据编码过程（思路）"><a href="#数据编码过程（思路）" class="headerlink" title="数据编码过程（思路）"></a>数据编码过程（思路）</h3><p>下面是数据解码的基本编写思路。</p><ol><li>添加编码器。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> PacketEncoder());</span><br></pre></td></tr></table></figure><ol start="2"><li>往<code>ByteBuf</code>逐个写字段，实现编码过程。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PacketEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">Packet</span>&gt; </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Packet packet, ByteBuf out)</span> </span>&#123;  </span><br><span class="line">        PacketCodec.INSTANCE.encode(out, packet);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>完整的自定义协议：<strong>PacketCodec#encode</strong>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ByteBuf byteBuf, Packet packet)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 1. 序列化 java 对象  </span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = Serializer.DEFAULT.serialize(packet);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 2. 实际编码过程  </span></span><br><span class="line">    byteBuf.writeInt(MAGIC_NUMBER);  </span><br><span class="line">    byteBuf.writeByte(packet.getVersion());  </span><br><span class="line">    byteBuf.writeByte(Serializer.DEFAULT.getSerializerAlgorithm());  </span><br><span class="line">    byteBuf.writeByte(packet.getCommand());  </span><br><span class="line">    byteBuf.writeInt(bytes.length);  </span><br><span class="line">    byteBuf.writeBytes(bytes);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解码数据过程（思路）"><a href="#解码数据过程（思路）" class="headerlink" title="解码数据过程（思路）"></a>解码数据过程（思路）</h3><p>下面是数据解码的基本编写思路：</p><ol><li>在handler当中添加自定义逻辑处理器。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> PacketDecoder());</span><br><span class="line">&#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li>定义解码逻辑处理器。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PacketDecoder</span> <span class="keyword">extends</span> <span class="title">MessageToMessageDecoder</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List out)</span> </span>&#123;  </span><br><span class="line">        out.add(PacketCodec.INSTANCE.decode(in));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面定义具体的解码过程：</p><ul><li>跳过魔数。</li><li>跳过协议版本号  。</li><li>读取序列化算法。</li><li>读取指令，数据包，算法标识等自定义协议的基本内容。</li><li>根据数据长度。</li><li>取出数据。</li></ul><p><strong>PacketCodec#decode</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Packet <span class="title">decode</span><span class="params">(ByteBuf byteBuf)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 跳过 magic number    byteBuf.skipBytes(4);  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 跳过版本号  </span></span><br><span class="line">    byteBuf.skipBytes(<span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 序列化算法  </span></span><br><span class="line">    <span class="keyword">byte</span> serializeAlgorithm = byteBuf.readByte();  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 指令  </span></span><br><span class="line">    <span class="keyword">byte</span> command = byteBuf.readByte();  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 数据包长度  </span></span><br><span class="line">    <span class="keyword">int</span> length = byteBuf.readInt();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];  </span><br><span class="line">    byteBuf.readBytes(bytes);  </span><br><span class="line">  </span><br><span class="line">    Class&lt;? extends Packet&gt; requestType = getRequestType(command);  </span><br><span class="line">    Serializer serializer = getSerializer(serializeAlgorithm);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (requestType != <span class="keyword">null</span> &amp;&amp; serializer != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> serializer.deserialize(requestType, bytes);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h3 id="JSON序列化方式之外其他序列化方式如何实现？"><a href="#JSON序列化方式之外其他序列化方式如何实现？" class="headerlink" title="JSON序列化方式之外其他序列化方式如何实现？"></a>JSON序列化方式之外其他序列化方式如何实现？</h3><h4 id="Java原生序列化"><a href="#Java原生序列化" class="headerlink" title="Java原生序列化"></a>Java原生序列化</h4><ul><li>类实现 Serializable 接口  </li><li>具体底层由ObjectOutputStream和ObjectInputStream实现  </li></ul><h4 id="Hessian"><a href="#Hessian" class="headerlink" title="Hessian"></a>Hessian</h4><ul><li>Hessian 是动态类型、二进制、紧凑的，并且可跨语言移植的一种序列化框架  </li><li>Hessian 协议要比 JDK、JSON 更加紧凑，性能上要比 JDK、JSON 序列化高效很多，而且生成的字节数也更小  </li></ul><h4 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h4><ul><li>谷歌实现的混合语言数据标准  </li><li>轻便、高效的结构化数据存储格式  </li><li>支持 Java、Python、C++、Go 等语言  </li><li>要求定义 IDL（Interface description language），并且使用对应语言的IDL生成序列化工具类</li></ul><h4 id="Thrift"><a href="#Thrift" class="headerlink" title="Thrift"></a>Thrift</h4><ul><li>Facebook于2007年开发的跨语言的rpc服框架  </li><li>通过Thrift的编译环境生成各种语言类型的接口文件</li></ul><h3 id="序列化和编码都是JAVA对象封装二进制过程，两者的联系和区别"><a href="#序列化和编码都是JAVA对象封装二进制过程，两者的联系和区别" class="headerlink" title="序列化和编码都是JAVA对象封装二进制过程，两者的联系和区别"></a>序列化和编码都是JAVA对象封装二进制过程，两者的联系和区别</h3><p>总结起来就是一句话：<strong>序列化是目标，编码是方法</strong>。网上有一张图非常直观的展示了两者的区别。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230629143232.png" alt="序列化和编码都是JAVA对象封装二进制过程，两者的联系和区别"></p><h4 id="两者的联系和区别"><a href="#两者的联系和区别" class="headerlink" title="两者的联系和区别"></a>两者的联系和区别</h4><p><strong>编码</strong>：信息从一种形式或格式转换为另一种形式的过程，目的是方便传输协议通信。</p><p><strong>序列化</strong>：“序列化”其实本身也是“信息从一种形式或格式转换为另一种形式的过程”，只不过这个表现形式直观具体，序列化也常常用于表达一个对象的状态。</p><h2 id="聊天系统的Netty细节优化"><a href="#聊天系统的Netty细节优化" class="headerlink" title="聊天系统的Netty细节优化"></a>聊天系统的Netty细节优化</h2><p>优化部分是聊天系统的精髓，也是使用Netty实践非常有价值的指导和参考，所以优先把优化部分放到前面介绍。</p><h2 id="1-使用共享Handler"><a href="#1-使用共享Handler" class="headerlink" title="1. 使用共享Handler"></a>1. 使用共享Handler</h2><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>在旧版本代码中，每个新连接每次通过 <strong>ChannelInitializer</strong> 调用，都会产生9个指令对象都被new一遍操作，但是可以看到其实很多处理器内部是没有任何 “状态”的，<strong>对于无状态的业务处理器就可以使用单例模式封装</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap</span><br><span class="line">                .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> </span>&#123;</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> Spliter());</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> PacketDecoder());</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> LoginRequestHandler());</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> AuthHandler());</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> MessageRequestHandler());</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> CreateGroupRequestHandler());</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> JoinGroupRequestHandler());</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> QuitGroupRequestHandler());</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> ListGroupMembersRequestHandler());</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> GroupMessageRequestHandler());</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> LogoutRequestHandler());</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> PacketEncoder());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure><h3 id="优化手段"><a href="#优化手段" class="headerlink" title="优化手段"></a>优化手段</h3><ul><li>通过加入注解 <code>@ChannelHandler.Shareble</code>，表示这个 handler 是支持多个 channel 共享的，否则会报错。</li><li>发布静态<strong>final</strong>的<strong>不可变对象</strong>来实现单例，编译器优化。  </li><li>最后还可以压缩Handler，把编码和解码过程放到一个Handler和公用的Handler放到一个Handller处理（比如请求指令分发解析处理）。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>主要的注意事项如下：</p><ul><li>并不是所有的Handler都可以单例  </li><li><strong>Spliter</strong> 不是单例的，因为它需要对每个数据做拆包处理。</li></ul><h2 id="2-缩短事件传播路径"><a href="#2-缩短事件传播路径" class="headerlink" title="2. 缩短事件传播路径"></a>2. 缩短事件传播路径</h2><h3 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h3><ul><li>首先，指令的<strong>decode</strong>必须要在最前面前面，因为涉及后面的命令解析，所以这个Handler是无法“压缩”的。</li><li>但是如果把每个命令<strong>decode</strong>之后再传播到每个命令事件，但是对应的事件又不做任何处理，那么会浪费很多次多余的命令判断。</li><li>根本目的：<strong>缩短事件传播链条</strong>，事件传播链尽可能短。</li></ul><h3 id="优化手段-1"><a href="#优化手段-1" class="headerlink" title="优化手段"></a>优化手段</h3><p>优化手段实际上也很简单，那就是 <strong>使用统一Handler</strong>。</p><p>通常的做法如下：</p><ol><li>该Handler只做判断，不做任何状态存储，使用单例优化。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> IMHandler INSTANCE = <span class="keyword">new</span> IMHandler();</span><br></pre></td></tr></table></figure><ol start="2"><li>聊天系统中利用HashMap存储所有的命令处理Handler，这里个人顺带指定下初始化大小优化一下。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">IMHandler</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    handlerMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">7</span>);  </span><br><span class="line">  </span><br><span class="line">    handlerMap.put(MESSAGE_REQUEST, MessageRequestHandler.INSTANCE);  </span><br><span class="line">    handlerMap.put(CREATE_GROUP_REQUEST, CreateGroupRequestHandler.INSTANCE);  </span><br><span class="line">    handlerMap.put(JOIN_GROUP_REQUEST, JoinGroupRequestHandler.INSTANCE);  </span><br><span class="line">    handlerMap.put(QUIT_GROUP_REQUEST, QuitGroupRequestHandler.INSTANCE);  </span><br><span class="line">    handlerMap.put(LIST_GROUP_MEMBERS_REQUEST, ListGroupMembersRequestHandler.INSTANCE);  </span><br><span class="line">    handlerMap.put(GROUP_MESSAGE_REQUEST, GroupMessageRequestHandler.INSTANCE);  </span><br><span class="line">    handlerMap.put(LOGOUT_REQUEST, LogoutRequestHandler.INSTANCE);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>回调<code>channelRead0</code> 实际上就是委托给map中的元素对应的指令处理器处理。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, Packet packet)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">    handlerMap.get(packet.getCommand()).channelRead(ctx, packet);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过一个统一的处理器包括多个静态单例处理器，有效减少JVM内存开销，单例也可以减少对象实例化的开销。</p><h2 id="3-事件传播源调整"><a href="#3-事件传播源调整" class="headerlink" title="3. 事件传播源调整"></a>3. 事件传播源调整</h2><h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><p>如果你的 outBound 类型的 handler 较多，在写数据的时候能用 <code>ctx.writeAndFlush()</code> 就用这个方法， 不要用 <code>ctx.channel().writeAndFlush()</code>。</p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>究其原因是<strong>ctx.writeAndFlush()</strong> 会绕过所有不需要处理的其他Outbound类型。<code>ctx.writeAndFlush()</code> 是从 pipeline 链中的<strong>当前节点开始往前找到第一个 outBound 类型向前传播</strong>的，如果这个对象不需要其他outBound的handler处理就可以用这个方法。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230710214033.png" alt="ctx.writeAndFlush()"></p><p>而<strong>ctx.channel().writeAndFlush()</strong> 表现则不同，它是从pipeline 链中的<strong>最后一个</strong> outBound 类型的 handler 开始，把对象往前进行传播，从图中就可以看到， outBound 的处理器越多，就会产生越多“无用”操作。</p><p>当然如果确定后面的 outBound 需要如此处理，那么就可以用这个方法。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230710214215.png" alt="ctx.channel().writeAndFlush()"></p><h3 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h3><ul><li>writeAndFlush为什么可以缩短事件传播路径？  </li><li>它是如何实现OutBound类型的事件传播缩短的?</li></ul><h2 id="4-减少阻塞主线程的操作【重要】"><a href="#4-减少阻塞主线程的操作【重要】" class="headerlink" title="4. 减少阻塞主线程的操作【重要】"></a>4. 减少阻塞主线程的操作【重要】</h2><p>Netty中容易被忽视，却是非常重要的一个概念。那就是 <strong>一个Channel的其中一个Handler阻塞，会导致所有其他绑定的Channel一起被拖慢</strong>。</p><p>比如只要有一个 <code>channel</code>的一个 <code>handler</code> 中的 <code>channelRead0()</code> 方法阻塞了 NIO 线程，最终都会拖慢绑定在该 NIO 线程上的其他所有的 channel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Channel&gt; channelList = 已有数据可读的 channel</span><br><span class="line"><span class="keyword">for</span> (Channel channel in channelist) &#123;</span><br><span class="line">   <span class="keyword">for</span> (ChannelHandler handler in channel.pipeline()) &#123;</span><br><span class="line">       handler.channelRead0();</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的操作如果for循环某次出现卡顿，这不仅仅拖慢一个客户端，而是拖慢所有客户端。</p><p>所以Netty进行客户端处理的时候一般设计为非阻塞模式，或者会使用 <strong>业务线程池</strong> 去预防这种情况。业务线程池的实现方式更为常见，也就是Netty中一套线程池，实际处理过程中再委派给自定义的业务线程池单开线程处理。这样就实现了非阻塞异步执行任务的目的。</p><p>需要注意引入业务线程池会增加系统复杂度，也会增加线上调试难度，所以做好链路追踪十分重要。</p><h2 id="5-如何准确统计时长？"><a href="#5-如何准确统计时长？" class="headerlink" title="5. 如何准确统计时长？"></a>5. 如何准确统计时长？</h2><p>错误做法：在一个线程的头尾加入时间差计算得出执行时长结果。</p><p>正确做法：使用<strong>writeAndFlush+addListener</strong> 的方式判断 <code>futrue.isDone</code> 之后才计算  </p><p>原因：<strong>writeAndFlush</strong> 在非NIO线程中它是一个异步操作，其他操作由第一个任务队列异步执行。 </p><p>关键点：<strong>writeAndFlush</strong> 真正执行完成才算是完成处理，监听它完成处理的回调动作才能算出准确执行时长。</p><h2 id="优化小结"><a href="#优化小结" class="headerlink" title="优化小结"></a>优化小结</h2><ul><li>如果Handler多例但是无状态，完全可以改为单例模式 。</li><li>尽可能减少Handler的臃肿，防止调用链路过长。</li><li>Handler的耗时操作要交给线程池开启新线程处理，一个耗时操作不只影响单个Channel。建议业务线程池单独开新线程方式优化，但是需要注意和线程绑定的相关参数处理问题 。</li><li>耗时统计，writeAndFlush属于异步任务。</li></ul><h1 id="实现登录"><a href="#实现登录" class="headerlink" title="实现登录"></a>实现登录</h1><h2 id="处理流程图"><a href="#处理流程图" class="headerlink" title="处理流程图"></a>处理流程图</h2><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230711112329.png" alt="处理流程图"></p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><ul><li>目标客户端和服务端分别启动Netty服务。</li><li>客户端发送登录请求指令，服务端解码之后根据传输结果校验，根据校验结果构建登录请求响应指令LoginResponsePacket。</li><li>通过ctx.writeAndFlush(loginResponsePacket); 回送响应结果给客户端。<ul><li>登录校验成功，通过SessionUtil添加session信息  </li></ul></li><li>客户端登录成功之后，构建请求指令对象，设置参数，通过Netty发送到服务端 。</li><li>服务端收到请求进行验证，并且构建相对应的响应指令结果对象。</li></ul><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>下面是大致的实现步骤：</p><ol><li>添加 <strong>LoginRequestHandler</strong> 登录逻辑处理器在Server端。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(LoginRequestHandler.INSTANCE);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginRequestHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">LoginRequestPacket</span>&gt; </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> LoginRequestHandler INSTANCE = <span class="keyword">new</span> LoginRequestHandler();  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">LoginRequestHandler</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, LoginRequestPacket loginRequestPacket)</span> </span>&#123;  </span><br><span class="line">        LoginResponsePacket loginResponsePacket = <span class="keyword">new</span> LoginResponsePacket();  </span><br><span class="line">        loginResponsePacket.setVersion(loginRequestPacket.getVersion());  </span><br><span class="line">        loginResponsePacket.setUserName(loginRequestPacket.getUserName());  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (valid(loginRequestPacket)) &#123;  </span><br><span class="line">            loginResponsePacket.setSuccess(<span class="keyword">true</span>);  </span><br><span class="line">            String userId = IDUtil.randomId();  </span><br><span class="line">            loginResponsePacket.setUserId(userId);  </span><br><span class="line">            System.out.println(<span class="string">"["</span> + loginRequestPacket.getUserName() + <span class="string">"]登录成功"</span>);  </span><br><span class="line">            SessionUtil.bindSession(<span class="keyword">new</span> Session(userId, loginRequestPacket.getUserName()), ctx.channel());  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            loginResponsePacket.setReason(<span class="string">"账号密码校验失败"</span>);  </span><br><span class="line">            loginResponsePacket.setSuccess(<span class="keyword">false</span>);  </span><br><span class="line">            System.out.println(<span class="keyword">new</span> Date() + <span class="string">": 登录失败!"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 登录响应  </span></span><br><span class="line">        ctx.writeAndFlush(loginResponsePacket);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">(LoginRequestPacket loginRequestPacket)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;  </span><br><span class="line">        SessionUtil.unBindSession(ctx.channel());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在客户端同样添加<strong>Handler</strong>，<code>LoginResponseHandler</code>，LoginResponseHandler的处理逻辑如下。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(LoginResponseHandler.INSTANCE);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginResponseHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">LoginResponsePacket</span>&gt; </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, LoginResponsePacket loginResponsePacket)</span> </span>&#123;  </span><br><span class="line">        String userId = loginResponsePacket.getUserId();  </span><br><span class="line">        String userName = loginResponsePacket.getUserName();  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (loginResponsePacket.isSuccess()) &#123;  </span><br><span class="line">            System.out.println(<span class="string">"["</span> + userName + <span class="string">"]登录成功，userId 为: "</span> + loginResponsePacket.getUserId());  </span><br><span class="line">            SessionUtil.bindSession(<span class="keyword">new</span> Session(userId, userName), ctx.channel());  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            System.out.println(<span class="string">"["</span> + userName + <span class="string">"]登录失败，原因："</span> + loginResponsePacket.getReason());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"客户端连接被关闭!"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端登录成功或者失败，如何把失败或者成功标识绑定在客户端连接？ 服务端如何高效判定客户端重新登录？</p><p>在聊天系统中实现比较简单粗暴。服务端高效判断的方法是在<code>ConcurrentHashMap</code>，Map当中存储用户的ID，如果登录成功则存储到此Map中，服务端也只需要判断Map元素即可高效判断是否登录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Channel&gt; userIdChannelMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><h2 id="热插拔客户端是否登录验证"><a href="#热插拔客户端是否登录验证" class="headerlink" title="热插拔客户端是否登录验证"></a>热插拔客户端是否登录验证</h2><p>首先校验是否登录部分封装到工具类当中，实现比较简单。</p><p><strong>SessionUtil</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasLogin</span><span class="params">(Channel channel)</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> getSession(channel) != <span class="keyword">null</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getSession</span><span class="params">(Channel channel)</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> channel.attr(Attributes.SESSION).get();  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AttributeKey&lt;Session&gt; SESSION = AttributeKey.newInstance("session");</span></span><br></pre></td></tr></table></figure><p><strong>AuthHandler</strong></p><p>实现热插拔的思路是<strong>判断是否登录，统一通过该调用链条完成</strong>，AuthHandler本身作为<strong>单独处理器</strong>封装判断登录校验逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Overridepublic</span> <span class="function"><span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!SessionUtil.hasLogin(ctx.channel())) &#123;</span><br><span class="line">        ctx.channel().close();    </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ctx.pipeline().remove(<span class="keyword">this</span>);        </span><br><span class="line">        <span class="keyword">super</span>.channelRead(ctx, msg);    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现双端收发消息"><a href="#实现双端收发消息" class="headerlink" title="实现双端收发消息"></a>实现双端收发消息</h1><h2 id="客户端处理"><a href="#客户端处理" class="headerlink" title="客户端处理"></a>客户端处理</h2><p>客户端成功登录之后，下一步是实现客户端和服务端互相发送数据。客户端收消息处理器如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 收消息处理器  </span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> MessageResponseHandler());</span><br></pre></td></tr></table></figure><p><strong>MessageResponseHandler</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageResponseHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">MessageResponsePacket</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, MessageResponsePacket messageResponsePacket)</span> </span>&#123;  </span><br><span class="line">        String fromUserId = messageResponsePacket.getFromUserId();  </span><br><span class="line">        String fromUserName = messageResponsePacket.getFromUserName();  </span><br><span class="line">        System.out.println(fromUserId + <span class="string">":"</span> + fromUserName + <span class="string">" -&gt; "</span> + messageResponsePacket  </span><br><span class="line">                .getMessage());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务端处理"><a href="#服务端处理" class="headerlink" title="服务端处理"></a>服务端处理</h2><p>因为是通用组件，服务端这里封装到 <strong>IMHandler</strong> 通用组件当中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handlerMap.put(MESSAGE_REQUEST, MessageRequestHandler.INSTANCE);</span><br></pre></td></tr></table></figure><p><strong>MessageRequestHandler</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageRequestHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">MessageRequestPacket</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MessageRequestHandler INSTANCE = <span class="keyword">new</span> MessageRequestHandler();  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MessageRequestHandler</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, MessageRequestPacket messageRequestPacket)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 1.拿到消息发送方的会话信息  </span></span><br><span class="line">        Session session = SessionUtil.getSession(ctx.channel());  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 2.通过消息发送方的会话信息构造要发送的消息  </span></span><br><span class="line">        MessageResponsePacket messageResponsePacket = <span class="keyword">new</span> MessageResponsePacket();  </span><br><span class="line">        messageResponsePacket.setFromUserId(session.getUserId());  </span><br><span class="line">        messageResponsePacket.setFromUserName(session.getUserName());  </span><br><span class="line">        messageResponsePacket.setMessage(messageRequestPacket.getMessage());  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 3.拿到消息接收方的 channel        Channel toUserChannel = SessionUtil.getChannel(messageRequestPacket.getToUserId());  </span></span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 4.将消息发送给消息接收方  </span></span><br><span class="line">        <span class="keyword">if</span> (toUserChannel != <span class="keyword">null</span> &amp;&amp; SessionUtil.hasLogin(toUserChannel)) &#123;  </span><br><span class="line">            toUserChannel.writeAndFlush(messageResponsePacket).addListener(future -&gt; &#123;  </span><br><span class="line">                <span class="keyword">if</span> (future.isDone()) &#123;  </span><br><span class="line">  </span><br><span class="line">                &#125;  </span><br><span class="line">  </span><br><span class="line">            &#125;);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            System.err.println(<span class="string">"["</span> + session.getUserId() + <span class="string">"] 不在线，发送失败!"</span>);  </span><br><span class="line">  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>实现双端收发消息小结内容如下：</p><ol><li>定义收发消息Java对象，对于消息进行收发。</li><li>学习 <code>Channel</code> 的 <code>attr</code> 的实际用法，可以给Channel绑定属性并且设置某些状态，内部实际也是通过Map维护的，所以不需要用户外部自己在自定义去维护。</li><li>如何在控制台当中获取消息并且发送到服务端。</li><li>服务端回传消息给客户端。</li></ol><h1 id="ChannelPipleline-和-ChannelHandler-概念"><a href="#ChannelPipleline-和-ChannelHandler-概念" class="headerlink" title="ChannelPipleline 和 ChannelHandler 概念"></a>ChannelPipleline 和 ChannelHandler 概念</h1><p>本部分是补充部分。主要介绍 Pipeline 和ChannelHanlder构成和一些基础概念。理解这一点之前需要先理解Channel这个概念。</p><h2 id="ChannelPipleline-和-ChannelHandler-构成图"><a href="#ChannelPipleline-和-ChannelHandler-构成图" class="headerlink" title="ChannelPipleline 和 ChannelHandler 构成图"></a>ChannelPipleline 和 ChannelHandler 构成图</h2><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230711121733.png" alt="ChannelPipleline 和 ChannelHandler 构成图"></p><h2 id="Channel-概念理解"><a href="#Channel-概念理解" class="headerlink" title="Channel 概念理解"></a>Channel 概念理解</h2><p><strong>一个客户端连接对应一个Channel，这个Channel可以类比BIO当中的传统概念Socket套接字。</strong></p><blockquote><p>A nexus to a network socket or a component which is capable of I/O operations such as read, write, connect, and bind.</p></blockquote><p>一个网络套接字的节点或一个能够进行（网络）I/O操作的组件，如读、写、连接和绑定。</p><h2 id="ChannelPipeline"><a href="#ChannelPipeline" class="headerlink" title="ChannelPipeline"></a>ChannelPipeline</h2><p>源码对于 ChannelPipeline 的定义如下：</p><blockquote><p>A list of ChannelHandlers which handles or intercepts inbound events and outbound operations of a Channel. ChannelPipeline implements an advanced form of the Intercepting Filter pattern to give a user full control over how an event is handled and how the ChannelHandlers in a pipeline interact with each other.</p></blockquote><p>源码中还有一个直观的设计图。</p><p>下图描述了I/O事件在ChannelPipeline中是如何被ChannelHandlers处理的。一个I/O事件由 ChannelInboundHandler 或 ChannelOutboundHandler处理，并通过调用ChannelHandlerContext中定义的事件传播方法，如ChannelHandlerContext.fireChannelRead(Object)和ChannelHandlerContext.write(Object)，转发给其最接近的处理程序。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230629165658.png" alt="ChannelInboundHandler"></p><p><code>ChannelPipeline</code> 的核心如下：</p><ul><li>处理或拦截一个Channel的入站事件和出站操作的链表。</li><li>通过责任链模式的设计，可以完全自定义处理逻辑和<code>ChannelHandler</code>之间互相通信的逻辑。</li></ul><h2 id="ChannelContext"><a href="#ChannelContext" class="headerlink" title="ChannelContext"></a>ChannelContext</h2><p><strong>ChannelHandler与Channel和ChannelPipeline之间的映射关系</strong>，由<code>ChannelHandlerContext</code>进⾏维护，根据其名称Context也可以看到存储更为丰富的信息。</p><blockquote><p>Enables a ChannelHandler to interact with its ChannelPipeline and other handlers.</p></blockquote><p>使得ChannelHandler能够与它的ChannelPipeline和其他处理程序互动。</p><ul><li><code>ChannelContext</code>可以获取整个<code>Channel</code>的信息。</li><li>获取所有的上下文。</li><li>逻辑处理器ChannelHandler定义处理逻辑。</li></ul><h2 id="ChannelHanlder"><a href="#ChannelHanlder" class="headerlink" title="ChannelHanlder"></a>ChannelHanlder</h2><p><code>ChannelHanlder</code> 包含两种理解。</p><p>第一种：可以理解为socket连接，客户端和服务端连接的时候会创建一个channel。 负责基本的IO操作，例如：<code>bind()</code>、<code>connect()</code>、<code>read()</code>、<code>write()</code>。 </p><p>第二种：Netty的Channel接口所提供的API，大大减少了Socket类复杂性。</p><p>因为Channel连接过程中存在双端 <code>input/output</code>，所以 <code>ChannelHandler</code> 也分类为 <code>ChannelInboundHandler</code> 和 <code>ChannelOutboundHandler</code>。</p><h3 id="ChannelInboundHandler"><a href="#ChannelInboundHandler" class="headerlink" title="ChannelInboundHandler"></a>ChannelInboundHandler</h3><ul><li>读取的逻辑抽象 。 </li><li><code>channelRead</code> 是最重要的方法 。</li><li>配合<code>ByteBuf</code>使用进行<code>buf.read</code>推进读指针移动 。</li></ul><h3 id="ChannelOutboundHandler"><a href="#ChannelOutboundHandler" class="headerlink" title="ChannelOutboundHandler"></a>ChannelOutboundHandler</h3><ul><li>对应写出的逻辑抽象 。 </li><li>核心方法是 <code>write</code>，<code>writeAndFlush</code> 。 </li></ul><h3 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h3><p>在使用过程中还存在对应的适配器。</p><ul><li><code>ChannelOutboundHandlerAdapter</code>（注意处理顺序和添加addLast的顺序相反）</li><li><code>ChannelInboundHandlerAdapter</code></li></ul><h1 id="客户端和服务端的-SimpleChannelInboundHandler-ChannelInboundHandlerAdapter-简化"><a href="#客户端和服务端的-SimpleChannelInboundHandler-ChannelInboundHandlerAdapter-简化" class="headerlink" title="客户端和服务端的 SimpleChannelInboundHandler/ChannelInboundHandlerAdapter 简化"></a>客户端和服务端的 SimpleChannelInboundHandler/ChannelInboundHandlerAdapter 简化</h1><p>整个聊天系统大部分的指令判断逻辑是重复的，下面介绍如何通过 SImpleChannelInboundHandler/ChannelInboundHandlerAdapter 简化指令的处理逻辑。</p><blockquote><p><a href="https://netty.io/4.0/api/io/netty/channel/ChannelInboundHandlerAdapter.html" target="_blank" rel="noopener" title="class in io.netty.channel"><code>ChannelInboundHandlerAdapter</code></a> which allows to explicit only handle a specific type of messages. For example here is an implementation which only handle <code>String</code> messages.</p></blockquote><p><strong>ChannelInboundHandlerAdapter</strong>  允许明确地只处理特定类型的消息。而<code>SimpleChannelInboundHandler</code>提供了一个模板，作用是把处理逻辑不变的内容写好在 <code>channelRead(ctx,msg)</code> 中，并且在里面调用<code>channelRead0</code> ，这样处理之后就可以通过抽象方法实现传递到子类中去了。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p><code>SimpleChannelInboundHandler</code>和<code>ChannelInboundHandlerAdapter</code>这两个类使用上不太好区分，下面再补充介绍一下如何正确对待使用两者。</p><p><code>ChannelInboundHandlerAdapter</code> 需要覆盖的方法是<strong>channelRead</strong>，特点是<strong>不会自动释放消息</strong>，需要调用<strong>ctx.fireChannelRead(msg)</strong> 向后续链条处理器传递消息，也就是需要手动通过责任链的方式传递给下位处理器。<br>​<br><code>SimpleChannelInboundHandler</code> 是 <code>ChannelInboundHandlerAdapter</code> 的子类，<strong>做了额外的处理，会自动释放消息</strong>，如果还需要继续传递消息，需调用一次 <strong>ReferenceCountUtil.retain(msg)</strong>。需注意<code>SimpleChannelInboundHandler</code>也需要调用<code>ctx.fireChannelRead(msg)</code>来触发链条中下一处理器处理。</p><p><code>ChannelInboundHandlerAdapter</code>通常用于处于链条中间的某些环节处理，对数据进行某些处理，如数据验证，需要将消息继续传递。<br>​<br><code>SimpleChannelInboundHandler</code>则比较适合链条最后一个环节，该环节处理完后，后续不再需要该消息，因此可以自动释放。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>在聊天系统中统一处理的Handler继承了SimpleChannelInboundHandler，重写<code>channelRead0</code>方法，主要对于解码之后的操作指令和通用Map进行匹配，如果匹配则分发到具体的逻辑处理器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IMHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">Packet</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> IMHandler INSTANCE = <span class="keyword">new</span> IMHandler();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> Map&lt;Byte, SimpleChannelInboundHandler&lt;? extends Packet&gt;&gt; handlerMap;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IMHandler</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        handlerMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">7</span>);  </span><br><span class="line">  </span><br><span class="line">        handlerMap.put(MESSAGE_REQUEST, MessageRequestHandler.INSTANCE);  </span><br><span class="line">        handlerMap.put(CREATE_GROUP_REQUEST, CreateGroupRequestHandler.INSTANCE);  </span><br><span class="line">        handlerMap.put(JOIN_GROUP_REQUEST, JoinGroupRequestHandler.INSTANCE);  </span><br><span class="line">        handlerMap.put(QUIT_GROUP_REQUEST, QuitGroupRequestHandler.INSTANCE);  </span><br><span class="line">        handlerMap.put(LIST_GROUP_MEMBERS_REQUEST, ListGroupMembersRequestHandler.INSTANCE);  </span><br><span class="line">        handlerMap.put(GROUP_MESSAGE_REQUEST, GroupMessageRequestHandler.INSTANCE);  </span><br><span class="line">        handlerMap.put(LOGOUT_REQUEST, LogoutRequestHandler.INSTANCE);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, Packet packet)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        handlerMap.get(packet.getCommand()).channelRead(ctx, packet);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="客户端和服务端单聊"><a href="#客户端和服务端单聊" class="headerlink" title="客户端和服务端单聊"></a>客户端和服务端单聊</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>输入用户名，服务端随机分配ID，这里省去通过账号和密码注册过程 。</li><li>多个客户端登录，用 userId 空格 消息的方式单聊。</li></ul><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><ol><li><p>使用工具类把UserId和Channel绑定为Session。</p><ul><li>Session的信息包含用户ID以及名称 ，后续可以扩展更多的字段。</li></ul></li><li><p>使用<code>SessionUtil</code>工具类操作Session，通过Session贮存当前会话信息。</p><ul><li>这里用的<strong>ConcurrentHashMap</strong>实现并发安全</li><li>ConcurrentHashMap为<strong>userId -&gt; Channel</strong>的映射Map。</li><li>用户登录的时候，需要把Session塞入Map。</li><li>当用户断开<code>Channel</code>连接退出的时候，需要移除Session信息  </li></ul></li><li><p>服务端接受消息并且转发（这里Netty类似转发手机信号的基站）</p><ul><li>获取会话信息。</li><li>构造发给客户端的对象<code>MessageResponse</code>。</li><li>消息接收方标识获取对应<code>Channel</code>。</li><li>如果目标用户登录则发送消息，如果对方不在线，则控制台打印警告信息。</li></ul></li></ol><p>具体的代码在前面的收发消息中有提到过，这里重复展示一遍。</p><p><strong>MessageResponseHandler</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageResponseHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">MessageResponsePacket</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, MessageResponsePacket messageResponsePacket)</span> </span>&#123;  </span><br><span class="line">        String fromUserId = messageResponsePacket.getFromUserId();  </span><br><span class="line">        String fromUserName = messageResponsePacket.getFromUserName();  </span><br><span class="line">        System.out.println(fromUserId + <span class="string">":"</span> + fromUserName + <span class="string">" -&gt; "</span> + messageResponsePacket  </span><br><span class="line">                .getMessage());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>MessageRequestHandler</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageRequestHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">MessageRequestPacket</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MessageRequestHandler INSTANCE = <span class="keyword">new</span> MessageRequestHandler();  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MessageRequestHandler</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, MessageRequestPacket messageRequestPacket)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 1.拿到消息发送方的会话信息  </span></span><br><span class="line">        Session session = SessionUtil.getSession(ctx.channel());  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 2.通过消息发送方的会话信息构造要发送的消息  </span></span><br><span class="line">        MessageResponsePacket messageResponsePacket = <span class="keyword">new</span> MessageResponsePacket();  </span><br><span class="line">        messageResponsePacket.setFromUserId(session.getUserId());  </span><br><span class="line">        messageResponsePacket.setFromUserName(session.getUserName());  </span><br><span class="line">        messageResponsePacket.setMessage(messageRequestPacket.getMessage());  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 3.拿到消息接收方的 channel        Channel toUserChannel = SessionUtil.getChannel(messageRequestPacket.getToUserId());  </span></span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 4.将消息发送给消息接收方  </span></span><br><span class="line">        <span class="keyword">if</span> (toUserChannel != <span class="keyword">null</span> &amp;&amp; SessionUtil.hasLogin(toUserChannel)) &#123;  </span><br><span class="line">            toUserChannel.writeAndFlush(messageResponsePacket).addListener(future -&gt; &#123;  </span><br><span class="line">                <span class="keyword">if</span> (future.isDone()) &#123;  </span><br><span class="line">  </span><br><span class="line">                &#125;  </span><br><span class="line">  </span><br><span class="line">            &#125;);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            System.err.println(<span class="string">"["</span> + session.getUserId() + <span class="string">"] 不在线，发送失败!"</span>);  </span><br><span class="line">  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="群聊发起和通知"><a href="#群聊发起和通知" class="headerlink" title="群聊发起和通知"></a>群聊发起和通知</h1><p>下面两个小节围绕群聊实现介绍。整个群聊和单聊实现类似，都是通过标识获取Channel，为了方面多个成员管理，设计 <code>ChannelGroup</code> 完成<code>Channel</code>的批量操作。</p><h2 id="预期效果"><a href="#预期效果" class="headerlink" title="预期效果"></a>预期效果</h2><ol><li>三位用户依次登录。</li><li>控制台输入 createGroup 指令，提示创建群聊需要 userId 列表，之后以英文逗号分隔userId。</li><li>群聊创建成功之后，所有群聊成员收到加入成功消息。</li></ol><h2 id="创建群聊实现"><a href="#创建群聊实现" class="headerlink" title="创建群聊实现"></a>创建群聊实现</h2><p>主要逻辑如下：</p><ol><li>创建一个 channel 分组。</li><li>筛选出待加入群聊的用户的 channel 和 userName。</li><li>创建群聊创建结果的响应。</li><li>给每个客户端发送拉群通知</li><li>保存群组相关的信息。</li></ol><p>其中存储群的相关信息利用了<code>ConcurrentHashMap</code>实现，和Session的会话信息存储方式类似，<strong>ChannelGroup</strong>对象负责封装多个Channel的信息，模拟群聊中的“群”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateGroupRequestHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">CreateGroupRequestPacket</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> CreateGroupRequestHandler INSTANCE = <span class="keyword">new</span> CreateGroupRequestHandler();  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CreateGroupRequestHandler</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, CreateGroupRequestPacket createGroupRequestPacket)</span> </span>&#123;  </span><br><span class="line">        List&lt;String&gt; userIdList = createGroupRequestPacket.getUserIdList();  </span><br><span class="line">  </span><br><span class="line">        List&lt;String&gt; userNameList = <span class="keyword">new</span> ArrayList&lt;&gt;();  </span><br><span class="line">        <span class="comment">// 1. 创建一个 channel 分组  </span></span><br><span class="line">        ChannelGroup channelGroup = <span class="keyword">new</span> DefaultChannelGroup(ctx.executor());  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 2. 筛选出待加入群聊的用户的 channel 和 userName        for (String userId : userIdList) &#123;  </span></span><br><span class="line">            Channel channel = SessionUtil.getChannel(userId);  </span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                channelGroup.add(channel);  </span><br><span class="line">                userNameList.add(SessionUtil.getSession(channel).getUserName());  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 3. 创建群聊创建结果的响应  </span></span><br><span class="line">        String groupId = IDUtil.randomId();  </span><br><span class="line">        CreateGroupResponsePacket createGroupResponsePacket = <span class="keyword">new</span> CreateGroupResponsePacket();  </span><br><span class="line">        createGroupResponsePacket.setSuccess(<span class="keyword">true</span>);  </span><br><span class="line">        createGroupResponsePacket.setGroupId(groupId);  </span><br><span class="line">        createGroupResponsePacket.setUserNameList(userNameList);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 4. 给每个客户端发送拉群通知  </span></span><br><span class="line">        channelGroup.writeAndFlush(createGroupResponsePacket);  </span><br><span class="line">  </span><br><span class="line">        System.out.print(<span class="string">"群创建成功，id 为 "</span> + createGroupResponsePacket.getGroupId() + <span class="string">", "</span>);  </span><br><span class="line">        System.out.println(<span class="string">"群里面有："</span> + createGroupResponsePacket.getUserNameList());  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 5. 保存群组相关的信息  </span></span><br><span class="line">        SessionUtil.bindChannelGroup(groupId, channelGroup);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端处理部分则是简单的打印创建群聊成功的信息，实现比较简单这里不再贴出相关代码。</p><h1 id="群聊成员管理实现"><a href="#群聊成员管理实现" class="headerlink" title="群聊成员管理实现"></a>群聊成员管理实现</h1><h2 id="设计流程和实现思路"><a href="#设计流程和实现思路" class="headerlink" title="设计流程和实现思路"></a>设计流程和实现思路</h2><h3 id="设计流程"><a href="#设计流程" class="headerlink" title="设计流程"></a>设计流程</h3><ol><li>加入群聊，控制台输出创建成功消息。</li><li>控制台输入joinGroup 之后输入群ID，加入群聊，控制台显示加入群成功。</li><li>控制台输入 listGroupMembers 然后输入群ID，展示群成员。</li><li>quitGroup 输入群ID，进行退群</li><li>控制台输入joinGroup 之后输入群ID显示对应成员不在，则退群成功。</li></ol><h3 id="实现思路-1"><a href="#实现思路-1" class="headerlink" title="实现思路"></a>实现思路</h3><ol><li>在控制台中加入群加入的命令处理器。</li><li>服务端处理群聊请求。</li><li>客户端处理加群响应.</li><li>群聊退出实现。</li></ol><h2 id="在控制台中加入群加入的命令处理器"><a href="#在控制台中加入群加入的命令处理器" class="headerlink" title="在控制台中加入群加入的命令处理器"></a>在控制台中加入群加入的命令处理器</h2><p><strong>JoinGroupConsoleCommand</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinGroupConsoleCommand</span> <span class="keyword">implements</span> <span class="title">ConsoleCommand</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exec</span><span class="params">(Scanner scanner, Channel channel)</span> </span>&#123;  </span><br><span class="line">        JoinGroupRequestPacket joinGroupRequestPacket = <span class="keyword">new</span> JoinGroupRequestPacket();  </span><br><span class="line">  </span><br><span class="line">        System.out.print(<span class="string">"输入 groupId，加入群聊："</span>);  </span><br><span class="line">        String groupId = scanner.next();  </span><br><span class="line">  </span><br><span class="line">        joinGroupRequestPacket.setGroupId(groupId);  </span><br><span class="line">        channel.writeAndFlush(joinGroupRequestPacket);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务端处理群聊请求"><a href="#服务端处理群聊请求" class="headerlink" title="服务端处理群聊请求"></a>服务端处理群聊请求</h2><p>服务端处理群聊请求：</p><ol><li>构建Channel分区，把处在同一个分组的Channel放到一个List当中存储  </li><li>如果群聊构建成功，则构建创建成功响应结果 。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinGroupRequestHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">JoinGroupRequestPacket</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> JoinGroupRequestHandler INSTANCE = <span class="keyword">new</span> JoinGroupRequestHandler();  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">JoinGroupRequestHandler</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, JoinGroupRequestPacket requestPacket)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 1. 获取群对应的 channelGroup，然后将当前用户的 channel 添加进去  </span></span><br><span class="line">        String groupId = requestPacket.getGroupId();  </span><br><span class="line">        ChannelGroup channelGroup = SessionUtil.getChannelGroup(groupId);  </span><br><span class="line">        channelGroup.add(ctx.channel());  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 2. 构造加群响应发送给客户端  </span></span><br><span class="line">        JoinGroupResponsePacket responsePacket = <span class="keyword">new</span> JoinGroupResponsePacket();  </span><br><span class="line">  </span><br><span class="line">        responsePacket.setSuccess(<span class="keyword">true</span>);  </span><br><span class="line">        responsePacket.setGroupId(groupId);  </span><br><span class="line">        ctx.writeAndFlush(responsePacket);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="客户端处理加群响应"><a href="#客户端处理加群响应" class="headerlink" title="客户端处理加群响应"></a>客户端处理加群响应</h2><p>简单打印加群的响应消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinGroupResponseHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">JoinGroupResponsePacket</span>&gt; </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, JoinGroupResponsePacket responsePacket)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (responsePacket.isSuccess()) &#123;  </span><br><span class="line">            System.out.println(<span class="string">"加入群["</span> + responsePacket.getGroupId() + <span class="string">"]成功!"</span>);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            System.err.println(<span class="string">"加入群["</span> + responsePacket.getGroupId() + <span class="string">"]失败，原因为："</span> + responsePacket.getReason());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="群聊退出实现"><a href="#群聊退出实现" class="headerlink" title="群聊退出实现"></a>群聊退出实现</h2><p>群聊退出主要是获取群对应的 channelGroup，然后将当前用户的 channel 移除，之后构建退群的响应信息回传客户端即可。</p><p><strong>QuitGroupRequestHandler</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuitGroupRequestHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">QuitGroupRequestPacket</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> QuitGroupRequestHandler INSTANCE = <span class="keyword">new</span> QuitGroupRequestHandler();  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">QuitGroupRequestHandler</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, QuitGroupRequestPacket requestPacket)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 1. 获取群对应的 channelGroup，然后将当前用户的 channel 移除  </span></span><br><span class="line">        String groupId = requestPacket.getGroupId();  </span><br><span class="line">        ChannelGroup channelGroup = SessionUtil.getChannelGroup(groupId);  </span><br><span class="line">        channelGroup.remove(ctx.channel());  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 2. 构造退群响应发送给客户端  </span></span><br><span class="line">        QuitGroupResponsePacket responsePacket = <span class="keyword">new</span> QuitGroupResponsePacket();  </span><br><span class="line">  </span><br><span class="line">        responsePacket.setGroupId(requestPacket.getGroupId());  </span><br><span class="line">        responsePacket.setSuccess(<span class="keyword">true</span>);  </span><br><span class="line">        ctx.writeAndFlush(responsePacket);  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h1><h2 id="网络问题"><a href="#网络问题" class="headerlink" title="网络问题"></a>网络问题</h2><h3 id="假死"><a href="#假死" class="headerlink" title="假死"></a>假死</h3><p>TCP层面来看，服务端收到4次握手包或者RST包才算真正断开连接，如果中途应用程序并没有捕获到，此时是认为这条连接存在的。</p><h3 id="假死引发问题"><a href="#假死引发问题" class="headerlink" title="假死引发问题"></a>假死引发问题</h3><ul><li>客户端发送数据超时无响应，影响体验。</li><li>浪费CPU和内存资源，性能下滑。</li></ul><h3 id="假死原因"><a href="#假死原因" class="headerlink" title="假死原因"></a>假死原因</h3><ul><li>公网丢包，网络抖动 。</li><li>应用程序阻塞无法读写 。</li><li>客户端或者服务端设别故障，网卡，机房故障。</li></ul><p>为了解决上面的问题，通常会使用心跳检测机制定期检测每个<code>Channel</code>连接是否存活。</p><h2 id="服务端心跳检测实现"><a href="#服务端心跳检测实现" class="headerlink" title="服务端心跳检测实现"></a>服务端心跳检测实现</h2><ol><li>通过<code>IdleStateHandler</code>自带<code>Handler</code>实现</li><li>继承类，然后开启定时任务</li><li>触发假死该<code>Handler</code>回调<code>channelIdle</code> 方法</li></ol><h2 id="客户端预判和防御假死"><a href="#客户端预判和防御假死" class="headerlink" title="客户端预判和防御假死"></a>客户端预判和防御假死</h2><ol><li>新建<code>Handler</code>。</li><li>开启定时线程。</li><li>组装心跳包。</li><li>发送心跳。</li><li>服务端简单开发接受和识别心跳包的Handler，之后回送收到心跳包消息即可。</li></ol><h2 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>心跳检测<strong>Handler</strong>插入到整个<strong>Pipeline</strong>最前面，因为如果连接实际已经断开后续的所有处理均无意义。</li><li>假死不一定“死”，防止服务端误判，客户端也需要措施防止假死和预判假死，这就是客户端预判的含义。</li></ul><h2 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h2><ol><li>IdleHandler 可否单例？</li><li>断开链接之后重新连接登录</li></ol><h3 id="IdleHandler-可否单例？"><a href="#IdleHandler-可否单例？" class="headerlink" title="IdleHandler 可否单例？"></a>IdleHandler 可否单例？</h3><p>答案是<strong>不能</strong>。因为它并不是无状态的，并且每个Channel都有各自的连接状态。</p><h3 id="断开链接之后重新连接登录"><a href="#断开链接之后重新连接登录" class="headerlink" title="断开链接之后重新连接登录"></a>断开链接之后重新连接登录</h3><p>通过额外的线程定时轮循所有的连接的活跃性，如果发现其中有死连接，则执行重连。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>熟悉聊天系统对于后续的源码分析十分有意义，项目的整体构建比较简单，个人在笔记中将重点部分做了一个梳理。</p><h1 id="文章参考"><a href="#文章参考" class="headerlink" title="文章参考"></a>文章参考</h1><p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vYm9vay9tLzY4NDQ3MzM3MzgxMTk1OTM5OTEvc2VjdGlvbi82ODQ0NzMzNzM4MjkxNTc2ODQwP3N1aWQ9MjA0MDMwMDQxNDE4NzQxNg==" title="https://juejin.cn/book/m/6844733738119593991/section/6844733738291576840?suid=2040300414187416">https://juejin.cn/book/m/6844733738119593991/section/6844733738291576840?suid=2040300414187416<i class="fa fa-external-link"></i></span></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      Netty聊天系统
    
    </summary>
    
    
      <category term="Netty" scheme="https://whitestore.top/categories/Netty/"/>
    
    
      <category term="Netty" scheme="https://whitestore.top/tags/Netty/"/>
    
  </entry>
  
</feed>
