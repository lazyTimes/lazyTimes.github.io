<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>爱看书的阿东</title>
  
  <subtitle>赐他一块白色石头，石头上写着新名</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://whitestore.top/"/>
  <updated>2023-06-15T13:10:39.212Z</updated>
  <id>https://whitestore.top/</id>
  
  <author>
    <name>阿东</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Mysql】How to store UTF8 characters in MySQL</title>
    <link href="https://whitestore.top/2023/06/15/mysqlcharacter/"/>
    <id>https://whitestore.top/2023/06/15/mysqlcharacter/</id>
    <published>2023-06-15T02:59:40.000Z</published>
    <updated>2023-06-15T13:10:39.212Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><p><span class="exturl" data-url="aHR0cHM6Ly91YmlxLmNvL2RhdGFiYXNlLWJsb2cvaG93LXRvLXN0b3JlLXV0ZjgtY2hhcmFjdGVycy1pbi1teXNxbC8=" title="https://ubiq.co/database-blog/how-to-store-utf8-characters-in-mysql/">How to store UTF8 characters in MySQL - Ubiq BI<i class="fa fa-external-link"></i></span></p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>关于 <strong>《如何在MySQL中存储UTF8字符》</strong> 的一篇英文博客阅读和个人实战笔记。注意个人实验过程中使用了docker的Mysql 5.7 版本，读者可以根据自身情况调整。</p><a id="more"></a><h1 id="1-Shell-检查字符集"><a href="#1-Shell-检查字符集" class="headerlink" title="1. Shell 检查字符集"></a>1. Shell 检查字符集</h1><p>如果不习惯Linux的小黑框，最简单的方式是用navicat的命令行工具查询，注意用户需要具备对应的系统配置权限，建议用root操作：</p><p>首先我们右击navicat的数据库连接配置（已准备好），选择“命令列界面”：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230416175305.png" alt="image.png"></p><p>之后是navicat仿照的Shell，等待用户输入：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230416175340.png" alt="image.png"></p><p>运行下面的命令可以查看所有字符集配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#39;character_set%&#39;;</span><br></pre></td></tr></table></figure><p>个人的实验结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#39;character_set%&#39;;</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| Variable_name            | Value                      |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| character_set_client     | utf8mb4                    |</span><br><span class="line">| character_set_connection | utf8mb4                    |</span><br><span class="line">| character_set_database   | utf8                       |</span><br><span class="line">| character_set_filesystem | binary                     |</span><br><span class="line">| character_set_results    | utf8mb4                    |</span><br><span class="line">| character_set_server     | latin1                     |</span><br><span class="line">| character_set_system     | utf8                       |</span><br><span class="line">| character_sets_dir       | &#x2F;usr&#x2F;share&#x2F;mysql&#x2F;charsets&#x2F; |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">8 rows in set (0.03 sec)</span><br></pre></td></tr></table></figure><p>可以看到字符集并不统一。</p><h1 id="2-修改字符集为UTF-8"><a href="#2-修改字符集为UTF-8" class="headerlink" title="2. 修改字符集为UTF-8"></a>2. 修改字符集为UTF-8</h1><p>个人使用为docker的mysql自定义映射的配置文件位置，和原始的安装方式配置文件配置略有不同。不过基本的操作方式都是修改<code>my.cnf</code>的配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[client] </span><br><span class="line">default-character-set=utf8mb4 </span><br><span class="line">[mysqld] </span><br><span class="line">character-set-server = utf8mb4</span><br></pre></td></tr></table></figure><p>个人操作记录如下，定位到映射文件位置之后，直接<code>vim</code>修改配置文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost conf]<span class="comment"># vim /opt/mysql/conf/mysql.cnf</span></span><br></pre></td></tr></table></figure><p>在配置文件当中做如下改动：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost conf]<span class="comment"># cat /opt/mysql/conf/mysql.cnf </span></span><br><span class="line"><span class="comment"># mysqld custom</span></span><br><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># 下面部分可以忽略</span></span><br><span class="line">sort_buffer_size = 16M</span><br><span class="line">read_rnd_buffer_size = 2M</span><br><span class="line">max_connections = 10024</span><br><span class="line"></span><br><span class="line"><span class="comment"># set character to utf-8</span></span><br><span class="line">character-set-server = utf8mb4</span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line"><span class="comment"># 注意客户端连接也要一并设置</span></span><br><span class="line">default-character-set=utf8mb4</span><br></pre></td></tr></table></figure><p>修改之后重启docker的mysql镜像。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost conf]<span class="comment"># docker ps </span></span><br><span class="line">CONTAINER ID   IMAGE       COMMAND                  CREATED       STATUS       PORTS                                                    NAMES</span><br><span class="line">58fa52f21404   mysql:5.7   <span class="string">"docker-entrypoint.s…"</span>   3 hours ago   Up 2 hours   33060/tcp, 0.0.0.0:13306-&gt;3306/tcp, :::13306-&gt;3306/tcp   mysql57</span><br></pre></td></tr></table></figure><p>重启之后万事大吉。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost conf]<span class="comment"># docker restart 58f</span></span><br></pre></td></tr></table></figure><p>之后依旧是连接mysql数据库，继续使用<code>show variables like &#39;character%&#39;;</code>命令查看当前字符集。</p><p>修改之前：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#39;character_set%&#39;;</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| Variable_name            | Value                      |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| character_set_client     | utf8mb4                    |</span><br><span class="line">| character_set_connection | utf8mb4                    |</span><br><span class="line">| character_set_database   | utf8                       |</span><br><span class="line">| character_set_filesystem | binary                     |</span><br><span class="line">| character_set_results    | utf8mb4                    |</span><br><span class="line">| character_set_server     | latin1                     |</span><br><span class="line">| character_set_system     | utf8                       |</span><br><span class="line">| character_sets_dir       | &#x2F;usr&#x2F;share&#x2F;mysql&#x2F;charsets&#x2F; |</span><br><span class="line">+--------------------------+----------------------------+</span><br></pre></td></tr></table></figure><p>修改之后结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;character%&#39;;</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| Variable_name            | Value                      |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| character_set_client     | utf8mb4                    |</span><br><span class="line">| character_set_connection | utf8mb4                    |</span><br><span class="line">| character_set_database   | utf8mb4                    |</span><br><span class="line">| character_set_filesystem | binary                     |</span><br><span class="line">| character_set_results    | utf8mb4                    |</span><br><span class="line">| character_set_server     | utf8mb4                    |</span><br><span class="line">| character_set_system     | utf8                       |</span><br><span class="line">| character_sets_dir       | &#x2F;usr&#x2F;share&#x2F;mysql&#x2F;charsets&#x2F; |</span><br><span class="line">+--------------------------+----------------------------+</span><br></pre></td></tr></table></figure><h1 id="3-数据表转换为UTF-8"><a href="#3-数据表转换为UTF-8" class="headerlink" title="3. 数据表转换为UTF-8"></a>3. 数据表转换为UTF-8</h1><p>运行下面的命令，将你的数据库的字符集和排序改为UTF8。用你的数据库名称替换下面的dbname。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER DATABASE dbname CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;&#96;</span><br></pre></td></tr></table></figure><blockquote><p>dbname 修改为自己的数据库即可</p></blockquote><p>上述命令将把你的数据库中的所有表转换为UTF8MB4 格式。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      请输入描述信息
    
    </summary>
    
    
      <category term="数据库-mysql" scheme="https://whitestore.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-mysql/"/>
    
    
      <category term="Mysql" scheme="https://whitestore.top/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>【Mysql】How to Increase Max Connections in MySQL</title>
    <link href="https://whitestore.top/2023/06/15/mysqlconnection/"/>
    <id>https://whitestore.top/2023/06/15/mysqlconnection/</id>
    <published>2023-06-15T02:07:14.000Z</published>
    <updated>2023-06-15T13:10:39.211Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><p><span class="exturl" data-url="aHR0cHM6Ly91YmlxLmNvL2RhdGFiYXNlLWJsb2cvaG93LXRvLWluY3JlYXNlLW1heC1jb25uZWN0aW9ucy1pbi1teXNxbC8=" title="https://ubiq.co/database-blog/how-to-increase-max-connections-in-mysql/">https://ubiq.co/database-blog/how-to-increase-max-connections-in-mysql/<i class="fa fa-external-link"></i></span></p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>有时候连接Mysql时候我们会遇到“Too many connections”这样的报错，当然更多可能是在生产过程中碰到这样的问题，默认情况下Mysql的整体服务器连接数设置过低。</p><blockquote><p>Sometimes MySQL server may give “Too many connections” error message when you try to connect to a MySQL database. Here’s how to increase max connections in MySQL to fix this problem.</p></blockquote><a id="more"></a><h1 id="Too-many-connections-的影响"><a href="#Too-many-connections-的影响" class="headerlink" title="Too many connections 的影响"></a>Too many connections 的影响</h1><p>这意味着所有可用的连接已经被各种客户端使用，你的MySQL服务器不能打开任何新的连接，直到任何现有的连接被关闭。</p><blockquote><p>By default, MySQL 5.5+ can handle up to 151 connections. This number is stored in server variable called <em>max_connections</em>. You can update max_connections variable to increase maximum supported connections in MySQL, provided your server has enough RAM to support the increased connections.</p></blockquote><h1 id="max-connections默认值"><a href="#max-connections默认值" class="headerlink" title="max_connections默认值"></a>max_connections默认值</h1><blockquote><p>By default, MySQL 5.5+ can handle up to 151 connections. This number is stored in server variable called <em>max_connections</em>. You can update max_connections variable to increase maximum supported connections in MySQL, provided your server has enough RAM to support the increased connections.</p></blockquote><p>在Mysql5.5+的版本中，这个值只有151，我们可以通过<code>show variables like &quot;max_connections&quot;;</code>查看自己的Mysql服务器最大连接数。根据当前的机器配置和实际情况，我们可以拉大这个参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;max_connections&quot;;</span><br><span class="line">+-----------------+-------+</span><br><span class="line">| Variable_name   | Value |</span><br><span class="line">+-----------------+-------+</span><br><span class="line">| max_connections | 151 |</span><br><span class="line">+-----------------+-------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><h1 id="如何扩大max-connections这个值？（docker-中的Mysql为例）"><a href="#如何扩大max-connections这个值？（docker-中的Mysql为例）" class="headerlink" title="如何扩大max_connections这个值？（docker 中的Mysql为例）"></a>如何扩大max_connections这个值？（docker 中的Mysql为例）</h1><p>下面是基础步骤。</p><h2 id="0-如何查看？"><a href="#0-如何查看？" class="headerlink" title="0. 如何查看？"></a>0. 如何查看？</h2><p>首先我们需要了解如何查看当前的最大连接数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &quot;max_connections&quot;;</span><br></pre></td></tr></table></figure><p>navicat 可以在<strong>命令行模式</strong>下查看查看连接数（这里为个人实验修改后结果）：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230416195103.png" alt="image.png"></p><p>有两种方法来增加MySQL连接。下面是通过MySQL命令行工具更新最大连接数为200的命令，无需重新启动。</p><h2 id="1-临时修改：命令"><a href="#1-临时修改：命令" class="headerlink" title="1. 临时修改：命令"></a>1. 临时修改：命令</h2><p>通过Mysql连接到客户端，可以使用下面的命令修改最大连接数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global max_connections &#x3D; 200;</span><br></pre></td></tr></table></figure><p>但是需要注意这种修改方式<strong>一旦重启就会失效</strong>，所以这个命令通常是在出现类似的生产事故的时候救急使用。</p><p>如果想要永久生效，需要修改mysql的相关配置文件。</p><h2 id="2-永久生效：系统配置修改"><a href="#2-永久生效：系统配置修改" class="headerlink" title="2. 永久生效：系统配置修改"></a>2. 永久生效：系统配置修改</h2><p>要永久生效需要修改系统配置，</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/my.cnf</span><br></pre></td></tr></table></figure><p>需要注意根据Linux发行版和安装类型不同，my.cnf文件可能位于以下任何位置。如果是docker，则my.cnf 位于自定义映射的位置</p><ul><li>/etc/my.cnf</li><li>/etc/mysql/my.cnf</li><li>$MYSQL_HOME/my.cnf</li><li>~/.my.cnf</li></ul><p>注意这个参数要配置到 <strong>[mysqld]</strong> 下面。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">max_connections = 10024</span><br></pre></td></tr></table></figure><p>最后只需要重启Mysql服务即可。</p><h1 id="重启Mysql"><a href="#重启Mysql" class="headerlink" title="重启Mysql"></a>重启Mysql</h1><p>个人搭建的Docker只需要重启镜像即可，较为方便。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost conf]<span class="comment"># docker restart 58f</span></span><br></pre></td></tr></table></figure><blockquote><p>docker 的 ID 支持模糊匹配。也可以自定义name之后进行重启。</p></blockquote><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>希望上述教程能帮助你了解如何增加MySQL的最大连接数。</p><blockquote><p>Hopefully, the above tutorial will help you increase max connections in MySQL.</p></blockquote><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      最大连接数
    
    </summary>
    
    
      <category term="数据库-mysql" scheme="https://whitestore.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-mysql/"/>
    
    
      <category term="Mysql" scheme="https://whitestore.top/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>【JAVA】JDK11新特性个人分析</title>
    <link href="https://whitestore.top/2023/03/19/jdk11update/"/>
    <id>https://whitestore.top/2023/03/19/jdk11update/</id>
    <published>2023-03-19T07:45:58.000Z</published>
    <updated>2023-06-15T13:10:39.210Z</updated>
    
    <content type="html"><![CDATA[<h1 id="历史背景"><a href="#历史背景" class="headerlink" title="历史背景"></a>历史背景</h1><p>2018年9 月 26 日，Oracle 官方宣布 Java 11 正式发布。这个版本中一共包含 <strong>17 个 JEP（JDK Enhancement Proposals，JDK 增强提案）</strong>。</p><p><strong>JDK 11 是一个长期支持版本（LTS, Long-Term-Support）</strong>，在编写本文的时间节点下和JDK17一样被用于编写项目代码的主流版本。</p><p>本文结合了各方资料整理出JDK11的新特性，工作上使用高版本JDK的机会确实不多，但是自己体验的过程中确实切身体会到JDK升级的好处。</p><h2 id="升级JDK11的意义"><a href="#升级JDK11的意义" class="headerlink" title="升级JDK11的意义"></a>升级JDK11的意义</h2><ul><li>大量的新特性、Bug 修复，例如，容器环境支持，GC 等基础领域的增强。</li><li>安全协议更新，比如废弃TLS1.2中不安全的加密算法，部分支持TLS1.3协议。</li><li>JVM的零成本优化。</li><li>划时代的<strong>垃圾收集器ZGC</strong>，关键目的是实现GC时间不超过10ms。</li><li><strong>G1垃圾收集器的免费升级</strong><ul><li>并行的 Full GC（JDK11之前Oracle没有考虑过G1需要并行Full GC）</li><li>快速的 CardTable 扫描</li><li>自适应的堆占用比例调整（IHOP）</li><li>在并发标记阶段的类型卸载</li></ul></li><li><strong>JVM自带工具增强</strong><ul><li>JEP 328: <strong>Flight Recorder（JFR）</strong>，商用版工具JFR转为开源。</li><li>JEP 331: <strong>Low-Overhead Heap Profiling</strong> 实现底层成本堆分析JVM扩展</li></ul></li><li>TLS协议精简<ul><li>完善Java标准HTTP类库上的扩展能力。</li><li>JEP 332: Transport Layer Security (TLS) 1.3，完全支持<strong>TLS 1.3</strong>（协议部分部分支持，加密算法部分基本满足要求）。</li></ul></li><li><strong>HTTP/2 Client API</strong><ul><li>完善了Java语言自身进行Http Client的能力</li><li>等同于把HttpClient官方化（难听点就是搬来了）</li><li><s>只要不写作者，谁也不知道自己写的还是抄的谁的</s></li></ul></li><li>废弃Nashorn JavaScript引擎<ul><li>实际上是全力推动Graal VM虚拟机的开发。</li></ul></li></ul><a id="more"></a><h1 id="升级内容"><a href="#升级内容" class="headerlink" title="升级内容"></a>升级内容</h1><p>下面就是根据”JEP（JDK Enhancement Proposals，JDK 增强提案）”进行介绍。关于原始的提案名称，这里放到了“附录”部分。</p><h2 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h2><h3 id="JEP-309-Dynamic-Class-File-Constants-类文件新结构"><a href="#JEP-309-Dynamic-Class-File-Constants-类文件新结构" class="headerlink" title="JEP 309: Dynamic Class-File Constants 类文件新结构"></a><strong>JEP 309: Dynamic Class-File Constants 类文件新结构</strong></h3><p>属于JVM层面的优化，简单了解即可。下面是搜集到的的一些国外网站的解释：</p><blockquote><p>Dynamic class-file constants<br>    JEP 309 extends the existing Java class-file format, creating CONSTANT_Dynamic. This is a JVM feature and doesn’t depend on the higher software layers. The loading of CONSTANT_Dynamic delegates the creation of a bootstrap method. When comparing it to the invokedynamic call, you will see how it delegates linking to a bootstrap method.<br>    One of the main goals of dynamic class-file constants is to make it simple to create new forms of materializable class-file constants, which provides language designers and compiler implementers with broader options for expressivity and performance. This is achieved by creating a new constant pool form that can be parameterized using a bootstrap method with static arguments.</p></blockquote><p>下面是简单概括和了解：</p><p>动态类文档常量： JEP 309扩展了现有的Java类文档格式，创建了CONSTANT_Dynamic。这是JVM 功能，不依赖于更高的软件层。加载CONSTANT_Dynamic委派引导方法的创建。将其与动态调用进行比较时，将看到它如何委托链接到引导方法。动态类文档常量的主要目标之一，是使创建可具体化的类文档常量的新形式<strong>变得简单</strong>，这为语言设计者和编译器实现者提供了更广泛的表达性和性能选项。</p><p>这是通过创建一个新的常量池形式来实现的，该表单可以使用带有静态参数的引导方法进行参数化。</p><blockquote><p>其目标是降低开发新形式的可实现类文件约束带来的成本和干扰</p></blockquote><p>这里的介绍还是不是很懂，所以我又找了一篇英文博客，它阐述了从JDK7出现的invokeDynamic指令到JDK11的新指令出现的含义。</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamF2YWNvZGVnZWVrcy5jb20vMjAxOC8wOC9oYW5kcy1vbi1qYXZhLWNvbnN0YW50ZHluYW1pYy5odG1s" title="https://www.javacodegeeks.com/2018/08/hands-on-java-constantdynamic.html">动手 Java 11 的常量动态 - Java 代码极客 - 2023 (javacodegeeks.com)<i class="fa fa-external-link"></i></span></p><p>Java的指令集新增基本都是大动作，作为对比个人联想到JDK7出现的新指令<strong>invokedynamic</strong>，周志明的《深入理解JVM虚拟机》中介绍了这个指令，并且JDK8以此为基础实现了Lambada语法。</p><p>下面是原书中有关invokedynamic的介绍：</p><blockquote><p>invokedynamic指令是在JDK 7时加入到字节码中的，当时确实只为了做动态语言（如JRuby、 Scala）支持，Java语言本身并不会用到它。而到了JDK 8时代，Java有了Lambda表达式和接口的默认方 法，它们在底层调用时就会用到invokedynamic指令，这时再提动态语言支持其实已不完全切合，我们 就只把它当个代称吧。</p></blockquote><p>所以从JDK11的这一次变动来看，又是一次类似 invokedynamic 的大更新？</p><h3 id="JEP-323-Local-Variable-Syntax-for-Lambda-Parameters"><a href="#JEP-323-Local-Variable-Syntax-for-Lambda-Parameters" class="headerlink" title="JEP 323: Local-Variable Syntax for Lambda Parameters"></a><strong>JEP 323: Local-Variable Syntax for Lambda Parameters</strong></h3><p>注意是“语法糖”，实际Class字节码中会被识别为正确的数据类型，并不是变为弱类型语言了，Java依旧是<strong>强类型语言</strong>。</p><p>这个改进主要目的实际上是侧重于Lambada的缺陷改善，下面通过实际代码演示进行介绍：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> javastack = <span class="string">"javastack"</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(javastack);</span><br></pre></td></tr></table></figure><p>局部变量类型推断指的是左边的类型直接使用 var 定义，而不用写具体的类型，编译器能根据右边的表达式自动推断类型，如上面的 String 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> javastack = <span class="string">"javastack"</span>;</span><br></pre></td></tr></table></figure><p>就等于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String javastack = <span class="string">"javastack"</span>;</span><br></pre></td></tr></table></figure><p>var的变量还对于Lambada语法进行了更多改进，<strong>声明隐式类型的lambda表达式的形参时允许使用var</strong>。使用var的好处是在使用lambda表达式时<strong>给参数加上注解</strong>。</p><p>比如我们常见的隐式类型的写法如下，JDK11之前都只能是这样的“隐式类型”写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x, y) -&gt; x.process(y)</span><br></pre></td></tr></table></figure><p>有声明var之后，从表面上看可以让变量“可读性”变强了一点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">var</span> x, <span class="keyword">var</span> y) -&gt; x.process(y)</span><br></pre></td></tr></table></figure><p>实际上有了“变量类型”之后，之前Java版本无法给Lambada表达式的隐式变量进行标记的问题就得到解决：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="meta">@Deprecated</span> <span class="keyword">var</span> x, <span class="meta">@Nullable</span> <span class="keyword">var</span> y) -&gt; x.process(y)</span><br></pre></td></tr></table></figure><p>另外这里扩展一下JDK的<strong>非Lambada的声明隐式类型</strong>，这是属于J<strong>ava10</strong>出现的东西，具体含义下面的代码一看便知：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo(); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> foo : foos) &#123; ... &#125; </span><br><span class="line"><span class="keyword">try</span> (<span class="keyword">var</span> foo = ...) &#123; ... &#125; <span class="keyword">catch</span> ...</span><br></pre></td></tr></table></figure><blockquote><p>这样的写法可以使得我们改变对象的时候更小概率改动遍历的代码，比如之前需要使用DtoA做遍历，现在里面的数据包装为Dtob了，这时候只需要动for循环里面的内容即可。</p></blockquote><h3 id="JEP-329-ChaCha20-and-Poly1305-Cryptographic-Algorithms-实现RFC7539中指定的ChaCha20和Poly1305两种加密算法-代替RC4"><a href="#JEP-329-ChaCha20-and-Poly1305-Cryptographic-Algorithms-实现RFC7539中指定的ChaCha20和Poly1305两种加密算法-代替RC4" class="headerlink" title="JEP 329: ChaCha20 and Poly1305 Cryptographic Algorithms 实现RFC7539中指定的ChaCha20和Poly1305两种加密算法, 代替RC4"></a>JEP 329: ChaCha20 and Poly1305 Cryptographic Algorithms 实现RFC7539中指定的ChaCha20和Poly1305两种加密算法, 代替RC4</h3><p>阅读这一节内容建议读者先有个印象： Java 11（2018年9 月 26 日） 和  TLS1.3 标准发布（2018年12月20日 · TLS1.3 正式版发布）</p><ul><li><strong>ChaCha20</strong>： 是 Google 设计的另一种加密算法，密钥长度固定为 256 位，纯软件运行性能要超过 AES，在ARMv8引擎升级之后，AES也飞速提升导致ChaCha20被反超。所以现在来看虽然优势不大，但是依然不错的一个算法。  </li><li><strong>Poly1305</strong>：是由Daniel Bernstein创建的消息身份验证代码（MAC）。Poly1305 采用 32 字节的一次性密钥和一条消息来生成 16 字节的标记。然后使用该标记对消息进行身份验证。每当Poly1305用作MAC算法时，都需要为完整性密钥分配256位。（引自：<span class="exturl" data-url="aHR0cHM6Ly93d3cucG9seTEzMDUuY29tLw==" title="https://www.poly1305.com/">Poly1305<i class="fa fa-external-link"></i></span>）</li></ul><blockquote><p>题外话：为什么ChaCha20和Poly1305在TLS1.3中合并为一个算法 ChaCha20-Poly1305？<br>其实很好理解，就好比两个运动员，一个专注长跑，另一个擅长短跑，一合体不就“无敌”了么， ChaCha20-Poly1305就是两个算法取长补短的效果，并且单独分开也是目前非常安全的算法。</p></blockquote><p>RFC7539 也就是IETF制定的TLS1.2的协议标准名称。RC4在很早之前就已经被证实存在漏洞，后面已经被废弃了。</p><p>看到这部分的时候，个人联想到之前学习的[[HTTP 面试题 - TLS1.3 初次解读]]的内容。TLS1.3不是把这两个合并成ChaCha20-Poly1305了么，并且它是TLS1.3 IETF指定的AEAD算法，JDK又是如何看待这个问题的呢？</p><p>个人抱着这个疑问查阅了JDK官方issue的，最终在下面的连接中找到了答案：</p><p><span class="exturl" data-url="aHR0cHM6Ly9idWdzLm9wZW5qZGsub3JnL2Jyb3dzZS9KREstODE0MDQ2Ng==" title="https://bugs.openjdk.org/browse/JDK-8140466">[JDK-8140466] ChaCha20 and Poly1305 TLS Cipher Suites - Java Bug System (openjdk.org)<i class="fa fa-external-link"></i></span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Fix <span class="title">request</span> <span class="params">(<span class="number">11</span>u)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">I would like to backport <span class="keyword">this</span> to 11u because of Chacha20 and Poly1305 cipher suite SHOULD be implemented <span class="keyword">for</span> TLSv1.3 according to rfc8446</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Original patch applies almost clean except <span class="keyword">for</span> the CipherSuite.java test - the list of cipher suites was reordered by JDK-8210632</span></span><br><span class="line"><span class="function">Also, CheckCipherSuites.java and CipherSuitesInOrder.java tests are updated to support CHACHA20 cipher suites.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">RFR: https:<span class="comment">//mail.openjdk.java.net/pipermail/jdk-updates-dev/2021-June/006644.html</span></span></span><br></pre></td></tr></table></figure><p>翻译过来：</p><blockquote><p>我想将其向后移植到 11u，因为 Chacha20 和 Poly1305 密码套件应该根据 rfc8446 为 TLSv1.3 实现 原始补丁（差不多）可以正常应用，除了 CipherSuite.java 测试 - 密码套件列表由 JDK-8210632 重新排序 此外，CheckCipherSuites.java 和 CipherSuitesInOrder.java 测试也进行了更新，以支持 CHACHA20 密码套件。</p></blockquote><p>当然顺带也查到了JDK代码改动提交地址，感兴趣代码改动细节可以看这一段代码：<span class="exturl" data-url="aHR0cHM6Ly9oZy5vcGVuamRrLm9yZy9qZGsvamRrL3Jldi83MjBmZDY1NDRiMDM=" title="https://hg.openjdk.org/jdk/jdk/rev/720fd6544b03">https://hg.openjdk.org/jdk/jdk/rev/720fd6544b03<i class="fa fa-external-link"></i></span></p><p>ChaCha20-Poly1305 算法，它是TLS 1.3 支持的AEAD算法。</p><p>最后是JDK的一段案例程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * XECPublicKey 和 XECPrivateKey  </span></span><br><span class="line"><span class="comment"> * RFC7748定义的秘钥协商方案更高效, 更安全. JDK增加两个新的接口  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XECPublicKeyAndXECPrivateKeyTest</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchAlgorithmException, InvalidAlgorithmParameterException, InvalidKeySpecException, InvalidKeyException </span>&#123;  </span><br><span class="line">        generateKeyPair();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generateKeyPair</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchAlgorithmException, InvalidAlgorithmParameterException, InvalidKeySpecException, InvalidKeyException </span>&#123;  </span><br><span class="line">        KeyPairGenerator kpg = KeyPairGenerator.getInstance(<span class="string">"XDH"</span>);  </span><br><span class="line">        NamedParameterSpec paramSpec = <span class="keyword">new</span> NamedParameterSpec(<span class="string">"X25519"</span>);  </span><br><span class="line">        kpg.initialize(paramSpec);  </span><br><span class="line">        KeyPair kp = kpg.generateKeyPair();  </span><br><span class="line">        PublicKey publicKey = generatePublic(paramSpec);  </span><br><span class="line">        generateSecret(kp, publicKey);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generateSecret</span><span class="params">(KeyPair kp, PublicKey pubKey)</span> <span class="keyword">throws</span> InvalidKeyException, NoSuchAlgorithmException </span>&#123;  </span><br><span class="line">        KeyAgreement ka = KeyAgreement.getInstance(<span class="string">"XDH"</span>);  </span><br><span class="line">  </span><br><span class="line">        ka.init(kp.getPrivate());  </span><br><span class="line">  </span><br><span class="line">        ka.doPhase(pubKey, <span class="keyword">true</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">byte</span>[] secret = ka.generateSecret();  </span><br><span class="line">        <span class="comment">// [B@10a035a0  </span></span><br><span class="line">        System.out.println(secret);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> PublicKey <span class="title">generatePublic</span><span class="params">(NamedParameterSpec paramSpec)</span> <span class="keyword">throws</span> NoSuchAlgorithmException, InvalidKeySpecException </span>&#123;  </span><br><span class="line">        KeyFactory kf = KeyFactory.getInstance(<span class="string">"XDH"</span>);  </span><br><span class="line">  </span><br><span class="line">        BigInteger u = <span class="keyword">new</span> BigInteger(<span class="string">"111"</span>);  </span><br><span class="line">  </span><br><span class="line">        XECPublicKeySpec pubSpec = <span class="keyword">new</span> XECPublicKeySpec(paramSpec, u);  </span><br><span class="line">  </span><br><span class="line">        PublicKey pubKey = kf.generatePublic(pubSpec);  </span><br><span class="line">        <span class="keyword">return</span> pubKey;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JEP-332-Transport-Layer-Security-TLS-1-3"><a href="#JEP-332-Transport-Layer-Security-TLS-1-3" class="headerlink" title="JEP 332: Transport Layer Security (TLS) 1.3"></a>JEP 332: Transport Layer Security (TLS) 1.3</h3><p>实际情况可以看看曾经负责过Java的安全开发工作的大佬文章：</p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmd5cHN5ZW5naW5lZXIuY29tL2VuL3NlY3VyaXR5L2FuLWV4YW1wbGUtb2YtdGxzLTEzLWNsaWVudC1hbmQtc2VydmVyLW9uLWphdmEuaHRtbA==" title="https://blog.gypsyengineer.com/en/security/an-example-of-tls-13-client-and-server-on-java.html">An example of TLS 1.3 client and server on Java | The blog of a gypsy engineer<i class="fa fa-external-link"></i></span>。</p><p>个人曾经在[[HTTP 面试题 - TLS1.3 初次解读]]对这位大佬做了一些简单阐述，并且建议看这部分内容前对于TLS1.3一定的了解，可能会有更深的印象。</p><p>根据作者所说就是Java11实现是实现了TLS1.3，但是是个“<strong>残血版</strong>”，比如不支持下面的特性：</p><ul><li>0-RTT data 0-RTT 数据</li><li>Post-handshake authentication 握手后认证</li><li>Signed certificate timestamps (SCT) 签名证书时间戳 (SCT)</li><li>ChaCha20/Poly1305 cipher suites (<span class="exturl" data-url="aHR0cHM6Ly9idWdzLm9wZW5qZGsuamF2YS5uZXQvYnJvd3NlL0pESy04MTQwNDY2" title="https://bugs.openjdk.java.net/browse/JDK-8140466">targeted to Java 12<i class="fa fa-external-link"></i></span>) ChaCha20/Poly1305 密码套件（<span class="exturl" data-url="aHR0cHM6Ly9idWdzLm9wZW5qZGsuamF2YS5uZXQvYnJvd3NlL0pESy04MTQwNDY2" title="https://bugs.openjdk.java.net/browse/JDK-8140466">针对 Java 12<i class="fa fa-external-link"></i></span>）</li><li>x25519/x448 elliptic curve algorithms x25519/x448 椭圆曲线算法（<span class="exturl" data-url="aHR0cHM6Ly9idWdzLm9wZW5qZGsuamF2YS5uZXQvYnJvd3NlL0pESy04MTcxMjc5" title="https://bugs.openjdk.java.net/browse/JDK-8171279">针对 Java 12<i class="fa fa-external-link"></i></span>）</li><li>edDSA signature algorithms edDSA 签名算法（<span class="exturl" data-url="aHR0cHM6Ly9idWdzLm9wZW5qZGsuamF2YS5uZXQvYnJvd3NlL0pESy04MTY2NTk2" title="https://bugs.openjdk.java.net/browse/JDK-8166596">针对 Java 12<i class="fa fa-external-link"></i></span>）</li></ul><p>但是从好的方面来看，Java11已经完全具备兼容TLS1.3的条件，因为这些不支持的仅仅是小部分内容，实际上大部分TLS1.3指定的最新加密套件都是支持的，使用者只需要改改“静态参数”，即可完成TLS1.2到TLS1.3的升级兼容。</p><blockquote><p>提示：为了防止误解，这里个人有必要补充一下。ChaCha20/Poly1305 并不是说JDK12才真正实现ChaCha20和Poly1305，<code>ChaCha20/Poly1305</code>不是ChaCha20+Poly1305，虽然本质上是融合到一块，但是实际上一个全新的算法。</p></blockquote><p>另外这一波也怪不到Oracle，谁让TLS1.3比JDK11晚发布3个月呢。</p><h3 id="JEP-321-HTTP-Client-Standard-标准Java异步HTTP客户端"><a href="#JEP-321-HTTP-Client-Standard-标准Java异步HTTP客户端" class="headerlink" title="JEP 321: HTTP Client (Standard) 标准Java异步HTTP客户端"></a>JEP 321: HTTP Client (Standard) 标准Java异步HTTP客户端</h3><p>这是自JDK9被引进孵化，直到JDK11才正式可用的处理 HTTP 请求的的 HTTP Client API，如小节标题所说，它支持同步和异步发送。</p><p>因为是跨越多个大版本的改建，Java11标准Java异步HTTP客户端最终被叫做 HTTP/2 Client。它定义了一个全新的实现了HTTP/2和WebSocket的HTTP客户端API，并且可以取代 HttpURLConnection。</p><p>过去HttpURLConnection 被人诟病的点如下：</p><ul><li>API 早于HTTP1.1 过于抽象。（HTTP1.0是草稿协议，没有被标准化）</li><li>API 难懂，编写的代码难以维护。</li><li>过度设计，很多支持的协议到现在基本只剩下HTTP。</li></ul><blockquote><p>java.net 包中可以找到这些 API，但是我并没有看到作者是谁=-=。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkHttpClient</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;  </span><br><span class="line">        <span class="keyword">var</span> request = HttpRequest.newBuilder()  </span><br><span class="line">                .uri(URI.create(<span class="string">"https://cn.bing.com/?mkt=zh-CN"</span>))  </span><br><span class="line">                .GET()  </span><br><span class="line">                .build();  </span><br><span class="line">        <span class="keyword">var</span> client = HttpClient.newHttpClient();  </span><br><span class="line"><span class="comment">// 同步  </span></span><br><span class="line">        HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());  </span><br><span class="line">        System.out.println(response.body());  </span><br><span class="line"><span class="comment">// 异步  </span></span><br><span class="line">        client.sendAsync(request, HttpResponse.BodyHandlers.ofString())  </span><br><span class="line">                .thenApply(HttpResponse::body)  </span><br><span class="line">                .thenAccept(System.out::println);  </span><br><span class="line">    &#125;<span class="comment">/**  </span></span><br><span class="line"><span class="comment">        截取部分内容：  </span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">     //]]&gt;&lt;/script&gt;&lt;script type="text/rms"&gt;//&lt;![CDATA[  </span></span><br><span class="line"><span class="comment">     var sj_appHTML=function(n,t)&#123;var f,e,o,r,i,s,h;if(t&amp;&amp;n)&#123;var c="innerHTML",l="script",a="appendChild",v="length",y="src",p=sj_ce,u=p("div");if(u[c]="&lt;br&gt;"+t,f=u.childNodes,u.removeChild(f[0]),e=u.getElementsByTagName(l),e)for(o=0;o&lt;e[v];o++)r=p(l),i=e[o],i&amp;&amp;(r.type=i.type=="module"||i.type=="importmap"?</span></span><br><span class="line"><span class="comment">     Process finished with exit code 0  </span></span><br><span class="line"><span class="comment">     */</span>&#125;</span><br></pre></td></tr></table></figure><p>JDK官方给JDK引入HTTP Client API了，以后还有必要用 Apache 的 HttpClient 工具包么？</p><h3 id="JEP-331-Low-Overhead-Heap-Profiling-低成本的堆分析"><a href="#JEP-331-Low-Overhead-Heap-Profiling-低成本的堆分析" class="headerlink" title="JEP 331: Low-Overhead Heap Profiling 低成本的堆分析"></a>JEP 331: Low-Overhead Heap Profiling 低成本的堆分析</h3><p>官方说明：<span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9qZXBzLzMzMQ==" title="https://openjdk.org/jeps/331">JEP 331: Low-Overhead Heap Profiling (openjdk.org)<i class="fa fa-external-link"></i></span></p><blockquote><p>Provide a low-overhead way of sampling Java heap allocations, accessible via JVMTI.</p></blockquote><p>官方的介绍是说通过<strong>JVMTI</strong>的<strong>sampling</strong>提供低堆内存开销的分析工具。</p><p>为什么有了如Java Flight Recorder、YourKit和VisualVM等非常实用的JVM分析工具，JDK官方还需要提供接口扩展堆分析的手段呢？</p><blockquote><p>One piece of information that is lacking from most of the existing tooling is the call site for <strong>particular allocations</strong>. Heap dumps and heap histograms do not contain this information. </p></blockquote><p>关键原因在于大多数的分析工具缺少<code>particular allocations</code>，这里的特定分配在个人的理解是“堆外”内存的分配，因为这部分是超出JVM管辖范围内直接通过操作系统底层往物理内存分配。</p><blockquote><p>现代的消息中间件Kafka、RocketMq等底层大量使用了<strong>页缓存</strong>这个东西，并且进行了大量的直接内存分配，不巧的是这部分内容刚好是JVM堆内存分析工具的痛点。所以JDK开发扩展这些接口也是时代发展的趋势之一。</p></blockquote><blockquote><p>This proposal mitigates these problems by providing an extensible JVMTI interface that allows the user to define the sampling interval and returns a set of live stack traces.</p></blockquote><p>通过提供一个可扩展的JVMTI接口来缓解这些问题，该接口允许用户定义采样间隔并返回一组实时堆栈跟踪。</p><p>因为用的是JVM对外接口，所以这个接口是C++写的，在<code>Use-case example</code>里面有很多的接入案例代码，如果不是要开发JVM堆分析工具，我们了解到这就可以收住了。</p><p>低成本的堆分析主要目标：</p><ul><li>开销低，可以持续默认启用。</li><li>可以通过一个定义明确的程序化接口访问。</li><li>可以对所有分配进行采样（即，不限于在某一特定堆区域的分配或以某一特定方式的分配）。</li><li>可以以<strong>独立</strong>于实现的方式进行定义（即，不依赖于任何特定的GC算法或虚拟机实现），并且可以提供关于存活Java对象和垃圾Java对象的信息。</li></ul><p>最终的实现如下：</p><ul><li>提供用于生产和消费数据作为事件的API<ul><li>提供缓存机制和二进制数据格式</li><li>允许事件配置和事件过滤</li><li>提供OS,JVM和JDK库的事件</li></ul></li></ul><h2 id="新增内容"><a href="#新增内容" class="headerlink" title="新增内容"></a>新增内容</h2><h3 id="JEP-330-Launch-Single-File-Source-Code-Programs-启动单一文件的源代码程序"><a href="#JEP-330-Launch-Single-File-Source-Code-Programs-启动单一文件的源代码程序" class="headerlink" title="JEP 330: Launch Single-File Source-Code Programs 启动单一文件的源代码程序"></a>JEP 330: Launch Single-File Source-Code Programs 启动单一文件的源代码程序</h3><p>提案愿意是：增强java启动器支持运行单个java源代码文件的程序。这是什么意思？在我们的认知里面，要运行一个 Java 源代码必须先编译，再运行两步执行动作。JDK11简化了允许java程序编译运行的过程。</p><p>这个功能是免去了Java初学者需要javac和Java运行class文件的步骤，直接java 类名即可编译运行，但是需要注意这种增强需要满足一定条件：</p><ul><li>第一点：执行源文件中的第一个类，第一个类必须包含main方法，比如下面的代码main方法在Test2当中就无法使用此特性：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">otherMethod</span><span class="params">()</span></span>&#123;  </span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第二点：不可以使用别源文件中的自定义类, 但是当前文件中的自定义类是可以使用的。</li></ul><p>到JDK10为止，Java启动器能以三种方式运行，JDK11补齐了另一块短板：</p><ol><li>启动一个class文件；</li><li>启动一个JAR中的main方法类；</li><li>启动一个模块中的main方法类；</li><li>启动java命令直接运行源码级别的Java文件（JDK11）</li></ol><blockquote><p>补充：只要是Java程序，无论多复杂，最终入口一定是main()。 </p></blockquote><h3 id="JEP-327-Unicode-10"><a href="#JEP-327-Unicode-10" class="headerlink" title="JEP 327: Unicode 10"></a>JEP 327: Unicode 10</h3><p>Unicode 10 增加了8518个字符， 总计达到了136690个字符，并且增加了4个脚本，同时还有56个新的emoji表情符号。</p><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHAlM0EvL3VuaWNvZGUub3JnL3ZlcnNpb25zL1VuaWNvZGUxMC4wLjAv" title="https://link.zhihu.com/?target=http%3A//unicode.org/versions/Unicode10.0.0/">http://unicode.org/versions/Unicode10.0.0/<i class="fa fa-external-link"></i></span></p><h3 id="JEP-328-Flight-Recorder"><a href="#JEP-328-Flight-Recorder" class="headerlink" title="JEP 328: Flight Recorder"></a>JEP 328: Flight Recorder</h3><p>英文名称直译过来是“飞行记录仪”，没错就是我们日常生活中的黑匣子。</p><p>在JDK11之前是一个商业版的特性，在java11当中开源出来，它可以导出事件到文件中，之后配合<strong>Java Mission Control</strong>来分析。</p><p>使用Flight Recorder 有两种方式：</p><ul><li>应用启动时配置java -XX:StartFlightRecording<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX: +StartFlightRecording=filename=&lt;path&gt;, duration=&lt;time&gt;</span><br></pre></td></tr></table></figure></li><li>使用jcmd来录制<ul><li><code>$ jcmd &lt;pid&gt; JFR.start</code></li><li><code>$ jcmd &lt;pid&gt; JFR.dump filename=recording.jfr</code></li><li><code>$ jcmd &lt;pid&gt; JFR.stop</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Jcmd &lt;pid&gt; JFR.start filename=&lt;path&gt; duration=&lt;time&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>扩展：<span class="exturl" data-url="aHR0cHM6Ly93d3cuamF2YXRwb2ludC5jb20vamF2YS1mbGlnaHQtcmVjb3JkZXI=" title="https://www.javatpoint.com/java-flight-recorder">Java Flight Recorder - Javatpoint<i class="fa fa-external-link"></i></span></p><p>感兴趣可以看看下面的文章介绍的简单的JFR使用教程，但是注意是JDK8 的：</p><p><span class="exturl" data-url="aHR0cHM6Ly9taWtleWdpdGh1Yi5naXRodWIuaW8vMjAyMS8wNS8xNC95dXF1ZS9saWd0NDEv" title="https://mikeygithub.github.io/2021/05/14/yuque/ligt41/">工具篇-性能分析工具JFR和JMC - 麦奇 (mikeygithub.github.io)<i class="fa fa-external-link"></i></span></p><h4 id="实战-JFR"><a href="#实战-JFR" class="headerlink" title="实战 JFR"></a>实战 JFR</h4><p>首先是编写一段JFR的测试案例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * JFR 的测试程序  </span></span><br><span class="line"><span class="comment"> * 需要使用JDK11以上的版本  </span></span><br><span class="line"><span class="comment"> * &lt;p&gt;  </span></span><br><span class="line"><span class="comment"> * src/main/java/com/zxd/interview/jfr/JfrTestApplication.java  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JfrTestApplication</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        List&lt;Object&gt; items = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">1</span>);  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;  </span><br><span class="line">                items.add(<span class="keyword">new</span> Object());  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (OutOfMemoryError e)&#123;  </span><br><span class="line">            System.out.println(e.getMessage());  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">assert</span> items.size() &gt; <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            System.out.println(e.getMessage());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了编译成功需要删除中文内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * JFR 的测试程序  </span></span><br><span class="line"><span class="comment"> * 需要使用JDK11以上的版本  </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * src/main/java/com/zxd/interview/jfr/JfrTestApplication.java */</span></span><br></pre></td></tr></table></figure><p>运行之后发现报错，这是因为中文导致的问题，这里把中文注释掉之后就OK了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">D:\adongstack\project\interview&gt;javac -d out -sourcepath src/main src/main/java/com/zxd/interview/jfr/JfrTestApplication.java</span><br><span class="line">src\main\java\com\zxd\interview\jfr\JfrTestApplication.java:<span class="number">7</span>: error: <span class="function">unmappable <span class="title">character</span> <span class="params">(<span class="number">0x8F</span>)</span> <span class="keyword">for</span> encoding GBK</span></span><br><span class="line"><span class="function"> * JFR 鐨勬祴璇曠▼搴?</span></span><br><span class="line"><span class="function">              ^</span></span><br><span class="line"><span class="function">src\main\java\com\zxd\interview\jfr\JfrTestApplication.java:8: error: unmappable <span class="title">character</span> <span class="params">(<span class="number">0x80</span>)</span> <span class="keyword">for</span> encoding GBK</span></span><br><span class="line"><span class="function"> * 闇?瑕佷娇鐢↗DK11浠ヤ笂鐨勭増鏈?</span></span><br><span class="line"><span class="function">    ^</span></span><br><span class="line"><span class="function">src\main\java\com\zxd\interview\jfr\JfrTestApplication.java:8: error: unmappable <span class="title">character</span> <span class="params">(<span class="number">0xAC</span>)</span> <span class="keyword">for</span> encoding GBK</span></span><br><span class="line"><span class="function"> * 闇?瑕佷娇鐢↗DK11浠ヤ笂鐨勭増鏈?</span></span><br></pre></td></tr></table></figure><p>通过下面的命令执行，编译JfrTestApplication：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+UnlockCommercialFeatures -XX:+FlightRecorder -XX:StartFlightRecording=duration=<span class="number">200</span>s,filename=flight.jfr -cp ./out/ com/zxd/interview/jfr/JfrTestApplication</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">D:\adongstack\project\interview&gt;java -XX:+UnlockCommercialFeatures -XX:+FlightRecorder -XX:StartFlightRecording=duration=<span class="number">200</span>s,filename=flight.jfr -cp ./out/ com/zxd/interview/jfr/JfrTestApplication</span><br><span class="line"></span><br><span class="line"><span class="function">Java <span class="title">HotSpot</span><span class="params">(TM)</span> 64-Bit Server VM warning: Ignoring option UnlockCommercialFeatures</span>; support was removed in <span class="number">11.0</span></span><br><span class="line">Started recording <span class="number">1</span>. The result will be written to:</span><br><span class="line">D:\adongstack\project\interview\flight.jfr</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">[<span class="number">70.761</span>s][warning][jfr,system,event] Exception occured during execution of period hook <span class="keyword">for</span> jdk.ThreadContextSwitchRate(<span class="number">345</span>)</span><br></pre></td></tr></table></figure><p>因为程序执行的是一个“死循环”，安静等待执行死循环直到OOM即可。执行完成之后，在Idea的项目根路径当中会出现下面的文件内容：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230313213708.png" alt=""></p><p>这个文件要如何阅读？这里要用JDK的另一个工具<strong>JMC</strong>。令人遗憾的是，JFR为JDK自带的工具，但是JMC需要我们自己去Oracle官网下载（JMC被官方从JDK中移除）。</p><h4 id="JMC安装"><a href="#JMC安装" class="headerlink" title="JMC安装"></a>JMC安装</h4><p>下载链接：<span class="exturl" data-url="aHR0cHM6Ly93d3cub3JhY2xlLmNvbS9qYXZhL3RlY2hub2xvZ2llcy9qYXZhc2UvcHJvZHVjdHMtam1jOC1kb3dubG9hZHMuaHRtbA==" title="https://www.oracle.com/java/technologies/javase/products-jmc8-downloads.html">https://www.oracle.com/java/technologies/javase/products-jmc8-downloads.html<i class="fa fa-external-link"></i></span></p><p>这里直接下载当前的最新版本即可。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230313213906.png" alt=""></p><p>Windows平台直接打开程序：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230313214004.png" alt=""></p><p>看到下面的界面说明可以正常使用：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230313214107.png" alt=""></p><h4 id="Java-Mission-Control-分析代码"><a href="#Java-Mission-Control-分析代码" class="headerlink" title="Java Mission Control 分析代码"></a>Java Mission Control 分析代码</h4><p>进入主界面，我们直接打开刚刚生成的jfr文件：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230313214128.png" alt=""></p><p>首先是一份报告，简单介绍了jfr的情况：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230313215717.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Application efficiency was affected by halts</span><br><span class="line"></span><br><span class="line">The highest ratio of application halts to execution time was 84.7 % during 2023&#x2F;3&#x2F;13 下午9:11:53.000 – 下午9:12:53. 2.59 % of the halts were for reasons other than GC. The halts ratio for the entire recording was 86.6 %. 2.21 % of the total halts were for reasons other than GC. Application halts are often caused by garbage collections, but can also be caused by excessive thread dumps or heap dumps. Investigate the VM Operation information and possibly the safepoint specific information.</span><br></pre></td></tr></table></figure><p>报告主要说明了整个应用程序大部分的时间都是在进行停顿，也就是对象的分配速度远远高于垃圾回收速度，垃圾收集器长时间工作而出现停顿和等待。</p><p>因为我们是while的死循环程序，可以明显CPU使用率逐渐飙升。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230313220008.png" alt=""></p><p>我们可以阅读“方法调用的统计信息”来查看整个死循环的过程中哪些方法被大量调用：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230313215645.png" alt=""></p><p>通过“方法”板块我们可以发现示例程序的另一个缺点：方法<code>java.util.ArrayList.grow（int）</code>已被调用147次，在每次没有足够的空间添加对象时扩大数组容量。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230313215544.png" alt=""></p><p>我们可能会看到许多其他有用的信息：</p><ul><li>有关创建对象的统计信息，当垃圾回收器创建和销毁这些对象时</li><li>有关线程年表的详细报告，它们何时被锁定或处于活动状态</li><li>应用程序正在执行哪些 I/O 操作</li></ul><h3 id="JEP-318-Epsilon-A-No-Op-Garbage-Collector-Epsilon-垃圾收集器"><a href="#JEP-318-Epsilon-A-No-Op-Garbage-Collector-Epsilon-垃圾收集器" class="headerlink" title="JEP 318: Epsilon: A No-Op Garbage Collector Epsilon 垃圾收集器"></a>JEP 318: Epsilon: A No-Op Garbage Collector Epsilon 垃圾收集器</h3><p>首先吸引我的是<strong>Epsilon</strong>这个单词，和CMS、G1这种带有含义的垃圾收集器名称一样，Epsilon 也有特殊的含义。</p><p>这个希腊字母同时也是英语音标<code>ɛ</code>的来源，下面的介绍引自：<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3poLWNuLyVDRSU5NQ==" title="https://zh.wikipedia.org/zh-cn/%CE%95">Ε - 维基百科，自由的百科全书 (wikipedia.org)<i class="fa fa-external-link"></i></span></p><blockquote><p>Epsilon（大写 Ε、小写 ε 或 ϵ；希腊语：έψιλον；中文音译：伊普西龙、厄普西隆、艾普西龙、艾普塞朗），是第五个希腊字母。Epsilon（ἒ ψιλόν）即“e 简单的、e 单一的”的意思，这是为了与中世纪发生单元音化而变为同音的二合字母 ai（αι，古希腊语：[ai̯]）做区别，古典时期本来这个字母读作ei（εἶ，古希腊语：[êː]）；源自腓尼基字母 HeHe，又从 epsilon 发展出了拉丁字母 E 和西里尔字母 Е。在希腊数字系统中，E 表示 5。</p></blockquote><p>Epsilon 垃圾收集器用法非常简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseEpsilonGC</span><br></pre></td></tr></table></figure><p>通常建议搭配参数<code>-XX:+UnlockExperimentalVMOptions</code> 使用。</p><blockquote><p>-XX:+UnlockExperimentalVMOptions ：<br>一般使用在一些低版本jdk想使用高级参数或者可能高版本有的参数情况；<br>        解锁实验参数，允许使用实验性参数，JVM中有些参数不能通过-XX直接复制需要先解锁，比如要使用某些参数的时候，可能不会生效，需要设置这个参数来解锁；</p></blockquote><p>JDK的描述是开发只负责内存分配，其他事情一概不做处理的垃圾收集器，“不回收垃圾的垃圾收集器”看起来怪怪的，因此用途也比较特殊：</p><ul><li>性能测试（它可以帮助过滤掉GC引起的性能假象）；</li><li>内存压力临界点测试（比如知道测试用例应该分配不超过1 GB的内存，我们可以使用-Xmx1g配置<code>-XX:+UseEpsilonGC</code>，如果违反了该约束，则会heap dump并崩溃）；</li><li>非常短的JOB任务（对于这种任务，接受GC清理堆那都是浪费空间）；</li><li>VM接口测试；</li><li>Last-drop 延迟&amp;吞吐改进；</li></ul><p>这里直接通过一个程序了解Epsilon垃圾收集器的效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * JDK11 新的垃圾收集器 Epsilon  </span></span><br><span class="line"><span class="comment"> * 需要配置启动参数：  </span></span><br><span class="line"><span class="comment"> * -XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC  </span></span><br><span class="line"><span class="comment"> */</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EpsilonGcTest</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;  </span><br><span class="line">  </span><br><span class="line">        List&lt;Garbage&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">long</span> count = <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">while</span> (flag)&#123;  </span><br><span class="line">            list.add(<span class="keyword">new</span> Garbage());  </span><br><span class="line">            <span class="keyword">if</span>(list.size() == <span class="number">100000</span> &amp;&amp; count == <span class="number">0</span>)&#123;  </span><br><span class="line">                list.clear();  </span><br><span class="line">                count++;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(<span class="string">"程序结束"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Garbage</span></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> n = (<span class="keyword">int</span>)(Math.random() * <span class="number">100</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;  </span><br><span class="line">        System.out.println(<span class="keyword">this</span> + <span class="string">"  : "</span>+ n + <span class="string">"is dying"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动之前，不要忘了设置VM Option，如果看不到<code>VM Option</code>这一行，可以点击”Modify options”中添加VM option。</p><blockquote><p>PS：下面的环境变量和program arguments设置启动参数是无效的。</p></blockquote><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230316072908.png" alt=""></p><p>启动之后一会儿控制台会打印下面的内容并且结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Terminating due to java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure><p>如果是传统的垃圾收集器，那么输出的结果将会是<code>System.out.println(this + &quot;  : &quot;+ n + &quot;is dying&quot;);</code>的内容，虽然整个程序依然会继续运行直到OOM，但是要花更多的时间等待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">com.zxd.interview.epsilongctest.Garbage@<span class="number">21</span>abe  : <span class="number">59</span>is dying</span><br><span class="line">com.zxd.interview.epsilongctest.Garbage@<span class="number">6f</span>6b18fc  : <span class="number">43</span>is dying</span><br><span class="line">com.zxd.interview.epsilongctest.Garbage@<span class="number">701264</span>d8  : <span class="number">56</span>is dying</span><br><span class="line">com.zxd.interview.epsilongctest.Garbage@<span class="number">5380</span>a941  : <span class="number">52</span>is dying</span><br><span class="line">com.zxd.interview.epsilongctest.Garbage@<span class="number">43</span>c78e65  : <span class="number">72</span>is dying</span><br><span class="line">com.zxd.interview.epsilongctest.Garbage@<span class="number">745</span>cd219  : <span class="number">11</span>is dying</span><br><span class="line">com.zxd.interview.epsilongctest.Garbage@<span class="number">170</span>b4cee  : <span class="number">68</span>is dying</span><br><span class="line">com.zxd.interview.epsilongctest.Garbage@<span class="number">411725</span>ef  : <span class="number">22</span>is dying</span><br><span class="line">com.zxd.interview.epsilongctest.Garbage@<span class="number">3</span>edc2f0e  : <span class="number">4</span>is dying</span><br><span class="line">com.zxd.interview.epsilongctest.Garbage@<span class="number">2</span>c82eed6  : <span class="number">58</span>is dying</span><br><span class="line">com.zxd.interview.epsilongctest.Garbage@<span class="number">61</span>a3bb94  : <span class="number">71</span>is dying</span><br><span class="line">com.zxd.interview.epsilongctest.Garbage@<span class="number">19e3</span>d212  : <span class="number">70</span>is dying</span><br><span class="line">com.zxd.interview.epsilongctest.Garbage@<span class="number">46182</span>a7f  : <span class="number">19</span>is dying</span><br><span class="line">com.zxd.interview.epsilongctest.Garbage@<span class="number">7</span>dd78834  : <span class="number">56</span>is dying</span><br><span class="line">com.zxd.interview.epsilongctest.Garbage@<span class="number">1</span>d4e301  : <span class="number">68</span>is dying</span><br></pre></td></tr></table></figure><p>从上面的案例可以看到，有时候不回收垃圾也是有帮助的。</p><h3 id="JEP-333-ZGC-A-Scalable-Low-Latency-Garbage-Collector-可伸缩低延迟垃圾收集器"><a href="#JEP-333-ZGC-A-Scalable-Low-Latency-Garbage-Collector-可伸缩低延迟垃圾收集器" class="headerlink" title="JEP 333: ZGC: A Scalable Low-Latency Garbage Collector (可伸缩低延迟垃圾收集器)"></a>JEP 333: ZGC: A Scalable Low-Latency Garbage Collector (可伸缩低延迟垃圾收集器)</h3><p>这应该是JDK11最为瞩目的特性, 没有之一， 但是后面带了Experimental, 说明JDK11这一个版本<strong>不建议用到生产环境</strong>。（JDK13才算是真正完善），ZGC问世对外宣传如下：</p><ul><li>GC暂停时间不会超过10ms；</li><li>即能处理几百兆小堆，也能处理几个T的大堆（OMG）；</li><li>和G1相比，应用吞吐能力不会下降超过15%；</li><li>为未来的GC功能和利用colord指针以及Load barriers优化奠定基础；</li><li>初始只支持64位系统；</li></ul><p>现代系统可用内存不断增大，GC垃圾收集器同样需要不断进化，现代的应用追求低延迟高吞吐量，ZGC的特点正好切中了GC的痛点。</p><p><strong>ZGC的设计目标是：支持TB级内存容量，暂停时间低（&lt;10ms），对整个程序吞吐量的影响小于15%。</strong></p><p>美团在2020年有一篇关于ZGC的分析文章质量很高： <span class="exturl" data-url="aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMjAvMDgvMDYvbmV3LXpnYy1wcmFjdGljZS1pbi1tZWl0dWFuLmh0bWw=" title="https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html"># 新一代垃圾回收器ZGC的探索与实践<i class="fa fa-external-link"></i></span>，如果比较难理解，还可以看看这一篇文章：<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMDU5MjEzMzk=" title="https://zhuanlan.zhihu.com/p/105921339"># 理解并应用JVM垃圾收集器-ZGC<i class="fa fa-external-link"></i></span></p><p>ZGC的了解程度停留在简单理解理论概念即可，下面是从网络整理的资料归档：</p><h4 id="GC术语"><a href="#GC术语" class="headerlink" title="GC术语"></a>GC术语</h4><p>注意下面的并行、串行、并发更偏向GC的概念：</p><ul><li>并行：可以存在多个GC线程同时进行工作，但是无法确定是否需要暂停用户线程</li><li>串行：指的是只有单个GC线程进行工作。注意串行也不一定需要暂停用户线程</li><li>STW：用户线程暂停，此时只有GC线程进行工作。</li><li>并发：GC的并发指的是具备并发性，如果说垃圾收集器某些阶段是并发的，那么可以简单在某些阶段GC线程可以和应用程序线程同时进行，但是这需要十分复杂的设计防止用户线程操作导致GC工作无效。</li><li>增量阶段指的是某个阶段可以再运行一段时间之后提前中止。</li></ul><h4 id="权衡"><a href="#权衡" class="headerlink" title="权衡"></a>权衡</h4><p>权衡主要是针对并行和并发阶段带来的问题，并行阶段如果GC占用过多的线程可能导致用户线程性能抖动，而并发阶段如果需要保证能同时处理GC的有效性和用户线程正常工作的问题。</p><h4 id="多层堆和压缩"><a href="#多层堆和压缩" class="headerlink" title="多层堆和压缩"></a>多层堆和压缩</h4><p>多层堆指的是让JVM管理内存可以像高速缓存一样分为多级缓存存储对象，通过对象分类将频繁访问对象和很少使用对象分开管理的技术。该功能可以通过扩展指针元数据来实现，指针可以实现计数器位并使用该信息来决定是否需要移动对象到较慢的存储上。</p><p>压缩是指对象可以以压缩形式保存在内存中，而不是将对象重定位到较慢的存储层。获取压缩对象的时候通过读屏障将其解压并且重新分配。</p><h4 id="多重映射"><a href="#多重映射" class="headerlink" title="多重映射"></a>多重映射</h4><p>这里不过多介绍计算机的虚拟内存和物理内存概念，简单知道操作系统通过<strong>映射表</strong>实现了物理内存和虚拟内存的映射，最终通过使用页表和处理器的内存管理单元（MMU）和转换查找缓冲器（TLB）来实现这一点。</p><p>而多重映射则指的是多个虚拟内存映射到同一块物理内存的技术。ZGC中使用三个映射来完成多重映射操作。</p><h4 id="读屏障"><a href="#读屏障" class="headerlink" title="读屏障"></a>读屏障</h4><p>读屏障是每当应用程序线程从堆加载引用时运行的代码片段（即访问对象上的非原生字段（non-primitive field））：</p><blockquote><p>读屏障是JVM向应用代码插入一小段代码的技术。当应用线程从堆中读取对象引用时，就会执行这段代码。需要注意的是，仅“<strong>从堆中读取对象引用</strong>”才会触发这段代码。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printName</span><span class="params">( Person person )</span> </span>&#123;</span><br><span class="line"><span class="comment">// 这里触发读屏障</span></span><br><span class="line">String name = person.name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为需要从heap读取引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">System.out.println(name); <span class="comment">// 这里没有直接触发读屏障</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如注释所说<code>String name = person.name;</code>这一行因为访问了对象非原生字段，将引用加载到本地的name变量，此时操作触发了读屏障。</p><p>如前面所说，读屏障是在返回对象引用之前“做手脚”，比较能想到的思路是引用中设置某些“标志位”的方式，但是ZGC实际用的是“测试加载的引用”检查是否满足条件，最后根据结果判断是否执行自己需要的特殊操作。</p><p>ZGC 最终选择在读屏障上动手脚，一部分原因是源自Shenadoah收集器的挑战，这个非JDK官方设计的垃圾收集器给Oracle不小的冲击。</p><h4 id="ZGC标记"><a href="#ZGC标记" class="headerlink" title="ZGC标记"></a>ZGC标记</h4><p>下面简单了解ZGC垃圾回收截断中的标记截断处理，ZGC的标记分为三个阶段：</p><ul><li>第一阶段是STW，其中GC roots被标记为活对象。<ul><li>从roots访问的对象集合称为Live集。GC roots标记步骤非常短，因为roots的总数通常比较小。</li></ul></li><li>第二阶段遍历对象图并标记所有可访问的对象。<ul><li>读屏障针使用掩码测试所有已加载的引用，该掩码确定它们是否已标记或尚未标记，如果尚未标记引用，则将其添加到队列以进行标记。</li></ul></li><li>第三阶段是边缘情况的处理，这里会有一个非常短暂的STW操作。也是针对经过前两次标记之后依然没有标记完成的最终检查。</li></ul><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230317150355.png" alt="image.png"></p><blockquote><p>GC roots类似于局部变量，通过它可以访问堆上其他对象。通过Gc root进行可达性分析查找出无法“到达”的对象则被标记为垃圾对象 </p></blockquote><h4 id="ZGC-重定位"><a href="#ZGC-重定位" class="headerlink" title="ZGC 重定位"></a>ZGC 重定位</h4><p>ZGC在对象清理上采用和G1类似的思路，也就是<strong>标记-复制</strong>把活对象移动到另一处，然后将只存在垃圾对象的内存释放掉，但是实现方法上更为取巧。</p><p>ZGC首先将堆分成许多页面，重定位开始的时候，会挑选一组需要重定位对象的页面，为了保证挑选准确此时需要<strong>短暂STW</strong>将该集合中root对象的引用映射到新位置。</p><p>移动root后下一阶段是<strong>并发重定位</strong>，此时GC线程遍历重定位集并重新定位其包含的页中所有对象，如果应用线程访问到这些需要重定位对象，则通过转发引用的方式重新定位读取新位置。</p><p>这里需要注意读屏障并不能完全保证所有指向旧对象的引用转到重新定位的地址上，在并发的情况下GC需要反复多次检查是否有引用指向旧的位置。</p><p>重定位的操作代价十分高昂，为了提高效率会和GC周期的标记阶段一起并行执行，GC周期标记阶段遍历对象对象图的时候，如果发现未重映射的引用则将其重新映射，然后标记为活动状态。</p><blockquote><p>这两步可以抽象认为是一个人负责干活，另一个人负责把前面干活遗留的工作进行检查和标记。</p></blockquote><blockquote><p>用户进程读取对象重新定位就是通过<strong>读屏障</strong>实现的。</p></blockquote><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230317151934.png" alt="image.png"></p><h4 id="ZGC-表现"><a href="#ZGC-表现" class="headerlink" title="ZGC 表现"></a>ZGC 表现</h4><p>ZGC的SPECjbb 2015吞吐量与Parallel GC（优化吞吐量）大致相当，但平均暂停时间为1ms，最长为4ms。 与之相比G1和Parallel有很多次超过200ms的GC停顿。</p><h4 id="ZGC的状态"><a href="#ZGC的状态" class="headerlink" title="ZGC的状态"></a>ZGC的状态</h4><p>ZGC 依然有很多亟待解决的问题，以G1为例从发布到支持之间超过3年，ZGC最终到JDK13被正式对外使用。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>从整体上看，ZGC的垃圾收集将所有的暂停控制只依赖于GC roots集合上，将停顿控制在一处以达到更好的GC效果。</p><p>标记垃圾对象的过程中，标记阶段处理标记终止的最<strong>后一次暂停</strong>是唯一的例外，但是它是增量的（不一定执行），如果超过GC时间预算，那么GC将恢复到并发标记，直到再次尝试。</p><h2 id="删除内容"><a href="#删除内容" class="headerlink" title="删除内容"></a>删除内容</h2><h3 id="JEP-320-Remove-the-Java-EE-and-CORBA-Modules"><a href="#JEP-320-Remove-the-Java-EE-and-CORBA-Modules" class="headerlink" title="JEP 320: Remove the Java EE and CORBA Modules"></a>JEP 320: Remove the Java EE and CORBA Modules</h3><p>Java EE和CORBA两个模块在JDK9中已经标记”deprecated”，在JDK11中正式移除。这部分内容基本上没有Java开发者接触到（连网络搜索都不会碰到）所以<strong>忘记</strong>即可。</p><p>JavaEE由4部分组成：</p><ul><li>JAX-WS (Java API for XML-Based Web Services),</li><li>JAXB (Java Architecture for XML Binding)</li><li>JAF (the JavaBeans Activation Framework)</li><li>Common Annotations.</li></ul><p>看起来比较多，但是这个特性和JavaSE关系不大。并且Maven也提供了JavaEE（<span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHAlM0EvL212bnJlcG9zaXRvcnkuY29tL2FydGlmYWN0L2phdmF4L2phdmFlZS1hcGkvOC4w" title="https://link.zhihu.com/?target=http%3A//mvnrepository.com/artifact/javax/javaee-api/8.0">http://mvnrepository.com/artifact/javax/javaee-api/8.0<i class="fa fa-external-link"></i></span> 第三方引用，所以移除的影响并不会很大。</p><p>至于CORBA，使用CORBA开发程序没有太大的兴趣。</p><blockquote><p>CORBA的XML相关模块被移除：<br>    <span class="exturl" data-url="aHR0cDovL2phdmEueG1sLndz" title="http://java.xml.ws">java.xml.ws<i class="fa fa-external-link"></i></span>,<br>    <code>java.xml.bind</code>，<br>    <span class="exturl" data-url="aHR0cDovL2phdmEueG1sLndz" title="http://java.xml.ws">java.xml.ws<i class="fa fa-external-link"></i></span>，<br>    <code>java.xml.ws.annotation</code>，<br>    <code>jdk.xml.bind</code>，<br>    <code>jdk.xml.ws</code><br>    最终保留：<code>java.xml</code>，<code>java.xml.crypto</code>，<code>jdk.xml.dom</code> 模块。</p></blockquote><blockquote><p>除此之外，还有：</p><p><span class="exturl" data-url="aHR0cDovL2phdmEuc2UuZWU=" title="http://java.se.ee">java.se.ee<i class="fa fa-external-link"></i></span>，<br><code>java.activation</code>，<br><code>java.transaction</code></p><p>被移除，但是java11新增一个<code>java.transaction.xa</code>模块</p></blockquote><h3 id="JEP-335-Deprecate-the-Nashorn-JavaScript-Engine（弃用-Nashorn-JavaScript-引擎）"><a href="#JEP-335-Deprecate-the-Nashorn-JavaScript-Engine（弃用-Nashorn-JavaScript-引擎）" class="headerlink" title="JEP 335: Deprecate the Nashorn JavaScript Engine（弃用 Nashorn JavaScript 引擎）"></a>JEP 335: Deprecate the Nashorn JavaScript Engine（弃用 Nashorn JavaScript 引擎）</h3><p>废除<strong>Nashorn javascript</strong>引擎，在后续版本准备移除掉，有需要的可以考虑使用GraalVM</p><p>最终：<strong>Nashorn JavaScript Engine 在 Java 15 已经不可用了</strong>。几乎不会用到的东西，为了让读者略微了解一下，这里用JDK8的Nashorn简单做个演示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NashornTest</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ScriptException, FileNotFoundException </span>&#123;  </span><br><span class="line">        <span class="comment">// 直接使用  </span></span><br><span class="line">        ScriptEngine engine = <span class="keyword">new</span> ScriptEngineManager().getEngineByName(<span class="string">"nashorn"</span>);  </span><br><span class="line">        engine.eval(<span class="string">"print('Hello World!');"</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 文件中运行  </span></span><br><span class="line">        ScriptEngine engine2 = <span class="keyword">new</span> ScriptEngineManager().getEngineByName(<span class="string">"nashorn"</span>);  </span><br><span class="line">        engine2.eval(<span class="keyword">new</span> FileReader(<span class="string">"E:\\adongstack\\project\\selfUp\\interview\\src\\main\\resources\\static\\js\\hello.js"</span>));  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现代项目大多数都是前后端分离的，哪怕没有前后端分离也基本没有人会在后端写很多隐患的JS脚本，个人认为是这些原因导致的<strong>Nashorn javascript</strong>默默无闻的诞生和默默无闻的毁灭。</p><p>Nashorn javascript引擎更多了解可以看这篇：<span class="exturl" data-url="aHR0cHM6Ly9tb3VzZTB3MC5naXRodWIuaW8vMjAxOC8xMi8wMi9JbnRyb2R1Y3Rpb24tdG8tTmFzaG9ybi8=" title="https://mouse0w0.github.io/2018/12/02/Introduction-to-Nashorn/">https://mouse0w0.github.io/2018/12/02/Introduction-to-Nashorn/<i class="fa fa-external-link"></i></span></p><h3 id="JEP-336-Deprecate-the-Pack200-Tools-and-API-废弃Pack200和相关API"><a href="#JEP-336-Deprecate-the-Pack200-Tools-and-API-废弃Pack200和相关API" class="headerlink" title="JEP : 336 : Deprecate the Pack200 Tools and API 废弃Pack200和相关API"></a>JEP : 336 : Deprecate the Pack200 Tools and API 废弃Pack200和相关API</h3><p>Pack200 是自Java5出现的 <strong>压缩工具</strong>，这个工具能对普通的jar文件进行高效压缩。</p><p>Pack200 合并原理是根据类的结构设计以及合并常量池的方式，最后去掉无用信息来实现高效压缩，注意这种压缩只能针对Java文件进行压缩，这种压缩方式是很有意义的，能达到jar包的10% - 40%的压缩率。</p><p>Java5中还提供了这一技术的API接口，可以将其嵌入到应用程序中使用。使用的方法很简单，下面的短短几行代码即可以实现jar的压缩和解压：</p><p>压缩</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Packer packer=Pack200.newPacker();</span><br><span class="line">OutputStream output=<span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(outfile));</span><br><span class="line">packer.pack(<span class="keyword">new</span> JarFile(jarFile), output);</span><br><span class="line">output.close();</span><br></pre></td></tr></table></figure><p>解压</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Unpacker unpacker=Pack200.newUnpacker();</span><br><span class="line">output=<span class="keyword">new</span> JarOutputStream(<span class="keyword">new</span> FileOutputStream(jarFile));</span><br><span class="line">unpacker.unpack(pack200File, output);</span><br><span class="line">output.close();</span><br></pre></td></tr></table></figure><p>看了上面的介绍，读者可能会跟我有一样的疑问，感觉这<strong>不是挺好的一东西么为啥要抛弃？</strong> 还能结合SpringBoot的jar包进行压缩，为了进一步了解JDK为啥要在Java11移除，这里找到的JDK官方的说明：</p><p><span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9qZXBzLzM2Nw==" title="https://openjdk.org/jeps/367">JEP 367: Remove the Pack200 Tools and API (openjdk.org)<i class="fa fa-external-link"></i></span></p><p>我把JDK官方的说明部分拿过来了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">There are three reasons to remove Pack200:</span><br><span class="line"></span><br><span class="line">1.  Historically, slow downloads of the JDK over 56k modems were an impediment to Java adoption. The relentless growth in JDK functionality caused the download size to swell, further impeding adoption. Compressing the JDK with Pack200 was a way to mitigate the problem. However, time has moved on: download speeds have improved, and JDK 9 introduced new compression schemes for both the Java runtime ([JEP 220](http:&#x2F;&#x2F;openjdk.java.net&#x2F;jeps&#x2F;220)) and the modules used to build the runtime ([JMOD](http:&#x2F;&#x2F;openjdk.java.net&#x2F;jeps&#x2F;261#Packaging:-JMOD-files)). Consequently, JDK 9 and later do not rely on Pack200; JDK 8 was the last release compressed with &#96;pack200&#96; at build time and uncompressed with &#96;unpack200&#96; at install time. In summary, a major consumer of Pack200 -- the JDK itself -- no longer needs it.</span><br><span class="line">    </span><br><span class="line">2.  Beyond the JDK, it was attractive to compress client applications, and especially applets, with Pack200. Some deployment technologies, such as Oracle&#39;s browser plug-in, would uncompress applet JARs automatically. However, the landscape for client applications has changed, and most browsers have dropped support for plug-ins. Consequently, a major class of consumers of Pack200 -- applets running in browsers -- are no longer a driver for including Pack200 in the JDK.</span><br><span class="line">    </span><br><span class="line">3.  Pack200 is a complex and elaborate technology. Its [file format](https:&#x2F;&#x2F;docs.oracle.com&#x2F;en&#x2F;java&#x2F;javase&#x2F;13&#x2F;docs&#x2F;specs&#x2F;pack-spec.html) is tightly coupled to the [class file format](https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;specs&#x2F;jvms&#x2F;se13&#x2F;html&#x2F;jvms-4.html#jvms-4.1) and the [JAR file format](https:&#x2F;&#x2F;docs.oracle.com&#x2F;en&#x2F;java&#x2F;javase&#x2F;13&#x2F;docs&#x2F;specs&#x2F;jar&#x2F;jar.html), both of which have evolved in ways unforeseen by JSR 200. (For example, [JEP 309](http:&#x2F;&#x2F;openjdk.java.net&#x2F;jeps&#x2F;309) added a new kind of constant pool entry to the class file format, and [JEP 238](http:&#x2F;&#x2F;openjdk.java.net&#x2F;jeps&#x2F;238) added versioning metadata to the JAR file format.) The implementation in the JDK is split between Java and native code, which makes it hard to maintain. The API in &#96;java.util.jar.Pack200&#96; was detrimental to the modularization of the Java SE Platform, leading to [the removal of four of its methods in Java SE 9](http:&#x2F;&#x2F;cr.openjdk.java.net&#x2F;~iris&#x2F;se&#x2F;9&#x2F;java-se-9-fr-spec&#x2F;#APIs-removed). Overall, the cost of maintaining Pack200 is significant, and outweighs the benefit of including it in Java SE and the JDK.</span><br></pre></td></tr></table></figure><p>一大坨论文一样的英文，这里抽取部分语句的关键点简单概括一下：</p><p>第一点：</p><ul><li>说白了就是有新人干活还有力气，老东西赶紧退休。过去网络带宽资源吃紧加上网速很慢，超过56k的jar包要下半天，压缩处理能在一定程度上<strong>治标</strong>。但是现代的网络环境下个几十K的东西几乎都是瞬间完成了，然后<strong>JDK9还引入了新的压缩方式</strong>（关键）。</li></ul><p>第二点：</p><ul><li>Pack200最后一点夹缝：作为浏览器开发插件压缩的生存空间也没了，现代浏览器插件有独有的开发方式，Java在这一块掀不起什么浪花。</li></ul><p>第三点：</p><ul><li><code>Pack200 is a complex and elaborate technology</code>。“Pack200是一项复杂而精细的技术”，我愿称之为高情商发言，低情商就是<strong>臃肿又难用</strong>。后面引经据典“批判了一番多么“精细”和“复杂”导致的问题。</li></ul><p>总结：<strong>网络下载速度的提升</strong>以及<strong>java9引入模块化系统</strong>之后<strong>不再依赖</strong>Pack200，因此这个版本将其移除掉。</p><h1 id="JDK11-其他内容"><a href="#JDK11-其他内容" class="headerlink" title="JDK11 其他内容"></a>JDK11 其他内容</h1><h2 id="Optional-增强"><a href="#Optional-增强" class="headerlink" title="Optional 增强"></a>Optional 增强</h2><p>新增了<code>empty()</code>方法来判断指定的 <code>Optional</code> 对象是否为空。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var op &#x3D; Optional.empty();</span><br><span class="line">System.out.println(op.isEmpty());&#x2F;&#x2F;判断指定的 Optional 对象是否为空</span><br></pre></td></tr></table></figure><h2 id="String-增强"><a href="#String-增强" class="headerlink" title="String 增强"></a>String 增强</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断字符串是否为空  </span></span><br><span class="line"><span class="string">" "</span>.isBlank();<span class="comment">//true  </span></span><br><span class="line"><span class="comment">//去除字符串首尾空格  </span></span><br><span class="line"><span class="string">" Java "</span>.strip();<span class="comment">// "Java"  </span></span><br><span class="line"><span class="comment">//去除字符串首部空格  </span></span><br><span class="line"><span class="string">" Java "</span>.stripLeading();   <span class="comment">// "Java "  </span></span><br><span class="line"><span class="comment">//去除字符串尾部空格  </span></span><br><span class="line"><span class="string">" Java "</span>.stripTrailing();  <span class="comment">// " Java"  </span></span><br><span class="line"><span class="comment">//重复字符串多少次  </span></span><br><span class="line"><span class="string">"Java"</span>.repeat(<span class="number">3</span>);             <span class="comment">// "JavaJavaJava"  </span></span><br><span class="line"><span class="comment">//返回由行终止符分隔的字符串集合。  </span></span><br><span class="line"><span class="string">"A\nB\nC"</span>.lines().count();    <span class="comment">// 3  </span></span><br><span class="line"><span class="string">"A\nB\nC"</span>.lines().collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h2 id="移除项"><a href="#移除项" class="headerlink" title="移除项"></a>移除项</h2><ul><li>移除了<code>com.sun.awt.AWTUtilities</code></li><li>移除了<code>sun.misc.Unsafe.defineClass</code></li><li>使用<code>java.lang.invoke.MethodHandles.Lookup.defineClass</code>来替代</li><li>移除了<code>Thread.destroy()</code>以及<code>Thread.stop(Throwable)</code>方法</li><li>移除了<code>sun.nio.ch.disableSystemWideOverlappingFileLockCheck</code>、<code>sun.locale.formatasdefault</code>属性</li><li>移除了<code>jdk.snmp</code>模块</li><li>移除了 <code>javafx</code> ，openjdk 估计是从java10版本就移除了，但是oracle jdk10还尚未移除javafx，而java11版本则oracle的jdk版本也移除了javafx。</li><li>移除了<strong>Java Mission Control</strong>，从JDK中移除之后，需要自己单独下载</li></ul><p>移除了这些<strong>Root Certificates</strong> ：</p><ul><li>Baltimore Cybertrust Code Signing CA</li><li>SECOM </li><li>AOL and Swisscom</li></ul><h2 id="废弃项"><a href="#废弃项" class="headerlink" title="废弃项"></a>废弃项</h2><ul><li><code>-XX+AggressiveOpts</code>选项</li><li><code>-XX:+UnlockCommercialFeatures</code></li><li><code>-XX:+LogCommercialFeatures</code>选项也不再需要</li></ul><h2 id="G1-垃圾收集器升级"><a href="#G1-垃圾收集器升级" class="headerlink" title="G1 垃圾收集器升级"></a>G1 垃圾收集器升级</h2><p>JDK11的G1垃圾收集齐相比于 JDK 8可以享受到：</p><ul><li>并行的 Full GC</li><li>快速的 CardTable 扫描</li><li>自适应的堆占用比例调整（IHOP）</li><li>在并发标记阶段的类型卸载<br>….等等</li></ul><p>这些都是针对 G1 的不断增强，串行 Full GC被常常诟病最终Oracle忍无可忍复用了CMS的并行GC代码给实现了（配置参数可以看出端倪，很多和CMS配置仅仅是换了个名字），最终是减少程序员的调优成本和调优时间。</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="17-个-JEP（JDK-Enhancement-Proposals，JDK-增强提案）"><a href="#17-个-JEP（JDK-Enhancement-Proposals，JDK-增强提案）" class="headerlink" title="17 个 JEP（JDK Enhancement Proposals，JDK 增强提案）"></a>17 个 JEP（JDK Enhancement Proposals，JDK 增强提案）</h2><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230311111312.png" alt=""></p><p>下面包含了这17个JEP的提案：</p><p>JEP 181: Nest-Based Access Control</p><p><strong>JEP 309: Dynamic Class-File Constants</strong></p><p>JEP 315: Improve Aarch64 Intrinsics</p><p><strong>JEP 318: Epsilon: A No-Op Garbage Collector</strong></p><p>JEP 320: Remove the Java EE and CORBA Modules</p><p>JEP 321: HTTP Client (Standard)</p><p><strong>JEP 323: Local-Variable Syntax for Lambda Parameters</strong></p><p>JEP 324: Key Agreement with Curve25519 and Curve448</p><p>JEP 327: Unicode 10</p><p><strong>JEP 328: Flight Recorder</strong></p><p>JEP 329: ChaCha20 and Poly1305 Cryptographic Algorithms</p><p>JEP 330: Launch Single-File Source-Code Programs</p><p>JEP 331: Low-Overhead Heap Profiling</p><p><strong>JEP 332: Transport Layer Security (TLS) 1.3</strong></p><p><strong>JEP 333: ZGC: A Scalable Low-Latency Garbage Collector (Experimental)</strong></p><p>JEP 335: Deprecate the Nashorn JavaScript Engine</p><p>JEP 336: Deprecate the Pack200 Tools and API</p><h3 id="Jshell（JDK9）"><a href="#Jshell（JDK9）" class="headerlink" title="Jshell（JDK9）"></a>Jshell（JDK9）</h3><p>和Go和Python这种自带Shell的语言进行对比，Java的Shell直到Java9才出现，Java9引入了jshell这个交互性工具，让Java也可以像脚本语言一样来运行，可以从控制台启动 jshell。</p><p>一个编程语言本该有的东西，这里就不多介绍了。Jshell比较适合刚刚入门Java语言的学习者使用。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>这篇文章把大部分JDK11新特性简单分析了一遍，如果有错误的论述欢迎指正。JDK的新版本特性还是非常有意思的，虽然不一定能在工作中用上，但是了解这些特性跟进时代是作为Java开发者的基本操守。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      JDK11
    
    </summary>
    
    
      <category term="Java" scheme="https://whitestore.top/categories/Java/"/>
    
    
      <category term="Java" scheme="https://whitestore.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Java】@ApiOperation vs @ApiResponse in Swagger</title>
    <link href="https://whitestore.top/2023/03/15/apioperate/"/>
    <id>https://whitestore.top/2023/03/15/apioperate/</id>
    <published>2023-03-15T07:00:09.000Z</published>
    <updated>2023-03-15T07:01:21.466Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFlbGR1bmcuY29tL3N3YWdnZXItYXBpb3BlcmF0aW9uLXZzLWFwaXJlc3BvbnNl" title="https://www.baeldung.com/swagger-apioperation-vs-apiresponse">https://www.baeldung.com/swagger-apioperation-vs-apiresponse<i class="fa fa-external-link"></i></span></p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>本文内容讨论的是 <em>@ApiOperation</em> 和 <em>@ApiResponse</em> 注解的优劣。</p><h1 id="介绍Swagger"><a href="#介绍Swagger" class="headerlink" title="介绍Swagger"></a>介绍Swagger</h1><p>一个RestFul最重要的是具备“自描述能力”，所谓的自描述能力是能在返回结果的同时，告知客户端调用下<br>一步的行为，Swagger在一定程度上封装和规范了这些操作。</p><p>什么是Swagger？</p><blockquote><p>Swagger represents a set of open-source tools built around OpenAPI Specification. It can help us design, build, document, and consume REST APIs.</p></blockquote><p>Swagger代表了一套围绕OpenAPI规范建立的开源工具。它可以帮助我们设计、构建、记录REST APIs接口。其中最为常用的注解便是 @ApiOperation 和 @ApiResponse。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/customers"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> CustomerService customerService;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">CustomerController</span><span class="params">(CustomerService customerService)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.customerService = customerService;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="meta">@GetMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> ResponseEntity&lt;CustomerResponse&gt; <span class="title">getCustomer</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> ResponseEntity.ok(customerService.getById(id));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面分别介绍这两个注解的使用，最后是进行对比。</p><a id="more"></a><h1 id="ApiOperation"><a href="#ApiOperation" class="headerlink" title="@ApiOperation"></a>@ApiOperation</h1><p>关键点：描述单独的一个操作和行为。通常用于单一的路径或者http请求方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation</span>(value = <span class="string">"Gets customer by ID"</span>, </span><br><span class="line">        response = CustomerResponse<span class="class">.<span class="keyword">class</span>, </span></span><br><span class="line"><span class="class">        <span class="title">notes</span> </span>= <span class="string">"Customer must exist"</span>)</span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;CustomerResponse&gt; <span class="title">getCustomer</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.ok(customerService.getById(id));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面介绍@ApiOperation的一些属性：</p><h2 id="value"><a href="#value" class="headerlink" title="value"></a>value</h2><p>value属性主要是描述接口的行为，注意参数大小不能超过120个字符。从长度限制来看要尽可能的简化注解的描述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation</span>(value = <span class="string">"Gets customer by ID"</span>)</span><br></pre></td></tr></table></figure><h2 id="notes"><a href="#notes" class="headerlink" title="notes"></a>notes</h2><p>个人认为把这个注解当成<code>comment</code>更为合适，notes和value的区别是可以填写的长度限制为text，意思是更为详细的叙述接口功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation</span>(value = <span class="string">"Gets customer by ID"</span>, notes = <span class="string">"Customer must exist"</span>)</span><br></pre></td></tr></table></figure><h2 id="response"><a href="#response" class="headerlink" title="response"></a>response</h2><p>@ApiOperation注解中定义的响应属性应该包含一般的响应类型。大部分情况下我们会把返回结果用统一的对象包装：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerResponse</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">   <span class="keyword">private</span> Long id;</span><br><span class="line">   <span class="keyword">private</span> String firstName;</span><br><span class="line">   <span class="keyword">private</span> String lastName;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>更为常见的是使用类似<code>AjaxDto</code>这样的对象封装响应Code，响应Msg和响应数据Data。</p></blockquote><p>在使用的过程中设置Class类，在Swagger文档中将会对应生成相关的对象以及</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation</span>(value = <span class="string">"Gets customer by ID"</span>,</span><br><span class="line">        response = CustomerResponse<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">        <span class="title">notes</span> </span>= <span class="string">"Customer must exist"</span>)</span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;CustomerResponse&gt; <span class="title">getCustomer</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.ok(customerService.getById(id));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><p>也就是响应code码，对应 <span class="exturl" data-url="aHR0cHM6Ly93d3cudzMub3JnL1Byb3RvY29scy9yZmMyNjE2L3JmYzI2MTYtc2VjMTAuaHRtbA==" title="https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">Http Status<i class="fa fa-external-link"></i></span></p><h1 id="ApiResponse"><a href="#ApiResponse" class="headerlink" title="@ApiResponse"></a>@ApiResponse</h1><p>@ApiResponse 注解主要用于描述接口的返回状态码以及对应的返回信息。虽然@ApiOperation注解描述了操作和一般的返回类型，但@ApiResponse注解描述了其余可能的状态码。</p><p>@ApiResponse注解的特点是<strong>方法注解优先于类注解</strong>。我们应该在@ApiResponses注解中使用@ApiResponse注解，无论我们有一个还是多个响应。</p><p>下面是正确的@ApiResponse 用法案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiResponses</span>(value = &#123;  </span><br><span class="line">        <span class="meta">@ApiResponse</span>(code = <span class="number">400</span>, message = <span class="string">"Invalid ID supplied"</span>),  </span><br><span class="line">        <span class="meta">@ApiResponse</span>(code = <span class="number">404</span>, message = <span class="string">"Customer not found"</span>)&#125;)  </span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/&#123;id&#125;"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;CustomerResponse&gt; <span class="title">getCustomer</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id) </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.ok(customerService.getById(id));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于特殊的状态码进行描述：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation</span>(value = <span class="string">"Gets customer by ID"</span>, notes = <span class="string">"Customer must exist"</span>)  </span><br><span class="line"><span class="meta">@ApiResponses</span>(value = &#123;  </span><br><span class="line">        <span class="meta">@ApiResponse</span>(code = <span class="number">200</span>, message = <span class="string">"OK"</span>, response = CustomerResponse<span class="class">.<span class="keyword">class</span>),  </span></span><br><span class="line"><span class="class">        @<span class="title">ApiResponse</span>(<span class="title">code</span> </span>= <span class="number">400</span>, message = <span class="string">"Invalid ID supplied"</span>),  </span><br><span class="line">        <span class="meta">@ApiResponse</span>(code = <span class="number">404</span>, message = <span class="string">"Customer not found"</span>),  </span><br><span class="line">        <span class="meta">@ApiResponse</span>(code = <span class="number">500</span>, message = <span class="string">"Internal server error"</span>, response = ErrorResponse<span class="class">.<span class="keyword">class</span>)&#125;)  </span></span><br><span class="line">@GetMapping("/&#123;id&#125;")  </span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;CustomerResponse&gt; <span class="title">getCustomer</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id) </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.ok(customerService.getById(id));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="code-和-message"><a href="#code-和-message" class="headerlink" title="code 和 message"></a>code 和 message</h2><p>与@ApiOperation注解中的code属性一样，它应该包含响应的HTTP状态代码。值得一提的是，我们不能用相同的代码属性定义一个以上的@ApiResponse。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiResponse</span>(code = <span class="number">400</span>, message = <span class="string">"Invalid ID supplied"</span>)</span><br></pre></td></tr></table></figure><h2 id="response-1"><a href="#response-1" class="headerlink" title="response"></a>response</h2><p>response可以为特殊的状态码指定对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErrorResponse</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String error;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次，让我们为内部服务器错误添加一个新的@ApiResponse。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiResponses</span>(value = &#123;</span><br><span class="line">        <span class="meta">@ApiResponse</span>(code = <span class="number">400</span>, message = <span class="string">"Invalid ID supplied"</span>),</span><br><span class="line">        <span class="meta">@ApiResponse</span>(code = <span class="number">404</span>, message = <span class="string">"Customer not found"</span>),</span><br><span class="line">        <span class="meta">@ApiResponse</span>(code = <span class="number">500</span>, message = <span class="string">"Internal server error"</span>, response = ErrorResponse<span class="class">.<span class="keyword">class</span>)&#125;)</span></span><br><span class="line">@GetMapping("/&#123;id&#125;")</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;CustomerResponse&gt; <span class="title">getCustomer</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.ok(customerService.getById(id));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ApiOperation-和-ApiResponse-区别"><a href="#ApiOperation-和-ApiResponse-区别" class="headerlink" title="@ApiOperation 和 @ApiResponse 区别"></a>@ApiOperation 和 @ApiResponse 区别</h1><table><thead><tr><th align="center">@ApiOperation</th><th align="center">@ApiResponse</th></tr></thead><tbody><tr><td align="center">通用用于描述一个操作</td><td align="center">用于描述操作的可能的响应</td></tr><tr><td align="center">通常用于成功的请求</td><td align="center">可以用于成功或者失败的各种请求</td></tr><tr><td align="center">只能用在方法级别</td><td align="center">可以用于类或者方法级别</td></tr><tr><td align="center">可以直接使用</td><td align="center">只能在@ApiResponses注解中使用。</td></tr><tr><td align="center">默认code为200</td><td align="center">没有默认值</td></tr></tbody></table><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      Java的注解使用
    
    </summary>
    
    
      <category term="Java" scheme="https://whitestore.top/categories/Java/"/>
    
    
      <category term="Java" scheme="https://whitestore.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Java】Best coding practices every java</title>
    <link href="https://whitestore.top/2023/03/15/bestjavacoding/"/>
    <id>https://whitestore.top/2023/03/15/bestjavacoding/</id>
    <published>2023-03-15T06:55:58.000Z</published>
    <updated>2023-03-15T06:58:01.118Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><p><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BhYmhpc2hla3NpbmdoamF2YS9iZXN0LWNvZGluZy1wcmFjdGljZXMtZXZlcnktamF2YS1kZXZlbG9wZXItc2hvdWxkLWZvbGxvdy03Yjc3NTI3YTcwNDgjaWRfdG9rZW49ZXlKaGJHY2lPaUpTVXpJMU5pSXNJbXRwWkNJNklqSTFOV05qWVRabFl6STRNVEEyTURKa09EQmlaV000T1dVME5UWmpORFE1TldRM05ERTRZbUlpTENKMGVYQWlPaUpLVjFRaWZRLmV5SnBjM01pT2lKb2RIUndjem92TDJGalkyOTFiblJ6TG1kdmIyZHNaUzVqYjIwaUxDSnVZbVlpT2pFMk56Z3pOekEzTkRVc0ltRjFaQ0k2SWpJeE5qSTVOakF6TlRnek5DMXJNV3MyY1dVd05qQnpNblJ3TW1FeWFtRnROR3hxWkdOdGN6QXdjM1IwWnk1aGNIQnpMbWR2YjJkc1pYVnpaWEpqYjI1MFpXNTBMbU52YlNJc0luTjFZaUk2SWpFd01qVXpOakF3TmpZMU1UQTVORFF4TnpNNE15SXNJbVZ0WVdsc0lqb2llbmhrYzJJMk5qWkFaMjFoYVd3dVkyOXRJaXdpWlcxaGFXeGZkbVZ5YVdacFpXUWlPblJ5ZFdVc0ltRjZjQ0k2SWpJeE5qSTVOakF6TlRnek5DMXJNV3MyY1dVd05qQnpNblJ3TW1FeWFtRnROR3hxWkdOdGN6QXdjM1IwWnk1aGNIQnpMbWR2YjJkc1pYVnpaWEpqYjI1MFpXNTBMbU52YlNJc0ltNWhiV1VpT2lKQmJHVjRJSGhoYm1SbGNpSXNJbkJwWTNSMWNtVWlPaUpvZEhSd2N6b3ZMMnhvTXk1bmIyOW5iR1YxYzJWeVkyOXVkR1Z1ZEM1amIyMHZZUzlCUjA1dGVYaFpaR0ZqVkhrM05rcFJOVEJNVDJWRFJXTlpSVWg2ZHpsc2RVUnBSblpmVmpaVE1XVm9hajF6T1RZdFl5SXNJbWRwZG1WdVgyNWhiV1VpT2lKQmJHVjRJaXdpWm1GdGFXeDVYMjVoYldVaU9pSjRZVzVrWlhJaUxDSnBZWFFpT2pFMk56Z3pOekV3TkRVc0ltVjRjQ0k2TVRZM09ETTNORFkwTlN3aWFuUnBJam9pTTJJNU4ySTBPRFEzWXpkbU9UUXhORGcyTkdZeU4yRXpOVGhoWTJRMU1ESTNZall6WVRReE1pSjkuSTMzRnlfYjBlUUFDSTRLV01qejBSc1d2YUZoMVgzLUk2MjU4dW92Mk82QjF4NHZxbjNQV0xBLU5kaXlUNzh0b0pVTklZR0oyUUxSenEwd3ozMzZFNHRfbmhyZmZ5N3FwN2E0S1VPS3FzOEl1UExEd2dXS3RxQXBOU2tweTlUV0I2MXJobFo4Q25yN3NnYlpvRzJ4dXhxMERqSlVtVmFZWi0tR1VVRmZ0Vkl6VHY5RHlMRVZORzcxeEZoWDlTNzNxWFNhSnR5YmJwMUpwam1NNTI2REFmLTYxS01yc29DQl9ZWjlETjJENFc0QzBCZEFNWlEyY1duWnZ2Rzd5SE1BSDBSNTFsN3huLW5VTWxNbktaTjEyd2ItVlpDU2J3ODZkNC1rS2dycjliMThkUDdSM0pEbE5oVW8zQ0VMNWx3WnBQV2RNajNnSHpSdzBaQnI5NEhXTFNn" title="https://medium.com/@abhisheksinghjava/best-coding-practices-every-java-developer-should-follow-7b77527a7048#id_token=eyJhbGciOiJSUzI1NiIsImtpZCI6IjI1NWNjYTZlYzI4MTA2MDJkODBiZWM4OWU0NTZjNDQ5NWQ3NDE4YmIiLCJ0eXAiOiJKV1QifQ.eyJpc3MiOiJodHRwczovL2FjY291bnRzLmdvb2dsZS5jb20iLCJuYmYiOjE2NzgzNzA3NDUsImF1ZCI6IjIxNjI5NjAzNTgzNC1rMWs2cWUwNjBzMnRwMmEyamFtNGxqZGNtczAwc3R0Zy5hcHBzLmdvb2dsZXVzZXJjb250ZW50LmNvbSIsInN1YiI6IjEwMjUzNjAwNjY1MTA5NDQxNzM4MyIsImVtYWlsIjoienhkc2I2NjZAZ21haWwuY29tIiwiZW1haWxfdmVyaWZpZWQiOnRydWUsImF6cCI6IjIxNjI5NjAzNTgzNC1rMWs2cWUwNjBzMnRwMmEyamFtNGxqZGNtczAwc3R0Zy5hcHBzLmdvb2dsZXVzZXJjb250ZW50LmNvbSIsIm5hbWUiOiJBbGV4IHhhbmRlciIsInBpY3R1cmUiOiJodHRwczovL2xoMy5nb29nbGV1c2VyY29udGVudC5jb20vYS9BR05teXhZZGFjVHk3NkpRNTBMT2VDRWNZRUh6dzlsdURpRnZfVjZTMWVoaj1zOTYtYyIsImdpdmVuX25hbWUiOiJBbGV4IiwiZmFtaWx5X25hbWUiOiJ4YW5kZXIiLCJpYXQiOjE2NzgzNzEwNDUsImV4cCI6MTY3ODM3NDY0NSwianRpIjoiM2I5N2I0ODQ3YzdmOTQxNDg2NGYyN2EzNThhY2Q1MDI3YjYzYTQxMiJ9.I33Fy_b0eQACI4KWMjz0RsWvaFh1X3-I6258uov2O6B1x4vqn3PWLA-NdiyT78toJUNIYGJ2QLRzq0wz336E4t_nhrffy7qp7a4KUOKqs8IuPLDwgWKtqApNSkpy9TWB61rhlZ8Cnr7sgbZoG2xuxq0DjJUmVaYZ--GUUFftVIzTv9DyLEVNG71xFhX9S73qXSaJtybbp1JpjmM526DAf-61KMrsoCB_YZ9DN2D4W4C0BdAMZQ2cWnZvvG7yHMAH0R51l7xn-nUMlMnKZN12wb-VZCSbw86d4-kKgrr9b18dP7R3JDlNhUo3CEL5lwZpPWdMj3gHzRw0ZBr94HWLSg">Best coding practices every java developer should follow<i class="fa fa-external-link"></i></span></p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#引言">引言</a></li><li><a href="#4-尽可能让变量私有化">4. 尽可能让变量私有化</a></li><li><a href="#6-警惕冗余初始化">6. 警惕冗余初始化</a></li><li><a href="#5-Stringbuilder替换字符串拼接争议">5. Stringbuilder替换字符串拼接【争议】</a></li><li><a href="#15-dry和kiss">15. dry和kiss</a></li><li><a href="#14-Solid">14. Solid</a></li><li><a href="#7-尽可能使用增强for循环或者foreach">7. 尽可能使用增强for循环或者foreach</a></li><li><a href="#13-日志打印规则">13. 日志打印规则</a></li><li><a href="#12-Hardcoding硬编码">12. Hardcoding硬编码</a></li><li><a href="#11-注释">11. 注释</a></li><li><a href="#10-避免创建不必要对象">10. 避免创建不必要对象</a></li><li><a href="#9-返回空集合而不是null">9. 返回空集合而不是null</a></li><li><a href="#8-精度选择">8. 精度选择</a></li><li><a href="#1-项目结构">1. 项目结构</a></li><li><a href="#2-遵循命名规范">2. 遵循命名规范</a></li><li><a href="#3-不要吞异常">3. 不要吞异常</a></li><li><a href="#16-使用枚举替代静态常量建议">16. 使用枚举替代静态常量【建议】</a></li><li><a href="#17-按作用域划分成员变量">17. 按作用域划分成员变量</a></li><li><a href="#18-在数字字段中使用下划线建议">18. 在数字字段中使用下划线【建议】</a></li><li><a href="#总结">总结</a></li><li><a href="#参考">参考</a></li></ul><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>把标题翻译成中文在国内也是一个老生常谈的问题：编程习惯和编码规范。</p><p>这篇文章大部分观点和国内的规范习惯类似，令我好奇的是外国人是如何理解这些内容的？</p><p>注意本文的Tips排序是打乱的，个人把感兴趣放到了前面来了。这篇文章的评论区非常精彩，这里一并整合了评论区的读者观点。</p><p>不管是学习还是了解老外的思考方式，或是在评论区当中看读者的讨论和纠正错误，阅读本文都是值得推荐的。</p><p>抱着半信半疑的态度学习这些内容，你会得到比单纯的了解和接受建议更多的收获。</p><a id="more"></a><h1 id="4-尽可能让变量私有化"><a href="#4-尽可能让变量私有化" class="headerlink" title="4. 尽可能让变量私有化"></a>4. 尽可能让变量私有化</h1><p>如果变量不需要意对外访问，那就建议使用私有描述对于参数进行描述。</p><p>评论区的读者对于这一个小节做了补充：</p><ul><li>如果是dto并且是final的，拥有公用数据的时候<strong>可以不私有化</strong>.。</li><li>比大量的setter更好建议是更合理的利用设计模式构建对象（比如建造者），或者利用委托第三方对象生产合适的对象（静态工厂替代构造器）。</li><li>尽可能让对象不可变。</li></ul><h1 id="6-警惕冗余初始化"><a href="#6-警惕冗余初始化" class="headerlink" title="6. 警惕冗余初始化"></a>6. 警惕冗余初始化</h1><blockquote><p>Therefore, a java best practice is to be aware of the default initialization values of member variables and avoid initializing the variables explicitly.</p></blockquote><p>Java 最佳实践是了解成员变量的默认初始化值并避免显式初始化变量，Java语言很多变量存在默认值，在自己编写初始化的时候不建议使用Java的默认值。</p><p>另一方面，有时候可以利用Java的初始化做数据库字段的优化，比如开关状态建议把0设置为开放1设置为关闭。</p><p>下面的代码的的对象初始化代码是毫无意义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String name = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isGenius = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Although it is very common practice, it is not encouraged to initialize member variables with the values: like 0, false and null. These values are already the default initialization values of member variables in Java. Therefore, a java best practice is to be aware of the default initialization values of member variables and avoid initializing the variables explicitly.</p></blockquote><p>尽管这是非常常见的做法，但不鼓励使用以下值初始化成员变量：如 0、false 和 null。这些值已经是 Java 中成员变量的默认初始化值。因此，Java 最佳实践是了解成员变量的缺省初始化值，并避免显式初始化变量。</p><p>See more here: <span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZWphdmEubmV0L2phdmEtY29yZS90aGUtamF2YS1sYW5ndWFnZS9qYXZhLWRlZmF1bHQtaW5pdGlhbGl6YXRpb24tb2YtaW5zdGFuY2UtdmFyaWFibGVzLWFuZC1pbml0aWFsaXphdGlvbi1ibG9ja3M=" title="https://www.codejava.net/java-core/the-java-language/java-default-initialization-of-instance-variables-and-initialization-blocks">Java default Initialization of Instance Variables and Initialization Blocks<i class="fa fa-external-link"></i></span>。</p><h1 id="5-Stringbuilder-替换字符串拼接【争议】"><a href="#5-Stringbuilder-替换字符串拼接【争议】" class="headerlink" title="5. Stringbuilder 替换字符串拼接【争议】"></a>5. Stringbuilder 替换字符串拼接【争议】</h1><p>实际上多数情况下“大可不必”，只有for循环的情况才考虑是否使用Stringbuilder替换。日常情况下字符拼接操作是完全没有问问题的，javac编译之后会把字符串自动用StringBuilder替换，真正应该手动创建该对象的场景是在<strong>for循环当中的大量的字符串拼接</strong>，内部会每次迭代新建Stringbuilder。</p><p>随着JDK版本的升级，到<strong>JDK9</strong>版本for循环新建StringBuilder的情况已经被改善了（但个人未从OpenJDK中找到对应源码验证）。</p><p>JDK13 从Python那边把多行文本的语法搬过来了，定义多行文本可以类似下面这样：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String htmlContent = “““&lt;html&gt;</span><br><span class="line">                           &lt;head&gt;</span><br><span class="line">                           &lt;/head&gt;</span><br><span class="line">                           &lt;body&gt;</span><br><span class="line">                              &lt;p&gt;Hello world!&lt;/p&gt;</span><br><span class="line">                           &lt;/body&gt;</span><br><span class="line">                         &lt;/html&gt;""";</span><br></pre></td></tr></table></figure><p>最后需要注意的是使用<strong>Stringbuilder</strong>，仅仅应该用在多线程循环操作字符串当中，如果在同步方法里面效率会非常低并且很慢。</p><p>介绍</p><blockquote><p>As a general rule, optimize at an architectural level, and write code for readability. Later on it’s easier to optimize a neat function, than to look for bugs in an optimized one.</p></blockquote><p>上面意思大致是说通用规则是优先写出具备高可读性的代码，然后再去进行优化这些简单的可优化点，这比在优化代码找错误要简单很多。</p><h1 id="15-dry和kiss"><a href="#15-dry和kiss" class="headerlink" title="15. dry和kiss"></a>15. dry和kiss</h1><blockquote><p>DRY stands for “Don’s Repeat Yourself</p></blockquote><p>如果代码可以公用就尽量公用，不要复制粘贴代码。</p><blockquote><p>kiss：KISS stands for “Keep It Simple, Stupid”.</p></blockquote><p>KISS就是保持简单，愚蠢。这个愚蠢指的是方法最好只知道干一件事情。这两点和Unix最初的设计的理念是一样的，简单好用即是美。</p><h1 id="14-Solid"><a href="#14-Solid" class="headerlink" title="14. Solid"></a>14. Solid</h1><p><strong>Single Responsibility Principle</strong> 单一职责：每个类和接口有明确目标。</p><p><strong>Open-Closed Principle</strong> 开闭原则：开放扩展，封闭修改。</p><p><strong>Liskov Substitution Principle</strong> 里式替代：尽可能让代码多态。</p><p><strong>Interface Segregation Principle</strong> 接口隔离：实现接口替代类继承。</p><p><strong>Dependency Inversion Principle</strong> 依赖倒转原则：依赖抽象而不是依赖实现。</p><h1 id="7-尽可能使用增强for循环或者foreach"><a href="#7-尽可能使用增强for循环或者foreach" class="headerlink" title="7. 尽可能使用增强for循环或者foreach"></a>7. 尽可能使用增强for循环或者foreach</h1><p>建议使用增强for循环（JDK5）和JDK8的foreach，当然最好的建议是活学活用stream的API。为什么会有这样的建议？好像for-index也不是啥坏写法。</p><blockquote><p>It’s because the index variable is error-prone, as we may alter it incidentally in the loop’s body, or we may starts the index from 1 instead of 0.</p></blockquote><p>这是因为索引变量容易出错，因为我们可能会在循环的主体中偶然改变它，或者我们可能从1而不是0开始索引。下面是Stream API带来便利的简单例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">findSmallesPositiveNumber</span><span class="params">(List&lt;Integer&gt; numbers)</span> </span>&#123;</span><br><span class="line">   Integer smallestPositiveNumber= <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">for</span> (Integer number: numbers) &#123;</span><br><span class="line">      <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (smallestPositiveNumber == <span class="keyword">null</span></span><br><span class="line">            || number &lt; smallestPositiveNumber) &#123;</span><br><span class="line">         smallestPositiveNumber = number;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> smallestPositiveNumber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Stream APi精简之后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;Integer&gt; <span class="title">findSmallesPositiveNumber</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      List&lt;Integer&gt; numbers)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> numbers.stream()</span><br><span class="line">      .filter(number -&gt; number &gt; <span class="number">0</span>)</span><br><span class="line">      .min(Integer::compare);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="13-日志打印规则"><a href="#13-日志打印规则" class="headerlink" title="13. 日志打印规则"></a>13. 日志打印规则</h1><p>作者的下面几条规则<strong>有待商榷</strong>，我个人建议是<strong>避免</strong>下面的做法：</p><blockquote><p>Developer should add logger on method entry and exit.</p></blockquote><p>在进出重要方法打印入参和出参。</p><blockquote><p>谨慎使用，建议涉及金额的操作情况打印。</p></blockquote><blockquote><p>Developer should add logger in “if” and “else” case to track which condition is true in case of any error.</p></blockquote><p>在if和else的条件判断处打印参数。</p><blockquote><p>Developer should also log exception to track the issue</p></blockquote><p>对于异常信息必须打印。</p><p>更为合理的做法是像下面这样：</p><blockquote><p>Definitely don’t log every if-else statement!</p></blockquote><p>不要在if/else分支中打印，更为合理的建议是记录响应以及错误。</p><blockquote><p><strong>Don’t log every method entry and exit!</strong></p></blockquote><p>不要在每个方法的入参和出参打印。当然这并不是铁律，比如三方接口调用就必须要在“入口”和“出口”中打印以便快速定位问题<del>和甩锅</del>。</p><blockquote><p>**Log exceptions that are unexpected. **</p></blockquote><p>记录“意外”的异常。比如多线程有可能的interrupt处理，文件读写有可能的IO异常。</p><p>从褒义和贬义两个层面看，日志都是非常具备“价值”的，好的日志可以帮你快速定位问题，不好的日志就像是垃圾一样迅速占用服务器的磁盘。只有非常核心的日志才需要跟踪每一步的行为，绝大多数情况下日志只需要在影响业务的位置进行打印。在打印日志段时候多思考一下<strong>日志等级</strong>的选择，这意味着你生产能否快速定位问题。</p><h1 id="12-Hardcoding硬编码"><a href="#12-Hardcoding硬编码" class="headerlink" title="12. Hardcoding硬编码"></a>12. Hardcoding硬编码</h1><p>硬编码回会导致程序难以理解。使用硬编码会增加理解难度，通常使用枚举替代是不错建议。根据dry的原则，在定义硬编码的时候，如果魔法值在JDK中存在类似定义或者存在现实意义，应该果断通过下面的方式进行纠正，比如下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> storeClosureDay = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><p>应该被替换为下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SUNDAY = <span class="number">7</span>;  </span><br><span class="line">[…]  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> storeClosureDay = SUNDAY;</span><br></pre></td></tr></table></figure><p><strong>不要</strong>这样使用，更为合适的处理方式是使用<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlLzgvZG9jcy9hcGkvamF2YS90aW1lL0RheU9mV2Vlay5odG1s" title="https://docs.oracle.com/javase/8/docs/api/java/time/DayOfWeek.html">DayOfWeek<i class="fa fa-external-link"></i></span> 的API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> DayOfWeek storeClosureDay = DayOfWeek.SUNDAY;</span><br></pre></td></tr></table></figure><p>避免硬编码是非常好的编程习惯，更好的习惯是使用易懂的硬编码。</p><h1 id="11-注释"><a href="#11-注释" class="headerlink" title="11. 注释"></a>11. 注释</h1><p>关键：<strong>注释只有在可读性较差并且需要注释描述关键意图的时候才使用</strong>。</p><blockquote><p>As your code will be read by various people with varying knowledge of Java, Proper comments should be used to give overviews of your code and provide additional information that cannot be perceived from the code itself. Comments are supposed to describe the working of your code to be read by Quality assurance engineer, reviewer, or maintenance staff .</p></blockquote><p>由于代码将被具有不同 Java 知识的各种人阅读，因此应该使用适当的注释来概述代码，并提供无法从代码本身感知的其他信息。注释应该描述代码的工作方式，以供质量保证工程师、审阅者或维护人员阅读。</p><p>注释关键点应该具备<strong>可读性</strong>，有时候没有任何注释的代码确实让人痛苦，更可怕的是因为代码更新但是注释不更新，这样的事情也时有发生=-=。最好的注释应该是代码本身会告知作者意图。</p><blockquote><p>PS：个人看过的没啥注释也能完全看懂，并且看完觉得写的非常美的代码目前只有Redission和Spring。</p></blockquote><h1 id="10-避免创建不必要对象"><a href="#10-避免创建不必要对象" class="headerlink" title="10. 避免创建不必要对象"></a>10. 避免创建不必要对象</h1><p>对象创建是最消耗内存的操作之一，这就是为什么最好的 Java 实践是避免创建任何不必要的对象，并且只应在需要时创建它们。</p><h1 id="9-返回空集合而不是null"><a href="#9-返回空集合而不是null" class="headerlink" title="9. 返回空集合而不是null"></a>9. 返回空集合而不是null</h1><blockquote><p>NPE is the most frequent exception in production with absolute leadership, do not give it a chance.</p></blockquote><p>更进一步说是让整个系统不要出现空指针异常，不应该因为项目代码妥协老旧的编程风格。一定不要让空指针有可乘之机。除了返回空集合以外，还可以利用Optional的工具类包装有可能为Null的对象，显式的告诉调用者对象有可能为Null。</p><blockquote><p>An empty collection might have a different meaning than no collection at all.&#x20;</p></blockquote><p>有时候null 也可能是“有意义”的，使用的时候也需要考虑具体情况，当然返回空集合肯定是没有任何问题的。</p><h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p>空集合相关的轮子在Collections可以找到答案，但是需要注意需要合理使用，JDK5之后出现了emptyXXX等集合类，但是这些类“暗藏杀机”，因为它们的效果和<strong>List.subList()</strong> 一样是<strong>immutable</strong> 的。</p><p>虽然JDK的工具类可以减少不必要的对象创建，但是假设接收方需要在收到空集合之后却还要往里面设置数据，这时候毫无疑问就会抛异常了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Returns an empty list (immutable).  This list is serializable.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;This example illustrates the type-safe way to obtain an empty list:</span></span><br><span class="line"><span class="comment">  * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">  *     List&amp;lt;String&amp;gt; s = Collections.emptyList();</span></span><br><span class="line"><span class="comment">  * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@implNote</span></span></span><br><span class="line"><span class="comment">  * Implementations of this method need not create a separate &lt;tt&gt;List&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">  * object for each call.   Using this method is likely to have comparable</span></span><br><span class="line"><span class="comment">  * cost to using the like-named field.  (Unlike this method, the field does</span></span><br><span class="line"><span class="comment">  * not provide type safety.)</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> &lt;T&gt; type of elements, if there were any, in the list</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> an empty immutable list</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span> #EMPTY_LIST</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">emptyList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (List&lt;T&gt;) EMPTY_LIST;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>我认为<code>emptyList()</code>更为合理的方法名称是 <code>immutableEmptyList()</code> 和 <code>mutableEmptyList()</code>，当然<code>mutableEmptyList()</code>就是new新的<code>ArrayList()</code>这样的方法，看起来是毫无意义的，也许JDK设计的时候也是考虑这种情况？</p><h1 id="8-精度选择"><a href="#8-精度选择" class="headerlink" title="8. 精度选择"></a>8. 精度选择</h1><blockquote><p>Most processors take almost same time in processing the operations on float and double but double offers way more precision then float that is why it is best practice to use double when precision is important otherwise you can go with float as it requires half space than double.。</p></blockquote><p>大型处理器在处理double和float的时候计算速度是类似的。但是在Java中大部分情况只要是涉及浮点数计算都是闭着眼睛用BigDecimal。如果精度很重要直接无脑使用BigDecimal，double和float都会骗人。</p><blockquote><p>When precision is important, use BigDecimal. Double and Float aren’t accurate. They will betray you when you least expect it. 1 + 1 can be 1.99999999999.</p></blockquote><p>当精度很重要时请使用BigDecimal，Double和Float并不精确。它们会在你最不期望的时候背叛你。1+1可能是1.99999999999。</p><h1 id="1-项目结构"><a href="#1-项目结构" class="headerlink" title="1. 项目结构"></a>1. 项目结构</h1><p>有点过于基础了。下面是Maven的经典结构，如果是Maven新手可以看看项目的基本布局</p><ul><li><em>src/main/java</em>: <strong>For source files</strong></li><li><em>src/main/resources</em>: <strong>For resource files, like properties</strong></li><li><em>src/test/java</em>: <strong>For test source files</strong></li><li><em>src/test/resources</em>: <strong>For test resource files, like properties</strong></li></ul><h1 id="2-遵循命名规范"><a href="#2-遵循命名规范" class="headerlink" title="2. 遵循命名规范"></a>2. 遵循命名规范</h1><p>没啥好讲的，程序员的基础素质。最好的命名规范不是参考某一个标准，而是能统一风格布局代码。</p><h1 id="3-不要吞异常"><a href="#3-不要吞异常" class="headerlink" title="3. 不要吞异常"></a>3. 不要吞异常</h1><p>在异常处理时在 catch 块中编写适当且有意义的消息是精英 java 开发人员首选的 java 最佳实践。<strong>新手常常会把异常捕获之后不做任何处理，吞异常是非常危险的行为</strong>。</p><p>得益于IDE的帮助，catch之后不打印任何信息的情况不是很多见，但是打印堆栈其实也是非常消耗资源的操作，同时因为是打印在控制台，如果不调用日志保存关键信息也有可能导致关键信息丢失。</p><h1 id="16-使用枚举替代静态常量【建议】"><a href="#16-使用枚举替代静态常量【建议】" class="headerlink" title="16. 使用枚举替代静态常量【建议】"></a>16. 使用枚举替代静态常量【建议】</h1><p>在Java推出枚举之前，定义一个常量基本只能使用下面的接口方式。在很多优秀框架的最早期版本中经常能看到这样的写法，并且到现在使用这种写法的不在少数 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RED = <span class="number">0xff0000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BLACK = <span class="number">0x000000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WHITE = <span class="number">0xffffff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>It’s because the purpose of interfaces is for inheritance and polymorphism, not for static stuffs like that. So the best practice recommends us to use an enum instead.&#x20;</p></blockquote><p>这是因为接口的目的是用于继承和多态性，而不是用于类似的静态东西。所以最佳实践建议我们使用枚举来代替。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Color &#123;</span><br><span class="line"> </span><br><span class="line">    BLACK(<span class="number">0x000000</span>),</span><br><span class="line">    WHITE(<span class="number">0xffffff</span>),</span><br><span class="line">    RED(<span class="number">0xff0000</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line"> </span><br><span class="line">    Color(<span class="keyword">int</span> code) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用枚举和静态常量的对比：</p><ul><li>枚举更具备描述性</li><li>Keep It Simple, Stupid。接口可以用于继承和多态，枚举能干的事情基本是常量定义。</li><li>接口的静态常量往往有其他的用途。</li></ul><blockquote><p>很少有人会在枚举设计复杂的逻辑，因为枚举的可扩展性很差并且理解和学习成本较高</p></blockquote><h1 id="17-按作用域划分成员变量"><a href="#17-按作用域划分成员变量" class="headerlink" title="17. 按作用域划分成员变量"></a>17. 按作用域划分成员变量</h1><blockquote><p>The best practice to organize member variables of a class by their scopes from most restrictive to least restrictive.&#x20;</p></blockquote><p>最好的做法是按其作用域从最严格到最不严格来组织一个类的成员变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> List&lt;Student&gt; listStudents;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> numberOfStudents;</span><br><span class="line">    <span class="keyword">private</span> String errorMessage;</span><br><span class="line">    <span class="keyword">float</span> rowHeight;</span><br><span class="line">    <span class="keyword">float</span> columnWidth;</span><br><span class="line">    <span class="keyword">protected</span> String[] columnNames;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numberOfRows;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numberOfColumns;</span><br><span class="line">    <span class="keyword">public</span> String title;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的成员变量定义眼花缭乱，通过作用域划分如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String errorMessage;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numberOfColumns;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numberOfRows;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">float</span> columnWidth;</span><br><span class="line">    <span class="keyword">float</span> rowHeight;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">protected</span> String[] columnNames;</span><br><span class="line">    <span class="keyword">protected</span> List&lt;Student&gt; listStudents;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> numberOfStudents;</span><br><span class="line">    <span class="keyword">public</span> String title;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="18-在数字字段中使用下划线【建议】"><a href="#18-在数字字段中使用下划线【建议】" class="headerlink" title="18. 在数字字段中使用下划线【建议】"></a>18. 在数字字段中使用下划线【建议】</h1><p>来自Java 7的小更新可以帮助我们把冗长的数字字段写得更易读。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> maxUploadSize = <span class="number">20971520</span>;</span><br><span class="line"><span class="keyword">long</span> accountBalance = <span class="number">1000000000000L</span>;</span><br><span class="line"><span class="keyword">float</span> pi = <span class="number">3.141592653589F</span>;</span><br></pre></td></tr></table></figure><p>和下面的代码作比较：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> maxUploadSize = <span class="number">20_971_520</span>;</span><br><span class="line"><span class="keyword">long</span> accountBalance = <span class="number">1_000_000_000_000L</span>;</span><br><span class="line"><span class="keyword">float</span> pi = <span class="number">3.141_592_653_589F</span>。</span><br></pre></td></tr></table></figure><p>哪一个更易懂？记得在数字字面中使用下划线，以提高代码的可读性。</p><blockquote><p><del>个人：尴尬，学了这么多年Java居然不知道有这种写法…..</del></p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这里罗列一下存在争议以及印象比较深的部分：</p><ul><li>StringBuilder替换字符串拼接。如果单纯拼接几个变量或者方法的结果，”+”号是完全没有问题的。<ul><li>虽然JDK 9 对于每次for循环new StringBuilder的BUG做了修复，但国内广泛使用JDK8的场景下依然需要避免for循环大量的字符串拼接。</li><li>这种优化不是关键，请更加关注合理的架构设计，因为这一点性能损耗对于现代处理器影响真的不大。</li><li>如果不需要考虑多线程的情况，更建议使用StringBuffer。</li></ul></li><li>精度选择，实际上不管有没有精度要求，碰到需要小数的运算建议使用BigDecimal，因为double和float的数学运算真的很容易出问题。</li><li>注释<ul><li>训练写出易懂的代码而不是易懂的注释</li><li>注释应该遵从KISS。“愚蠢”的代码最好理解。</li></ul></li><li>在大型的数字参数值中使用下划线，这是一个很容易忽略的Java小技巧，对于和金额有关的处理，这种写法非常有帮助。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>另一位读者：<span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BsYWp0aGFiYWxhenMvYmVzdC1jb2RpbmctcHJhY3RpY2VzLWV2ZXJ5LWphdmEtZGV2ZWxvcGVyLXNob3VsZC1mb2xsb3ctNDVkZmJiYzk3NzRm" title="https://medium.com/@lajthabalazs/best-coding-practices-every-java-developer-should-follow-45dfbbc9774f">Best coding practices every Java developer should follow?<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZWphdmEubmV0L2NvZGluZy8xMC1qYXZhLWNvcmUtYmVzdC1wcmFjdGljZXMtZXZlcnktamF2YS1wcm9ncmFtbWVyLXNob3VsZC1rbm93I05hbWluZ0NvbnZlbnRpb24=" title="https://www.codejava.net/coding/10-java-core-best-practices-every-java-programmer-should-know#NamingConvention">10 Java Core Best Practices Every Java Programmer Should Know<i class="fa fa-external-link"></i></span></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      java规范案例
    
    </summary>
    
    
      <category term="Java" scheme="https://whitestore.top/categories/Java/"/>
    
    
      <category term="Java" scheme="https://whitestore.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】How to Use the Stdin, Stderr, and Stdout Streams in Bash</title>
    <link href="https://whitestore.top/2023/03/15/stdinouterr/"/>
    <id>https://whitestore.top/2023/03/15/stdinouterr/</id>
    <published>2023-03-15T06:49:31.000Z</published>
    <updated>2023-03-15T06:50:44.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="How-to-Use-the-Stdin-Stderr-and-Stdout-Streams-in-Bash"><a href="#How-to-Use-the-Stdin-Stderr-and-Stdout-Streams-in-Bash" class="headerlink" title="How to Use the Stdin, Stderr, and Stdout Streams in Bash"></a>How to Use the Stdin, Stderr, and Stdout Streams in Bash</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#原文">原文</a></li><li><a href="#引言">引言</a><ul><li><a href="#Redirection-Operators-of-Stdin-Stdout-and-Stderr">Redirection Operators of Stdin, Stdout, and Stderr</a></li></ul></li><li><a href="#Uses-of-Stdin-Stdout-and-Stderr">Uses of Stdin, Stdout, and Stderr</a></li><li><a href="#Example-1-Use-of-Stdin">Example 1: Use of Stdin</a><ul><li><a href="#-等操作符使用">&gt;、&gt;&gt;、&lt; 等操作符使用</a></li></ul></li><li><a href="#Example-2-Use-of-Stdout">Example 2: Use of Stdout</a><ul><li><a href="#pipe--管道符和stdout">pipe (|) 管道符和stdout</a></li></ul></li><li><a href="#Example-3-Use-of-Stdin-and-Stdout">Example 3: Use of Stdin and Stdout</a></li><li><a href="#Example-4-Use-of-Stderr">Example 4: Use of Stderr</a></li></ul><h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubGludXhjb25zdWx0YW50Lm9yZy9ob3ctdG8tdXNlLXRoZS1zdGRpbi1zdGRlcnItYW5kLXN0ZG91dC1zdHJlYW1zLWluLWJhc2gv" title="https://www.linuxconsultant.org/how-to-use-the-stdin-stderr-and-stdout-streams-in-bash/">How to Use the Stdin, Stderr, and Stdout Streams in Bash – Linux Consultant<i class="fa fa-external-link"></i></span></p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>当Linux操作系统启动时，将会有三个流被打开。它们是<strong>stdin</strong>、<strong>stdout</strong>和<strong>stderr</strong>。</p><p><strong>stdin</strong> 的全称是标准输入，用于接受用户的输入。</p><p><strong>stdout</strong> 的完整形式是标准输出，用于将命令的输出存储到stdout流中。</p><p><strong>stderr</strong> 的完整形式是标准错误，用于将任何命令产生的错误信息存储到数据流中。</p><p><strong>stdin</strong>、<strong>stdout</strong> 和 <strong>stderr</strong> 的相应数字标识符值为<strong>0</strong>、<strong>1</strong>和<strong>2</strong>。</p><a id="more"></a><h2 id="Redirection-Operators-of-Stdin-Stdout-and-Stderr"><a href="#Redirection-Operators-of-Stdin-Stdout-and-Stderr" class="headerlink" title="Redirection Operators of Stdin, Stdout, and Stderr"></a>Redirection Operators of Stdin, Stdout, and Stderr</h2><p>Stdin、Stdout和Stderr的重定向操作符</p><p>重定向符号使用：&#x20;</p><ul><li>“&lt;” 或  “0&lt;”用于stdin流。</li><li>“&gt;” 或 “1&gt;”用于stdout流。</li><li>“2”用于stderr流。</li></ul><h1 id="Uses-of-Stdin-Stdout-and-Stderr"><a href="#Uses-of-Stdin-Stdout-and-Stderr" class="headerlink" title="Uses of Stdin, Stdout, and Stderr"></a>Uses of Stdin, Stdout, and Stderr</h1><p>下面是一些使用stdin，stdout，stderr的使用案例。</p><p>取出文件的内容并在终端打印的方法在这个例子中显示。</p><h1 id="Example-1-Use-of-Stdin"><a href="#Example-1-Use-of-Stdin" class="headerlink" title="Example 1: Use of Stdin"></a><strong>Example 1: Use of Stdin</strong></h1><h3 id="gt-、-gt-gt-、-lt-等操作符使用"><a href="#gt-、-gt-gt-、-lt-等操作符使用" class="headerlink" title="&gt;、&gt;&gt;、&lt; 等操作符使用"></a>&gt;、&gt;&gt;、&lt; 等操作符使用</h3><p>运行下面的 “cat “命令，创建一个名为<strong>testdata.txt</strong>的带有一些内容的文本文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat &gt; testdata.txt</span><br></pre></td></tr></table></figure><p>注意输入上面的命令之后，此时shell会等待输入流进行输入，此时可以再控制台随意输入一些字符，之后按键ctrl + c**的方式结束输入，此时<code>ls</code>当前可以看到会出现新文件 testdata.txt。</p><p>注意如果我们重复执行此命令，那么每次新的输入都会 <strong>覆盖掉旧的输入。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-8-8-ubuntu:~$ cat &gt; testdata.txt</span><br><span class="line">abcdefg</span><br><span class="line">^C</span><br><span class="line">ubuntu@VM-8-8-ubuntu:~$ cat testdata.txt </span><br><span class="line">abcdefg</span><br></pre></td></tr></table></figure><p>运行下面的 “cat “命令，将一些内容<strong>追加</strong>到testdata.txt文件中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat &gt;&gt; testdata.txt</span><br></pre></td></tr></table></figure><p>下面是实践代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-8-8-ubuntu:~$ cat testdata.txt </span><br><span class="line">abcdefg</span><br><span class="line">ubuntu@VM-8-8-ubuntu:~$ cat &gt;&gt; testdata.txt</span><br><span class="line">hijklmn</span><br><span class="line">^C</span><br><span class="line">ubuntu@VM-8-8-ubuntu:~$ cat testdata.txt </span><br><span class="line">abcdefg</span><br><span class="line">hijklmn</span><br></pre></td></tr></table></figure><p>运行下面的 “cat “命令，从testdata.txt文件中获取一个输入流，并将其打印到终端。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat &lt; testdata.txt</span><br></pre></td></tr></table></figure><p>从表面效果上来看此命令实际上只是执行了<code>&lt;</code> 符号前面的命令而已。但是在后续的案例中，将会介绍如何读入输入流重定向到另一个输出流：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-8-8-ubuntu:~$ ls &lt; testdata.txt </span><br><span class="line">testdata2.txt  testdata.txt</span><br><span class="line">ubuntu@VM-8-8-ubuntu:~$ ls -l &lt; testdata.txt </span><br><span class="line">total 8</span><br><span class="line">-rw-rw-r-- 1 ubuntu ubuntu 23 Mar 14 13:06 testdata2.txt</span><br><span class="line">-rw-rw-r-- 1 ubuntu ubuntu 16 Mar 14 13:13 testdata.txt</span><br></pre></td></tr></table></figure><p><strong>Output:</strong></p><blockquote><p>The following output appears after executing the previous commands after adding the string, “<span class="exturl" data-url="aHR0cDovL2xpbnV4aGludC5jb20=" title="http://linuxhint.com">linuxhint.com<i class="fa fa-external-link"></i></span>”, and “Scripting Language” into the testdata.txt file:</p></blockquote><p>输出：</p><p>在英文原文的案例中，在testdata.txt文件中加入 “<span class="exturl" data-url="aHR0cDovL2xpbnV4aGludC5jb20=" title="http://linuxhint.com">linuxhint.com<i class="fa fa-external-link"></i></span> “和 “脚本语言 “这两个字符串后，执行前面的命令会出现以下输出。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/image-20230315143349057.png" alt="image-20230315143349057"></p><blockquote><p>The method of creating a file using pipe (|) and redirection operator is shown in this example.</p></blockquote><p>除了上面几种方法外，还可以使用管道（|）和重定向操作符创建文件。</p><h1 id="Example-2-Use-of-Stdout"><a href="#Example-2-Use-of-Stdout" class="headerlink" title="Example 2: Use of Stdout"></a><strong>Example 2: Use of Stdout</strong></h1><h3 id="pipe-管道符和stdout"><a href="#pipe-管道符和stdout" class="headerlink" title="pipe (|) 管道符和stdout"></a>pipe (|) 管道符和stdout</h3><p>下面是一个使用管道符重定向输出并且创建文件的例子。</p><blockquote><p>Run the following command to write a string data into the text file named testdata2.txt by piping. The output of the “echo” command is sent to the input of the “cat” command using the pipe (|) operator:</p></blockquote><p>通过下面的命令，把echo的命令发送到cat当中，最后重定向输出流到文件testdata2.txt。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-8-8-ubuntu:~$ <span class="built_in">echo</span> <span class="string">"Learn Bash Programming"</span> | cat &gt; testdata2.txt</span><br><span class="line">ubuntu@VM-8-8-ubuntu:~$ ls</span><br><span class="line">testdata2.txt</span><br></pre></td></tr></table></figure><blockquote><p>Run the following “cat” command to check the content of the testdata2.txt file:</p></blockquote><p>再次运行 “cat “命令检查testdata2.txt文件的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-8-8-ubuntu:~$ cat testdata2.txt </span><br><span class="line">Learn Bash Programming</span><br></pre></td></tr></table></figure><blockquote><p><strong>Output:</strong></p></blockquote><blockquote><p>The following output appears after executing the previous commands. According to the output, the output of the “echo” command is written into the testdata2.txt file:</p></blockquote><p>输出：</p><p>下面的例子可以可以看到echo的输出内容被重定向写入到testdata2.txt 这个文件当中，下面是合并两个命令的输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-8-8-ubuntu:~$ <span class="built_in">echo</span> <span class="string">"Learn Bash Programming"</span> | cat &gt; testdata2.txt</span><br><span class="line">ubuntu@VM-8-8-ubuntu:~$ ls</span><br><span class="line">testdata2.txt</span><br><span class="line">ubuntu@VM-8-8-ubuntu:~$ cat testdata2.txt </span><br><span class="line">Learn Bash Programming</span><br></pre></td></tr></table></figure><blockquote><p>Run the following command to write the output of the “ls –l” command into a text file named list.txt using the redirection operator (‘&gt;’):</p></blockquote><p>运行以下命令，使用重定向操作符（’<code>&gt;</code>‘）将 <code>ls -l</code>命令的输出写入一个名为list.txt的文本文件中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l  &gt; list.txt</span><br></pre></td></tr></table></figure><p>个人的实验结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-8-8-ubuntu:~$ ls -l  &gt; list.txt</span><br><span class="line">ubuntu@VM-8-8-ubuntu:~$ cat list.txt </span><br><span class="line">total 8</span><br><span class="line">-rw-rw-r-- 1 ubuntu ubuntu  0 Mar 14 13:18 list2.txt</span><br><span class="line">-rw-rw-r-- 1 ubuntu ubuntu  0 Mar 14 13:22 list.txt</span><br><span class="line">-rw-rw-r-- 1 ubuntu ubuntu 23 Mar 14 13:06 testdata2.txt</span><br><span class="line">-rw-rw-r-- 1 ubuntu ubuntu 16 Mar 14 13:13 testdata.txt</span><br></pre></td></tr></table></figure><h1 id="Example-3-Use-of-Stdin-and-Stdout"><a href="#Example-3-Use-of-Stdin-and-Stdout" class="headerlink" title="Example 3: Use of Stdin and Stdout"></a>Example 3: Use of Stdin and Stdout</h1><blockquote><p>The method of using both stdin and stdout to take an input from a file and write it into a file is shown in this example.</p></blockquote><p>这部分介绍了如何同时使用stdin和stdout。</p><blockquote><p>Run the following “cat” command to take the content of the testdata.txt file and write it into the testfile.txt file and the terminal:</p></blockquote><p>下面的cat命令可以把testdata.txt文件的内容打印到控制台，同时重定向输出流写入文件到另一个文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-8-8-ubuntu:~$ cat &lt; testdata.txt &gt; otherfile.txt</span><br><span class="line">ubuntu@VM-8-8-ubuntu:~$ cat testdata.txt </span><br><span class="line">abcdefg</span><br><span class="line">hijklmn</span><br><span class="line">ubuntu@VM-8-8-ubuntu:~$ cat otherfile.txt </span><br><span class="line">abcdefg</span><br><span class="line">hijklmn</span><br></pre></td></tr></table></figure><blockquote><p> PS：为了方便理解，建议读者把上面的命令分为两个操作，类似这样的写法：<code>( cat &lt; testdata.txt ) &gt; otherfile.txt</code>。</p></blockquote><p>上面的命令可以看作两个部分，第一部分是读取testdata.txt的内容作为输入流，然后输出再输出到 otherfile.txt。最终两个文件内容是一样的，这个操作的命令效果和CP复制一个文件的效果类似：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-8-8-ubuntu:~$ cp otherfile.txt otherfile2.txt</span><br></pre></td></tr></table></figure><h1 id="Example-4-Use-of-Stderr"><a href="#Example-4-Use-of-Stderr" class="headerlink" title="Example 4: Use of Stderr"></a>Example 4: Use of Stderr</h1><blockquote><p>The content of the standard error can be printed in the terminal or redirected into a file or sent to the /dev/null that works like the recycle bin. The different ways to pass the standard error are shown in this example</p></blockquote><p>stderr是标准错误信息，通常的做法是输出到控制台或者输出到文件，还有一种方式是丢弃到<strong>/dev/null</strong>这个“黑洞”当中，下面的例子是stderr的用法案例：</p><p>下面的命令是正确的，它用换行符打印了 “Hello “字符串。所以下面的命令<strong>没有产生标准错误</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-8-8-ubuntu:~$ <span class="built_in">printf</span> <span class="string">"%s\n"</span> <span class="string">"Hello"</span></span><br><span class="line">Hello</span><br></pre></td></tr></table></figure><p>我们可以通过 <code>echo $?</code> 的方式，检查上一个命令是否正确：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-8-8-ubuntu:~$ <span class="built_in">echo</span> $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>下面的命令是错误的，因为没有名为 “<code>pirntf</code> “的命令。所以它产生了一个<strong>标准错误</strong>，并且错误被打印控制台。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-8-8-ubuntu:~$ pirntf <span class="string">"%s\n"</span> <span class="string">"Hello"</span></span><br><span class="line">Command <span class="string">'pirntf'</span> not found, did you mean:</span><br><span class="line">  <span class="built_in">command</span> <span class="string">'printf'</span> from deb coreutils (8.32-4.1ubuntu1)</span><br><span class="line">Try: sudo apt install &lt;deb name&gt;</span><br></pre></td></tr></table></figure><p>这时候检查上一个命令是否正确会，结果返回一个非0值代表上一条命令有误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-8-8-ubuntu:~$ <span class="built_in">echo</span> $?</span><br><span class="line">127</span><br></pre></td></tr></table></figure><blockquote><p>Sometimes, it requires printing the custom error by hiding the standard error to make the error more understandable for the users. This task can be done by redirecting the error into the /dev/null. The “2&gt;” is used here to redirect the error into /dev/null.</p></blockquote><p>有时，控制台需要通过隐藏标准错误来打印自定义错误，使用户更容易理解错误，这个任务可以通过将错误重定向到<code>/dev/null</code>中来完成。这里使用 “<code>2&gt;</code>“来重定向错误到<code>/dev/null</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-8-8-ubuntu:~$ pirntf <span class="string">"%s\n"</span> <span class="string">"Hello"</span> 2&gt; /dev/null</span><br><span class="line">ubuntu@VM-8-8-ubuntu:~$ <span class="built_in">echo</span> $?</span><br><span class="line">127</span><br></pre></td></tr></table></figure><blockquote><p>Sometimes, the standard error requires storing into a file for future use. This task can be done by redirecting the error into a file using the “2&gt;” operator.</p></blockquote><p>有时，标准错误需要存储到一个文件中提供给以后使用（日志备份）。这项任务同样可以通过使用 “2&gt;”操作符将错误重定向到一个文件中来完成。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-8-8-ubuntu:~$ pirntf <span class="string">"%s\n"</span> <span class="string">"Hello"</span> 2&gt; error.txt</span><br><span class="line">ubuntu@VM-8-8-ubuntu:~$ cat error.txt </span><br><span class="line">Command <span class="string">'pirntf'</span> not found, did you mean:</span><br><span class="line">  <span class="built_in">command</span> <span class="string">'printf'</span> from deb coreutils (8.32-4.1ubuntu1)</span><br><span class="line">Try: sudo apt install &lt;deb name&gt;</span><br></pre></td></tr></table></figure><p>从结果可以看到在执行命令后标准错误被正确写入error.txt文件。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>The uses of stdin, stdout, and stderr are explained in this tutorial using multiple examples that will help the Linux users to understand the concept of these streams and use them properly when required.</p></blockquote><p>本教程用多个例子解释了stdin、stdout和stderr的用途，这将有助于Linux用户理解这些流的概念，并在需要时正确使用它们。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      流介绍
    
    </summary>
    
    
      <category term="Linux" scheme="https://whitestore.top/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://whitestore.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【RocketMq】Rocket 生产者相关知识点 - 消息发送者参数详解</title>
    <link href="https://whitestore.top/2023/03/11/rocketshengchanzhe/"/>
    <id>https://whitestore.top/2023/03/11/rocketshengchanzhe/</id>
    <published>2023-03-10T23:27:49.000Z</published>
    <updated>2023-06-15T13:10:39.212Z</updated>
    
    <content type="html"><![CDATA[<p>#rocketmq</p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>首先注意本次讨论的RokcetMq源码版本为 <strong>4.9.4</strong>，距离5.0发布 的没有多久。</p><p>这一节针对RocketMq的生产者请求发送的部分细节进行阐述，主要包含了下面的内容：DefaultMQProducer 为生产者默认对象，这个对象继承自 ClientConfig，里面包含了请求者的通用配置，所以可以拆分为两个部分进行理解，第一部分为ClientConfig，第二部分为DefaultMQProducer。</p><h1 id="ClientConfig-部分"><a href="#ClientConfig-部分" class="headerlink" title="ClientConfig 部分"></a>ClientConfig 部分</h1><p>ClientConfig 定义了一些配置的获取方法，定义了命名空间等参数。无论是消息的发送者还是消费者都是通用的。</p><p>下面根据本次的版本的源代码介绍相关参数。</p><table><thead><tr><th>名称</th><th>描述</th><th>参数类型</th><th>默认值</th><th>有效值</th><th>重要性</th></tr></thead><tbody><tr><td>namesrvAddr</td><td>NameServer的地址列表</td><td>String</td><td>从-D系统参数rocketmq.namesrv.addr或环境变量。NAMESRV_ADDR</td><td></td><td></td></tr><tr><td>instanceName</td><td>客户端实例名称</td><td>String</td><td>从-D系统参数rocketmq.client.name获取，否则就是DEFAULT</td><td></td><td></td></tr><tr><td>clientIP</td><td>客户端IP</td><td>String</td><td>RemotingUtil.getLocalAddress()</td><td></td><td></td></tr><tr><td>namespace</td><td>客户端命名空间</td><td>String</td><td></td><td></td><td></td></tr><tr><td>accessChannel</td><td>设置访问通道</td><td>AccessChannel</td><td>LOCAL</td><td></td><td></td></tr><tr><td>clientCallbackExecutorThreads</td><td>客户端通信层接收到网络请求的时候，处理器的核数</td><td>int</td><td>Runtime.getRuntime().availableProcessors()</td><td></td><td></td></tr><tr><td>pollNameServerInterval</td><td>轮询从NameServer获取路由信息的时间间隔</td><td>int</td><td>30000，单位毫秒</td><td></td><td></td></tr><tr><td>heartbeatBrokerInterval</td><td>定期发送注册心跳到broker的间隔</td><td>int</td><td>30000，单位毫秒</td><td></td><td></td></tr><tr><td>persistConsumerOffsetInterval</td><td>作用于Consumer，持久化消费进度的间隔</td><td>int</td><td>默认值5000，单位毫秒</td><td></td><td></td></tr><tr><td>pullTimeDelayMillsWhenException</td><td>拉取消息出现异常的延迟时间设置</td><td>long</td><td>1000，单位毫秒</td><td></td><td></td></tr><tr><td>unitName</td><td>单位名称</td><td>String</td><td></td><td></td><td></td></tr><tr><td>unitMode</td><td>单位模式</td><td>boolean</td><td>false</td><td></td><td></td></tr><tr><td>vipChannelEnabled</td><td>是否启用vip netty通道以发送消息</td><td>boolean</td><td>从-D com.rocketmq.sendMessageWithVIPChannel参数的值，若无则是true</td><td></td><td></td></tr><tr><td>useTLS</td><td>是否使用安全传输。</td><td>boolean</td><td>从-D系统参数tls.enable获取，否则就是false</td><td></td><td></td></tr><tr><td>mqClientApiTimeout</td><td>mq客户端api超时设置</td><td>int</td><td>3000，单位毫秒</td><td></td><td></td></tr><tr><td>language</td><td>客户端实现语言</td><td>LanguageCode</td><td>LanguageCode.<em>JAVA</em></td><td></td><td></td></tr></tbody></table><a id="more"></a><h2 id="namesrvAddr"><a href="#namesrvAddr" class="headerlink" title="namesrvAddr"></a>namesrvAddr</h2><p>NameServer 的地址列表。</p><h2 id="clientIp"><a href="#clientIp" class="headerlink" title="clientIp"></a>clientIp</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String clientIP = RemotingUtil.getLocalAddress();</span><br></pre></td></tr></table></figure><p>从代码中可以看到，使用<code>RemotingUtil#getLocalAddress</code> 获取IP信息，在当前版本中默认返回不是<code>127.0</code>或者<code>192.168</code>开头的 IPV4地址，否则尝试获取IPV6的地址，如果都找不到就用LocalHost地址。</p><h2 id="instanceName"><a href="#instanceName" class="headerlink" title="instanceName"></a>instanceName</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String instanceName = System.getProperty(<span class="string">"rocketmq.client.name"</span>, <span class="string">"DEFAULT"</span>);</span><br></pre></td></tr></table></figure><p><code>instanceName</code>主要获取当前默认的系统参数客户端实例名称，它是客户端标识 CID 的组成部分</p><h2 id="unitName-单元名称"><a href="#unitName-单元名称" class="headerlink" title="unitName 单元名称"></a>unitName 单元名称</h2><p>也是CID的组成部分之一，如果获取 NameServer 的地址是通过 URL 进行动态更新的话，会通过这个单元名称进行附加，用来区分不同的NameServer地址服务。</p><h2 id="clientCallbackExecutorThreads-回调线程池数量"><a href="#clientCallbackExecutorThreads-回调线程池数量" class="headerlink" title="clientCallbackExecutorThreads 回调线程池数量"></a>clientCallbackExecutorThreads 回调线程池数量</h2><p>表示public回调线程池的数量，默认为CPU的核数，通常这个值直接根据JVM获取的结果为基准即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> clientCallbackExecutorThreads = Runtime.getRuntime().availableProcessors();</span><br></pre></td></tr></table></figure><h2 id="namespace-命名空间"><a href="#namespace-命名空间" class="headerlink" title="namespace 命名空间"></a>namespace 命名空间</h2><p>4.5.1 之后才加入的新机制。主要适用场景为全链路压测的时候可以利用不同的命名空间划分出真实消息和压测消息，使得线上业务正常执行的情况下同步处理测试流程。</p><h2 id="pollNameServerInterval-NameServer同步间隔"><a href="#pollNameServerInterval-NameServer同步间隔" class="headerlink" title="pollNameServerInterval NameServer同步间隔"></a>pollNameServerInterval NameServer同步间隔</h2><p>生产者客户端默认每隔出30S向NameServer 更新Topic的相关信息，注意这个参数在消费端同样存在相同的配置，这个配置通常不建议修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * Pulling topic information interval from the named server */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> pollNameServerInterval = <span class="number">1000</span> * <span class="number">30</span>;</span><br></pre></td></tr></table></figure><h2 id="heartbeatBrokerInterval-Broker心跳间隔"><a href="#heartbeatBrokerInterval-Broker心跳间隔" class="headerlink" title="heartbeatBrokerInterval Broker心跳间隔"></a>heartbeatBrokerInterval Broker心跳间隔</h2><p>客户端向 Broker 发送心跳包的时间间隔，默认为 30s，不建议修改该值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * Heartbeat interval in microseconds with message broker */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> heartbeatBrokerInterval = <span class="number">1000</span> * <span class="number">30</span>;</span><br></pre></td></tr></table></figure><h2 id="persistConsumerOffsetInterval"><a href="#persistConsumerOffsetInterval" class="headerlink" title="persistConsumerOffsetInterval"></a>persistConsumerOffsetInterval</h2><p>客户端持久化消息消费进度的间隔，默认为 5s，该值不建议修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * Offset persistent interval for consumer */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> persistConsumerOffsetInterval = <span class="number">1000</span> * <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h1 id="DefaultMQProducer-部分"><a href="#DefaultMQProducer-部分" class="headerlink" title="DefaultMQProducer 部分"></a>DefaultMQProducer 部分</h1><p>这部分定义了日志和常见的使用消息队列方法，注意在类的开头定义了一个 <strong>transient</strong> 变量执行内部的保护方法。</p><p>官方文档中极少DefaultMQProducer配置如下：</p><table><thead><tr><th>名称</th><th>描述</th><th>参数类型</th><th>默认值</th><th>有效值</th><th>重要性</th></tr></thead><tbody><tr><td>producerGroup</td><td>生产组的名称，一类Producer的标识</td><td>String</td><td>DEFAULT_PRODUCER</td><td></td><td></td></tr><tr><td>createTopicKey</td><td>发送消息的时候，如果没有找到topic，若想自动创建该topic，需要一个key topic，这个值即是key topic的值</td><td>String</td><td>TopicValidator.AUTO_CREATE_TOPIC_KEY_TOPIC</td><td></td><td></td></tr><tr><td>defaultTopicQueueNums</td><td>自动创建topic的话，默认queue数量是多少</td><td>int</td><td>4</td><td></td><td></td></tr><tr><td>sendMsgTimeout</td><td>默认的发送超时时间</td><td>int</td><td>3000，单位毫秒</td><td></td><td></td></tr><tr><td>compressMsgBodyOverHowmuc</td><td>消息body需要压缩的阈值</td><td>int</td><td>1024 * 4，4K</td><td></td><td></td></tr><tr><td>retryTimesWhenSendFailed</td><td>同步发送失败的话，rocketmq内部重试多少次</td><td>int</td><td>2</td><td></td><td></td></tr><tr><td>retryTimesWhenSendAsyncFailed</td><td>异步发送失败的话，rocketmq内部重试多少次</td><td>int</td><td>2</td><td></td><td></td></tr><tr><td>retryAnotherBrokerWhenNotStoreOK</td><td>发送的结果如果不是SEND_OK状态，是否当作失败处理而尝试重发</td><td>boolean</td><td>false</td><td></td><td></td></tr><tr><td>maxMessageSize</td><td>客户端验证，允许发送的最大消息体大小</td><td>int</td><td>1024 <em>1024</em> 4，4M</td><td></td><td></td></tr><tr><td>traceDispatcher</td><td>异步传输数据接口</td><td>TraceDispatcher</td><td>null</td><td></td><td></td></tr></tbody></table><h2 id="DefaultMQProducerImpl-内部对象"><a href="#DefaultMQProducerImpl-内部对象" class="headerlink" title="DefaultMQProducerImpl 内部对象"></a>DefaultMQProducerImpl 内部对象</h2><p><code>defaultMQProducerImpl</code> 比较意思，因为此对象是 <code>DefaultMQProducerImpl</code> 整个实现类的实际调用者，这里用了受保护的内部对象完成所有方法调用，用final是规避旧版本多个线程初始化对象非原子性的问题，同时保证持有的内部对象不可变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * Wrapping internal implementations for virtually all methods presented in this class. */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">transient</span> DefaultMQProducerImpl defaultMQProducerImpl;</span><br></pre></td></tr></table></figure><blockquote><p>为什么这里要用 transient？<br>transient 关键字确保对象被序列化之后不会泄漏 DefaultMQProducerImpl 对象。</p></blockquote><h2 id="InternalLogger-日志对象"><a href="#InternalLogger-日志对象" class="headerlink" title="InternalLogger 日志对象"></a>InternalLogger 日志对象</h2><p>接着是日志对象，日志对象 InternalLogger 如下定义，内部实现比较简单，基本是一些info和debug日志打印。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InternalLogger log = ClientLogger.getLog()</span><br></pre></td></tr></table></figure><p>客户端日志的实现类存储路径时是：<code>${user.home}/logs/rocketmqlogs/rocketmq_client.log</code>，这个路径的获取细节在<code>org.apache.rocketmq.client.log.ClientLogger#createClientAppender</code>可以看到有关细节。使用<code>System.getProperty(&quot;user.home&quot;)</code>获取的路径在Unix系统中相当于用户的主目录。</p><blockquote><p>user.home 如果是 xxx 则是 /usr/home/xxx 为开始，比如个人的Mac电脑最终的存放地址为：<code>/Users/zxd/logs/rocketmqlogs/rocketmq_client.log</code>。</p></blockquote><h2 id="producerGroup-消息组"><a href="#producerGroup-消息组" class="headerlink" title="producerGroup 消息组"></a>producerGroup 消息组</h2><p>表示发送者所属组定义如下，根据注释可以得知，gropu 可以实现生产者实例的聚合，主要用在事务的的时候需要使用到，而如果是非事务的消息，每一个进程都是唯一的，彼此没有关联。</p><p>有关事务的内容涉及需要用到Broker反查机制，这里不做过多牵扯，继续介绍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * Producer group conceptually aggregates all producer instances of exactly same role, which is particularly * important when transactional messages are involved. &lt;/p&gt;  </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * For non-transactional messages, it does not matter as long as it's unique per process. &lt;/p&gt;  </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * See &lt;a href="http://rocketmq.apache.org/docs/core-concept/"&gt;core concepts&lt;/a&gt; for more discussion.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">private</span> String producerGroup;</span><br></pre></td></tr></table></figure><p>我们可以通过相关命令或者可视化工具查看发送者所属组的状态。注意默认的主题队列数量，RocketMq默认设置为4。</p><p>这里用了volatile保证多线程对于主题队列的数量时可见的，多个生产者实例观察的数量是一致的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * Number of queues to create per default topic. */</span><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> defaultTopicQueueNums = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><h2 id="sendMsgTimeout-消息发送默认超时时间"><a href="#sendMsgTimeout-消息发送默认超时时间" class="headerlink" title="sendMsgTimeout 消息发送默认超时时间"></a>sendMsgTimeout 消息发送默认超时时间</h2><p>消息默认发送的超时时间为3秒，</p><p>注意的是在 RocketMQ 4.3.0 版本之前由于存在重试机制，程序设置的设计为单次重试的超时时间，即如果设置重试次数为 3 次，则 <code>DefaultMQProducer#send</code> 方法可能会超过 9s 才返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * Timeout for sending messages. */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> sendMsgTimeout = <span class="number">3000</span>;</span><br></pre></td></tr></table></figure><p>主要的改动点在<code>org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl</code> 这个对象里面</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202209280724815.png" alt=""></p><p>修复的方式比较简单粗暴，是增加一个纳秒值进行计算 ，如果请求时间超过发送请求的时间太久就抛出异常。下一次请求对应的扣除掉本次耗费的时间再进行重试，如果重试超过的总时间超过超时时间也同样抛出异常。</p><p>这就意味着如果超时次数设置10次，可能不到10次就会因为超时时间的判断抛出异常信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> costTimeAsync = System.currentTimeMillis() - beginStartTime;  </span><br><span class="line"><span class="keyword">if</span> (timeout &lt; costTimeAsync) &#123;  </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RemotingTooMuchRequestException(<span class="string">"sendKernelImpl call timeout"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="compressMsgBodyOverHowmuch-压缩阈值"><a href="#compressMsgBodyOverHowmuch-压缩阈值" class="headerlink" title="compressMsgBodyOverHowmuch 压缩阈值"></a>compressMsgBodyOverHowmuch 压缩阈值</h2><p>默认情况下，如果消息的长度超过4K，那么RocketMq默认会对于消息开启压缩，虽然会增加CPU的性能损耗，但是可以有效减少网络方便的开销。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * Compress message body threshold, namely, message body larger than 4k will be compressed on default. */</span></span><br><span class="line"> <span class="comment">// 压缩消息体阈值，即默认压缩大于4k的消息体。</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> compressMsgBodyOverHowmuch = <span class="number">1024</span> * <span class="number">4</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">tryToCompressMessage</span><span class="params">(<span class="keyword">final</span> Message msg)</span> </span>&#123;  </span><br><span class="line"><span class="comment">// 批量数据目前不支持压缩</span></span><br><span class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> MessageBatch) &#123;  </span><br><span class="line">        <span class="comment">//batch does not support compressing right now  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">byte</span>[] body = msg.getBody();  </span><br><span class="line">    <span class="keyword">if</span> (body != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (body.length &gt;= <span class="keyword">this</span>.defaultMQProducer.getCompressMsgBodyOverHowmuch()) &#123;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="comment">// 压缩之后的数据</span></span><br><span class="line">                <span class="keyword">byte</span>[] data = compressor.compress(body, compressLevel);  </span><br><span class="line">                <span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                    msg.setBody(data);  </span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;                &#125;  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">                log.error(<span class="string">"tryToCompressMessage exception"</span>, e);  </span><br><span class="line">                log.warn(msg.toString());  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="retryTimesWhenSendFailed-同步失败重试"><a href="#retryTimesWhenSendFailed-同步失败重试" class="headerlink" title="retryTimesWhenSendFailed 同步失败重试"></a>retryTimesWhenSendFailed 同步失败重试</h2><p>同步消息发送重试次数。RocketMQ 客户端内部在消息发送失败时默认会重试 2 次。该参数与 <code>sendMsgTimeout</code> 联合生效，但是需要注意这个参数在SYNC模式下才会重试2次，如果是其他模式则默认是一次失败不再进行重试。</p><p>在SYNC模式只重试一次可以看下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> timesTotal = communicationMode == CommunicationMode.SYNC ? <span class="number">1</span> + <span class="keyword">this</span>.defaultMQProducer.getRetryTimesWhenSendFailed() : <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="retryTimesWhenSendAsyncFailed-异步消息重试"><a href="#retryTimesWhenSendAsyncFailed-异步消息重试" class="headerlink" title="retryTimesWhenSendAsyncFailed 异步消息重试"></a>retryTimesWhenSendAsyncFailed 异步消息重试</h2><p>见名知意，发送重试次数，如果是同步则默认为 2，即重试 2 次，一共有 3 次机会，如果是异步则只有一次机会，但是是写死1在判断处。</p><p>关键的代码在<code>org.apache.rocketmq.client.impl.MQClientAPIImpl#onExceptionImpl</code> 这个参数巨多的方法当中，简单判断当前的异步消息总的重试次数，如果重试多次超过次数则通过sendCallback回调发送异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * Maximum number of retry to perform internally before claiming sending failure in synchronous mode. &lt;/p&gt;  </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * This may potentially cause message duplication which is up to application developers to resolve. */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> retryTimesWhenSendFailed = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h2 id="retryAnotherBrokerWhenNotStoreOK-失败向其他Broker重试"><a href="#retryAnotherBrokerWhenNotStoreOK-失败向其他Broker重试" class="headerlink" title="retryAnotherBrokerWhenNotStoreOK 失败向其他Broker重试"></a>retryAnotherBrokerWhenNotStoreOK 失败向其他Broker重试</h2><p>根据方法的本意按照道理来说如果客户端收到的结果不是 SEND_OK，应该直接向另外一个 Broker 重试，但根据代码分析目前这个参数并不能按预期运作，官方一致也没有关注过这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * Maximum number of retry to perform internally before claiming sending failure in asynchronous mode. &lt;/p&gt;  </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * This may potentially cause message duplication which is up to application developers to resolve. */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> retryTimesWhenSendAsyncFailed = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h2 id="maxMessageSize-最大消息体"><a href="#maxMessageSize-最大消息体" class="headerlink" title="maxMessageSize 最大消息体"></a>maxMessageSize 最大消息体</h2><p>允许发送的最大消息体，默认为 4M，具体可以看下面的判断，注意Broker也有 maxMessageSize 这个参数的设置，故客户端的设置不能超过服务端的配置：</p><p>客户端的发送限制如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * Maximum allowed message body size in bytes. */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> maxMessageSize = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">4</span>; <span class="comment">// 4M</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (msg.getBody().length &gt; defaultMQProducer.getMaxMessageSize()) &#123;  </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(ResponseCode.MESSAGE_ILLEGAL,  </span><br><span class="line">        <span class="string">"the message body size over max value, MAX: "</span> + defaultMQProducer.getMaxMessageSize());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>maxMessageSize 另一个使用地点是在RocketMq的轨迹消息长度判断中，不过这一块的代码在2022年的上半年被某位大神大改优化过，里面的优化代码比较值得学习，但是因为这一块牵扯的内容比较大部头需要先放放，我们看其他参数内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 轨迹消息中累计到3/4左右的时候就进行合并提交</span></span><br><span class="line"><span class="keyword">if</span> (currentMsgSize &gt;= traceProducer.getMaxMessageSize() - <span class="number">10</span> * <span class="number">1000</span>) &#123;  </span><br><span class="line">    List&lt;TraceTransferBean&gt; dataToSend = <span class="keyword">new</span> ArrayList(traceTransferBeanList);  </span><br><span class="line">    AsyncDataSendTask asyncDataSendTask = <span class="keyword">new</span> AsyncDataSendTask(traceTopicName, regionId, dataToSend);  </span><br><span class="line">    traceExecutor.submit(asyncDataSendTask);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">this</span>.clear();  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sendLatencyFaultEnable-失败延迟规避"><a href="#sendLatencyFaultEnable-失败延迟规避" class="headerlink" title="sendLatencyFaultEnable 失败延迟规避"></a>sendLatencyFaultEnable 失败延迟规避</h2><p>失败规避机制默认为false，它的含义是当Product向Broker发送消息失败之后，客户端的在内部重试的时候会规避掉上一次发送失败的Broker，并且一段时间内不会再向该Broker进行发送。</p><h2 id="notAvailableDuration-不可用延迟数组"><a href="#notAvailableDuration-不可用延迟数组" class="headerlink" title="notAvailableDuration 不可用延迟数组"></a>notAvailableDuration 不可用延迟数组</h2><p>不可用延迟数组，利用等比数列的时间发送消息，根据数组的设置在多少时间内不向Broker发送消息。从默认值可以看到这里是按照阶层的方式进行增长的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">long</span>[] notAvailableDuration = &#123;<span class="number">0L</span>, <span class="number">0L</span>, <span class="number">30000L</span>, <span class="number">60000L</span>, <span class="number">120000L</span>, <span class="number">180000L</span>, <span class="number">600000L</span>&#125;;</span><br></pre></td></tr></table></figure><h2 id="latencyMax-延迟最大值"><a href="#latencyMax-延迟最大值" class="headerlink" title="latencyMax  延迟最大值"></a>latencyMax  延迟最大值</h2><p>设置消息发送的最大延迟级别，同样涉及了延迟推送机制。这里暂时略过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">long</span>[] latencyMax = &#123;<span class="number">50L</span>, <span class="number">100L</span>, <span class="number">550L</span>, <span class="number">1000L</span>, <span class="number">2000L</span>, <span class="number">3000L</span>, <span class="number">15000L</span>&#125;;</span><br></pre></td></tr></table></figure><h1 id="MqAdmin"><a href="#MqAdmin" class="headerlink" title="MqAdmin"></a>MqAdmin</h1><p>定义了一些基础的规范接口，由于和我们平时写业务代码的Service Interface类似，这里不在过多展开介绍，而是简单罗列一些比较常用的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">-   String key：根据 key 查找 Broker，即新主题创建在哪些 Broker 上</span></span><br><span class="line"><span class="comment">-   String newTopic：主题名称</span></span><br><span class="line"><span class="comment">-   int queueNum：主题队列个数</span></span><br><span class="line"><span class="comment">-   int topicSysFlag：主题的系统参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createTopic</span><span class="params">(String key, String newTopic, <span class="keyword">int</span> queueNum, <span class="keyword">int</span> topicSysFlag)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment">根据队列与时间戳，从消息消费队列中查找消息，返回消息的物理偏移量（在 commitlog 文件中的偏移量）。</span></span></span><br><span class="line"><span class="function"><span class="comment">MessageQueue mq：消息消费队列</span></span></span><br><span class="line"><span class="function"><span class="comment">long timestamp：时间戳</span></span></span><br><span class="line"><span class="function"><span class="comment">*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">searchOffset</span><span class="params">(MessageQueue mq, <span class="keyword">long</span> timestamp)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> <span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> 查询消息消费队列当前最大的逻辑偏移量，在 consumequeue 文件中的偏移量。</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">maxOffset</span><span class="params">(<span class="keyword">final</span> MessageQueue mq)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"> <span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> 查询消息消费队列当前最小的逻辑偏移量。</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">minOffset</span><span class="params">(<span class="keyword">final</span> MessageQueue mq)</span> </span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment">返回消息消费队列中第一条消息的存储时间戳。</span></span></span><br><span class="line"><span class="function"><span class="comment">*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">earliestMsgStoreTime</span><span class="params">(MessageQueue mq)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment">根据消息的物理偏移量查找消息</span></span></span><br><span class="line"><span class="function"><span class="comment">*/</span></span></span><br><span class="line"><span class="function">MessageExt <span class="title">viewMessage</span><span class="params">(String offsetMsgId)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment">根据主题与消息的全局唯一 ID 查找消息。</span></span></span><br><span class="line"><span class="function"><span class="comment">*/</span>    </span></span><br><span class="line"><span class="function">MessageExt <span class="title">viewMessage</span><span class="params">(String topic, String msgId)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment">批量查询消息，其参数列表如下：</span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment">String topic：主题名称</span></span></span><br><span class="line"><span class="function"><span class="comment">String key：消息索引 Key</span></span></span><br><span class="line"><span class="function"><span class="comment">int maxNum：本次查询最大返回消息条数</span></span></span><br><span class="line"><span class="function"><span class="comment">long begin：开始时间戳</span></span></span><br><span class="line"><span class="function"><span class="comment">long end：结束时间戳</span></span></span><br><span class="line"><span class="function"><span class="comment">*/</span></span></span><br><span class="line"><span class="function">QueryResult <span class="title">queryMessage</span><span class="params">(String topic, String key, <span class="keyword">int</span> maxNum, <span class="keyword">long</span> begin,<span class="keyword">long</span> end)</span></span></span><br></pre></td></tr></table></figure><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>简单的进行一些API讲解，我们可以下具体使用到之后再来本文查阅会更有实际意义。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      rocketmq使用
    
    </summary>
    
    
      <category term="RocketMq" scheme="https://whitestore.top/categories/RocketMq/"/>
    
    
      <category term="RocketMq" scheme="https://whitestore.top/tags/RocketMq/"/>
    
  </entry>
  
  <entry>
    <title>【RocketMq】使用Idea部署RocketMq 源代码（4.9.4）</title>
    <link href="https://whitestore.top/2023/03/11/rocketjianhua/"/>
    <id>https://whitestore.top/2023/03/11/rocketjianhua/</id>
    <published>2023-03-10T23:24:00.000Z</published>
    <updated>2023-06-15T13:10:39.212Z</updated>
    
    <content type="html"><![CDATA[<p>#rocketmq  </p><h1 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h1><p>笔记为主，Idea部署RocketMq的简化流程。</p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwYWNoZS9yb2NrZXRtcQ==" title="https://github.com/apache/rocketmq">https://github.com/apache/rocketmq<i class="fa fa-external-link"></i></span></p><h1 id="二、提示"><a href="#二、提示" class="headerlink" title="二、提示"></a>二、提示</h1><h2 id="2-1-IDEA版本"><a href="#2-1-IDEA版本" class="headerlink" title="2.1 IDEA版本"></a>2.1 IDEA版本</h2><p>个人使用的Idea版本。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220826144547.png" alt=""></p><a id="more"></a><h2 id="2-2-RocketMq源码版本"><a href="#2-2-RocketMq源码版本" class="headerlink" title="2.2 RocketMq源码版本"></a>2.2 RocketMq源码版本</h2><p>需要注意下载源代码之前，先检查一下自己的java版本，最低要求JDK1.8以上。</p><p>个人拉取的版本为 <strong>4.9.4</strong>，因为时效性未来版本有些代码可能会被改进，所以要注意版本问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java version <span class="string">"1.8.0_341"</span></span><br><span class="line">Java(TM) <span class="function">SE Runtime <span class="title">Environment</span> <span class="params">(build <span class="number">1.8</span><span class="number">.0</span>_341-b10)</span></span></span><br><span class="line"><span class="function">Java <span class="title">HotSpot</span><span class="params">(TM)</span> 64-Bit Server <span class="title">VM</span> <span class="params">(build <span class="number">25.341</span>-b10, mixed mode)</span></span></span><br></pre></td></tr></table></figure><p>拉源码，这一步不需要过多介绍，直接点击主页右上角即可。</p><blockquote><p>这里从官方fork 了一下项目</p></blockquote><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220826151618.png" alt=""></p><p>github 现在墙越来越厚，拉代码经常失败，没办法只能再套一层，用 gitee fork了一遍，双层套娃属于是。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220826152001.png" alt=""></p><p>最后终于成功拉代码到本地（真不容易）。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220826151917.png" alt=""></p><h1 id="三、操作步骤"><a href="#三、操作步骤" class="headerlink" title="三、操作步骤"></a>三、操作步骤</h1><h2 id="3-1-下载源代码"><a href="#3-1-下载源代码" class="headerlink" title="3.1 下载源代码"></a>3.1 下载源代码</h2><p>个人fork版本（4.9.9）：<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vbGF6eVRpbWVzL3JvY2tldG1xLWFkb25nLmdpdA==" title="https://gitee.com/lazyTimes/rocketmq-adong.git">https://gitee.com/lazyTimes/rocketmq-adong.git<i class="fa fa-external-link"></i></span></p><p>官方gituhb（最新版本）：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwYWNoZS9yb2NrZXRtcS5naXQ=" title="https://github.com/apache/rocketmq.git">https://github.com/apache/rocketmq.git<i class="fa fa-external-link"></i></span></p><p><strong>源码目录结构</strong>：</p><ul><li><strong>broker</strong>: broker 模块（broke 启动进程）</li><li><strong>client</strong> ：消息客户端，包含消息生产者、消息消费者相关类</li><li><strong>common</strong> ：公共包</li><li><strong>dev</strong> ：开发者信息（非源代码）</li><li><strong>distribution</strong> ：部署实例文件夹（非源代码）</li><li><strong>example</strong>: RocketMQ 例代码</li><li><strong>filter</strong> ：消息过滤相关基础类</li><li><strong>filtersrv</strong>：消息过滤服务器实现相关类（Filter启动进程）</li><li><strong>logappender</strong>：日志实现相关类</li><li><strong>namesrv</strong>：NameServer实现相关类（NameServer启动进程）</li><li><strong>openmessageing</strong>：消息开放标准</li><li><strong>remoting</strong>：远程通信模块，基于Netty</li><li><strong>srcutil</strong>：服务工具类</li><li><strong>store</strong>：消息存储实现相关类</li><li><strong>style</strong>：checkstyle相关实现</li><li><strong>test</strong>：测试相关类</li><li><strong>tools</strong>：工具类，监控命令相关实现类</li></ul><h2 id="3-2-检查Maven配置"><a href="#3-2-检查Maven配置" class="headerlink" title="3.2 检查Maven配置"></a>3.2 检查Maven配置</h2><p>拉下来之后不要急着调配置，我们先检查idea里面的Maven配置是否被重置，如果被重置了就改回来，另外最好检查一下当前使用的项目编译版本， IDEA 经常会用内置的JDK版本对项目编译，个人也因为这个问题浪费了不少时间。</p><p>总而言之，拉下项目做下面三件事：</p><ul><li>编译，检查是否报错</li><li>检查JDK版本</li><li>检查Maven配置，以及Maven所用JDK打包版本（在setting里可以看到）。</li><li>反复检查，确保无误。</li></ul><h2 id="3-3-设置NameServ"><a href="#3-3-设置NameServ" class="headerlink" title="3.3 设置NameServ"></a>3.3 设置NameServ</h2><p>首先是设置命名服务，这是Producer发送消息必要服务之一。</p><p>这一步核心步骤就两个：</p><ul><li>启动参数设置 <code>ROCKETMQ_HOME</code> ，如果不会设置就直接项目的根路径，但还是建议设置一个单独目录里面方便后续观察。</li><li>设置<code>logback_namesrv.xml</code>，它所在的路径必须跟 <code>ROCKETMQ_HOME</code> 相同，否则 <code>NameServ</code> 启动会报错。</li></ul><p>设置<code>ROCKETMQ</code>运行主目录，Mac系统和Window设置出来的路径不一样，个人使用Windows作为案例，所以设置的路径为：<code>E:\adongstack\project\selfUp\rocketmq-adong</code></p><ol><li>接着我们进入 NameSer 这个项目，直接跑<code>org.apache.rocketmq.namesrv.NamesrvStartup#main()</code>方法，不出意外会给一个提示：</li></ol><blockquote><p>Please set the ROCKETMQ_HOME variable in your environment to match the location of the RocketMQ installation</p></blockquote><p>日志非常简洁明了，要求设置 <code>ROCKETMQ_HOME</code>，但是要设置在哪里，怎么设置？</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220826155828.png" alt=""></p><ol start="2"><li>运行过一次<code>org.apache.rocketmq.namesrv.NamesrvStartup#main()</code>方法之后，Idea会有历史启动记录保留，这时候可以对于启动参数进行配置：</li></ol><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220826160028.png" alt=""></p><ol start="3"><li>点击启动参数Env…..，然后在里面配置前文提到的<code>ROCKETMQ_HOME</code>，这里个人设置了独立路径，建议读者尝试的时候用一个单独的空文件目录，方便后期查找。</li></ol><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220826160215.png" alt=""></p><ol start="4"><li>注意新版本IDEA的按钮位置变了，点击“+”号之后，填充参数。</li></ol><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220826160352.png" alt=""></p><ol start="5"><li>确认之后，会发现下面的效果。然后继续运行<code>Main()</code>方法。</li></ol><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220826160453.png" alt="路径配置结果"></p><p>但是很遗憾，还是报错，日志提示需要<code>logback_namesrv.xml</code>，实际上就是logback的日志配置文件，我们可以从源代码的<code>E:\adongstack\project\selfUp\rocketmq-adong\distribution\conf\logback_namesrv.xml</code>（个人路径为例）找到这个文件的配置。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220826164323.png" alt=""></p><ol start="6"><li>因为不知道文件放在哪里，我们尝试把项目的<code>logback_namesrv.xml</code>配置放到下面这个位置，看看什么效果。</li></ol><blockquote><p>logback的配置这里就不介绍了，可以自行查阅官方文档或者上网查查资料了解配置含义。</p></blockquote><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220826164712.png" alt=""></p><p>然而这种配置方式<strong>是错的</strong>，实际上我们要移动配置到 <strong>ROCKETMQ_HOME</strong> 所在目录中。日志报错会引导我们进行正确改进。</p><ol start="7"><li>最后尝试执行<code>org.apache.rocketmq.namesrv.NamesrvStartup#main()</code>方法，成功！打印内容如下。</li></ol><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The Name Server boot success. serializeType=JSON</span><br></pre></td></tr></table></figure><h2 id="3-4-设置Broker"><a href="#3-4-设置Broker" class="headerlink" title="3.4 设置Broker"></a>3.4 设置Broker</h2><p>Broker负责持久化队列消息，以及从NameServ 中寻找路由信息，Producer 借助NameServ 找到Broker之后会推送消息，Broker成功收到消息后通知Producer消息发送成功。</p><p>这一步设置比较关键，仔细观察配置。</p><p>设置Broker主要考虑两点，第一点是<code>broker.conf</code>配置，第二点是配置Broker的logback的xml日志文件。</p><p>接着我们设置 Broker ，Broker的启动入口在<code>src/main/java/org/apache/rocketmq/broker/BrokerStartup.java</code>，一上来我们先不急着改启动环境的参数，而是先把 Broker 的关键配置改了，<strong>主要设置 NameServer 的地址、Broker 的名称等相关属性</strong>，这些依赖配置文件<code>broker.conf</code>。</p><p>首先我们要先查自己本地回环网卡的IP地址（就是s你上网那张网卡的IP），比如我的IP是<code>192.168.0.6</code>。</p><p>有了IP之后，我们可以先备份一份<code>distribution/conf/broker.conf</code>文件，然后修改里面的配置：</p><blockquote><p>也可以直接复制一份<code>distribution/conf/broker.conf</code>配置到 <strong>ROCKETMQ_HOME</strong>然后再进行改动，这里仅仅是个人习惯问题，方便日后直接在项目里面立马可以看到自己定义的配置。</p></blockquote><p><code>broker.conf</code>官方给的默认配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">brokerClusterName &#x3D; DefaultCluster  </span><br><span class="line">brokerName &#x3D; broker-a  </span><br><span class="line">brokerId &#x3D; 0  </span><br><span class="line">deleteWhen &#x3D; 04  </span><br><span class="line">fileReservedTime &#x3D; 48  </span><br><span class="line">brokerRole &#x3D; ASYNC_MASTER  </span><br><span class="line">flushDiskType &#x3D; ASYNC_FLUSH</span><br></pre></td></tr></table></figure><p><code>broker.conf</code>修改之后的配置，注意有新增内容，个人命名为<code>broker-back.conf</code>：</p><blockquote><p>这些配置都可以从源代码的配置文件里面找到对应的参数属性。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 使用如下配置文件  </span><br><span class="line">brokerClusterName &#x3D; DefaultCluster  </span><br><span class="line">brokerName &#x3D; broker-a  </span><br><span class="line">brokerId &#x3D; 0  </span><br><span class="line">deleteWhen &#x3D; 04  </span><br><span class="line">fileReservedTime &#x3D; 48  </span><br><span class="line">brokerRole &#x3D; ASYNC_MASTER  </span><br><span class="line">flushDiskType &#x3D; ASYNC_FLUSH  </span><br><span class="line">storePathRootDir&#x3D;E:\\adongstack\\project\\selfUp\\rocketmq-adong\\tmp\\run-dev\\store  </span><br><span class="line">storePathCommitLog&#x3D;E:\\adongstack\\project\\selfUp\\rocketmq-adong\\tmp\\run-dev\\store\\commitlog  </span><br><span class="line"># 重点内容</span><br><span class="line">namesrvAddr&#x3D;127.0.0.1:9876  </span><br><span class="line">brokerIP1&#x3D;192.168.0.6  </span><br><span class="line">brokerIP2&#x3D;192.168.0.6  </span><br><span class="line">autoCreateTopicEnable&#x3D;true</span><br></pre></td></tr></table></figure><blockquote><p>为啥是 store 和 store\commitlog，一个是Broker的持久化仓库地址，一个是提交日志存储地址，这里建议分开，RocketMq的commitlog使用的是追加写入的方式。</p></blockquote><p>注意网上有一些教程的配置文件内容可能比这份文件要多一些，其实只是更加细化的配置而已，这些简单的配置足够我们调试最简单的源码。</p><p>修改完成之后，我们同样把<strong>distribution/conf/logback_brokerxml</strong> 以及 <strong>broker.conf</strong>拷贝到 <code>ROCKETMQ_HOME</code>当中。经过这么一番操作配置，最终结果如下：</p><blockquote><p>这里把所有的配置放到一个文件夹里面，方便管理，截图所属文件的根路径是<code>E:\adongstack\project\selfUp\rocketmq-adong\tmp\run-dev</code></p></blockquote><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220826173454.png" alt=""></p><p>解剖路径如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># `E:\adongstack\project\selfUp\rocketmq-adong\tmp\run-dev`//.....</span></span><br><span class="line"><span class="meta">-</span> <span class="string">store</span></span><br><span class="line"><span class="meta">-</span> <span class="string">commitlog</span></span><br><span class="line"><span class="meta">-</span> <span class="string">broker.conf</span></span><br><span class="line"><span class="meta">-</span> <span class="string">logback_broker.xml</span></span><br><span class="line"><span class="meta">-</span> <span class="string">logback_namesrv.xml</span></span><br></pre></td></tr></table></figure><p>最后，我们在<code>cc</code>的启动参数进行如下配置：</p><p><code>-c 启动参数</code> 对应conf配置文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-c E:\\adongstack\\project\\selfUp\\rocketmq-adong\\tmp\\run-dev\\broker.conf</span><br></pre></td></tr></table></figure><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220826205432.png" alt="BrokerStartup启动参数"></p><p>最后再运行一遍<code>BrokerStartup</code>的main方法，出现下面的内容说明配置成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The broker[broker-a, 192.168.0.103:10911] boot success. serializeType&#x3D;JSON and name server is 127.0.0.1:9876</span><br></pre></td></tr></table></figure><h2 id="3-5-运行测试"><a href="#3-5-运行测试" class="headerlink" title="3.5 运行测试"></a>3.5 运行测试</h2><p>首先我们把前面两个小节配置的NameServ和Broker的配置进行启动：</p><p>Broker 启动打印：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The broker[broker-a, <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10911</span>] boot success. serializeType=JSON and name server is <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9876</span></span><br></pre></td></tr></table></figure><p>NameServ 启动打印：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The Name Server boot success. serializeType=JSON</span><br></pre></td></tr></table></figure><p>接着是使用Producer做测试，这里使用的是<code>org.apache.rocketmq.example.quickstart.Producer#main()</code>方法，注意这个案例是不能够直接拿来用的，因为我们使用debug模式，<strong>需要放开一行注释代码</strong>。</p><p>因为上面的所有配置都是使用官方推荐的默认配置，所以需要只需要放开这一段注释，默认连接的NameServ 端口是 9876。</p><blockquote><p>// Uncomment the following line while debugging, namesrvAddr should be set to your local address<br>  // 调试时取消注释以下行，namesrvAddr 应设置为您的本地地址，读者第一次看到这里应该是注释过的<br>  producer.setNamesrvAddr(DEFAULT_NAMESRVADDR);</p></blockquote><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220826215646.png" alt=""></p><p>Producer的最终打印结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SendResult [sendStatus=SEND_OK, msgId=<span class="number">7F</span>000001858818B4AAC28569CA6C0000, offsetMsgId=<span class="number">7F</span>00000100002A9F00000000000000EF, messageQueue=MessageQueue [topic=TopicTest, brokerName=broker-a, queueId=<span class="number">0</span>], queueOffset=<span class="number">1</span>]</span><br><span class="line"><span class="number">21</span>:<span class="number">45</span>:<span class="number">02.846</span> [NettyClientSelector_1] INFO RocketmqRemoting - closeChannel: close the connection to remote address[<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9876</span>] result: <span class="keyword">true</span></span><br><span class="line"><span class="number">21</span>:<span class="number">45</span>:<span class="number">02.848</span> [NettyClientSelector_1] INFO RocketmqRemoting - closeChannel: close the connection to remote address[<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10911</span>] result: <span class="keyword">true</span></span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>IDEA 部署源代码整体流程比较简单，比较麻烦的反而是一些运行参数的配置上。另外github现在连接十分不稳定，建议用国内的一些代码管理网站进行同步，gitee、coding 都可以。</p><p>需要注意进行测试的时候一定要把注释放开，否则会一直出现Producer连不上的报错异常。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      部署和使用RocketMq
    
    </summary>
    
    
      <category term="RocketMq" scheme="https://whitestore.top/categories/RocketMq/"/>
    
    
      <category term="RocketMq" scheme="https://whitestore.top/tags/RocketMq/"/>
    
  </entry>
  
  <entry>
    <title>【RocketMq】商用RocketMq和开源RocketMq的兼容问题解决方案</title>
    <link href="https://whitestore.top/2023/03/11/shangyong/"/>
    <id>https://whitestore.top/2023/03/11/shangyong/</id>
    <published>2023-03-10T23:21:11.000Z</published>
    <updated>2023-06-15T13:10:39.213Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在阿里云的官方网站提供了RocketMq的商用版本，但是个人在项目应用上发现和SpirngBoot以及Spring Cloud（Alibaba）等开源的RocketMQ依赖虽然可以正常兼容，但是依然出现了注解失效、启动报错，商用和开源版本的不兼容导致部分代码要重复编写的蛋疼问题。</p><p>这样的兼容问题不是简单加个SDK依赖，切换到商用配置就可以直接使用的（因为个人起初真就是这么想），为了避免后面再遇到这种<strong>奇葩</strong>的开发测试用开源RocketMq，生产环境需要使用商用集群的RocketMq的混合配置的业务场景，个人花了小半天时间熟读阿里云的接入文档，加上各种尝试和测试，总结出一套可以快速使用的兼容模板方案。</p><p>如果不了解阿里云商用RocketMq，可以看最后一个大节的【阿里云商用RocketMq介绍】介绍。个人的兼容方案灵感来自于官方提供的这个DEMO项目：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FsaXdhcmVNUS9tcS1kZW1vL3RyZWUvbWFzdGVyL3NwcmluZ2Jvb3QvamF2YS1zcHJpbmdib290LWRlbW8=" title="https://github.com/AliwareMQ/mq-demo/tree/master/springboot/java-springboot-demo">springboot/java-springboot-demo<i class="fa fa-external-link"></i></span>。</p><p>注意本方案是基于<strong>SpringBoot2.X</strong>和 <strong>Spring cloud Alibaba</strong> 的两个项目环境构建项目基础，在SpringBoot上只做了生产者的配置，而在Spring Cloud Alibaba的Nacos上进行了生产者和消费者的完整兼容方案。</p><p>最后注意兼容集成的版本为商用RocketMq使用<strong>4.x</strong>版本，最近新出的5.X 的版本并<strong>未进行测试</strong>，不保证正常使用。</p><a id="more"></a><h1 id="兼容关键点"><a href="#兼容关键点" class="headerlink" title="兼容关键点"></a>兼容关键点</h1><ol><li>在沿用SpringBoot的YML基础配置基础上实现商用和开源模式的兼容。</li><li>商用RocketMq需要使用官方提供的依赖包，依赖包可以正常兼容SpringBoot等依赖。</li><li>集成之后便于开发和扩展，并且易于其他开发人员理解。</li><li>两种模式之间互相不会产生干扰。</li></ol><h1 id="SpringBoot2-X-兼容"><a href="#SpringBoot2-X-兼容" class="headerlink" title="SpringBoot2.X 兼容"></a>SpringBoot2.X 兼容</h1><p>下面先介绍<strong>SpringBoot项目</strong>的兼容。</p><h2 id="SpringBoot项目兼容"><a href="#SpringBoot项目兼容" class="headerlink" title="SpringBoot项目兼容"></a>SpringBoot项目兼容</h2><h3 id="开源版本"><a href="#开源版本" class="headerlink" title="开源版本"></a>开源版本</h3><p>首先我们观察YAML文件，对于<strong>开源版本的RocketMq</strong>设置，单机版本可以直接配置一个ip和端口即可，如果是集群则用分号隔开多个NameServer的连接IP地址（NameServ独立部署，内部进行自动同步 ）。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#消息队列</span></span><br><span class="line"><span class="attr">rocketmq:</span></span><br><span class="line">  <span class="comment"># 自定义属性，作用下文将会进行解释</span></span><br><span class="line">  <span class="attr">use-aliyun-rocketSever:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">name-server:</span> <span class="number">192.168</span><span class="number">.58</span><span class="number">.128</span><span class="string">:9876</span> <span class="comment"># 192.168.244.128:9876;192.168.244.129:9876;</span></span><br><span class="line">  <span class="attr">producer:</span></span><br><span class="line">    <span class="attr">group:</span> <span class="string">testGroup</span></span><br><span class="line">    <span class="comment"># 本地开发不使用商业版，可以不配置</span></span><br><span class="line">    <span class="attr">secret-key:</span> <span class="string">NONE</span></span><br><span class="line">    <span class="comment"># 本地开发不使用商业版，可以不配置</span></span><br><span class="line">    <span class="attr">access-key:</span> <span class="string">NONE</span></span><br><span class="line">    <span class="comment"># 商用版本请求超时时间，开源版本不使用此参数</span></span><br><span class="line">    <span class="attr">timeoutMillis:</span> <span class="string">NONE</span></span><br></pre></td></tr></table></figure><p>SpringBoot中集成开源的RocketMq非常简单，只需要一个依赖就可以自动完成相关准备：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-spring-boot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>具体的使用通常为封装或者直接使用<code>RocketMqTemplate</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RocketMQTemplate mqTemplate;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendRocketMqUniqueTextMessage</span><span class="params">(String topic, String tag, String queueMsg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(topic) &amp;&amp; StringUtils.isNotEmpty(tag) &amp;&amp; StringUtils.isNotEmpty(queueMsg)) &#123;</span><br><span class="line">            String queueName = topic + <span class="string">":"</span> + tag;</span><br><span class="line">            <span class="comment">//封装消息，分配唯一id</span></span><br><span class="line">            MessageData messageData = <span class="keyword">new</span> MessageData();</span><br><span class="line">            messageData.setMsgId(IdUtil.randomUUID());</span><br><span class="line">            messageData.setMsgContent(queueMsg);</span><br><span class="line">            queueMsg = JSON.toJSONString(messageData);</span><br><span class="line">            log.info(<span class="string">"线程：&#123;&#125;，向队列：&#123;&#125;，发送消息：&#123;&#125;"</span>, Thread.currentThread()</span><br><span class="line">                    .getName(), queueName, queueMsg);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mqTemplate.syncSend(queueName, queueMsg);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.info(<span class="string">"向队列：&#123;&#125;，发送消息出现异常：&#123;&#125;"</span>, queueName, queueMsg);</span><br><span class="line">                <span class="comment">//出现异常，保存异常信息到数据库</span></span><br><span class="line">                SaMqMessageFail saMqMessageFail = <span class="keyword">new</span> SaMqMessageFail();</span><br><span class="line">                <span class="comment">// 封装失败消息，调用失效处理Service将失败发送请求入库，或许通过其他方法重试</span></span><br><span class="line">                saMqMessageFailService.insert(saMqMessageFail);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>开源版本的SpringBoot集成RocketMq就是如此简单。</p><h3 id="商用版本"><a href="#商用版本" class="headerlink" title="商用版本"></a>商用版本</h3><p>商用版本RocketMq我们使用<span class="exturl" data-url="aHR0cHM6Ly9oZWxwLmFsaXl1bi5jb20vZG9jdW1lbnRfZGV0YWlsLzI5NTQ0Lmh0bWw=" title="https://help.aliyun.com/document_detail/29544.html">商业版TCP协议SDK（推荐）<i class="fa fa-external-link"></i></span>，注意这里用的是<strong>4.X版本</strong>。商用版本的YAML配置和开源版本<strong>显式配置</strong>是一样的，但是需要注意参数<code>use-aliyun-rocketSever=true</code>，并且<code>secretKey</code>和<code>accessKey</code>以及<code>name-server</code>都需要配置为阿里云提供的配置，最后设置消息发送超时时间<code>timeoutMillis</code>设置合理时间（单位为毫秒），便于排查问题和防止线程长期占用：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#消息队列</span></span><br><span class="line"><span class="attr">rocketmq:</span></span><br><span class="line">  <span class="attr">use-aliyun-rocketSever:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 使用阿里云提供的endpoint</span></span><br><span class="line">  <span class="attr">name-server:</span> <span class="string">http://xxxxx.aliyuncs.com:8080</span></span><br><span class="line">  <span class="attr">producer:</span></span><br><span class="line">    <span class="attr">group:</span> <span class="string">testGroup</span></span><br><span class="line">    <span class="attr">secret-key:</span> <span class="string">xxx</span></span><br><span class="line">    <span class="attr">access-key:</span> <span class="string">xxxx</span></span><br><span class="line">    <span class="comment"># 商用版本请求超时时间</span></span><br><span class="line">    <span class="attr">timeoutMillis:</span> <span class="number">15000</span></span><br><span class="line">  <span class="comment"># 如果需要设置消费者，可以按照同样的方式集成</span></span><br><span class="line">  <span class="attr">consumer:</span></span><br><span class="line">  <span class="attr">group:</span> <span class="string">testGroup</span></span><br><span class="line">    <span class="attr">secret-key:</span> <span class="string">xxx</span></span><br><span class="line">    <span class="attr">access-key:</span> <span class="string">xxxx</span></span><br><span class="line">    <span class="comment"># 商用版本请求超时时间 15秒</span></span><br><span class="line">    <span class="attr">timeoutMillis:</span> <span class="number">15000</span></span><br></pre></td></tr></table></figure><blockquote><p>注意这里仅仅配置了生产者，读者可以按需设置为消费者，设置方式和生产者同理。</p></blockquote><p>设置YAML之后，我们需要在Maven中引入下面的配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun.openservices<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ons-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--以下版本号请替换为Java SDK的最新版本号--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.8.1.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后应该如何使用呢？这里就是商用RocketMq比较蛋疼的点了，使用<code>RocketMQTemplate</code>是这种情况下是无法使用商用RocketMq的，我们需要 <strong>手动注入商用的SDK依赖ProducerBean</strong>，具体的操作如下：</p><ol><li>构建<strong>配置类</strong>，这里仿照了官方提供的demo增减配置：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">阿里云服务配置封装，注意和本地部署的rocketmq配置区分</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"rocketmq"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AliyunRocketMqConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *鉴权需要的AccessKey ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.use-aliyun-rocketSever:null&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String useAliyunRocketMqServerEnable;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *鉴权需要的AccessKey ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.producer.access-key:null&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String accessKey;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *鉴权需要的AccessKey Secret</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.producer.secret-key:null&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String secretKey;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例TCP 协议公网接入地址（实际项目，填写自己阿里云MQ的公网地址）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.name-server:null&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String nameSrvAddr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 延时队列group</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.producer.group:null&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String groupId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息发送超时时间，如果服务端在配置的对应时间内未ACK，则发送客户端认为该消息发送失败。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.producer.timeoutMillis:null&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String timeoutMillis;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取Properties</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Properties <span class="title">getRocketMqProperty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.setProperty(PropertyKeyConst.GROUP_ID,<span class="keyword">this</span>.getGroupId());</span><br><span class="line">        properties.setProperty(PropertyKeyConst.AccessKey, <span class="keyword">this</span>.accessKey);</span><br><span class="line">        properties.setProperty(PropertyKeyConst.SecretKey, <span class="keyword">this</span>.secretKey);</span><br><span class="line">        properties.setProperty(PropertyKeyConst.NAMESRV_ADDR, <span class="keyword">this</span>.nameSrvAddr);</span><br><span class="line">        properties.setProperty(PropertyKeyConst.SendMsgTimeoutMillis, <span class="keyword">this</span>.timeoutMillis);</span><br><span class="line">        <span class="keyword">return</span> properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>构建商用RocketMq初始化类。这里会遇到<strong>比较蛋疼的事情</strong>，因为我们的依赖是商用RocketMq与开源的SpringBoot依赖共存的，虽然我们可以商用的RocketMq，但是启动的时候会执行到此类进行初始化，<strong>返回NULL会导致SpringBoot项目无法正常启动</strong>，这里无奈只能使用一个warn日志进行提示开源版本有可能出现Bean被覆盖问题，实际上使用下来没有特别大的影响。</li></ol><blockquote><p> 写的比较丑陋，读者有更优雅的处理方式欢迎指导。笔者目前只想到了使用这种“不管”的方式保证项目不改任何代码的情况正常运行。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 阿里云rocketMq初始化</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AliyunProducerInit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AliyunRocketMqConfig aliyunRocketMqConfig;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(initMethod = <span class="string">"start"</span>, destroyMethod = <span class="string">"shutdown"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProducerBean <span class="title">buildProducer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!Boolean.valueOf(aliyunRocketMqConfig.getUseAliyunRocketMqServerEnable()))&#123;</span><br><span class="line">            log.warn(<span class="string">"非商用版本为了兼容依然需要注入此Bean，但是只读取有关nameServ和group信息"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ProducerBean producer = <span class="keyword">new</span> ProducerBean();</span><br><span class="line">        <span class="comment">// ProducerBean中的properties只有被覆盖的配置会使用自定义配置，其他配置会使用SDK的默认配置。</span></span><br><span class="line">        producer.setProperties(aliyunRocketMqConfig.getRocketMqProperty());</span><br><span class="line">        <span class="keyword">return</span> producer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外这里必须要吐槽一下商用RocketMq的注释居然是<strong>全中文</strong>的！比如<code>com.aliyun.openservices.ons.api.bean.ProducerBean</code>的注释：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/image-20221229195508260.png" alt="producerBean"></p><blockquote><p> 这样是好事还是坏事，大家自行体会。。。。。个人第一次看到的时候着实被震惊了。</p></blockquote><ol start="3"><li>做完上面两步之后，我们就可以实现<code>RocketMqTemplate</code>调用请求，至此完成兼容。</li></ol><h2 id="SpringBoot项目兼容小结"><a href="#SpringBoot项目兼容小结" class="headerlink" title="SpringBoot项目兼容小结"></a>SpringBoot项目兼容小结</h2><p>这里简单小结一下SpringBoot的兼容过程，可以看到整个步骤仅仅是 在商用RocketMq多做了一步bean注入的操作而已，整体使用上十分简单。但是这里只介绍了生产者的集成，那么消费者如何兼容？稍安勿躁，我们接着看Spring Cloud版本的集成案例。</p><h2 id="Spring-Cloud-Alibaba项目兼容"><a href="#Spring-Cloud-Alibaba项目兼容" class="headerlink" title="Spring Cloud Alibaba项目兼容"></a>Spring Cloud Alibaba项目兼容</h2><p>目前国内使用的比较多的是<strong>Spring Cloud Alibaba</strong>，注意这些配置都写入到Nacos当中。</p><h3 id="开源版本-1"><a href="#开源版本-1" class="headerlink" title="开源版本"></a>开源版本</h3><p>开源版本的接入方式和SpringBoot是一样的，这里简单回顾：</p><ol><li>开源版本需要设置参数，这里设置了生产者和消费者：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#消息队列 - 开源版本</span></span><br><span class="line"><span class="attr">rocketmq:</span></span><br><span class="line">  <span class="attr">use-aliyun-rocketSever:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">name-server:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.92</span><span class="string">:9876</span></span><br><span class="line">  <span class="attr">producer:</span></span><br><span class="line">    <span class="attr">group:</span> <span class="string">testGroup</span></span><br><span class="line">    <span class="attr">secret-key:</span> <span class="string">NONE</span></span><br><span class="line">    <span class="attr">access-key:</span> <span class="string">NONE</span></span><br><span class="line">    <span class="attr">timeoutMillis:</span> <span class="number">15000</span></span><br><span class="line">    <span class="attr">consumeThreadNums:</span> <span class="number">20</span></span><br><span class="line">  <span class="attr">consumer:</span></span><br><span class="line">    <span class="attr">group:</span> <span class="string">testGroup</span></span><br><span class="line">    <span class="attr">secret-key:</span> <span class="string">NONE</span></span><br><span class="line">    <span class="attr">access-key:</span> <span class="string">NONE</span></span><br><span class="line">    <span class="attr">timeoutMillis:</span> <span class="number">15000</span></span><br><span class="line">    <span class="attr">consumeThreadNums:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><ol start="2"><li>添加依赖：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-spring-boot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>使用<code>RocketMqTemplate</code>可以进行消息发送，而消费者则需要使用监听器+注解的方式，快速注入一个消费者。大体模板如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener</span>(topic = <span class="string">"test_topic"</span>, consumerGroup = <span class="string">"testGroup"</span>, selectorExpression = <span class="string">"test_tag"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueRemoteRecoListener</span> <span class="keyword">implements</span> <span class="title">RocketMQListener</span>&lt;<span class="title">MessageExt</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(MessageExt message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dosomething</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="商用版本-1"><a href="#商用版本-1" class="headerlink" title="商用版本"></a>商用版本</h3><p>这节是本文稍微复杂一点的部分，我们按照步骤介绍接入过程：</p><ol><li>在Nacos的配置中加入RocketMq商用所需的配置内容，和开源版本的设置类似：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#消息队列 - 商用版本</span></span><br><span class="line"><span class="attr">rocketmq:</span></span><br><span class="line"> <span class="comment"># 开源RocketMq和商业版RocketMq切换开关</span></span><br><span class="line"><span class="attr">use-aliyun-rocketSever:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">name-server:</span> <span class="string">http://xxxx.mq.aliyuncs.com:80</span></span><br><span class="line"><span class="attr">producer:</span></span><br><span class="line"><span class="comment"># 目前uat借助开发测试使用</span></span><br><span class="line">  <span class="attr">group:</span> <span class="string">testGroup</span></span><br><span class="line">  <span class="attr">secret-key:</span> <span class="string">xxx</span></span><br><span class="line">  <span class="attr">access-key:</span> <span class="string">xxx</span></span><br><span class="line">  <span class="attr">timeoutMillis:</span> <span class="number">15000</span></span><br><span class="line">  <span class="attr">consumeThreadNums:</span> <span class="number">20</span></span><br><span class="line"><span class="attr">consumer:</span></span><br><span class="line">  <span class="attr">group:</span> <span class="string">testGroup</span></span><br><span class="line">  <span class="attr">secret-key:</span> <span class="string">xxx</span></span><br><span class="line">  <span class="attr">access-key:</span> <span class="string">xxx</span></span><br><span class="line">  <span class="attr">timeoutMillis:</span> <span class="number">15000</span></span><br><span class="line">  <span class="attr">consumeThreadNums:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><ol start="2"><li>添加商用RocketMq的TCP接入方式需要的依赖包。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun.openservices<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ons-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--以下版本号请替换为Java SDK的最新版本号--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.8.1.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>新增<strong>配置类</strong>，和SpringBoot的商用版本方式也是类似的：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * rocketmq 阿里云服务配置封装，注意和本地部署的rocketmq配置区分</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"rocketmq"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AliyunCommercialRocketMqConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *鉴权需要的AccessKey ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.use-aliyun-rocketSever:null&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String useAliyunRocketMqServerEnable;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *鉴权需要的AccessKey ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.consumer.access-key:null&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String accessKey;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.use-aliyun-rocketsever:null&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String useAliyunRocketServer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *鉴权需要的AccessKey Secret</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.consumer.secret-key:null&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String secretKey;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例TCP 协议公网接入地址（实际项目，填写自己阿里云MQ的公网地址）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.name-server:null&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String nameSrvAddr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 延时队列group</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.consumer.group:null&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String groupId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息发送超时时间，如果服务端在配置的对应时间内未ACK，则发送客户端认为该消息发送失败。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.consumer.timeoutMillis:null&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String timeoutMillis;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将消费者线程数固定为20个 20为默认值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;rocketmq.consumer.consumeThreadNums:null&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String consumeThreadNums;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Properties <span class="title">getRocketMqProperty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.setProperty(PropertyKeyConst.GROUP_ID,<span class="keyword">this</span>.getGroupId());</span><br><span class="line">        properties.setProperty(PropertyKeyConst.AccessKey, <span class="keyword">this</span>.accessKey);</span><br><span class="line">        properties.setProperty(PropertyKeyConst.SecretKey, <span class="keyword">this</span>.secretKey);</span><br><span class="line">        properties.setProperty(PropertyKeyConst.NAMESRV_ADDR, <span class="keyword">this</span>.nameSrvAddr);</span><br><span class="line">        properties.setProperty(PropertyKeyConst.SendMsgTimeoutMillis, <span class="keyword">this</span>.timeoutMillis);</span><br><span class="line">        <span class="keyword">return</span> properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>下一步是扩展官方<strong>消息订阅类</strong>，为啥要这样做？主要是接入实验中发现官方的消息订阅类没有 <strong>全量参数</strong>的构造器，难以对于消息订阅类<strong>静态参数化</strong>常量，构造一个订阅消息使用默认方式还需要static代码块设置。所以这里对于官方的消息订阅类进行扩展，子类代码是对于父类拷贝了一遍，没有做其他改动：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">对于指定类进行扩展，更容易的初始化</span></span><br><span class="line"><span class="comment"><span class="doctag">@see</span> com.aliyun.openservices.ons.api.bean.Subscription 被扩展类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AliyunCommercialRocketMqSubscriptionExt</span> <span class="keyword">extends</span> <span class="title">Subscription</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String topic;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 条件表达式，具体参考rocketmq</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String expression;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * TAG or SQL92</span></span><br><span class="line"><span class="comment">     * &lt;br&gt;if null, equals to TAG</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.aliyun.openservices.ons.api.ExpressionType#TAG</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.aliyun.openservices.ons.api.ExpressionType#SQL92</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> prime = <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        result = prime * result + ((topic == <span class="keyword">null</span>) ? <span class="number">0</span> : topic.hashCode());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getClass() != obj.getClass()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        AliyunCommercialRocketMqSubscriptionExt other = (AliyunCommercialRocketMqSubscriptionExt) obj;</span><br><span class="line">        <span class="keyword">if</span> (topic == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (other.topic != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!topic.equals(other.topic)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>接着我们构建静态化的消息订阅类，这个常量类会封装系统需要使用到的消息订阅对象，在后续注册监听器需要使用，这里先提前定义。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 队列常规配置，用于启动时候初始化配置，</span></span><br><span class="line"><span class="comment"> * 所有配置均需要放置到此类中对外扩展使用</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AliyunCommercialRocketMqConstants</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TEST_TOPIC = <span class="string">"test_topic"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TEST_TAG = <span class="string">"test_tag"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参考案例，仅仅作为开发验证使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> AliyunCommercialRocketMqSubscriptionExt QUEUE_TEST = <span class="keyword">new</span> AliyunCommercialRocketMqSubscriptionExt(RocketMqKey.TEST_TOPIC, RocketMqKey.TEST_TAG, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了方便管理，我们可以把这些关键Key在单独放到一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RocketMqKey</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TEST_TOPIC = <span class="string">"test_topic"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TEST_TAG = <span class="string">"test_tag"</span>;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 队列常规配置，用于启动时候初始化配置，</span></span><br><span class="line"><span class="comment"> * 所有配置均需要放置到此类中对外扩展使用</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AliyunCommercialRocketMqConstants</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参考案例，仅仅作为开发验证使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> AliyunCommercialRocketMqSubscriptionExt QUEUE_TEST = <span class="keyword">new</span> AliyunCommercialRocketMqSubscriptionExt(RocketMqKey.TEST_TOPIC, RocketMqKey.TEST_TAG, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>做好一系列准备之后，我们开始<strong>商用版本生产者兼容</strong>，商用版本的发送者可以像是下面这样封装官方提供的demo，也可以使用<strong>注入ProducerBean</strong>的方式集成：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 商用aliyun Rocketmq 工具类封装</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AliyunCommercialRocketMqSendUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> KEEP_ALIVE_TIME = <span class="number">60L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadPoolExecutor THREAD_POOL_EXECUTOR = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">            KEEP_ALIVE_TIME, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> SynchronousQueue&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Producer producer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SaMqMessageFailService saMqMessageFailService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AliyunRocketMqConfig aliyunRocketMqConfig;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异步推送，需要调用方手动指定callback</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singleAsyncSend</span><span class="params">(String topic, String tag, String msgBody, SendCallback sendCallback)</span> </span>&#123;</span><br><span class="line">        singleAsyncSend(topic, tag, msgBody, <span class="keyword">null</span>, sendCallback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异步推送，需要调用方手动指定callback</span></span><br><span class="line"><span class="comment">     * 如果需要使用callback通知，可以使用下面的代码进行处理</span></span><br><span class="line"><span class="comment">     &lt;pre&gt;</span></span><br><span class="line"><span class="comment">         producer.sendAsync(msg, new SendCallback() &#123;</span></span><br><span class="line"><span class="comment">        <span class="doctag">@Override</span></span></span><br><span class="line"><span class="comment">        public void onSuccess(final SendResult sendResult) &#123;</span></span><br><span class="line"><span class="comment">            assert sendResult != null;</span></span><br><span class="line"><span class="comment">            System.out.println(sendResult);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        <span class="doctag">@Override</span></span></span><br><span class="line"><span class="comment">        public void onException(final OnExceptionContext context) &#123;</span></span><br><span class="line"><span class="comment">            ONSClientException exception = context.getException();</span></span><br><span class="line"><span class="comment">            //                    //出现异常意味着发送失败，为了避免消息丢失，建议缓存该消息然后进行重试。</span></span><br><span class="line"><span class="comment">            log.error("【RocketMq-Commercial】发送失败，消息存储到失败记录表，发送 topic =&gt; &#123;&#125;, 发送 tag =&gt; &#123;&#125;， msgBody =&gt; &#123;&#125;， key =&gt; &#123;&#125;（如果设置key，可以使用key查找消息）,商用版需要在RocketMq云服务重试，失败原因为: &#123;&#125;"</span></span><br><span class="line"><span class="comment">            , topic, tag, msgBody, key, exception.getMessage());</span></span><br><span class="line"><span class="comment">            buildMqErrorInfoAndInsertDb(msgBody, exception);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;);</span></span><br><span class="line"><span class="comment">     &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> topic 主题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: tag  标签</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: msgBody 推送消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: key 方便消息查找的key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: sendCallback 手动回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singleAsyncSend</span><span class="params">(String topic, String tag, String msgBody, String key, SendCallback sendCallback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Boolean.FALSE.equals(Boolean.valueOf(aliyunRocketMqConfig.getUseAliyunRocketMqServerEnable())))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"请设置 UseAliyunRocketServer=true 切换到商用rocketMq模式"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isAnyBlank(topic, tag, msgBody)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"topic, tag and msgBody must be not blank"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对于使用异步接口，建议设置单独的回调处理线程池，拥有更灵活的配置和监控能力。</span></span><br><span class="line">        <span class="comment">//如下构造线程的方式请求队列为无界仅用作示例，有OOM的风险。</span></span><br><span class="line">        <span class="comment">//更合理的构造方式请参考阿里巴巴Java开发手册： https://github.com/alibaba/p3c</span></span><br><span class="line">        producer.setCallbackExecutor(THREAD_POOL_EXECUTOR);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环发送消息</span></span><br><span class="line">        Message msg = <span class="keyword">new</span> Message( <span class="comment">//</span></span><br><span class="line">                <span class="comment">// Message所属的Topic</span></span><br><span class="line">                topic,</span><br><span class="line">                <span class="comment">// Message Tag 可理解为Gmail中的标签，对消息进行再归类，方便Consumer指定过滤条件在MQ服务器过滤</span></span><br><span class="line">                tag,</span><br><span class="line">                <span class="comment">// Message Body 可以是任何二进制形式的数据， MQ不做任何干预</span></span><br><span class="line">                <span class="comment">// 需要Producer与Consumer协商好一致的序列化和反序列化方式</span></span><br><span class="line">                msgBody.getBytes());</span><br><span class="line">        <span class="comment">// 设置代表消息的业务关键属性，请尽可能全局唯一</span></span><br><span class="line">        <span class="comment">// 以方便您在无法正常收到消息情况下，可通过MQ 控制台查询消息并补发</span></span><br><span class="line">        <span class="comment">// 注意：不设置也不会影响消息正常收发</span></span><br><span class="line">        <span class="keyword">if</span> (CharSequenceUtil.isNotBlank(key)) &#123;</span><br><span class="line">            msg.setKey(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发送消息，只要不抛异常就是成功</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            producer.sendAsync(msg, sendCallback);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ONSClientException exception) &#123;</span><br><span class="line">            <span class="comment">//出现异常意味着发送失败，为了避免消息丢失，建议缓存该消息然后进行重试。</span></span><br><span class="line">            log.error(<span class="string">"【RocketMq-Commercial】发送失败，消息存储到失败记录表，发送 topic =&gt; &#123;&#125;, 发送 tag =&gt; &#123;&#125;， msgBody =&gt; &#123;&#125;， key =&gt; &#123;&#125;（如果设置key，可以使用key查找消息）,商用版需要在RocketMq云服务重试，失败原因为: &#123;&#125;"</span></span><br><span class="line">                    , topic, tag, msgBody, key, exception.getMessage());</span><br><span class="line">            buildMqErrorInfoAndInsertDb(msgBody, exception);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞单独推送队列，使用系统默认的Key生成规则</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> topic 主题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span> 阻塞单独推送队列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: tag 标签</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: msgBody msgBody内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singleSyncSend</span><span class="params">(String topic, String tag, String msgBody)</span> </span>&#123;</span><br><span class="line">        singleSyncSend(topic, tag, msgBody, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞单独推送队列，使用系统默认的Key生成规则</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> topic 主题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span> 阻塞单独推送队列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: tag 标签</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: msgBody msgBody内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singleSyncSend</span><span class="params">(String topic, String tag, String msgBody, String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!Boolean.valueOf(aliyunRocketMqConfig.getUseAliyunRocketMqServerEnable()))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"请设置 UseAliyunRocketServer=true 切换到商用rocketMq模式"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isAnyBlank(topic, tag, msgBody)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"topic, tag and msgBody must be not blank"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Message msg = <span class="keyword">new</span> Message( <span class="comment">//</span></span><br><span class="line">                <span class="comment">// Message所属的Topic</span></span><br><span class="line">                topic,</span><br><span class="line">                <span class="comment">// Message Tag 可理解为Gmail中的标签，对消息进行再归类，方便Consumer指定过滤条件在MQ服务器过滤</span></span><br><span class="line">                tag,</span><br><span class="line">                <span class="comment">// Message Body 可以是任何二进制形式的数据， MQ不做任何干预</span></span><br><span class="line">                <span class="comment">// 需要Producer与Consumer协商好一致的序列化和反序列化方式</span></span><br><span class="line">                msgBody.getBytes());</span><br><span class="line">        <span class="comment">// 设置代表消息的业务关键属性，请尽可能全局唯一</span></span><br><span class="line">        <span class="comment">// 以方便您在无法正常收到消息情况下，可通过MQ 控制台查询消息并补发</span></span><br><span class="line">        <span class="comment">// 注意：不设置也不会影响消息正常收发</span></span><br><span class="line">        <span class="keyword">if</span> (CharSequenceUtil.isNotBlank(key)) &#123;</span><br><span class="line">            msg.setKey(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发送消息，只要不抛异常就是成功</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SendResult sendResult = producer.send(msg);</span><br><span class="line">            log.info(<span class="string">"【RocketMq-Commercial】推送成功，singleSyncSend =&gt; &#123;&#125;"</span>, JSON.toJSONString(sendResult));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ONSClientException e) &#123;</span><br><span class="line">            log.error(<span class="string">"【RocketMq-Commercial】发送失败，消息存储到失败记录表，发送 topic =&gt; &#123;&#125;, 发送 tag =&gt; &#123;&#125;， msgBody =&gt; &#123;&#125;， key =&gt; &#123;&#125;（如果设置key，可以使用key查找消息）,商用版需要在RocketMq云服务重试，失败原因为: &#123;&#125;"</span></span><br><span class="line">                    , topic, tag, msgBody, key, e.getMessage());</span><br><span class="line">            buildMqErrorInfoAndInsertDb(msgBody, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建mq错误信息，并且插入到异常推送表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msgBody</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span> 构建mq错误信息，并且插入到异常推送表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildMqErrorInfoAndInsertDb</span><span class="params">(String msgBody, ONSClientException e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//出现异常意味着发送失败，为了避免消息丢失，建议缓存该消息然后进行重试。</span></span><br><span class="line">        <span class="comment">//出现异常，保存异常信息到数据库</span></span><br><span class="line">        SaMqMessageFail saMqMessageFail = <span class="keyword">new</span> SaMqMessageFail();</span><br><span class="line">        saMqMessageFail.setMqId(IdUtil.randomUUID());</span><br><span class="line">        saMqMessageFail.setQueueName(<span class="string">"RocketMq-Commercial"</span>);</span><br><span class="line">        saMqMessageFail.setQueueMessage(msgBody);</span><br><span class="line">        <span class="comment">// 2 代表失败</span></span><br><span class="line">        saMqMessageFail.setStatus(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 1 代表重试次数</span></span><br><span class="line">        saMqMessageFail.setProcCount(<span class="number">1</span>);</span><br><span class="line">        saMqMessageFail.setFailReason(e.toString());</span><br><span class="line">        saMqMessageFail.setCreateDate(<span class="keyword">new</span> Date());</span><br><span class="line">        saMqMessageFailService.insert(saMqMessageFail);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注入ProductBean的方式可以从上面提到的SpringBoot集成方式处理。</p></blockquote><ol start="7"><li>现在我们解决之前遗留的问题，如果是消费者，应该如何更优雅的接收消息？首先我们需要明白，商用RocketMq注入是需要依靠手动构建<strong>监听器</strong>，但是我们上面提到SpringBoot提供了<code>注解+ @Component</code>的方式实现队列监听的消费者。此外为了避免和开源版本冲突，我们使用之前参数配置自定义的开关，在遇到开源版本的时候我们<strong>返回null</strong>（这里返回null Spring会扫描获取SpringBoot的RocketMq依赖，不会出现报错和无法启动的问题，和前面的情况略有不同）防止自动注入商用RocketMq的监听器。</li></ol><p>下面是商用版本注入ConsumerBean的代码，订阅商用RocketMq的消费监听器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  阿里云商用Rocketmq 队列接收</span></span><br><span class="line"><span class="comment"> *  商用rocketmqConsumer的所有请求会进入一个入口，需要分发到不同的具体业务处理。</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AliyunCommercialRocketMqQueueConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AliyunCommercialRocketMqConfig aliyunCommercialRocketMqConfig;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义的监听器</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AliyunCommerciaRocketMqTestListener aliyunCommerciaRocketMqTestListener;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(initMethod = <span class="string">"start"</span>, destroyMethod = <span class="string">"shutdown"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConsumerBean <span class="title">buildConsumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果开关为false, 则不能注入此对象，否则商用的API会顶替掉 框架诸如的Bean出现异常</span></span><br><span class="line">        <span class="keyword">if</span>(!Boolean.valueOf(aliyunCommercialRocketMqConfig.getUseAliyunRocketServer()))&#123;</span><br><span class="line">            log.warn(<span class="string">"非商用版本不注入商用版本监听器"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ConsumerBean consumerBean = <span class="keyword">new</span> ConsumerBean();</span><br><span class="line">        <span class="comment">//配置文件</span></span><br><span class="line">        Properties properties = aliyunCommercialRocketMqConfig.getRocketMqProperty();</span><br><span class="line">        properties.setProperty(PropertyKeyConst.GROUP_ID, aliyunCommercialRocketMqConfig.getGroupId());</span><br><span class="line">        <span class="comment">//将消费者线程数固定为20个 20为默认值</span></span><br><span class="line">        properties.setProperty(PropertyKeyConst.ConsumeThreadNums, aliyunCommercialRocketMqConfig.getConsumeThreadNums());</span><br><span class="line">        consumerBean.setProperties(properties);</span><br><span class="line">        <span class="comment">//订阅关系</span></span><br><span class="line">        Map&lt;Subscription, MessageListener&gt; subscriptionTable = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 使用了之前定义的测试用的监听器</span></span><br><span class="line">        subscriptionTable.put(AliyunCommercialRocketMqConstants.QUEUE_TEST, aliyunCommerciaRocketMqTestListener);</span><br><span class="line">        <span class="comment">//订阅多个topic如上面设置</span></span><br><span class="line"></span><br><span class="line">        consumerBean.setSubscriptionTable(subscriptionTable);</span><br><span class="line">        <span class="keyword">return</span> consumerBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AliyunCommerciaRocketMqTestListener</code> 自定义监听器为了兼容商用和开源版本做了下面的改变，为了方便理解这里加入了相关注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 监听器开发模板</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">// 开源版本可以兼容此注解</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener</span>(topic = RocketMqKey.TEST_TOPIC, consumerGroup = RocketMqKey.TEST_GROUP, selectorExpression = RocketMqKey.TEST_TAG)</span><br><span class="line"><span class="comment">// RocketMQListener&lt;MessageExt&gt; 属于SpringBoot RocketMq的依赖</span></span><br><span class="line"><span class="comment">// MessageListener 属于商用RocketMq的SDK</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueRemoteReconListener</span> <span class="keyword">implements</span> <span class="title">RocketMQListener</span>&lt;<span class="title">MessageExt</span>&gt;, <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开源版本的使用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(MessageExt message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 开源版本的SpringBoot方式，和上文介绍相同</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span>  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 消息类. 一条消息由主题, 消息体以及可选的消息标签, 自定义附属键值对构成.</span></span><br><span class="line"><span class="comment">     * 注意: 我们对每条消息的自定义键值对的长度没有限制, 但所有的自定义键值对, 系统键值对序列化后, 所占空间不能超过32767字节.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: context 每次消费消息的上下文，供将来扩展使用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> com.aliyun.openservices.ons.api.Action </span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Action <span class="title">consume</span><span class="params">(Message message, ConsumeContext context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 商用版本要求实现这个方法,Action如下，默认失败重试16次，返回ReconsumeLater会触发重试机制，所以会存在重复消费的问题</span></span><br><span class="line"><span class="comment">//public enum Action &#123;</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 消费成功，继续消费下一条消息</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//CommitMessage,</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 消费失败，告知服务器稍后再投递这条消息，继续消费其他消息</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//ReconsumeLater,</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是消费者的兼容处理，既可以满足开源版本的注解开发要求，也可以不膨胀类的情况下沿用扩展。</p><h3 id="Spring-Cloud-Alibaba项目兼容小结"><a href="#Spring-Cloud-Alibaba项目兼容小结" class="headerlink" title="Spring Cloud Alibaba项目兼容小结"></a>Spring Cloud Alibaba项目兼容小结</h3><p>从个人的角度来看，在生产者的兼容上比较容易实现，按照官方的demo构建带商用RocketMq的ProducerBean即可，而消费者的集成则要复杂一些，这里为了考虑不重复的设置或者写重复代码，把关键的配置静态化，同时为了官方写的粗糙的消息订阅类做了继承覆盖的操作兼容。此外为了防止开源版本的消费者Bean被商用的监听器覆盖导致失效，使用了简单的开关来进行Bean的注入控制，写的比较粗糙，读者有更好的写法欢迎讨论。</p><p>总体来看来说商用版本的RocketMq集成起来略微麻烦，但是还是可以接受。此外也可以看到SDK的兼容性实际上是比较简陋的，很多地方的很像但是又完全是自己重新设计的，感觉就是一个新的团队给老团队做出来的东西做兼容的感觉，不过不就是桥接嘛，我也会，所以最后个人对付消费者兼容就用来多接口实现的兼容写法了。</p><p>最终的集成效果是开源版本关闭注入bean的开关，配置为了照顾Properties对于不需要的配置进行占位处理，而商用版本则打开开关，通过自定义注入监听器的方式顶替掉SpringBoot的依赖。</p><p>最后的效果是只需要修改RocketMq的配置，启动之后自动连接到相关的RocketMq。</p><p>开源版本：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#消息队列 - 开源版本</span></span><br><span class="line"><span class="attr">rocketmq:</span></span><br><span class="line">  <span class="attr">use-aliyun-rocketSever:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">name-server:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.92</span><span class="string">:9876</span></span><br><span class="line">  <span class="attr">producer:</span></span><br><span class="line">    <span class="attr">group:</span> <span class="string">testGroup</span></span><br><span class="line">    <span class="attr">secret-key:</span> <span class="string">NONE</span></span><br><span class="line">    <span class="attr">access-key:</span> <span class="string">NONE</span></span><br><span class="line">    <span class="attr">timeoutMillis:</span> <span class="number">15000</span></span><br><span class="line">    <span class="attr">consumeThreadNums:</span> <span class="number">20</span></span><br><span class="line">  <span class="attr">consumer:</span></span><br><span class="line">    <span class="attr">group:</span> <span class="string">testGroup</span></span><br><span class="line">    <span class="attr">secret-key:</span> <span class="string">NONE</span></span><br><span class="line">    <span class="attr">access-key:</span> <span class="string">NONE</span></span><br><span class="line">    <span class="attr">timeoutMillis:</span> <span class="number">15000</span></span><br><span class="line">    <span class="attr">consumeThreadNums:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><p>商用版本</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#消息队列 - 商用版本</span></span><br><span class="line"><span class="attr">rocketmq:</span></span><br><span class="line"> <span class="comment"># 开源RocketMq和商业版RocketMq切换开关</span></span><br><span class="line">  <span class="attr">use-aliyun-rocketSever:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">name-server:</span> <span class="string">http://xxxx.mq.aliyuncs.com:80</span></span><br><span class="line">  <span class="attr">producer:</span></span><br><span class="line"><span class="comment"># 目前uat借助开发测试使用</span></span><br><span class="line">    <span class="attr">group:</span> <span class="string">testGroup</span></span><br><span class="line">      <span class="attr">secret-key:</span> <span class="string">xxx</span></span><br><span class="line">      <span class="attr">access-key:</span> <span class="string">xxx</span></span><br><span class="line">      <span class="attr">timeoutMillis:</span> <span class="number">15000</span></span><br><span class="line">      <span class="attr">consumeThreadNums:</span> <span class="number">20</span></span><br><span class="line">    <span class="attr">consumer:</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">testGroup</span></span><br><span class="line">      <span class="attr">secret-key:</span> <span class="string">xxx</span></span><br><span class="line">      <span class="attr">access-key:</span> <span class="string">xxx</span></span><br><span class="line">      <span class="attr">timeoutMillis:</span> <span class="number">15000</span></span><br><span class="line">      <span class="attr">consumeThreadNums:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><h1 id="阿里云商用RocketMq简单介绍（4-X版本）"><a href="#阿里云商用RocketMq简单介绍（4-X版本）" class="headerlink" title="阿里云商用RocketMq简单介绍（4.X版本）"></a>阿里云商用RocketMq简单介绍（4.X版本）</h1><p>官方介绍：<span class="exturl" data-url="aHR0cHM6Ly9oZWxwLmFsaXl1bi5jb20vcHJvZHVjdC8yOTUzMC5odG1s" title="https://help.aliyun.com/product/29530.html">https://help.aliyun.com/product/29530.html<i class="fa fa-external-link"></i></span></p><p>有关RocketMq本身的介绍部分可以阅读：[[【RocketMq】RocketMq 扫盲]]，这里挑了商用版本个人认为需要关注的几个点进行介绍。注意这里使用的商用RocketMq版本为4.X的版本。</p><h2 id="计费模式"><a href="#计费模式" class="headerlink" title="计费模式"></a>计费模式</h2><p>商用RocketMq主要分为下面几个部分：</p><ul><li>主系列：标准版、专业版、铂金版</li><li>子系列：单节点版、集群版</li></ul><p>个人最后是白嫖了公司的商用集群版RocketMq进行实验，计费的方式分为<strong>包年包月</strong>和<strong>按量付费</strong>，前者适用于流量比较大并且固定的情况，使用套餐比较划算，而后者按需付费则适用于RocketMq使用较少（或者不稳定）或者调用量较少的情况，个人学习也比较推荐按量付费模式，比包年包月划算很多。</p><p>如果出现欠费，在实例停服7天后两种付费模式均会清除所有的RocketMq数据，而日常欠费则会被自动停用，嘛，和电话卡欠费差不多的道理，这里就不过多拓展了。如果要退订商用RocketMq的服务。按量付费可以随时退订，包年包月也会根据天数进行退订。</p><blockquote><p>PS：看完这一整套计费模式下来，发现还是挺良心的。让我没想到的是包年包月居然可以计算未使用的天数返还，这一点挺不错的，用起来不用担心被套进去。</p></blockquote><h2 id="接入方式"><a href="#接入方式" class="headerlink" title="接入方式"></a>接入方式</h2><p>商用RocketMq的接入步骤如下：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20221229175755.png" alt=""></p><p>官方在快速入门中提供了创建资源的解释视频：<span class="exturl" data-url="aHR0cHM6Ly9oZWxwLmFsaXl1bi5jb20vZG9jdW1lbnRfZGV0YWlsLzQ0MTkxNC5odG1s" title="https://help.aliyun.com/document_detail/441914.html">https://help.aliyun.com/document_detail/441914.html<i class="fa fa-external-link"></i></span>。有两个点需要注意，第一个点是RAM用户必须要进行账户授权才能正常使用，第二个点是对外访问方式设置，消息队列RocketMQ版支持VPC访问和公网访问。资源创建完成之后就可以使用官方提供的SDK收发消息，在使用之前需要注意下面这些前提：</p><ul><li><p><span class="exturl" data-url="aHR0cHM6Ly9oZWxwLmFsaXl1bi5jb20vZG9jdW1lbnRfZGV0YWlsLzQ0NDc1Mi5odG0jdGFzay0yMjMzNjgz" title="https://help.aliyun.com/document_detail/444752.htm#task-2233683">步骤二：创建资源<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamV0YnJhaW5zLmNvbS9pZGVhLz9zcG09YTJjNGcuMTExODY2MjMuMC4wLjZiMWMyYjM2MXZhRUhG" title="https://www.jetbrains.com/idea/?spm=a2c4g.11186623.0.0.6b1c2b361vaEHF">安装IDEA<i class="fa fa-external-link"></i></span></p><p>您可以使用IntelliJ IDEA或者Eclipse，本文以IntelliJ IDEA Ultimate为例。</p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cub3JhY2xlLmNvbS9qYXZhL3RlY2hub2xvZ2llcy9kb3dubG9hZHMv" title="https://www.oracle.com/java/technologies/downloads/">安装1.8或以上版本JDK<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9tYXZlbi5hcGFjaGUub3JnL2Rvd25sb2FkLmNnaT9zcG09YTJjNGcuMTExODY2MjMuMC4wLjMyYjk0ZmViZndha2VCJmZpbGU9ZG93bmxvYWQuY2dp" title="https://maven.apache.org/download.cgi?spm=a2c4g.11186623.0.0.32b94febfwakeB&file=download.cgi">安装2.5或以上版本Maven<i class="fa fa-external-link"></i></span></p></li></ul><p>之后便是在项目中引入JAVA依赖和复制粘贴模板代码验证。</p><h2 id="消息队列模型"><a href="#消息队列模型" class="headerlink" title="消息队列模型"></a>消息队列模型</h2><p>商用RocketMq的基本使用逻辑如下：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20221229182359.png" alt=""></p><p>按照消息类型，商用RocketMq提供了下面的消息类型：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9oZWxwLmFsaXl1bi5jb20vZG9jdW1lbnRfZGV0YWlsLzQ0MDI0MC5odG1sP3NwbT1hMmM0Zy4xMTE4NjYyMy4wLjAuNTljMzQ2NmJsOGpFbk0=" title="https://help.aliyun.com/document_detail/440240.html?spm=a2c4g.11186623.0.0.59c3466bl8jEnM">普通消息<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9oZWxwLmFsaXl1bi5jb20vZG9jdW1lbnRfZGV0YWlsLzQ0MDI0MS5odG1sP3NwbT1hMmM0Zy4xMTE4NjYyMy4wLjAuMTFmNDI4NGNmRUpIdFU=" title="https://help.aliyun.com/document_detail/440241.html?spm=a2c4g.11186623.0.0.11f4284cfEJHtU">顺序消息<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9oZWxwLmFsaXl1bi5jb20vZG9jdW1lbnRfZGV0YWlsLzQ0MDI0Mi5odG1sP3NwbT1hMmM0Zy4xMTE4NjYyMy4wLjAuZWQ4OTRkMzg1ZFdmR0M=" title="https://help.aliyun.com/document_detail/440242.html?spm=a2c4g.11186623.0.0.ed894d385dWfGC">定时/延时消息<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9oZWxwLmFsaXl1bi5jb20vZG9jdW1lbnRfZGV0YWlsLzQ0MDI0NC5odG1sP3NwbT1hMmM0Zy4xMTE4NjYyMy4wLjAuMTFmNDRhZDRlTjFpenk=" title="https://help.aliyun.com/document_detail/440244.html?spm=a2c4g.11186623.0.0.11f44ad4eN1izy">事务消息<i class="fa fa-external-link"></i></span></li></ul><h2 id="SDK接入参考"><a href="#SDK接入参考" class="headerlink" title="SDK接入参考"></a>SDK接入参考</h2><p>SDK接入的主页链接如下：</p><p><span class="exturl" data-url="aHR0cHM6Ly9oZWxwLmFsaXl1bi5jb20vZG9jdW1lbnRfZGV0YWlsLzY5MTExLmh0bWw=" title="https://help.aliyun.com/document_detail/69111.html">https://help.aliyun.com/document_detail/69111.html<i class="fa fa-external-link"></i></span></p><p>主要介绍了下面几个点，实际参考第二个推荐的接入方式即可。</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9oZWxwLmFsaXl1bi5jb20vZG9jdW1lbnRfZGV0YWlsLzEyNDY5My5odG1s" title="https://help.aliyun.com/document_detail/124693.html">SDK参考概述<i class="fa fa-external-link"></i></span></li><li><a href="https://help.aliyun.com/document_detail/29544.html" target="_blank" rel="noopener"><strong>商业版TCP协议SDK（推荐）</strong></a></li><li><span class="exturl" data-url="aHR0cHM6Ly9oZWxwLmFsaXl1bi5jb20vZG9jdW1lbnRfZGV0YWlsLzE0MTc3OC5odG1s" title="https://help.aliyun.com/document_detail/141778.html">商业版HTTP协议SDK（多语言推荐）<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9oZWxwLmFsaXl1bi5jb20vZG9jdW1lbnRfZGV0YWlsLzEyODYwMC5odG1s" title="https://help.aliyun.com/document_detail/128600.html">社区版TCP协议SDK（仅供开源用户上云使用）<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9oZWxwLmFsaXl1bi5jb20vZG9jdW1lbnRfZGV0YWlsLzE2NDU2Ny5odG1s" title="https://help.aliyun.com/document_detail/164567.html">订阅消息常见问题<i class="fa fa-external-link"></i></span></li></ul><p>对于JAVA应用程序建议使用TCP协议SDK，集成的方式也比较简单，为了方便理解，也可以通过以下链接获取相关Demo，里面都有详细的注释解释：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FsaXdhcmVNUS9tcS1kZW1vL3RyZWUvbWFzdGVyL3NwcmluZy9qYXZhLXNwcmluZy1kZW1v" title="https://github.com/AliwareMQ/mq-demo/tree/master/spring/java-spring-demo">spring/java-spring-demo<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FsaXdhcmVNUS9tcS1kZW1vL3RyZWUvbWFzdGVyL3NwcmluZ2Jvb3QvamF2YS1zcHJpbmdib290LWRlbW8=" title="https://github.com/AliwareMQ/mq-demo/tree/master/springboot/java-springboot-demo">springboot/java-springboot-demo<i class="fa fa-external-link"></i></span></li></ul><p>如果是HTTP协议的SDK，则使用下面的依赖包：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun.mq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mq-http-sdk<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--以下版本号请替换为Java SDK的最新版本号--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">classifier</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果是TCP协议的接入方式，则使用下面的依赖包：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun.openservices<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ons-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--以下版本号请替换为Java SDK的最新版本号--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.8.1.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="接入细节说明"><a href="#接入细节说明" class="headerlink" title="接入细节说明"></a>接入细节说明</h3><p>个人在实验的时候发现HTTP协议的版本集成SDK更像是给了一套API工具包，好处是可以不需要依赖Spring框架等单独使用，但是最大的缺点也是这里，很难用于框架当中，如果要实现自动接收消息并且处理，需要依靠<strong>手动实现定时任务</strong>拉取消息实现自动消费，这一点也比较蛋疼。</p><p>这里列举 <strong>HTTP的SDK</strong>的发送和接受代码，首先是生产者的模板代码，这些代码和开源的RocketMq使用类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略大量代码。。。</span></span><br><span class="line"><span class="comment">// 循环发送4条消息。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                TopicMessage pubMsg;        <span class="comment">// 普通消息。</span></span><br><span class="line">                pubMsg = <span class="keyword">new</span> TopicMessage(</span><br><span class="line">                <span class="comment">// 消息内容。</span></span><br><span class="line">                <span class="string">"hello mq!"</span>.getBytes(),</span><br><span class="line">                <span class="comment">// 消息标签。</span></span><br><span class="line">                <span class="string">"A"</span></span><br><span class="line">                );</span><br><span class="line">                <span class="comment">// 设置消息的自定义属性。</span></span><br><span class="line">                pubMsg.getProperties().put(<span class="string">"a"</span>, String.valueOf(i));</span><br><span class="line">                <span class="comment">// 设置消息的Key。</span></span><br><span class="line">                pubMsg.setMessageKey(<span class="string">"MessageKey"</span>);</span><br><span class="line">               </span><br><span class="line">            <span class="comment">// 同步发送消息，只要不抛异常就是成功。</span></span><br><span class="line">            TopicMessage pubResultMsg = producer.publishMessage(pubMsg);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 同步发送消息，只要不抛异常就是成功。</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> Date() + <span class="string">" Send mq message success. Topic is:"</span> + topic + <span class="string">", msgId is: "</span> + pubResultMsg.getMessageId()</span><br><span class="line">                        + <span class="string">", bodyMD5 is: "</span> + pubResultMsg.getMessageBodyMD5());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="comment">// 消息发送失败，需要进行重试处理，可重新发送这条消息或持久化这条数据进行补偿处理。</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> Date() + <span class="string">" Send mq message failed. Topic is:"</span> + topic);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 省略大量代码。。。</span></span><br></pre></td></tr></table></figure><p>而在接收方稍微麻烦一些，官方的案例是使用 <strong>死循环</strong>不断检查Broker是否有积压消息，如果有则通过<strong>主动拉取消息</strong>的模式去拉取消息。</p><blockquote><p> 实现多线程等待的效果可以写入到Thread继承类的Run方法中。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 在当前线程循环消费消息，建议多开个几个线程并发消费消息。</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 省略大量代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理业务逻辑。</span></span><br><span class="line">            <span class="keyword">for</span> (Message message : messages) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Receive message: "</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 消息重试时间到达前若不确认消息消费成功，则消息会被重复消费。</span></span><br><span class="line">            <span class="comment">// 消息句柄有时间戳，同一条消息每次消费的时间戳都不一样。</span></span><br><span class="line">            &#123;</span><br><span class="line">                List&lt;String&gt; handles = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">                <span class="keyword">for</span> (Message message : messages) &#123;</span><br><span class="line">                    handles.add(message.getReceiptHandle());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    consumer.ackMessage(handles);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    <span class="comment">// 某些消息的句柄可能超时，会导致消息消费状态确认不成功。</span></span><br><span class="line">                    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> AckMessageException) &#123;</span><br><span class="line">                        AckMessageException errors = (AckMessageException) e;</span><br><span class="line">                        System.out.println(<span class="string">"Ack message fail, requestId is:"</span> + errors.getRequestId() + <span class="string">", fail handles:"</span>);</span><br><span class="line">                        <span class="keyword">if</span> (errors.getErrorMessages() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">for</span> (String errorHandle :errors.getErrorMessages().keySet()) &#123;</span><br><span class="line">                                System.out.println(<span class="string">"Handle:"</span> + errorHandle + <span class="string">", ErrorCode:"</span> + errors.getErrorMessages().get(errorHandle).getErrorCode()</span><br><span class="line">                                        + <span class="string">", ErrorMsg:"</span> + errors.getErrorMessages().get(errorHandle).getErrorMessage());</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125; <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line">     <span class="comment">// 省略大量代码</span></span><br></pre></td></tr></table></figure><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>算是一次个人兼容的笔记。还是要吐槽商用的RocketMq集成真的挺无语的，不过阿里的东西懂的都懂。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      学习和使用RocketMq
    
    </summary>
    
    
      <category term="RocketMq" scheme="https://whitestore.top/categories/RocketMq/"/>
    
    
      <category term="RocketMq" scheme="https://whitestore.top/tags/RocketMq/"/>
    
  </entry>
  
  <entry>
    <title>【Java】Best coding practices every java developer should</title>
    <link href="https://whitestore.top/2023/03/11/codingparctice/"/>
    <id>https://whitestore.top/2023/03/11/codingparctice/</id>
    <published>2023-03-10T23:13:34.000Z</published>
    <updated>2023-06-15T13:10:39.211Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><p><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BhYmhpc2hla3NpbmdoamF2YS9iZXN0LWNvZGluZy1wcmFjdGljZXMtZXZlcnktamF2YS1kZXZlbG9wZXItc2hvdWxkLWZvbGxvdy03Yjc3NTI3YTcwNDgjaWRfdG9rZW49ZXlKaGJHY2lPaUpTVXpJMU5pSXNJbXRwWkNJNklqSTFOV05qWVRabFl6STRNVEEyTURKa09EQmlaV000T1dVME5UWmpORFE1TldRM05ERTRZbUlpTENKMGVYQWlPaUpLVjFRaWZRLmV5SnBjM01pT2lKb2RIUndjem92TDJGalkyOTFiblJ6TG1kdmIyZHNaUzVqYjIwaUxDSnVZbVlpT2pFMk56Z3pOekEzTkRVc0ltRjFaQ0k2SWpJeE5qSTVOakF6TlRnek5DMXJNV3MyY1dVd05qQnpNblJ3TW1FeWFtRnROR3hxWkdOdGN6QXdjM1IwWnk1aGNIQnpMbWR2YjJkc1pYVnpaWEpqYjI1MFpXNTBMbU52YlNJc0luTjFZaUk2SWpFd01qVXpOakF3TmpZMU1UQTVORFF4TnpNNE15SXNJbVZ0WVdsc0lqb2llbmhrYzJJMk5qWkFaMjFoYVd3dVkyOXRJaXdpWlcxaGFXeGZkbVZ5YVdacFpXUWlPblJ5ZFdVc0ltRjZjQ0k2SWpJeE5qSTVOakF6TlRnek5DMXJNV3MyY1dVd05qQnpNblJ3TW1FeWFtRnROR3hxWkdOdGN6QXdjM1IwWnk1aGNIQnpMbWR2YjJkc1pYVnpaWEpqYjI1MFpXNTBMbU52YlNJc0ltNWhiV1VpT2lKQmJHVjRJSGhoYm1SbGNpSXNJbkJwWTNSMWNtVWlPaUpvZEhSd2N6b3ZMMnhvTXk1bmIyOW5iR1YxYzJWeVkyOXVkR1Z1ZEM1amIyMHZZUzlCUjA1dGVYaFpaR0ZqVkhrM05rcFJOVEJNVDJWRFJXTlpSVWg2ZHpsc2RVUnBSblpmVmpaVE1XVm9hajF6T1RZdFl5SXNJbWRwZG1WdVgyNWhiV1VpT2lKQmJHVjRJaXdpWm1GdGFXeDVYMjVoYldVaU9pSjRZVzVrWlhJaUxDSnBZWFFpT2pFMk56Z3pOekV3TkRVc0ltVjRjQ0k2TVRZM09ETTNORFkwTlN3aWFuUnBJam9pTTJJNU4ySTBPRFEzWXpkbU9UUXhORGcyTkdZeU4yRXpOVGhoWTJRMU1ESTNZall6WVRReE1pSjkuSTMzRnlfYjBlUUFDSTRLV01qejBSc1d2YUZoMVgzLUk2MjU4dW92Mk82QjF4NHZxbjNQV0xBLU5kaXlUNzh0b0pVTklZR0oyUUxSenEwd3ozMzZFNHRfbmhyZmZ5N3FwN2E0S1VPS3FzOEl1UExEd2dXS3RxQXBOU2tweTlUV0I2MXJobFo4Q25yN3NnYlpvRzJ4dXhxMERqSlVtVmFZWi0tR1VVRmZ0Vkl6VHY5RHlMRVZORzcxeEZoWDlTNzNxWFNhSnR5YmJwMUpwam1NNTI2REFmLTYxS01yc29DQl9ZWjlETjJENFc0QzBCZEFNWlEyY1duWnZ2Rzd5SE1BSDBSNTFsN3huLW5VTWxNbktaTjEyd2ItVlpDU2J3ODZkNC1rS2dycjliMThkUDdSM0pEbE5oVW8zQ0VMNWx3WnBQV2RNajNnSHpSdzBaQnI5NEhXTFNn" title="https://medium.com/@abhisheksinghjava/best-coding-practices-every-java-developer-should-follow-7b77527a7048#id_token=eyJhbGciOiJSUzI1NiIsImtpZCI6IjI1NWNjYTZlYzI4MTA2MDJkODBiZWM4OWU0NTZjNDQ5NWQ3NDE4YmIiLCJ0eXAiOiJKV1QifQ.eyJpc3MiOiJodHRwczovL2FjY291bnRzLmdvb2dsZS5jb20iLCJuYmYiOjE2NzgzNzA3NDUsImF1ZCI6IjIxNjI5NjAzNTgzNC1rMWs2cWUwNjBzMnRwMmEyamFtNGxqZGNtczAwc3R0Zy5hcHBzLmdvb2dsZXVzZXJjb250ZW50LmNvbSIsInN1YiI6IjEwMjUzNjAwNjY1MTA5NDQxNzM4MyIsImVtYWlsIjoienhkc2I2NjZAZ21haWwuY29tIiwiZW1haWxfdmVyaWZpZWQiOnRydWUsImF6cCI6IjIxNjI5NjAzNTgzNC1rMWs2cWUwNjBzMnRwMmEyamFtNGxqZGNtczAwc3R0Zy5hcHBzLmdvb2dsZXVzZXJjb250ZW50LmNvbSIsIm5hbWUiOiJBbGV4IHhhbmRlciIsInBpY3R1cmUiOiJodHRwczovL2xoMy5nb29nbGV1c2VyY29udGVudC5jb20vYS9BR05teXhZZGFjVHk3NkpRNTBMT2VDRWNZRUh6dzlsdURpRnZfVjZTMWVoaj1zOTYtYyIsImdpdmVuX25hbWUiOiJBbGV4IiwiZmFtaWx5X25hbWUiOiJ4YW5kZXIiLCJpYXQiOjE2NzgzNzEwNDUsImV4cCI6MTY3ODM3NDY0NSwianRpIjoiM2I5N2I0ODQ3YzdmOTQxNDg2NGYyN2EzNThhY2Q1MDI3YjYzYTQxMiJ9.I33Fy_b0eQACI4KWMjz0RsWvaFh1X3-I6258uov2O6B1x4vqn3PWLA-NdiyT78toJUNIYGJ2QLRzq0wz336E4t_nhrffy7qp7a4KUOKqs8IuPLDwgWKtqApNSkpy9TWB61rhlZ8Cnr7sgbZoG2xuxq0DjJUmVaYZ--GUUFftVIzTv9DyLEVNG71xFhX9S73qXSaJtybbp1JpjmM526DAf-61KMrsoCB_YZ9DN2D4W4C0BdAMZQ2cWnZvvG7yHMAH0R51l7xn-nUMlMnKZN12wb-VZCSbw86d4-kKgrr9b18dP7R3JDlNhUo3CEL5lwZpPWdMj3gHzRw0ZBr94HWLSg">Best coding practices every java developer should follow<i class="fa fa-external-link"></i></span></p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#引言">引言</a></li><li><a href="#4-尽可能让变量私有化">4. 尽可能让变量私有化</a></li><li><a href="#6-警惕冗余初始化">6. 警惕冗余初始化</a></li><li><a href="#5-Stringbuilder替换字符串拼接争议">5. Stringbuilder替换字符串拼接【争议】</a></li><li><a href="#15-dry和kiss">15. dry和kiss</a></li><li><a href="#14-Solid">14. Solid</a></li><li><a href="#7-尽可能使用增强for循环或者foreach">7. 尽可能使用增强for循环或者foreach</a></li><li><a href="#13-日志打印规则">13. 日志打印规则</a></li><li><a href="#12-Hardcoding硬编码">12. Hardcoding硬编码</a></li><li><a href="#11-注释">11. 注释</a></li><li><a href="#10-避免创建不必要对象">10. 避免创建不必要对象</a></li><li><a href="#9-返回空集合而不是null">9. 返回空集合而不是null</a></li><li><a href="#8-精度选择">8. 精度选择</a></li><li><a href="#1-项目结构">1. 项目结构</a></li><li><a href="#2-遵循命名规范">2. 遵循命名规范</a></li><li><a href="#3-不要吞异常">3. 不要吞异常</a></li><li><a href="#16-使用枚举替代静态常量建议">16. 使用枚举替代静态常量【建议】</a></li><li><a href="#17-按作用域划分成员变量">17. 按作用域划分成员变量</a></li><li><a href="#18-在数字字段中使用下划线建议">18. 在数字字段中使用下划线【建议】</a></li><li><a href="#总结">总结</a></li><li><a href="#参考">参考</a></li></ul><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>把标题翻译成中文在国内也是一个老生常谈的问题：编程习惯和编码规范。</p><p>这篇文章大部分观点和国内的规范习惯类似，令我好奇的是外国人是如何理解这些内容的？</p><p>注意本文的Tips排序是打乱的，个人把感兴趣放到了前面来了。这篇文章的评论区非常精彩，这里一并整合了评论区的读者观点。</p><p>不管是学习还是习老外的思考方式，或是大在评论区当中看读者的讨论和纠正错误，阅读本文都是值得推荐的。</p><p>抱着半信半疑的态度学习这些内容，你会得到比单纯的了解和接受建议更多的收获。</p><a id="more"></a><h1 id="4-尽可能让变量私有化"><a href="#4-尽可能让变量私有化" class="headerlink" title="4. 尽可能让变量私有化"></a>4. 尽可能让变量私有化</h1><p>如果变量不需要意对外访问，那就建议使用私有描述对于参数进行描述。</p><p>评论区的读者对于这一个小节做了补充：</p><ul><li>如果是dto并且是final的，拥有公用数据的时候<strong>可以不私有化</strong>.。</li><li>比大量的setter更好建议是更合理的利用设计模式构建对象（比如建造者），或者利用委托第三方对象生产合适的对象（静态工厂替代构造器）。</li><li>尽可能让对象不可变。</li></ul><h1 id="6-警惕冗余初始化"><a href="#6-警惕冗余初始化" class="headerlink" title="6. 警惕冗余初始化"></a>6. 警惕冗余初始化</h1><blockquote><p>Therefore, a java best practice is to be aware of the default initialization values of member variables and avoid initializing the variables explicitly.</p></blockquote><p>Java 最佳实践是了解成员变量的默认初始化值并避免显式初始化变量，Java语言很多变量存在默认值，在自己编写初始化的时候不建议使用Java的默认值。</p><p>另一方面，有时候可以利用Java的初始化做数据库字段的优化，比如开关状态建议把0设置为开放1设置为关闭。</p><p>下面的代码的的对象初始化代码是毫无意义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String name = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isGenius = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Although it is very common practice, it is not encouraged to initialize member variables with the values: like 0, false and null. These values are already the default initialization values of member variables in Java. Therefore, a java best practice is to be aware of the default initialization values of member variables and avoid initializing the variables explicitly.</p></blockquote><p>尽管这是非常常见的做法，但不鼓励使用以下值初始化成员变量：如 0、false 和 null。这些值已经是 Java 中成员变量的默认初始化值。因此，Java 最佳实践是了解成员变量的缺省初始化值，并避免显式初始化变量。</p><p>See more here: <span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZWphdmEubmV0L2phdmEtY29yZS90aGUtamF2YS1sYW5ndWFnZS9qYXZhLWRlZmF1bHQtaW5pdGlhbGl6YXRpb24tb2YtaW5zdGFuY2UtdmFyaWFibGVzLWFuZC1pbml0aWFsaXphdGlvbi1ibG9ja3M=" title="https://www.codejava.net/java-core/the-java-language/java-default-initialization-of-instance-variables-and-initialization-blocks">Java default Initialization of Instance Variables and Initialization Blocks<i class="fa fa-external-link"></i></span>。</p><h1 id="5-Stringbuilder-替换字符串拼接【争议】"><a href="#5-Stringbuilder-替换字符串拼接【争议】" class="headerlink" title="5. Stringbuilder 替换字符串拼接【争议】"></a>5. Stringbuilder 替换字符串拼接【争议】</h1><p>实际上多数情况下“大可不必”，只有for循环的情况才考虑是否使用Stringbuilder替换。日常情况下字符拼接操作是完全没有问问题的，javac编译之后会把字符串自动用StringBuilder替换，真正应该手动创建该对象的场景是在<strong>for循环当中的大量的字符串拼接</strong>，内部会每次迭代新建Stringbuilder。</p><p>随着JDK版本的升级，到<strong>JDK9</strong>版本for循环新建StringBuilder的情况已经被改善了（但个人未从OpenJDK中找到对应源码验证）。</p><p>JDK13 从Python那边把多行文本的语法搬过来了，定义多行文本可以类似下面这样：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String htmlContent = “““&lt;html&gt;</span><br><span class="line">                           &lt;head&gt;</span><br><span class="line">                           &lt;/head&gt;</span><br><span class="line">                           &lt;body&gt;</span><br><span class="line">                              &lt;p&gt;Hello world!&lt;/p&gt;</span><br><span class="line">                           &lt;/body&gt;</span><br><span class="line">                         &lt;/html&gt;""";</span><br></pre></td></tr></table></figure><p>最后需要注意的是使用<strong>Stringbuilder</strong>，仅仅应该用在多线程循环操作字符串当中，如果在同步方法里面效率会非常低并且很慢。</p><p>介绍</p><blockquote><p>As a general rule, optimize at an architectural level, and write code for readability. Later on it’s easier to optimize a neat function, than to look for bugs in an optimized one.</p></blockquote><p>上面意思大致是说通用规则是优先写出具备高可读性的代码，然后再去进行优化这些简单的可优化点，这比在优化代码找错误要简单很多。</p><h1 id="15-dry和kiss"><a href="#15-dry和kiss" class="headerlink" title="15. dry和kiss"></a>15. dry和kiss</h1><blockquote><p>DRY stands for “Don’s Repeat Yourself</p></blockquote><p>如果代码可以公用就尽量公用，不要复制粘贴代码。</p><blockquote><p>kiss：KISS stands for “Keep It Simple, Stupid”.</p></blockquote><p>KISS就是保持简单，愚蠢。这个愚蠢指的是方法最好只知道干一件事情。这两点和Unix最初的设计的理念是一样的，简单好用即是美。</p><h1 id="14-Solid"><a href="#14-Solid" class="headerlink" title="14. Solid"></a>14. Solid</h1><p><strong>Single Responsibility Principle</strong> 单一职责：每个类和接口有明确目标。</p><p><strong>Open-Closed Principle</strong> 开闭原则：开放扩展，封闭修改。</p><p><strong>Liskov Substitution Principle</strong> 里式替代：尽可能让代码多态。</p><p><strong>Interface Segregation Principle</strong> 接口隔离：实现接口替代类继承。</p><p><strong>Dependency Inversion Principle</strong> 依赖倒转原则：依赖抽象而不是依赖实现。</p><h1 id="7-尽可能使用增强for循环或者foreach"><a href="#7-尽可能使用增强for循环或者foreach" class="headerlink" title="7. 尽可能使用增强for循环或者foreach"></a>7. 尽可能使用增强for循环或者foreach</h1><p>建议使用增强for循环（JDK5）和JDK8的foreach，当然最好的建议是活学活用stream的API。为什么会有这样的建议？好像for-index也不是啥坏写法。</p><blockquote><p>It’s because the index variable is error-prone, as we may alter it incidentally in the loop’s body, or we may starts the index from 1 instead of 0.</p></blockquote><p>这是因为索引变量容易出错，因为我们可能会在循环的主体中偶然改变它，或者我们可能从1而不是0开始索引。下面是Stream API带来便利的简单例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">findSmallesPositiveNumber</span><span class="params">(List&lt;Integer&gt; numbers)</span> </span>&#123;</span><br><span class="line">   Integer smallestPositiveNumber= <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">for</span> (Integer number: numbers) &#123;</span><br><span class="line">      <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (smallestPositiveNumber == <span class="keyword">null</span></span><br><span class="line">            || number &lt; smallestPositiveNumber) &#123;</span><br><span class="line">         smallestPositiveNumber = number;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> smallestPositiveNumber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Stream APi精简之后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;Integer&gt; <span class="title">findSmallesPositiveNumber</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      List&lt;Integer&gt; numbers)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> numbers.stream()</span><br><span class="line">      .filter(number -&gt; number &gt; <span class="number">0</span>)</span><br><span class="line">      .min(Integer::compare);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="13-日志打印规则"><a href="#13-日志打印规则" class="headerlink" title="13. 日志打印规则"></a>13. 日志打印规则</h1><p>作者的下面几条规则<strong>有待商榷</strong>，我个人建议是<strong>避免</strong>下面的做法：</p><blockquote><p>Developer should add logger on method entry and exit.</p></blockquote><p>在进出重要方法打印入参和出参。</p><blockquote><p>谨慎使用，建议涉及金额的操作情况打印。</p></blockquote><blockquote><p>Developer should add logger in “if” and “else” case to track which condition is true in case of any error.</p></blockquote><p>在if和else的条件判断处打印参数。</p><blockquote><p>Developer should also log exception to track the issue</p></blockquote><p>对于异常信息必须打印。</p><p>更为合理的做法是像下面这样：</p><blockquote><p>Definitely don’t log every if-else statement!</p></blockquote><p>不要在if/else分支中打印，更为合理的建议是记录响应以及错误。</p><blockquote><p><strong>Don’t log every method entry and exit!</strong></p></blockquote><p>不要在每个方法的入参和出参打印。当然这并不是铁律，比如三方接口调用就必须要在“入口”和“出口”中打印以便快速定位问题<del>和甩锅</del>。</p><blockquote><p>**Log exceptions that are unexpected. **</p></blockquote><p>记录“意外”的异常。比如多线程有可能的interrupt处理，文件读写有可能的IO异常。</p><p>从褒义和贬义两个层面看，日志都是非常具备“价值”的，好的日志可以帮你快速定位问题，不好的日志就像是垃圾一样迅速占用服务器的磁盘。只有非常核心的日志才需要跟踪每一步的行为，绝大多数情况下日志只需要在影响业务的位置进行打印。在打印日志段时候多思考一下<strong>日志等级</strong>的选择，这意味着你生产能否快速定位问题。</p><h1 id="12-Hardcoding硬编码"><a href="#12-Hardcoding硬编码" class="headerlink" title="12. Hardcoding硬编码"></a>12. Hardcoding硬编码</h1><p>硬编码回会导致程序难以理解。使用硬编码会增加理解难度，通常使用枚举替代是不错建议。根据dry的原则，在定义硬编码的时候，如果魔法值在JDK中存在类似定义或者存在现实意义，应该果断通过下面的方式进行纠正，比如下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> storeClosureDay = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><p>应该被替换为下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SUNDAY = <span class="number">7</span>;  </span><br><span class="line">[…]  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> storeClosureDay = SUNDAY;</span><br></pre></td></tr></table></figure><p><strong>不要</strong>这样使用，更为合适的处理方式是使用<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlLzgvZG9jcy9hcGkvamF2YS90aW1lL0RheU9mV2Vlay5odG1s" title="https://docs.oracle.com/javase/8/docs/api/java/time/DayOfWeek.html">DayOfWeek<i class="fa fa-external-link"></i></span> 的API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> DayOfWeek storeClosureDay = DayOfWeek.SUNDAY;</span><br></pre></td></tr></table></figure><p>避免硬编码是非常好的编程习惯，更好的习惯是使用易懂的硬编码。</p><h1 id="11-注释"><a href="#11-注释" class="headerlink" title="11. 注释"></a>11. 注释</h1><p>关键：<strong>注释只有在可读性较差并且需要注释描述关键意图的时候才使用</strong>。</p><blockquote><p>As your code will be read by various people with varying knowledge of Java, Proper comments should be used to give overviews of your code and provide additional information that cannot be perceived from the code itself. Comments are supposed to describe the working of your code to be read by Quality assurance engineer, reviewer, or maintenance staff .</p></blockquote><p>由于代码将被具有不同 Java 知识的各种人阅读，因此应该使用适当的注释来概述代码，并提供无法从代码本身感知的其他信息。注释应该描述代码的工作方式，以供质量保证工程师、审阅者或维护人员阅读。</p><p>注释关键点应该具备<strong>可读性</strong>，有时候没有任何注释的代码确实让人痛苦，更可怕的是因为代码更新但是注释不更新，这样的事情也时有发生=-=。最好的注释应该是代码本身会告知作者意图。</p><blockquote><p>PS：个人看过的没啥注释也能完全看懂，并且看完觉得写的非常美的代码目前只有Redission和Spring。</p></blockquote><h1 id="10-避免创建不必要对象"><a href="#10-避免创建不必要对象" class="headerlink" title="10. 避免创建不必要对象"></a>10. 避免创建不必要对象</h1><p>对象创建是最消耗内存的操作之一，这就是为什么最好的 Java 实践是避免创建任何不必要的对象，并且只应在需要时创建它们。</p><h1 id="9-返回空集合而不是null"><a href="#9-返回空集合而不是null" class="headerlink" title="9. 返回空集合而不是null"></a>9. 返回空集合而不是null</h1><blockquote><p>NPE is the most frequent exception in production with absolute leadership, do not give it a chance.</p></blockquote><p>更进一步说是让整个系统不要出现空指针异常，不应该因为项目代码妥协老旧的编程风格。一定不要让空指针有可乘之机。除了返回空集合以外，还可以利用Optional的工具类包装有可能为Null的对象，显式的告诉调用者对象有可能为Null。</p><blockquote><p>An empty collection might have a different meaning than no collection at all.&#x20;</p></blockquote><p>有时候null 也可能是“有意义”的，使用的时候也需要考虑具体情况，当然返回空集合肯定是没有任何问题的。</p><h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p>空集合相关的轮子在Collections可以找到答案，但是需要注意需要合理使用，JDK5之后出现了emptyXXX等集合类，但是这些类“暗藏杀机”，因为它们的效果和<strong>List.subList()</strong> 一样是<strong>immutable</strong> 的。</p><p>虽然JDK的工具类可以减少不必要的对象创建，但是假设接收方需要在收到空集合之后却还要往里面设置数据，这时候毫无疑问就会抛异常了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Returns an empty list (immutable).  This list is serializable.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;This example illustrates the type-safe way to obtain an empty list:</span></span><br><span class="line"><span class="comment">  * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">  *     List&amp;lt;String&amp;gt; s = Collections.emptyList();</span></span><br><span class="line"><span class="comment">  * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@implNote</span></span></span><br><span class="line"><span class="comment">  * Implementations of this method need not create a separate &lt;tt&gt;List&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">  * object for each call.   Using this method is likely to have comparable</span></span><br><span class="line"><span class="comment">  * cost to using the like-named field.  (Unlike this method, the field does</span></span><br><span class="line"><span class="comment">  * not provide type safety.)</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> &lt;T&gt; type of elements, if there were any, in the list</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> an empty immutable list</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span> #EMPTY_LIST</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">emptyList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (List&lt;T&gt;) EMPTY_LIST;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>我认为<code>emptyList()</code>更为合理的方法名称是 <code>immutableEmptyList()</code> 和 <code>mutableEmptyList()</code>，当然<code>mutableEmptyList()</code>就是new新的<code>ArrayList()</code>这样的方法，看起来是毫无意义的，也许JDK设计的时候也是考虑这种情况？</p><h1 id="8-精度选择"><a href="#8-精度选择" class="headerlink" title="8. 精度选择"></a>8. 精度选择</h1><blockquote><p>Most processors take almost same time in processing the operations on float and double but double offers way more precision then float that is why it is best practice to use double when precision is important otherwise you can go with float as it requires half space than double.。</p></blockquote><p>大型处理器在处理double和float的时候计算速度是类似的。但是在Java中大部分情况只要是涉及浮点数计算都是闭着眼睛用BigDecimal。如果精度很重要直接无脑使用BigDecimal，double和float都会骗人。</p><blockquote><p>When precision is important, use BigDecimal. Double and Float aren’t accurate. They will betray you when you least expect it. 1 + 1 can be 1.99999999999.</p></blockquote><p>当精度很重要时请使用BigDecimal，Double和Float并不精确。它们会在你最不期望的时候背叛你。1+1可能是1.99999999999。</p><h1 id="1-项目结构"><a href="#1-项目结构" class="headerlink" title="1. 项目结构"></a>1. 项目结构</h1><p>有点过于基础了。下面是Maven的经典结构，如果是Maven新手可以看看项目的基本布局</p><ul><li><em>src/main/java</em>: <strong>For source files</strong></li><li><em>src/main/resources</em>: <strong>For resource files, like properties</strong></li><li><em>src/test/java</em>: <strong>For test source files</strong></li><li><em>src/test/resources</em>: <strong>For test resource files, like properties</strong></li></ul><h1 id="2-遵循命名规范"><a href="#2-遵循命名规范" class="headerlink" title="2. 遵循命名规范"></a>2. 遵循命名规范</h1><p>没啥好讲的，程序员的基础素质。最好的命名规范不是参考某一个标准，而是能统一风格布局代码。</p><h1 id="3-不要吞异常"><a href="#3-不要吞异常" class="headerlink" title="3. 不要吞异常"></a>3. 不要吞异常</h1><p>在异常处理时在 catch 块中编写适当且有意义的消息是精英 java 开发人员首选的 java 最佳实践。<strong>新手常常会把异常捕获之后不做任何处理，吞异常是非常危险的行为</strong>。</p><p>得益于IDE的帮助，catch之后不打印任何信息的情况不是很多见，但是打印堆栈其实也是非常消耗资源的操作，同时因为是打印在控制台，如果不调用日志保存关键信息也有可能导致关键信息丢失。</p><h1 id="16-使用枚举替代静态常量【建议】"><a href="#16-使用枚举替代静态常量【建议】" class="headerlink" title="16. 使用枚举替代静态常量【建议】"></a>16. 使用枚举替代静态常量【建议】</h1><p>在Java推出枚举之前，定义一个常量基本只能使用下面的接口方式。在很多优秀框架的最早期版本中经常能看到这样的写法，并且到现在使用这种写法的不在少数 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RED = <span class="number">0xff0000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BLACK = <span class="number">0x000000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WHITE = <span class="number">0xffffff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>It’s because the purpose of interfaces is for inheritance and polymorphism, not for static stuffs like that. So the best practice recommends us to use an enum instead.&#x20;</p></blockquote><p>这是因为接口的目的是用于继承和多态性，而不是用于类似的静态东西。所以最佳实践建议我们使用枚举来代替。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Color &#123;</span><br><span class="line"> </span><br><span class="line">    BLACK(<span class="number">0x000000</span>),</span><br><span class="line">    WHITE(<span class="number">0xffffff</span>),</span><br><span class="line">    RED(<span class="number">0xff0000</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line"> </span><br><span class="line">    Color(<span class="keyword">int</span> code) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用枚举和静态常量的对比：</p><ul><li>枚举更具备描述性</li><li>Keep It Simple, Stupid。接口可以用于继承和多态，枚举能干的事情基本是常量定义。</li><li>接口的静态常量往往有其他的用途。</li></ul><blockquote><p>很少有人会在枚举设计复杂的逻辑，因为枚举的可扩展性很差并且理解和学习成本较高</p></blockquote><h1 id="17-按作用域划分成员变量"><a href="#17-按作用域划分成员变量" class="headerlink" title="17. 按作用域划分成员变量"></a>17. 按作用域划分成员变量</h1><blockquote><p>The best practice to organize member variables of a class by their scopes from most restrictive to least restrictive.&#x20;</p></blockquote><p>最好的做法是按其作用域从最严格到最不严格来组织一个类的成员变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> List&lt;Student&gt; listStudents;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> numberOfStudents;</span><br><span class="line">    <span class="keyword">private</span> String errorMessage;</span><br><span class="line">    <span class="keyword">float</span> rowHeight;</span><br><span class="line">    <span class="keyword">float</span> columnWidth;</span><br><span class="line">    <span class="keyword">protected</span> String[] columnNames;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numberOfRows;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numberOfColumns;</span><br><span class="line">    <span class="keyword">public</span> String title;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的成员变量定义眼花缭乱，通过作用域划分如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String errorMessage;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numberOfColumns;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numberOfRows;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">float</span> columnWidth;</span><br><span class="line">    <span class="keyword">float</span> rowHeight;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">protected</span> String[] columnNames;</span><br><span class="line">    <span class="keyword">protected</span> List&lt;Student&gt; listStudents;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> numberOfStudents;</span><br><span class="line">    <span class="keyword">public</span> String title;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="18-在数字字段中使用下划线【建议】"><a href="#18-在数字字段中使用下划线【建议】" class="headerlink" title="18. 在数字字段中使用下划线【建议】"></a>18. 在数字字段中使用下划线【建议】</h1><p>来自Java 7的小更新可以帮助我们把冗长的数字字段写得更易读。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> maxUploadSize = <span class="number">20971520</span>;</span><br><span class="line"><span class="keyword">long</span> accountBalance = <span class="number">1000000000000L</span>;</span><br><span class="line"><span class="keyword">float</span> pi = <span class="number">3.141592653589F</span>;</span><br></pre></td></tr></table></figure><p>和下面的代码作比较：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> maxUploadSize = <span class="number">20_971_520</span>;</span><br><span class="line"><span class="keyword">long</span> accountBalance = <span class="number">1_000_000_000_000L</span>;</span><br><span class="line"><span class="keyword">float</span> pi = <span class="number">3.141_592_653_589F</span>。</span><br></pre></td></tr></table></figure><p>哪一个更易懂？记得在数字字面中使用下划线，以提高代码的可读性。</p><blockquote><p><del>个人：尴尬，学了这么多年Java居然不知道有这种写法…..</del></p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这里罗列一下存在争议以及印象比较深的部分：</p><ul><li>StringBuilder替换字符串拼接。如果单纯拼接几个变量或者方法的结果，”+”号是完全没有问题的。<ul><li>虽然JDK 9 对于每次for循环new StringBuilder的BUG做了修复，但国内广泛使用JDK8的场景下依然需要避免for循环大量的字符串拼接。</li><li>这种优化不是关键，请更加关注合理的架构设计，因为这一点性能损耗对于现代处理器影响真的不大。</li><li>如果不需要考虑多线程的情况，更建议使用StringBuffer。</li></ul></li><li>精度选择，实际上不管有没有精度要求，碰到需要小数的运算建议使用BigDecimal，因为double和float的数学运算真的很容易出问题。</li><li>注释<ul><li>训练写出易懂的代码而不是易懂的注释</li><li>注释应该遵从KISS。“愚蠢”的代码最好理解。</li></ul></li><li>在大型的数字参数值中使用下划线，这是一个很容易忽略的Java小技巧，对于和金额有关的处理，这种写法非常有帮助。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>另一位读者：<span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BsYWp0aGFiYWxhenMvYmVzdC1jb2RpbmctcHJhY3RpY2VzLWV2ZXJ5LWphdmEtZGV2ZWxvcGVyLXNob3VsZC1mb2xsb3ctNDVkZmJiYzk3NzRm" title="https://medium.com/@lajthabalazs/best-coding-practices-every-java-developer-should-follow-45dfbbc9774f">Best coding practices every Java developer should follow?<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZWphdmEubmV0L2NvZGluZy8xMC1qYXZhLWNvcmUtYmVzdC1wcmFjdGljZXMtZXZlcnktamF2YS1wcm9ncmFtbWVyLXNob3VsZC1rbm93I05hbWluZ0NvbnZlbnRpb24=" title="https://www.codejava.net/coding/10-java-core-best-practices-every-java-programmer-should-know#NamingConvention">10 Java Core Best Practices Every Java Programmer Should Know<i class="fa fa-external-link"></i></span></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      Best coding practices every java developer should follow
    
    </summary>
    
    
      <category term="java-java基础" scheme="https://whitestore.top/categories/java-java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="https://whitestore.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【Kafka】编译 Kafka2.7 源码并搭建源码环境（Ver 2.7.2）</title>
    <link href="https://whitestore.top/2023/03/07/kafka-zk/"/>
    <id>https://whitestore.top/2023/03/07/kafka-zk/</id>
    <published>2023-03-07T13:17:48.000Z</published>
    <updated>2023-03-15T06:58:45.026Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Kafka 是通过 Scala 和 Java共同编写的语言，之所以选择<strong>2.7.2</strong>的版本是因为这个版本的Kafka是最后一版本保留ZK的版本。</p><blockquote><p>为什么不直接部署最新版代码？</p><p>因为过去很长一段时间Kafka都是和ZK配合的，并且有很多成熟项目都使用了带ZK的Kafka，去ZK的Kafka还有不少的路要走。</p></blockquote><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><ul><li>JDK：1.8.0_351</li><li>Scala：2.12.8</li><li>Gradle：6.6</li><li>Zookeeper：3.4.14</li></ul><h1 id="Kafka-2-7-2"><a href="#Kafka-2-7-2" class="headerlink" title="Kafka 2.7.2"></a>Kafka 2.7.2</h1><p>建议fork一个官方的分支到自己的仓库，方便自己学习的时候添加注释等内容。</p><p>地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwYWNoZS9rYWZrYQ==" title="https://github.com/apache/kafka">https://github.com/apache/kafka<i class="fa fa-external-link"></i></span></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230304143229.png" alt=""></p><h2 id="安装JDK-1-8"><a href="#安装JDK-1-8" class="headerlink" title="安装JDK 1.8"></a>安装JDK 1.8</h2><p>JDK的教程玩网上有非常多，寻找合适的JDK8的版本即可。</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cub3JhY2xlLmNvbS9qYXZhL3RlY2hub2xvZ2llcy9qYXZhc2UvamF2YXNlOC1hcmNoaXZlLWRvd25sb2Fkcy5odG1s" title="https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html">https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html<i class="fa fa-external-link"></i></span></p><a id="more"></a><h2 id="安装-Scala-2-12-8"><a href="#安装-Scala-2-12-8" class="headerlink" title="安装 Scala 2.12.8"></a>安装 Scala 2.12.8</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>下载地址为：<span class="exturl" data-url="aHR0cHM6Ly93d3cuc2NhbGEtbGFuZy5vcmcvZG93bmxvYWQvMi4xMi44Lmh0bWw=" title="https://www.scala-lang.org/download/2.12.8.html">https://www.scala-lang.org/download/2.12.8.html<i class="fa fa-external-link"></i></span></p><p>个人为Win 11，直接下载Windows 安装版本：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230212201119.png" alt=""></p><p>个人是window系统，直接点击下一步即可，安装过程这里省略了。</p><h3 id="配置-SCALA-HOME"><a href="#配置-SCALA-HOME" class="headerlink" title="配置 SCALA_HOME"></a>配置 SCALA_HOME</h3><p>安装完成之后是在对应的操作系统配置环境变量，个人在Path变量中增加<strong>SCALA_HOME</strong>，并且指定地址即可。因为个人是Windows 安装版本安装，已经自动配置了环境变量。安装完成之后结果如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\adong&gt;scala -version</span><br><span class="line">Scala code runner version 2.12.8 -- Copyright 2002-2018, LAMP/EPFL and Lightbend, Inc.</span><br></pre></td></tr></table></figure><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230212201419.png" alt=""></p><h2 id="安装-gradle-6-6"><a href="#安装-gradle-6-6" class="headerlink" title="安装 gradle 6.6"></a>安装 gradle 6.6</h2><p>下载地址：<span class="exturl" data-url="aHR0cHM6Ly9zZXJ2aWNlcy5ncmFkbGUub3JnL2Rpc3RyaWJ1dGlvbnMv" title="https://services.gradle.org/distributions/">https://services.gradle.org/distributions/<i class="fa fa-external-link"></i></span></p><p>我们选择想要安装的发布版本，<strong>gradle-x.x-bin.zip</strong> 是需要下载的安装发布版，<strong>gradle-x.x-src.zip</strong> 是源码，<strong>gradle-x.x-all.zip</strong> 则是下载全部的文件。这里我选择的是<code>gradle-6.6.1-bin.zip</code>。</p><h3 id="配置-Gradle-环境变量"><a href="#配置-Gradle-环境变量" class="headerlink" title="配置 Gradle 环境变量"></a>配置 Gradle 环境变量</h3><p>直接把gradle 的安装目录bin地址贴到环境变量的Path当中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:\adongstack\mysoft\gradle-6.6.1\bin</span><br></pre></td></tr></table></figure><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230212203101.png" alt=""></p><p>然后是在<code>cmd</code>当中验证即可：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\adong&gt;gradle -v</span><br><span class="line"></span><br><span class="line">Welcome to Gradle 6.6.1!</span><br><span class="line"></span><br><span class="line">Here are the highlights of this release:</span><br><span class="line"> - Experimental build configuration caching</span><br><span class="line"> - Built-in conventions <span class="keyword">for</span> handling credentials</span><br><span class="line"> - Java compilation supports --release flag</span><br><span class="line"></span><br><span class="line">For more details see https://docs.gradle.org/6.6.1/release-notes.html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Gradle 6.6.1</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Build time:   2020-08-25 16:29:12 UTC</span><br><span class="line">Revision:     f2d1fb54a951d8b11d25748e4711bec8d128d7e3</span><br><span class="line"></span><br><span class="line">Kotlin:       1.3.72</span><br><span class="line">Groovy:       2.5.12</span><br><span class="line">Ant:          Apache Ant(TM) version 1.10.8 compiled on May 10 2020</span><br><span class="line">JVM:          1.8.0_333 (Oracle Corporation 25.333-b02)</span><br><span class="line">OS:           Windows 11 10.0 amd64</span><br></pre></td></tr></table></figure><h2 id="安装-Zookeeper-3-4-14"><a href="#安装-Zookeeper-3-4-14" class="headerlink" title="安装 Zookeeper 3.4.14"></a>安装 Zookeeper 3.4.14</h2><p>个人建议安装到虚拟机的Linux系统，安装的操作如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://archive.apache.org/dist/zookeeper/zookeeper-3.4.14/zookeeper-3.4.14.tar.gz</span><br></pre></td></tr></table></figure><p>国内的访问速度比较慢，这里直接上外网拖了一个安装包放到网盘，读者根据网盘下载即可：</p><blockquote><p>链接：<span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMVI2eno1cGZmdXdWOEQ3Qi1ONlBWN1E/cHdkPXdvcG4=" title="https://pan.baidu.com/s/1R6zz5pffuwV8D7B-N6PV7Q?pwd=wopn">https://pan.baidu.com/s/1R6zz5pffuwV8D7B-N6PV7Q?pwd=wopn<i class="fa fa-external-link"></i></span><br>    提取码：wopn </p></blockquote><h3 id="创建-data-文件夹"><a href="#创建-data-文件夹" class="headerlink" title="创建 data 文件夹"></a>创建 data 文件夹</h3><p>在Zookeeper 3.4.14的目录当中准备<code>data</code>文件夹。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[zxd@localhost zookeeper-3.4.14]$ mkdir data</span><br><span class="line">mkdir: cannot create directory ‘data’: Permission denied</span><br><span class="line">[zxd@localhost zookeeper-3.4.14]$ sudo mkdir data</span><br><span class="line">[sudo] password <span class="keyword">for</span> zxd: </span><br><span class="line">[zxd@localhost zookeeper-3.4.14]$ ls</span><br><span class="line">bin  conf  data  dist-maven</span><br></pre></td></tr></table></figure><h3 id="修改-zoo-cfg-中的-data-属性"><a href="#修改-zoo-cfg-中的-data-属性" class="headerlink" title="修改 zoo.cfg 中的 data 属性"></a>修改 zoo.cfg 中的 data 属性</h3><p>我们将Zookeeper的数据目录执行刚刚新建的data文件夹。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> conf</span><br><span class="line">vim zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure><p><code>vim zoo_sample.cfg zoo.cfg</code>，我们修改相关的配置，默认目录在<code>/tmp/zookeeper</code>，这里个人改为<code>/opt/zookeeper/zookeeper-3.4.14/data</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># the directory where the snapshot is stored.</span></span><br><span class="line"><span class="comment"># do not use /tmp for storage, /tmp here is just </span></span><br><span class="line"><span class="comment"># example sakes.</span></span><br><span class="line"><span class="comment">#dataDir=/tmp/zookeeper</span></span><br><span class="line">dataDir=/opt/zookeeper/zookeeper-3.4.14/data</span><br><span class="line"><span class="comment"># the port at which the clients will connect</span></span><br><span class="line">clientPort=2181</span><br></pre></td></tr></table></figure><p>修改之后我们使用<code>-x</code> 应用修改。</p><h2 id="启动Zookeeper"><a href="#启动Zookeeper" class="headerlink" title="启动Zookeeper"></a>启动Zookeeper</h2><p>编辑完成之后，进入到安装目录的bin目录当中启动Zookeeper。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[zxd@localhost zookeeper-3.4.14]$ <span class="built_in">cd</span> bin/</span><br><span class="line">[zxd@localhost bin]$ sudo ./zkServer.sh start </span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/zookeeper/zookeeper-3.4.14/bin/../conf/zoo.cfg</span><br><span class="line">grep: /opt/zookeeper/zookeeper-3.4.14/bin/../conf/zoo.cfg: No such file or directory</span><br><span class="line">mkdir: cannot create directory ‘’: No such file or directory</span><br><span class="line">Starting zookeeper ... STARTED</span><br></pre></td></tr></table></figure><p>发现没有启动成功，根据提示我们需要zoo.cfg的配置，这部分为Zk的内容，这里就直接跳过了。</p><h2 id="Kafka-2-7-2-源码下载"><a href="#Kafka-2-7-2-源码下载" class="headerlink" title="Kafka 2.7.2 源码下载"></a>Kafka 2.7.2 源码下载</h2><p>下载<code>kafka-2.7.2-src.tgz</code>包之后，解压到对应的目录，接下来需要导入到Idea当中。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230212212305.png" alt=""></p><h2 id="导入Idea"><a href="#导入Idea" class="headerlink" title="导入Idea"></a>导入Idea</h2><p>下载源码之后在Idea当中导入Kafka项目。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230212213914.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230212213934.png" alt=""></p><p>导入项目之后，我们进入到Setting， 设置Gradle的Home地址。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230212214041.png" alt=""></p><p>这里把Gradle的Home地址设置为自己本机安装的，不使用Iead自带的。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230212214002.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230212214219.png" alt=""></p><h3 id="修改-build-gradle"><a href="#修改-build-gradle" class="headerlink" title="修改 build.gradle"></a>修改 build.gradle</h3><p>接下来还不能导 jar 包，需要把镜像文件下载服务器更换为国内的私服，否则会相当慢，直接导致 “time out” 报错。进入 kafka 源码包，修改 <strong>build.gradle</strong> 文件，在原来配置上，添加阿里的私服配置。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230212214419.png" alt=""></p><p>下面的内容复制到 <strong>build.gradle</strong> 文件的对应位置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">maven &#123;</span><br><span class="line">url 'http://maven.aliyun.com/nexus/content/groups/public/'</span><br><span class="line">&#125;</span><br><span class="line">maven &#123;</span><br><span class="line">url 'http://maven.aliyun.com/nexus/content/repositories/jcenter'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>文件当中查找<code>buildscript</code>可以快速定位。</p></blockquote><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230212214501.png" alt=""></p><p>注意最后需要 <strong>调整一下位置</strong>，优先从阿里云的库获取：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;  </span><br><span class="line">  repositories &#123;  </span><br><span class="line">    maven &#123;  </span><br><span class="line">      url <span class="string">'http://maven.aliyun.com/nexus/content/groups/public/'</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">    maven &#123;  </span><br><span class="line">      url <span class="string">'http://maven.aliyun.com/nexus/content/repositories/jcenter'</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">    mavenCentral()  </span><br><span class="line">    jcenter()  </span><br><span class="line">    maven &#123;  </span><br><span class="line">      url <span class="string">"https://plugins.gradle.org/m2/"</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure><p>接着还需要复制到<code>allproject</code>当中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">maven &#123;</span><br><span class="line">url <span class="string">'http://maven.aliyun.com/nexus/content/groups/public/'</span></span><br><span class="line">&#125;</span><br><span class="line">maven &#123;</span><br><span class="line">url <span class="string">'http://maven.aliyun.com/nexus/content/repositories/jcenter'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复制到的位置大概如下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">allprojects</span> &#123;  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">repositories</span> &#123;  </span><br><span class="line">    maven &#123;  </span><br><span class="line">      url <span class="string">'http://maven.aliyun.com/nexus/content/groups/public/'</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">    maven &#123;  </span><br><span class="line">      url <span class="string">'http://maven.aliyun.com/nexus/content/repositories/jcenter'</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">    mavenCentral()  </span><br><span class="line">  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>替换之后耐心等待依赖下载完成：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230212221849.png" alt=""></p><p>在依赖安装完成之后，我们可以点一下Idea顶部的小锤子，最后的提示编译成功：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230212223300.png" alt=""></p><h3 id="安装-Idea-scala-插件"><a href="#安装-Idea-scala-插件" class="headerlink" title="安装 Idea scala 插件"></a>安装 Idea scala 插件</h3><p>Idea导入源码之后的<code>.scala</code>文件是没有语法提示的，我们安装插件之后可以正常阅读scala的源码：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230212225657.png" alt=""></p><p>插件安装完成之后需要重启。访问<code>kafka.scala</code>，如果相关的代码出现颜色和语法提示说明插件安装成功：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230212225903.png" alt=""></p><h2 id="选择-scala-jdk"><a href="#选择-scala-jdk" class="headerlink" title="选择 scala jdk"></a>选择 scala jdk</h2><p>如果读者是第一次搭建Kafka和使用scala，大概率会出现下面的提示：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230212230210.png" alt=""></p><p>根据提示设置<code>scala jdk</code>的安装目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files (x86)\scala\bin</span><br></pre></td></tr></table></figure><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230212230345.png" alt=""></p><p>设置完成之后一切就大功告成了。</p><h2 id="编译和构建-Kafka-源码"><a href="#编译和构建-Kafka-源码" class="headerlink" title="编译和构建 Kafka 源码"></a>编译和构建 Kafka 源码</h2><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230212223700.png" alt=""></p><p>这里个人不太熟悉Idea对于gradle的使用，最后用了gradle的命令进行构建，构建之后出现下面的内容表示正确：</p><p><code>gradle</code>命令是用来下载和更新 Gradle 套件（Gradle Wrapper）的，<code>gradle jar</code>是用 Gradle 套件构建 Kafka 工程，生成 Jar 文件。</p><p>下面是使用<code>gradle</code> 命令的结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">adong@Adong-pc MINGW64 /e/adongstack/project/selfUp/kafka-2.7/kafka-2.7.2-src</span><br><span class="line">$ gradle</span><br><span class="line">Starting a Gradle Daemon, 1 busy Daemon could not be reused, use --status <span class="keyword">for</span> details</span><br><span class="line"></span><br><span class="line">&gt; Configure project :</span><br><span class="line">Building project <span class="string">'core'</span> with Scala version 2.13.3</span><br><span class="line">Building project <span class="string">'streams-scala'</span> with Scala version 2.13.3</span><br><span class="line"></span><br><span class="line">&gt; Task :<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">Welcome to Gradle 6.6.1.</span><br><span class="line"></span><br><span class="line">To run a build, run gradle &lt;task&gt; ...</span><br><span class="line"></span><br><span class="line">To see a list of available tasks, run gradle tasks</span><br><span class="line"></span><br><span class="line">To see a list of <span class="built_in">command</span>-line options, run gradle --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">To see more detail about a task, run gradle <span class="built_in">help</span> --task &lt;task&gt;</span><br><span class="line"></span><br><span class="line">For troubleshooting, visit https://help.gradle.org</span><br><span class="line"></span><br><span class="line">Deprecated Gradle features were used <span class="keyword">in</span> this build, making it incompatible with Gradle 7.0.</span><br><span class="line">Use <span class="string">'--warning-mode all'</span> to show the individual deprecation warnings.</span><br><span class="line">See https://docs.gradle.org/6.6.1/userguide/command_line_interface.html<span class="comment">#sec:command_line_warnings</span></span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL <span class="keyword">in</span> 44s</span><br><span class="line">1 actionable task: 1 executed</span><br></pre></td></tr></table></figure><p>下面使用<code>gradle jar</code>的编译结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">adong@Adong-pc MINGW64 /e/adongstack/project/selfUp/kafka-2.7/kafka-2.7.2-src</span><br><span class="line">$ gradle jar</span><br><span class="line"></span><br><span class="line">&gt; Configure project :</span><br><span class="line">Building project <span class="string">'core'</span> with Scala version 2.13.3</span><br><span class="line">Building project <span class="string">'streams-scala'</span> with Scala version 2.13.3</span><br><span class="line"></span><br><span class="line">&gt; Task :clients:processMessages</span><br><span class="line">MessageGenerator: processed 121 Kafka message JSON files(s).</span><br><span class="line"></span><br><span class="line">&gt; Task :raft:processMessages</span><br><span class="line">MessageGenerator: processed 1 Kafka message JSON files(s).</span><br><span class="line">&lt;=------------&gt; 12% EXECUTING [2m 6s]</span><br><span class="line"></span><br><span class="line">&gt; Task :clients:processTestMessages</span><br><span class="line">MessageGenerator: processed 2 Kafka message JSON files(s).</span><br><span class="line">&lt;==-----------&gt; 21% EXECUTING [3m 10s]</span><br><span class="line"></span><br><span class="line">&gt; Task :streams:processMessages</span><br><span class="line">MessageGenerator: processed 1 Kafka message JSON files(s).</span><br><span class="line"></span><br><span class="line">Deprecated Gradle features were used <span class="keyword">in</span> this build, making it incompatible with Gradle 7.0.</span><br><span class="line">Use <span class="string">'--warning-mode all'</span> to show the individual deprecation warnings.</span><br><span class="line">See https://docs.gradle.org/6.6.1/userguide/command_line_interface.html<span class="comment">#sec:command_line_warnings</span></span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL <span class="keyword">in</span> 3m 58s</span><br><span class="line">87 actionable tasks: 87 executed</span><br></pre></td></tr></table></figure><p>最后使用下面的命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle clean build -x <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>但是这种命令构建过程会出现一些报错，可以把报错所需要的依赖jar包放到下面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:\adongstack\project\selfUp\kafka-2.7\kafka-2.7.2-src\gradle\wrapper</span><br></pre></td></tr></table></figure><p>要构建整个 Kafka 工程并打包出一个可运行的二进制环境命令如下</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle clean releaseTarGz</span><br></pre></td></tr></table></figure><h3 id="其他构建命令"><a href="#其他构建命令" class="headerlink" title="其他构建命令"></a>其他构建命令</h3><p>还有其他gradle的构建命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">构建 jar包并运行</span><br><span class="line">.&#x2F;gradle jar</span><br><span class="line"></span><br><span class="line">构建项目，看你是idea工具还是eclipse</span><br><span class="line">.&#x2F;gradle idea</span><br><span class="line">.&#x2F;gradle eclipse</span><br><span class="line"></span><br><span class="line">构建源码包</span><br><span class="line">.&#x2F;gradle srcJar</span><br><span class="line"></span><br><span class="line">构建javadoc文档</span><br><span class="line">.&#x2F;gradle aggregatedJavadoc</span><br><span class="line"></span><br><span class="line">清理并构建</span><br><span class="line">.&#x2F;gradle clean</span><br></pre></td></tr></table></figure><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>Kafka当中同样存在很多单元测试，下面是一些核心模块的单元测试命令。</p><p>core 模块单元测试：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle core:test</span><br></pre></td></tr></table></figure><p>client 模块单元测试：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle clients:test</span><br></pre></td></tr></table></figure><p>模块当中的某个子模块单元测试：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle connect:[submodule]:test</span><br></pre></td></tr></table></figure><blockquote><p>Connect 工程下细分了多个子模块，比如 api、runtime 等，需要显式地指定要 测试的子模块名才能进行测试。</p></blockquote><p>stream 模块单元测试。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle connect:[submodule]:test</span><br></pre></td></tr></table></figure><p>个人实际使用之后会发现有部分报错信息：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230213070600.png" alt=""></p><p>除了上面的整个模块的单元测试，如果只想要测试某个模块下的某个类，可以使用下面的方法：</p><p>单独对某一个具体的测试用例进行测试，比如测试 <strong>LogTest</strong> 类：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle core:test --tests kafka.log.LogTest</span><br></pre></td></tr></table></figure><p>个人的执行结果如下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ gradle core:test --tests kafka.log.LogTest</span><br><span class="line"></span><br><span class="line">&gt; Configure <span class="keyword">project</span> :</span><br><span class="line">Building <span class="keyword">project</span> <span class="string">'core'</span> with Scala version <span class="number">2.13</span>.<span class="number">3</span></span><br><span class="line">Building <span class="keyword">project</span> <span class="string">'streams-scala'</span> with Scala version <span class="number">2.13</span>.<span class="number">3</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">Task</span> :core:test</span><br><span class="line">kafka.log.LogTest.testLogDelete failed, log available in E:\adongstack\<span class="keyword">project</span>\selfUp\kafka-<span class="number">2.7</span>\kafka-<span class="number">2.7</span>.<span class="number">2</span>-src\core\build\reports\testOutput\kafka.log.LogTest.testLogDelete.test.stdout</span><br><span class="line"></span><br><span class="line">kafka.log.LogTest &gt; testLogDelete FAILED</span><br><span class="line">    org.apache.kafka.common.errors.KafkaStorageException: Error <span class="keyword">while</span> deleting log <span class="keyword">for</span> kafka-<span class="number">936488</span> in dir C:\Users\adong\AppData\Local\Temp\kafka-<span class="number">7162272829353105740</span></span><br><span class="line"></span><br><span class="line">        Caused by:</span><br><span class="line">        java.nio.<span class="keyword">file</span>.FileSystemException: C:\Users\adong\AppData\Local\Temp\kafka-<span class="number">7162272829353105740</span>\kafka-<span class="number">936488</span>\<span class="number">00000000000000000000</span>.timeindex -&gt; C:\Users\adong\AppData\Local\Temp\kafka-<span class="number">7162272829353105740</span>\kafka-<span class="number">936488</span>\<span class="number">00000000000000000000</span>.timeindex.deleted: ▒▒һ▒▒▒▒▒▒▒▒▒▒ʹ▒ô▒▒ļ▒▒▒▒▒▒▒▒޷▒▒▒▒ʡ▒</span><br></pre></td></tr></table></figure><h1 id="Kafka目录结构"><a href="#Kafka目录结构" class="headerlink" title="Kafka目录结构"></a>Kafka目录结构</h1><p><strong>bin 目录</strong>：保存 Kafka 工具行脚本，我们熟知的 kafka-server-start 和 kafka-consoleproducer 等脚本都存放在这。</p><p><strong>clients 目录</strong>：保存 Kafka 客户端代码，比如生产者和消费者的代码都在该目录下。 </p><p><strong>config 目录</strong>：保存 Kafka 的配置文件，其中比较重要的配置文件是 server.properties。 </p><p><strong>connect 目录</strong>：保存 Connect 组件的源代码。Kafka Connect 组件是用来实现 Kafka 与外部系统之间的<strong>实时数据传输</strong>的。 </p><p><strong>core 目录</strong>：保存 Broker 端代码。Kafka 服务器端代码全部保存在该目录下。</p><p><strong>streams 目录</strong>：保存 Streams 组件的源代码。Kafka Streams 是实现 Kafka <strong>实时流处理</strong>的组件。</p><p><strong>server 目录</strong>：顾名思义，它是 Kafka 的服务器端主代码，里面的类非常多，很多关键的 Kafka 组件都存放在这里，比如状态机、Purgatory 延时机制等。</p><blockquote><p>Kafka Streams is a client library for building applications and microservices, where the input and output data are stored in Kafka clusters.</p></blockquote><p>提供一个基于 Kafka 的流式处理类库，直接提供具体的类给开发者调用，整个应用的运行方式主要由开发者控制，方便使用和调试。</p><p>Kafka Streams 是一个用来构建流处理程序的库，特别是其输入是一个 Kafka topic，输出是另一个 Kafka topic 的程序（或者是调用外部服务，或者是更新数据库，或者其它）。它使得你以一种分布式以及容错的方式来做这件事情。</p><p><strong>coordinator 包</strong>：保存了消费者端的 GroupCoordinator 代码和用于事务的 TransactionCoordinator 代码。对 coordinator 包进行分析，特别是对消费者端的 GroupCoordinator 代码进行分析，是我们弄明白 Broker 端协调者组件设计原理的关 键。</p><h1 id="其他目录结构"><a href="#其他目录结构" class="headerlink" title="其他目录结构"></a>其他目录结构</h1><p>除了上面的核心目录之外，我们还可以在项目根路径看到一些其他模块：</p><p><strong>network 包</strong>：封装了 Kafka 服务器端网络层的代码，特别是 SocketServer.scala 这个文件，是 Kafka 实现 Reactor 模式的具体操作类，非常值得一读。</p><p><strong>consumer 包</strong>：后面会丢弃该包，用 clients 包下 consumer 相关类代替。</p><p><strong>tools 包</strong>：工具类。</p><p><strong>log 包</strong>：保存了 Kafka 最核心的日志结构代码，包括日志、日志段、索引文件等, 另外，该包下还封装了 Log Compaction 的实现机制，是非常重要的源码包。</p><p><strong>checkstyle 目录</strong>：代码规范，自动化检测。</p><blockquote><p>Checkstyle 是什么，类似于代码规范的自动化检测插件，国内最为经典的是阿里巴巴的规约插件，而最出名的检查插件为 <code>google style guide</code>，Checkstyle 就是以类似这种风格开发出的一个自动化插件，来辅助判断代码格式是否满足规范。</p></blockquote><p>该目录下的文件定义了工程代码格式的规范，我们可以在 build.gradle 中看到相关 checkstyle 的配置和自动化代码格式化配置：</p><p><strong>checkstyle 配置（build.gradle）</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkstyleConfigProperties</span></span>(configFileName) &#123;  </span><br><span class="line">  [importControlFile: <span class="string">"$rootDir/checkstyle/$configFileName"</span>,  </span><br><span class="line">   suppressionsFile: <span class="string">"$rootDir/checkstyle/suppressions.xml"</span>,  </span><br><span class="line">   headerFile: <span class="string">"$rootDir/checkstyle/java.header"</span>]  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkstyle &#123;  </span><br><span class="line">  configProperties = checkstyleConfigProperties(<span class="string">"import-control-core.xml"</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>connect 目录</strong>：保存 Connect 组件的源代码。 Kafka Connect 组件是用来实现 Kafka 与外部系统之间的实时数据传输的。</p><p><strong>docs 目录</strong>：Kafka 设计文档以及组件相关结构图。</p><p><strong>examples 目录</strong>：Kafka 样例相关目录。</p><p><strong>gradle 目录</strong>：gradle 的脚本和依赖包定义等相关文件。</p><p><strong>jmh-benchmarks 目录</strong>：Kafka 代码微基准测试相关类。</p><blockquote><p>JMH，即 Java Microbenchmark Harness，是<strong>专门用于代码微基准测试的工具套件</strong>。Micro Benchmark 是什么意思？简单的来说就是<strong>基于方法层面的基准测试</strong>，精度可以达到微秒级。当你定位到热点方法，希望进一步优化方法性能的时候，就可以使用 JMH 对优化的结果进行量化的分析。</p></blockquote><p>JMH 比较典型的应用场景有：</p><ul><li>准确的知道某个方法需要执行多长时间，以及执行时间和输入之间的相关性；</li><li>对比接口不同实现在给定条件下的吞吐量，找到最优实现。</li></ul><p><strong>kafka-logs 目录</strong>：server.properties 文件中配置 log.dirs 生成的目录。</p><p><strong>log4j-appender 目录</strong>：</p><blockquote><p>A log4j appender that produces log messages to Kafka</p></blockquote><p>这个目录里面就一个 KafkaLog4jAppender 类。</p><p><strong>raft 目录</strong>：raft 一致性协议相关模块。</p><p><strong>tests 目录</strong>：此目录的内容介绍如何进行 Kafka 系统集成和性能测试。</p><p><strong>tools 目录</strong>：工具类模块。</p><p><strong>vagrant 目录</strong>：介绍如何在 Vagrant 虚拟环境中运行 Kafka，提供了相关的脚本文件和说明文档。</p><blockquote><p>Vagrant 是一个基于 Ruby 的工具，用于创建和部署虚拟化开发环境。它使用 Oracle 的开源 VirtualBox 虚拟化系统，使用 Chef 创建自动化虚拟环境。</p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDA0MDc5MDUyNA==" title="https://segmentfault.com/a/1190000040790524">https://segmentfault.com/a/1190000040790524<i class="fa fa-external-link"></i></span></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      Kafka
    
    </summary>
    
    
      <category term="Kafka" scheme="https://whitestore.top/categories/Kafka/"/>
    
    
      <category term="Kafka" scheme="https://whitestore.top/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】getline解释</title>
    <link href="https://whitestore.top/2023/02/28/getlines/"/>
    <id>https://whitestore.top/2023/02/28/getlines/</id>
    <published>2023-02-28T09:18:00.000Z</published>
    <updated>2023-02-28T09:19:06.634Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><p>先说一下重要的知识点：</p><ul><li><code>getline;</code>在<code>awk</code>中可以用于控制“循环”。</li><li><code>getline;</code>之后，awk会改变对应的NF，NR，FNR和$0等内部变量</li><li><code>getline;</code>拿到的是<strong>下一行</strong>而不是当前行，概念想象为<code>++i</code>操作即可。</li></ul><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>getline命令改变了awk的运行逻辑，是awk命令不可或缺的一部分。awk本质上就是一个for循环，它每次对输入文件的一行进行处理，然后转而执行下一行，直到整个文件的每一行都被执行完毕。整个过程是自动的无需做什么。</p><p><code>getline</code>命令却可以让你去<strong>控制循环</strong>。当然，getline命令执行后，awk会设置NF，NR，FNR和$0等这些<strong>内部变量</strong>。</p><a id="more"></a><h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><p>我们先看一个简单的例子，打印出从1到10之间的偶数：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[zxd@localhost kafka2.<span class="number">8</span>.X]$ seq <span class="number">10</span> <span class="params">| awk '&#123;getline; print $0&#125;'</span></span><br><span class="line"><span class="params">2</span></span><br><span class="line"><span class="params">4</span></span><br><span class="line"><span class="params">6</span></span><br><span class="line"><span class="params">8</span></span><br><span class="line"><span class="params">10</span></span><br></pre></td></tr></table></figure><p>这个命令的的执行逻辑是执行一个for循环从1到10，在循环内部先执行<code>getline;</code>然后打印<code>$0</code>，<code>$0</code>指向的就是当前的变量，注意<code>getline;</code>获取的是<strong>获取当前行的下一行</strong>，类似我们编程语言的<code>++i</code>，注意<code>getline;</code>之后，awk会改变对应的NF，NR，FNR和$0等内部变量，所以<code>$0</code>值会随着遍历改变，最后实现打印偶数效果。</p><p>根据上面的介绍我们可以推导出打印奇数的逻辑：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[zxd@localhost kafka2.8.X]$ seq 10 | awk <span class="string">'&#123; print $0;getline;&#125;'</span></span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">7</span><br><span class="line">9</span><br></pre></td></tr></table></figure><h1 id="临时变量使用"><a href="#临时变量使用" class="headerlink" title="临时变量使用"></a>临时变量使用</h1><p>奇偶行对调打印，原来在奇数行的内容将其打印在偶数行，原来在偶数行的内容将其打印在奇数行，要实现这个功能，需要在循环中使用临时变量：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seq 10 | awk <span class="string">'&#123;getline tmp; print tmp; print $0&#125;'</span></span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[zxd@localhost kafka2.8.X]$ seq 10 | awk <span class="string">'&#123;getline tmp; print tmp; print $0&#125;'</span></span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">8</span><br><span class="line">7</span><br><span class="line">10</span><br><span class="line">9</span><br></pre></td></tr></table></figure><h1 id="文件合并"><a href="#文件合并" class="headerlink" title="文件合并"></a>文件合并</h1><p>在上面的例子当中<code>tmp</code>变量是不会改变的。</p><p>getline也可以从另外一个文件中读取内容。下面例子实现将两个文件的每一行都打印在一行上：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vim b.txt</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">vim c.txt</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">[zxd@localhost ~]$ awk <span class="string">'&#123;printf "%s ", $0; getline &lt; "c.txt"; print $0&#125;'</span> b.txt </span><br><span class="line">1 6</span><br><span class="line">2 7</span><br><span class="line">3 8</span><br><span class="line">4 9</span><br><span class="line">5 10</span><br></pre></td></tr></table></figure><h1 id="日期获取"><a href="#日期获取" class="headerlink" title="日期获取"></a>日期获取</h1><p>getline也可以用来执行一个UNIX命令，并得到它的输出。下面例子通过getline得到系统的当前时间：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN &#123;"date" | getline; close("date"); print $0&#125;'</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zxd@localhost ~]$ awk <span class="string">'BEGIN &#123;"date" | getline; close("date"); print $0&#125;'</span></span><br><span class="line">Wed Mar  1 00:34:01 CST 2023</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYmVpY2hlbmdmL2FydGljbGUvZGV0YWlscy81MTM2NzMxMQ==" title="https://blog.csdn.net/xibeichengf/article/details/51367311"># awk getline命令解析<i class="fa fa-external-link"></i></span></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      getline介绍）
    
    </summary>
    
    
      <category term="Linux" scheme="https://whitestore.top/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://whitestore.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】awk命令介绍</title>
    <link href="https://whitestore.top/2023/02/28/awkstudy/"/>
    <id>https://whitestore.top/2023/02/28/awkstudy/</id>
    <published>2023-02-28T09:16:48.000Z</published>
    <updated>2023-02-28T09:19:26.986Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p><code>Awk</code>是一种用于高级文本处理的通用脚本语言，其主要用作报告和分析工具，与大多数其他程序性编程语言不同，<code>Awk</code>是数据驱动的，也就是说需要定义一组针对输入文本要执行的操作，然后其获取输入数据，对其进行转换，然后将结果发送到标准输出。</p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk [ -F fs ] [ -v <span class="keyword">var</span>=value ] [ <span class="string">'prog'</span> | -f progfile ] [ file ... ]</span><br></pre></td></tr></table></figure><h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><ul><li><code>-F fs</code>: 将输入字段分隔符设置为正则表达式<code>fs</code>。</li><li><code>-v var=value</code>: 在执行<code>awk</code>程序之前，将值赋值给变量<code>var</code>。</li><li><code>&#39;prog&#39;</code>: <code>awk</code>程序。</li><li><code>-f progfile</code>: 指定文件<code>progfile</code>，其中包含要执行的<code>awk</code>程序。</li><li><code>file ...</code>: 由指定的<code>awk</code>程序处理的文件。</li></ul><a id="more"></a><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>示例文件<code>example.txt</code>文件内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Bucks Milwaukee    <span class="number">60</span> <span class="number">22</span> <span class="number">0.732</span> </span><br><span class="line">Raptors Toronto    <span class="number">55</span> <span class="number">24</span> <span class="number">0.707</span> </span><br><span class="line"><span class="number">76</span>ers Philadelphia <span class="number">51</span> <span class="number">31</span> <span class="number">0.622</span></span><br><span class="line">Celtics Boston     <span class="number">33</span> <span class="number">33</span> <span class="number">0.598</span></span><br><span class="line">Pacers Indiana     <span class="number">30</span> <span class="number">34</span> <span class="number">0.585</span></span><br></pre></td></tr></table></figure><p>输出<code>example.txt</code>的第<code>3</code>个字段。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'&#123; print $3 &#125;'</span> example.txt</span><br><span class="line"># 60</span><br><span class="line"># 55</span><br><span class="line"># 51</span><br><span class="line"># 33</span><br><span class="line"># 30</span><br></pre></td></tr></table></figure><p>使用正则表达式匹配出以<code>R</code>开头的组。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'/^R/ &#123; print $1,$2,$3,$4 &#125;'</span> example.txt</span><br><span class="line"># Raptors Toronto 55 24</span><br></pre></td></tr></table></figure><p>使用<code>BEGIN</code>以及<code>END</code>输出在处理记录之前与之后执行的操作，处理过程为输出第二个字段包含<code>Tor</code>的组。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN &#123; print "Start Processing" &#125;; $2 ~ /Tor/ &#123;print $1,$2,$3,$4 &#125;; END &#123; print "End Processing" &#125;'</span> example.txt</span><br><span class="line"># Start Processing</span><br><span class="line"># Raptors Toronto 55 24</span><br><span class="line"># End Processing</span><br></pre></td></tr></table></figure><h1 id="每日一题"><a href="#每日一题" class="headerlink" title="每日一题"></a>每日一题</h1><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1dpbmRydW5uZXJNYXgvRXZlcnlEYXkvYmxvYi9tYXN0ZXIvTGludXgvYXdrJUU1JTkxJUJEJUU0JUJCJUE0Lm1k" title="https://github.com/WindrunnerMax/EveryDay/blob/master/Linux/awk%E5%91%BD%E4%BB%A4.md">EveryDay/awk命令.md at master · WindrunnerMax/EveryDay · GitHub<i class="fa fa-external-link"></i></span></p><h1 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h1><p>[[【Linux】getline解释]]</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><span class="exturl" data-url="aHR0cHM6Ly9saW51eGl6ZS5jb20vcG9zdC9hd2stY29tbWFuZC8=" title="https://linuxize.com/post/awk-command/">https://linuxize.com/post/awk-command/<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY29tcHV0ZXJob3BlLmNvbS91bml4L3Vhd2suaHRt" title="https://www.computerhope.com/unix/uawk.htm">https://www.computerhope.com/unix/uawk.htm<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS9saW51eC9saW51eC1jb21tLWF3ay5odG1s" title="https://www.runoob.com/linux/linux-comm-awk.html">https://www.runoob.com/linux/linux-comm-awk.html<i class="fa fa-external-link"></i></span></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      awk
    
    </summary>
    
    
      <category term="Linux" scheme="https://whitestore.top/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://whitestore.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【Kafka】Kafka-Server-start.sh 启动脚本分析（Ver 2.7.2）</title>
    <link href="https://whitestore.top/2023/02/27/kafkastart/"/>
    <id>https://whitestore.top/2023/02/27/kafkastart/</id>
    <published>2023-02-26T23:42:33.000Z</published>
    <updated>2023-03-02T01:34:33.623Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kafka-Server-start-sh"><a href="#Kafka-Server-start-sh" class="headerlink" title="Kafka-Server-start.sh"></a>Kafka-Server-start.sh</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -lt 1 ];  </span><br><span class="line"><span class="keyword">then</span>  </span><br><span class="line"> <span class="comment"># 提示命令使用方法</span></span><br><span class="line"> <span class="built_in">echo</span> <span class="string">"USAGE: <span class="variable">$0</span> [-daemon] server.properties [--override property=value]*"</span> <span class="built_in">exit</span> 1  </span><br><span class="line"><span class="keyword">fi</span>  </span><br><span class="line">base_dir=$(dirname <span class="variable">$0</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"x<span class="variable">$KAFKA_LOG4J_OPTS</span>"</span> = <span class="string">"x"</span> ]; <span class="keyword">then</span>  </span><br><span class="line">    <span class="built_in">export</span> KAFKA_LOG4J_OPTS=<span class="string">"-Dlog4j.configuration=file:<span class="variable">$base_dir</span>/../config/log4j.properties"</span>  </span><br><span class="line"><span class="keyword">fi</span>  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"x<span class="variable">$KAFKA_HEAP_OPTS</span>"</span> = <span class="string">"x"</span> ]; <span class="keyword">then</span>  </span><br><span class="line">    <span class="built_in">export</span> KAFKA_HEAP_OPTS=<span class="string">"-Xmx1G -Xms1G"</span>  </span><br><span class="line"><span class="keyword">fi</span>  </span><br><span class="line">  </span><br><span class="line">EXTRA_ARGS=<span class="variable">$&#123;EXTRA_ARGS-'-name kafkaServer -loggc'&#125;</span>  </span><br><span class="line">  </span><br><span class="line">COMMAND=<span class="variable">$1</span>  </span><br><span class="line"><span class="keyword">case</span> <span class="variable">$COMMAND</span> <span class="keyword">in</span>  </span><br><span class="line">  -daemon)  </span><br><span class="line">    EXTRA_ARGS=<span class="string">"-daemon "</span><span class="variable">$EXTRA_ARGS</span>  </span><br><span class="line">    <span class="built_in">shift</span>  </span><br><span class="line">    ;;  </span><br><span class="line">  *)  </span><br><span class="line">    ;;  </span><br><span class="line"><span class="keyword">esac</span>  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">exec</span> <span class="variable">$base_dir</span>/kafka-run-class.sh <span class="variable">$EXTRA_ARGS</span> kafka.Kafka <span class="string">"<span class="variable">$@</span>"</span></span><br></pre></td></tr></table></figure><ol><li>判断参数有没有，参数个数小于1就提示用法；</li><li>获取脚本当前路径赋值给变量 base_dir；</li><li>判断日志参数 <strong>KAFKA_LOG4J_OPTS</strong> 是否为空，为空就给它一个值；</li><li>判断堆参数 <strong>KAFKA_HEAP_OPTS</strong>是否为空，为空就默认给它赋值为 “-Xmx1G -Xms1G”，默认的堆空间指定为1G；</li><li>判断启动命令中第一个参数是否为 <code>-daemon</code>，如果是就以<strong>守护进程启动</strong>（其实不是，是赋给另一个变量 EXTRA_ARGS）；</li><li>执行命令。</li></ol><p>最后一个脚本是执行另一个脚本：<code>kafka-run-class.sh</code>，这个脚本的内容比较复杂了。</p><a id="more"></a><h1 id="kafka-run-class-sh"><a href="#kafka-run-class-sh" class="headerlink" title="kafka-run-class.sh"></a>kafka-run-class.sh</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -lt 1 ];</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"USAGE: <span class="variable">$0</span> [-daemon] [-name servicename] [-loggc] classname [opts]"</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CYGWIN == 1 if Cygwin is detected, else 0.</span></span><br><span class="line"><span class="keyword">if</span> [[ $(uname -a) =~ <span class="string">"CYGWIN"</span> ]]; <span class="keyword">then</span></span><br><span class="line">  CYGWIN=1</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  CYGWIN=0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$INCLUDE_TEST_JARS</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  INCLUDE_TEST_JARS=<span class="literal">false</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Exclude jars not necessary for running commands.</span></span><br><span class="line">regex=<span class="string">"(-(test|test-sources|src|scaladoc|javadoc)\.jar|jar.asc)$"</span></span><br><span class="line"><span class="function"><span class="title">should_include_file</span></span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">"<span class="variable">$INCLUDE_TEST_JARS</span>"</span> = <span class="literal">true</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">return</span> 0</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  file=<span class="variable">$1</span></span><br><span class="line">  <span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$(echo "$file" | egrep "$regex")</span>"</span> ] ; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">return</span> 0</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">return</span> 1</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">base_dir=$(dirname <span class="variable">$0</span>)/..</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$SCALA_VERSION</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  SCALA_VERSION=2.13.3</span><br><span class="line">  <span class="keyword">if</span> [[ -f <span class="string">"<span class="variable">$base_dir</span>/gradle.properties"</span> ]]; <span class="keyword">then</span></span><br><span class="line">    SCALA_VERSION=`grep <span class="string">"^scalaVersion="</span> <span class="string">"<span class="variable">$base_dir</span>/gradle.properties"</span> | cut -d= -f 2`</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$SCALA_BINARY_VERSION</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  SCALA_BINARY_VERSION=$(<span class="built_in">echo</span> <span class="variable">$SCALA_VERSION</span> | cut -f 1-2 -d <span class="string">'.'</span>)</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># run ./gradlew copyDependantLibs to get all dependant jars in a local dir</span></span><br><span class="line"><span class="built_in">shopt</span> -s nullglob</span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$UPGRADE_KAFKA_STREAMS_TEST_VERSION</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">for</span> dir <span class="keyword">in</span> <span class="string">"<span class="variable">$base_dir</span>"</span>/core/build/dependant-libs-<span class="variable">$&#123;SCALA_VERSION&#125;</span>*;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    CLASSPATH=<span class="string">"<span class="variable">$CLASSPATH</span>:<span class="variable">$dir</span>/*"</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">"<span class="variable">$base_dir</span>"</span>/examples/build/libs/kafka-examples*.jar;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> should_include_file <span class="string">"<span class="variable">$file</span>"</span>; <span class="keyword">then</span></span><br><span class="line">    CLASSPATH=<span class="string">"<span class="variable">$CLASSPATH</span>"</span>:<span class="string">"<span class="variable">$file</span>"</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$UPGRADE_KAFKA_STREAMS_TEST_VERSION</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  clients_lib_dir=$(dirname <span class="variable">$0</span>)/../clients/build/libs</span><br><span class="line">  streams_lib_dir=$(dirname <span class="variable">$0</span>)/../streams/build/libs</span><br><span class="line">  streams_dependant_clients_lib_dir=$(dirname <span class="variable">$0</span>)/../streams/build/dependant-libs-<span class="variable">$&#123;SCALA_VERSION&#125;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  clients_lib_dir=/opt/kafka-<span class="variable">$UPGRADE_KAFKA_STREAMS_TEST_VERSION</span>/libs</span><br><span class="line">  streams_lib_dir=<span class="variable">$clients_lib_dir</span></span><br><span class="line">  streams_dependant_clients_lib_dir=<span class="variable">$streams_lib_dir</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">"<span class="variable">$clients_lib_dir</span>"</span>/kafka-clients*.jar;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> should_include_file <span class="string">"<span class="variable">$file</span>"</span>; <span class="keyword">then</span></span><br><span class="line">    CLASSPATH=<span class="string">"<span class="variable">$CLASSPATH</span>"</span>:<span class="string">"<span class="variable">$file</span>"</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">"<span class="variable">$streams_lib_dir</span>"</span>/kafka-streams*.jar;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> should_include_file <span class="string">"<span class="variable">$file</span>"</span>; <span class="keyword">then</span></span><br><span class="line">    CLASSPATH=<span class="string">"<span class="variable">$CLASSPATH</span>"</span>:<span class="string">"<span class="variable">$file</span>"</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$UPGRADE_KAFKA_STREAMS_TEST_VERSION</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">"<span class="variable">$base_dir</span>"</span>/streams/examples/build/libs/kafka-streams-examples*.jar;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> should_include_file <span class="string">"<span class="variable">$file</span>"</span>; <span class="keyword">then</span></span><br><span class="line">      CLASSPATH=<span class="string">"<span class="variable">$CLASSPATH</span>"</span>:<span class="string">"<span class="variable">$file</span>"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  VERSION_NO_DOTS=`<span class="built_in">echo</span> <span class="variable">$UPGRADE_KAFKA_STREAMS_TEST_VERSION</span> | sed <span class="string">'s/\.//g'</span>`</span><br><span class="line">  SHORT_VERSION_NO_DOTS=<span class="variable">$&#123;VERSION_NO_DOTS:0:(($&#123;#VERSION_NO_DOTS&#125;</span> - 1))&#125; <span class="comment"># remove last char, ie, bug-fix number</span></span><br><span class="line">  <span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">"<span class="variable">$base_dir</span>"</span>/streams/upgrade-system-tests-<span class="variable">$SHORT_VERSION_NO_DOTS</span>/build/libs/kafka-streams-upgrade-system-tests*.jar;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> should_include_file <span class="string">"<span class="variable">$file</span>"</span>; <span class="keyword">then</span></span><br><span class="line">      CLASSPATH=<span class="string">"<span class="variable">$file</span>"</span>:<span class="string">"<span class="variable">$CLASSPATH</span>"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">"<span class="variable">$SHORT_VERSION_NO_DOTS</span>"</span> = <span class="string">"0100"</span> ]; <span class="keyword">then</span></span><br><span class="line">    CLASSPATH=<span class="string">"/opt/kafka-<span class="variable">$UPGRADE_KAFKA_STREAMS_TEST_VERSION</span>/libs/zkclient-0.8.jar"</span>:<span class="string">"<span class="variable">$CLASSPATH</span>"</span></span><br><span class="line">    CLASSPATH=<span class="string">"/opt/kafka-<span class="variable">$UPGRADE_KAFKA_STREAMS_TEST_VERSION</span>/libs/zookeeper-3.4.6.jar"</span>:<span class="string">"<span class="variable">$CLASSPATH</span>"</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">"<span class="variable">$SHORT_VERSION_NO_DOTS</span>"</span> = <span class="string">"0101"</span> ]; <span class="keyword">then</span></span><br><span class="line">    CLASSPATH=<span class="string">"/opt/kafka-<span class="variable">$UPGRADE_KAFKA_STREAMS_TEST_VERSION</span>/libs/zkclient-0.9.jar"</span>:<span class="string">"<span class="variable">$CLASSPATH</span>"</span></span><br><span class="line">    CLASSPATH=<span class="string">"/opt/kafka-<span class="variable">$UPGRADE_KAFKA_STREAMS_TEST_VERSION</span>/libs/zookeeper-3.4.8.jar"</span>:<span class="string">"<span class="variable">$CLASSPATH</span>"</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">"<span class="variable">$streams_dependant_clients_lib_dir</span>"</span>/rocksdb*.jar;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  CLASSPATH=<span class="string">"<span class="variable">$CLASSPATH</span>"</span>:<span class="string">"<span class="variable">$file</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">"<span class="variable">$streams_dependant_clients_lib_dir</span>"</span>/*hamcrest*.jar;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  CLASSPATH=<span class="string">"<span class="variable">$CLASSPATH</span>"</span>:<span class="string">"<span class="variable">$file</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">"<span class="variable">$base_dir</span>"</span>/tools/build/libs/kafka-tools*.jar;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> should_include_file <span class="string">"<span class="variable">$file</span>"</span>; <span class="keyword">then</span></span><br><span class="line">    CLASSPATH=<span class="string">"<span class="variable">$CLASSPATH</span>"</span>:<span class="string">"<span class="variable">$file</span>"</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> dir <span class="keyword">in</span> <span class="string">"<span class="variable">$base_dir</span>"</span>/tools/build/dependant-libs-<span class="variable">$&#123;SCALA_VERSION&#125;</span>*;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  CLASSPATH=<span class="string">"<span class="variable">$CLASSPATH</span>:<span class="variable">$dir</span>/*"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> cc_pkg <span class="keyword">in</span> <span class="string">"api"</span> <span class="string">"transforms"</span> <span class="string">"runtime"</span> <span class="string">"file"</span> <span class="string">"mirror"</span> <span class="string">"mirror-client"</span> <span class="string">"json"</span> <span class="string">"tools"</span> <span class="string">"basic-auth-extension"</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">"<span class="variable">$base_dir</span>"</span>/connect/<span class="variable">$&#123;cc_pkg&#125;</span>/build/libs/connect-<span class="variable">$&#123;cc_pkg&#125;</span>*.jar;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> should_include_file <span class="string">"<span class="variable">$file</span>"</span>; <span class="keyword">then</span></span><br><span class="line">      CLASSPATH=<span class="string">"<span class="variable">$CLASSPATH</span>"</span>:<span class="string">"<span class="variable">$file</span>"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">  <span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$base_dir</span>/connect/<span class="variable">$&#123;cc_pkg&#125;</span>/build/dependant-libs"</span> ] ; <span class="keyword">then</span></span><br><span class="line">    CLASSPATH=<span class="string">"<span class="variable">$CLASSPATH</span>:<span class="variable">$base_dir</span>/connect/<span class="variable">$&#123;cc_pkg&#125;</span>/build/dependant-libs/*"</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># classpath addition for release</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">"<span class="variable">$base_dir</span>"</span>/libs/*;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> should_include_file <span class="string">"<span class="variable">$file</span>"</span>; <span class="keyword">then</span></span><br><span class="line">    CLASSPATH=<span class="string">"<span class="variable">$CLASSPATH</span>"</span>:<span class="string">"<span class="variable">$file</span>"</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">"<span class="variable">$base_dir</span>"</span>/core/build/libs/kafka_<span class="variable">$&#123;SCALA_BINARY_VERSION&#125;</span>*.jar;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> should_include_file <span class="string">"<span class="variable">$file</span>"</span>; <span class="keyword">then</span></span><br><span class="line">    CLASSPATH=<span class="string">"<span class="variable">$CLASSPATH</span>"</span>:<span class="string">"<span class="variable">$file</span>"</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">shopt</span> -u nullglob</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$CLASSPATH</span>"</span> ] ; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Classpath is empty. Please build the project first e.g. by running './gradlew jar -PscalaVersion=<span class="variable">$SCALA_VERSION</span>'"</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JMX settings</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$KAFKA_JMX_OPTS</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  KAFKA_JMX_OPTS=<span class="string">"-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.authenticate=false  -Dcom.sun.management.jmxremote.ssl=false "</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JMX port to use</span></span><br><span class="line"><span class="keyword">if</span> [  <span class="variable">$JMX_PORT</span> ]; <span class="keyword">then</span></span><br><span class="line">  KAFKA_JMX_OPTS=<span class="string">"<span class="variable">$KAFKA_JMX_OPTS</span> -Dcom.sun.management.jmxremote.port=<span class="variable">$JMX_PORT</span> "</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Log directory to use</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"x<span class="variable">$LOG_DIR</span>"</span> = <span class="string">"x"</span> ]; <span class="keyword">then</span></span><br><span class="line">  LOG_DIR=<span class="string">"<span class="variable">$base_dir</span>/logs"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Log4j settings</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$KAFKA_LOG4J_OPTS</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="comment"># Log to console. This is a tool.</span></span><br><span class="line">  LOG4J_DIR=<span class="string">"<span class="variable">$base_dir</span>/config/tools-log4j.properties"</span></span><br><span class="line">  <span class="comment"># If Cygwin is detected, LOG4J_DIR is converted to Windows format.</span></span><br><span class="line">  (( CYGWIN )) &amp;&amp; LOG4J_DIR=$(cygpath --path --mixed <span class="string">"<span class="variable">$&#123;LOG4J_DIR&#125;</span>"</span>)</span><br><span class="line">  KAFKA_LOG4J_OPTS=<span class="string">"-Dlog4j.configuration=file:<span class="variable">$&#123;LOG4J_DIR&#125;</span>"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="comment"># create logs directory</span></span><br><span class="line">  <span class="keyword">if</span> [ ! -d <span class="string">"<span class="variable">$LOG_DIR</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    mkdir -p <span class="string">"<span class="variable">$LOG_DIR</span>"</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If Cygwin is detected, LOG_DIR is converted to Windows format.</span></span><br><span class="line">(( CYGWIN )) &amp;&amp; LOG_DIR=$(cygpath --path --mixed <span class="string">"<span class="variable">$&#123;LOG_DIR&#125;</span>"</span>)</span><br><span class="line">KAFKA_LOG4J_OPTS=<span class="string">"-Dkafka.logs.dir=<span class="variable">$LOG_DIR</span> <span class="variable">$KAFKA_LOG4J_OPTS</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Generic jvm settings you want to add</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$KAFKA_OPTS</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  KAFKA_OPTS=<span class="string">""</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set Debug options if enabled</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"x<span class="variable">$KAFKA_DEBUG</span>"</span> != <span class="string">"x"</span> ]; <span class="keyword">then</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Use default ports</span></span><br><span class="line">    DEFAULT_JAVA_DEBUG_PORT=<span class="string">"5005"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$JAVA_DEBUG_PORT</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">        JAVA_DEBUG_PORT=<span class="string">"<span class="variable">$DEFAULT_JAVA_DEBUG_PORT</span>"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Use the defaults if JAVA_DEBUG_OPTS was not set</span></span><br><span class="line">    DEFAULT_JAVA_DEBUG_OPTS=<span class="string">"-agentlib:jdwp=transport=dt_socket,server=y,suspend=<span class="variable">$&#123;DEBUG_SUSPEND_FLAG:-n&#125;</span>,address=<span class="variable">$JAVA_DEBUG_PORT</span>"</span></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$JAVA_DEBUG_OPTS</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">        JAVA_DEBUG_OPTS=<span class="string">"<span class="variable">$DEFAULT_JAVA_DEBUG_OPTS</span>"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Enabling Java debug options: <span class="variable">$JAVA_DEBUG_OPTS</span>"</span></span><br><span class="line">    KAFKA_OPTS=<span class="string">"<span class="variable">$JAVA_DEBUG_OPTS</span> <span class="variable">$KAFKA_OPTS</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Which java to use</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$JAVA_HOME</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  JAVA=<span class="string">"java"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  JAVA=<span class="string">"<span class="variable">$JAVA_HOME</span>/bin/java"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Memory options</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$KAFKA_HEAP_OPTS</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  KAFKA_HEAP_OPTS=<span class="string">"-Xmx256M"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JVM performance options</span></span><br><span class="line"><span class="comment"># MaxInlineLevel=15 is the default since JDK 14 and can be removed once older JDKs are no longer supported</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$KAFKA_JVM_PERFORMANCE_OPTS</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  KAFKA_JVM_PERFORMANCE_OPTS=<span class="string">"-server -XX:+UseG1GC -XX:MaxGCPauseMillis=20 -XX:InitiatingHeapOccupancyPercent=35 -XX:+ExplicitGCInvokesConcurrent -XX:MaxInlineLevel=15 -Djava.awt.headless=true"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$#</span> -gt 0 ]; <span class="keyword">do</span></span><br><span class="line">  COMMAND=<span class="variable">$1</span></span><br><span class="line">  <span class="keyword">case</span> <span class="variable">$COMMAND</span> <span class="keyword">in</span></span><br><span class="line">    -name)</span><br><span class="line">      DAEMON_NAME=<span class="variable">$2</span></span><br><span class="line">      CONSOLE_OUTPUT_FILE=<span class="variable">$LOG_DIR</span>/<span class="variable">$DAEMON_NAME</span>.out</span><br><span class="line">      <span class="built_in">shift</span> 2</span><br><span class="line">      ;;</span><br><span class="line">    -loggc)</span><br><span class="line">      <span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$KAFKA_GC_LOG_OPTS</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">        GC_LOG_ENABLED=<span class="string">"true"</span></span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line">      <span class="built_in">shift</span></span><br><span class="line">      ;;</span><br><span class="line">    -daemon)</span><br><span class="line">      DAEMON_MODE=<span class="string">"true"</span></span><br><span class="line">      <span class="built_in">shift</span></span><br><span class="line">      ;;</span><br><span class="line">    *)</span><br><span class="line">      <span class="built_in">break</span></span><br><span class="line">      ;;</span><br><span class="line">  <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># GC options</span></span><br><span class="line">GC_FILE_SUFFIX=<span class="string">'-gc.log'</span></span><br><span class="line">GC_LOG_FILE_NAME=<span class="string">''</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"x<span class="variable">$GC_LOG_ENABLED</span>"</span> = <span class="string">"xtrue"</span> ]; <span class="keyword">then</span></span><br><span class="line">  GC_LOG_FILE_NAME=<span class="variable">$DAEMON_NAME</span><span class="variable">$GC_FILE_SUFFIX</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># The first segment of the version number, which is '1' for releases before Java 9</span></span><br><span class="line">  <span class="comment"># it then becomes '9', '10', ...</span></span><br><span class="line">  <span class="comment"># Some examples of the first line of `java --version`:</span></span><br><span class="line">  <span class="comment"># 8 -&gt; java version "1.8.0_152"</span></span><br><span class="line">  <span class="comment"># 9.0.4 -&gt; java version "9.0.4"</span></span><br><span class="line">  <span class="comment"># 10 -&gt; java version "10" 2018-03-20</span></span><br><span class="line">  <span class="comment"># 10.0.1 -&gt; java version "10.0.1" 2018-04-17</span></span><br><span class="line">  <span class="comment"># We need to match to the end of the line to prevent sed from printing the characters that do not match</span></span><br><span class="line">  JAVA_MAJOR_VERSION=$(<span class="string">"<span class="variable">$JAVA</span>"</span> -version 2&gt;&amp;1 | sed -E -n <span class="string">'s/.* version "([0-9]*).*$/\1/p'</span>)</span><br><span class="line">  <span class="keyword">if</span> [[ <span class="string">"<span class="variable">$JAVA_MAJOR_VERSION</span>"</span> -ge <span class="string">"9"</span> ]] ; <span class="keyword">then</span></span><br><span class="line">    KAFKA_GC_LOG_OPTS=<span class="string">"-Xlog:gc*:file=<span class="variable">$LOG_DIR</span>/<span class="variable">$GC_LOG_FILE_NAME</span>:time,tags:filecount=10,filesize=100M"</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    KAFKA_GC_LOG_OPTS=<span class="string">"-Xloggc:<span class="variable">$LOG_DIR</span>/<span class="variable">$GC_LOG_FILE_NAME</span> -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=10 -XX:GCLogFileSize=100M"</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Remove a possible colon prefix from the classpath (happens at lines like `CLASSPATH="$CLASSPATH:$file"` when CLASSPATH is blank)</span></span><br><span class="line"><span class="comment"># Syntax used on the right side is native Bash string manipulation; for more details see</span></span><br><span class="line"><span class="comment"># http://tldp.org/LDP/abs/html/string-manipulation.html, specifically the section titled "Substring Removal"</span></span><br><span class="line">CLASSPATH=<span class="variable">$&#123;CLASSPATH#:&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If Cygwin is detected, classpath is converted to Windows format.</span></span><br><span class="line">(( CYGWIN )) &amp;&amp; CLASSPATH=$(cygpath --path --mixed <span class="string">"<span class="variable">$&#123;CLASSPATH&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Launch mode</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"x<span class="variable">$DAEMON_MODE</span>"</span> = <span class="string">"xtrue"</span> ]; <span class="keyword">then</span></span><br><span class="line">  nohup <span class="string">"<span class="variable">$JAVA</span>"</span> <span class="variable">$KAFKA_HEAP_OPTS</span> <span class="variable">$KAFKA_JVM_PERFORMANCE_OPTS</span> <span class="variable">$KAFKA_GC_LOG_OPTS</span> <span class="variable">$KAFKA_JMX_OPTS</span> <span class="variable">$KAFKA_LOG4J_OPTS</span> -cp <span class="string">"<span class="variable">$CLASSPATH</span>"</span> <span class="variable">$KAFKA_OPTS</span> <span class="string">"<span class="variable">$@</span>"</span> &gt; <span class="string">"<span class="variable">$CONSOLE_OUTPUT_FILE</span>"</span> 2&gt;&amp;1 &lt; /dev/null &amp;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">exec</span> <span class="string">"<span class="variable">$JAVA</span>"</span> <span class="variable">$KAFKA_HEAP_OPTS</span> <span class="variable">$KAFKA_JVM_PERFORMANCE_OPTS</span> <span class="variable">$KAFKA_GC_LOG_OPTS</span> <span class="variable">$KAFKA_JMX_OPTS</span> <span class="variable">$KAFKA_LOG4J_OPTS</span> -cp <span class="string">"<span class="variable">$CLASSPATH</span>"</span> <span class="variable">$KAFKA_OPTS</span> <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>脚本内容很长，但是实际上只有最后一部分才是真正在完成启动操作：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Launch mode</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"x<span class="variable">$DAEMON_MODE</span>"</span> = <span class="string">"xtrue"</span> ]; <span class="keyword">then</span></span><br><span class="line">  nohup <span class="string">"<span class="variable">$JAVA</span>"</span> <span class="variable">$KAFKA_HEAP_OPTS</span> <span class="variable">$KAFKA_JVM_PERFORMANCE_OPTS</span> <span class="variable">$KAFKA_GC_LOG_OPTS</span> <span class="variable">$KAFKA_JMX_OPTS</span> <span class="variable">$KAFKA_LOG4J_OPTS</span> -cp <span class="string">"<span class="variable">$CLASSPATH</span>"</span> <span class="variable">$KAFKA_OPTS</span> <span class="string">"<span class="variable">$@</span>"</span> &gt; <span class="string">"<span class="variable">$CONSOLE_OUTPUT_FILE</span>"</span> 2&gt;&amp;1 &lt; /dev/null &amp;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">exec</span> <span class="string">"<span class="variable">$JAVA</span>"</span> <span class="variable">$KAFKA_HEAP_OPTS</span> <span class="variable">$KAFKA_JVM_PERFORMANCE_OPTS</span> <span class="variable">$KAFKA_GC_LOG_OPTS</span> <span class="variable">$KAFKA_JMX_OPTS</span> <span class="variable">$KAFKA_LOG4J_OPTS</span> -cp <span class="string">"<span class="variable">$CLASSPATH</span>"</span> <span class="variable">$KAFKA_OPTS</span> <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h1 id="Launch-modes"><a href="#Launch-modes" class="headerlink" title="Launch modes"></a>Launch modes</h1><p>在脚本最后一段是有关启动方式的提示。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Launch mode</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"x<span class="variable">$DAEMON_MODE</span>"</span> = <span class="string">"xtrue"</span> ]; <span class="keyword">then</span></span><br><span class="line">  nohup <span class="string">"<span class="variable">$JAVA</span>"</span> <span class="variable">$KAFKA_HEAP_OPTS</span> <span class="variable">$KAFKA_JVM_PERFORMANCE_OPTS</span> <span class="variable">$KAFKA_GC_LOG_OPTS</span> <span class="variable">$KAFKA_JMX_OPTS</span> <span class="variable">$KAFKA_LOG4J_OPTS</span> -cp <span class="string">"<span class="variable">$CLASSPATH</span>"</span> <span class="variable">$KAFKA_OPTS</span> <span class="string">"<span class="variable">$@</span>"</span> &gt; <span class="string">"<span class="variable">$CONSOLE_OUTPUT_FILE</span>"</span> 2&gt;&amp;1 &lt; /dev/null &amp;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">exec</span> <span class="string">"<span class="variable">$JAVA</span>"</span> <span class="variable">$KAFKA_HEAP_OPTS</span> <span class="variable">$KAFKA_JVM_PERFORMANCE_OPTS</span> <span class="variable">$KAFKA_GC_LOG_OPTS</span> <span class="variable">$KAFKA_JMX_OPTS</span> <span class="variable">$KAFKA_LOG4J_OPTS</span> -cp <span class="string">"<span class="variable">$CLASSPATH</span>"</span> <span class="variable">$KAFKA_OPTS</span> <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>这段脚本说明了之前的一大堆脚本都是为了这里启动赋值进行的一系列操作，这里根据传递参数判断是否守护进程的方式启动。这里以使用比较多的 <strong>守护进程</strong>启动方式进行参数介绍（实际上两者差别不算很大）。</p><h2 id="KAFKA-HEAP-OPTS"><a href="#KAFKA-HEAP-OPTS" class="headerlink" title="KAFKA_HEAP_OPTS"></a>KAFKA_HEAP_OPTS</h2><p><strong>KAFKA_HEAP_OPTS</strong> 出自最开头，判断堆参数 <strong>KAFKA_HEAP_OPTS</strong>是否为空，为空就默认给它赋值为 “-Xmx1G -Xms1G”。</p><h2 id="KAFKA-JVM-PERFORMANCE-OPTS"><a href="#KAFKA-JVM-PERFORMANCE-OPTS" class="headerlink" title="KAFKA_JVM_PERFORMANCE_OPTS"></a>KAFKA_JVM_PERFORMANCE_OPTS</h2><p>这个值代表了JVM的启动参数。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># JVM performance options</span></span><br><span class="line"><span class="comment"># MaxInlineLevel=15 is the default since JDK 14 and can be removed once older JDKs are no longer supported</span></span><br><span class="line"><span class="comment"># MaxInlineLevel=15 是自JDK 14以来的默认值，一旦旧的JDK不再支持，就可以删除。</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$KAFKA_JVM_PERFORMANCE_OPTS</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  KAFKA_JVM_PERFORMANCE_OPTS=<span class="string">"-server -XX:+UseG1GC -XX:MaxGCPauseMillis=20 -XX:InitiatingHeapOccupancyPercent=35 -XX:+ExplicitGCInvokesConcurrent -XX:MaxInlineLevel=15 -Djava.awt.headless=true"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$#</span> -gt 0 ]; <span class="keyword">do</span></span><br><span class="line">  COMMAND=<span class="variable">$1</span></span><br><span class="line">  <span class="keyword">case</span> <span class="variable">$COMMAND</span> <span class="keyword">in</span></span><br><span class="line">    -name)</span><br><span class="line">      DAEMON_NAME=<span class="variable">$2</span></span><br><span class="line">      CONSOLE_OUTPUT_FILE=<span class="variable">$LOG_DIR</span>/<span class="variable">$DAEMON_NAME</span>.out</span><br><span class="line">      <span class="built_in">shift</span> 2</span><br><span class="line">      ;;</span><br><span class="line">    -loggc)</span><br><span class="line">      <span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$KAFKA_GC_LOG_OPTS</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">        GC_LOG_ENABLED=<span class="string">"true"</span></span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line">      <span class="built_in">shift</span></span><br><span class="line">      ;;</span><br><span class="line">    -daemon)</span><br><span class="line">      DAEMON_MODE=<span class="string">"true"</span></span><br><span class="line">      <span class="built_in">shift</span></span><br><span class="line">      ;;</span><br><span class="line">    *)</span><br><span class="line">      <span class="built_in">break</span></span><br><span class="line">      ;;</span><br><span class="line">  <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h2 id="G1垃圾收集器"><a href="#G1垃圾收集器" class="headerlink" title="G1垃圾收集器"></a>G1垃圾收集器</h2><p>Kafka默认使用G1的垃圾收集器，本身最低JDK版本要求就是JDK1.8。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-server -XX:+UseG1GC -XX:MaxGCPauseMillis=20 -XX:InitiatingHeapOccupancyPercent=35 -XX:+ExplicitGCInvokesConcurrent -XX:MaxInlineLevel=15 -Djava.awt.headless=<span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="MaxGCPauseMillis"><a href="#MaxGCPauseMillis" class="headerlink" title="MaxGCPauseMillis"></a>MaxGCPauseMillis</h3><p><code>-XX:MaxGCPauseMillis</code>：GC最大的停顿毫秒数，暂停时间默认值200ms，如果设置比这个小的值，G1收集器会尽可能的达到这个预期设置。</p><p>因为Kafka是非常激进的高并发分布式消息队列，为了获取更高的并发，使用20ms的极限值值尽可能的减少GC时间，最后用极短GC的代价换取高吞吐，当然结果会导致垃圾回收不干净。</p><p>但Kafka对于JVM本身的堆内存占用并不是很多，默认20ms的停顿时间其实是可以放心使用的。</p><p>此外从Kafka的设计来看，更频繁的GC是为了尽可能的触发Full Gc，因为Full Gc是回收Direct Memory的条件，而Kafka大量使用了页缓存提高数据的Log的读写速度，底层用的也是Java的Direct Memory。</p><h3 id="InitiatingHeapOccupancyPercent"><a href="#InitiatingHeapOccupancyPercent" class="headerlink" title="InitiatingHeapOccupancyPercent"></a>InitiatingHeapOccupancyPercent</h3><p>这个参数实际上出入比较大，根据源码分析在<strong>JDK8b12</strong>版本之后，以及<strong>JDK11</strong> 之前这个参数和官方的文档描述，这个值的含义是符合“整堆”来计算是否触发Mixed Gc，但是<strong>JDK8b12</strong>版本之后更高的补丁，以及<strong>JDK11</strong>之后就变了，它变成根据<strong>老年代占整堆的比重</strong>。</p><p>这样的出入问题源自此参数的<strong>源码BUG</strong>，这部分涉及源码的探讨就不讨论了，具体可以看<span class="exturl" data-url="aHR0cHM6Ly9kb3VkYXhpYS5jbHViL2luZGV4LnBocC9hcmNoaXZlcy8yMTIv" title="https://doudaxia.club/index.php/archives/212/">关于G1收集器参数InitiatingHeapOccupancyPercent的正确认知 - 豆大侠的菜地 (doudaxia.club)<i class="fa fa-external-link"></i></span>这篇大佬的文章分析。</p><p>这里直接给出结论：</p><ul><li>如果你使用的JDK版本在8b12之前，XX:InitiatingHeapOccupancyPercent是<strong>整个堆</strong>使用量与<strong>堆总体容量的</strong>比值；</li><li>如果你使用的JDK版本在8b12之后（包括大版本9、10、11….），那么<code>XX:InitiatingHeapOccupancyPercent</code>是<strong>老年代大小与堆总体容量的比值</strong>这种说法和修改之后的JVM源码符合。</li></ul><p>整体算是一个隐藏已久的BUG，因为G1的垃圾收集器设计角度看，它更关心的是<code>Old Region</code>占满整个堆空间之前提前尽可能的进行回收，而不是简单的看看剩余空间在整个堆空间的占比，因为剩余空间不是一个十分可靠的衡量值。</p><p>为了验证上文大佬的说法，个人也去参阅JDK8的Oracle文档：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlLzgvZG9jcy90ZWNobm90ZXMvdG9vbHMvdW5peC9qYXZhLmh0bWw=" title="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">java (oracle.com)<i class="fa fa-external-link"></i></span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-XX:c=percent</span><br><span class="line">    <span class="function">Sets the percentage of the heap <span class="title">occupancy</span> <span class="params">(<span class="number">0</span> to <span class="number">100</span>)</span> at which to start a concurrent GC cycle. It is used by garbage collectors that trigger a concurrent GC cycle based on the occupancy of the entire heap, not just one of the <span class="title">generations</span> <span class="params">(<span class="keyword">for</span> example, the G1 garbage collector)</span>.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    By <span class="keyword">default</span>, the initiating value is set to 45%. A value of 0 implies nonstop GC cycles. The following example shows how to set the initiating heap occupancy to 75%:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    -XX:InitiatingHeapOccupancyPercent</span>=<span class="number">75</span></span><br></pre></td></tr></table></figure><p>关键字 <strong>entire heap</strong>，也就是简单的剩余空间和整堆的占比。这里同样接着翻阅了一下，直到<strong>JDK12</strong>版本，这个描述还是和JDK8的版本一致的。直到阅读长期支持的<strong>JDK17</strong>的文档，发现里面的说法终于变了：</p><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vZW4vamF2YS9qYXZhc2UvMTcvZ2N0dW5pbmcvZ2FyYmFnZS1maXJzdC1nMS1nYXJiYWdlLWNvbGxlY3RvcjEuaHRtbCNHVUlELURBNjI5NkRELTlBQUItNDk1NS04QjVCLTY4MzY1MTkzNjE1NQ==" title="https://docs.oracle.com/en/java/javase/17/gctuning/garbage-first-g1-garbage-collector1.html#GUID-DA6296DD-9AAB-4955-8B5B-683651936155">Garbage-First (G1) Garbage Collector (oracle.com<i class="fa fa-external-link"></i></span></p><blockquote><p><code>XX:InitiatingHeapOccupancyPercent</code> determines the initial value as a percentage of the size of the current old generation as long as there aren’t enough observations to make a good prediction of the Initiating Heap Occupancy threshold. Turn off this behavior of G1 using the option<code>-XX:-G1UseAdaptiveIHOP</code>. In this case, the value of <code>-XX:InitiatingHeapOccupancyPercent</code> always determines this threshold.。<br>“XX：启动堆占用百分比”将初始值确定为<strong>当前老一代大小的百分比</strong>，只要没有足够的观测值来很好地预测起始堆占用阈值。<br>使用选项’<code>-XX:-G1UseAdaptiveIHOP</code>‘关闭G1的此行为。在这种情况下<code>-XX:InitiatingHeapOccupancyPercent</code>  启动堆占用百分比’的值始终确定此阈值。</p></blockquote><p>所以这个值的真实含义和使用的JDK版本有关，并且JDK8的后续补丁版本也修复了这个问题，所以最终建议是升级JDK8的补丁版本，或者使用JDK11之后的版本。</p><h3 id="XX-ExplicitGCInvokesConcurrent"><a href="#XX-ExplicitGCInvokesConcurrent" class="headerlink" title="-XX:+ExplicitGCInvokesConcurrent"></a>-XX:+ExplicitGCInvokesConcurrent</h3><p>看似简单的参数，实际上又是隐藏这非常多的“坑”和细节，这里我们划分更多的小节慢慢细品。</p><h4 id="简单理解"><a href="#简单理解" class="headerlink" title="简单理解"></a>简单理解</h4><p>这个参数是指通过使用<code>System.gc()</code>请求<strong>启用并发 GC 的调用</strong>，<strong>默认禁用</strong>。如果没有特殊的应用场景，大部分情况下这个参数都是被建议禁用的，而并发GC实际上就是CMS的并发回收处理。</p><p>个人在官方文档中搜到类似的参数描述：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlLzkvZ2N0dW5pbmcvZ2FyYmFnZS1maXJzdC1nYXJiYWdlLWNvbGxlY3Rvci10dW5pbmcuaHRtI0pTR0NULUdVSUQtMEJCM0I3NDItQTk4NS00RDVFLUE5QzUtNDMzQTEyN0ZFMEY2" title="https://docs.oracle.com/javase/9/gctuning/garbage-first-garbage-collector-tuning.htm#JSGCT-GUID-0BB3B742-A985-4D5E-A9C5-433A127FE0F6">Garbage-First Garbage Collector Tuning (oracle.com)<i class="fa fa-external-link"></i></span>。</p><blockquote><p>Other causes than Allocation Failure for a Full GC typically indicate that either the application or some external tool causes a full heap collection. If the cause is , and there is no way to modify the application sources, the effect of Full GCs can be mitigated by using or let the VM completely ignore them by setting . <strong>External tools may still force Full GCs; they can be removed only by not requesting them.System.gc()-XX:+ExplicitGCInvokesConcurrent -XX:+DisableExplicitGC</strong></p></blockquote><p>上面一大段的话大意指的是：阻止外部调用Full GC（也就是<code>System.gc()</code>）要么直接设置<code>-XX:+DisableExplicitGC</code>，要么设置<code>-XX:+ExplicitGCInvokesConcurrent</code>提高强制Full Gc的效率，阅读源码发现这两个参<strong>数不能一起开启</strong>，因为<code>-XX:+ExplicitGCInvokesConcurrent</code>需要关闭<code>-XX:+DisableExplicitGC</code>参数才能生效。</p><blockquote><p>部分文章也解释仅仅建议在G1的垃圾收集器中可以使用<code>-XX:+ExplicitGCInvokesConcurrent</code>。其他垃圾收集器不建议使用。</p></blockquote><h4 id="Kafka官方修复BUG：-XX-DisableExplicitGC-改为-XX-ExplicitGCInvokesConcurrent"><a href="#Kafka官方修复BUG：-XX-DisableExplicitGC-改为-XX-ExplicitGCInvokesConcurrent" class="headerlink" title="Kafka官方修复BUG：-XX:+DisableExplicitGC 改为 -XX:+ExplicitGCInvokesConcurrent"></a>Kafka官方修复BUG：-XX:+DisableExplicitGC 改为 -XX:+ExplicitGCInvokesConcurrent</h4><p>为什么两者只能选其一使用，JDK 8 的JVM中存在类似的代码可以给予解释。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GenCollectedHeap::should_do_concurrent_full_gc</span><span class="params">(GCCause::Cause cause)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查参数 -XX:+DisableExplicitGC 和 -XX:+ExplicitGCInvokesConcurrent</span></span><br><span class="line">  <span class="keyword">return</span> UseConcMarkSweepGC &amp;&amp;</span><br><span class="line">         ((cause == GCCause::_gc_locker &amp;&amp; GCLockerInvokesConcurrent) ||</span><br><span class="line">         <span class="comment">// -XX:+ExplicitGCInvokesConcurrent 需要满足不配置-XX:+DisableExplicitGC的条件，才能判定为true</span></span><br><span class="line">          (cause == GCCause::_java_lang_system_gc &amp;&amp; ExplicitGCInvokesConcurrent));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GenCollectedHeap::collect</span><span class="params">(GCCause::Cause cause)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查参数 -XX:+DisableExplicitGC 和 -XX:+ExplicitGCInvokesConcurrent</span></span><br><span class="line">  <span class="keyword">if</span> (should_do_concurrent_full_gc(cause)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SERIALGC</span></span><br><span class="line">    <span class="comment">// mostly concurrent full collection</span></span><br><span class="line">    collect_mostly_concurrent(cause);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  <span class="comment">// SERIALGC</span></span></span><br><span class="line">    ShouldNotReachHere();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// SERIALGC</span></span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">#ifdef ASSERT</span><br><span class="line">    <span class="keyword">if</span> (cause == GCCause::_scavenge_alot) &#123;</span><br><span class="line">      <span class="comment">// minor collection only</span></span><br><span class="line">      collect(cause, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Stop-the-world full collection</span></span><br><span class="line">      <span class="comment">// STW 进行Full Gc</span></span><br><span class="line">      collect(cause, n_gens() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">// Stop-the-world full collection</span></span><br><span class="line">    collect(cause, n_gens() - <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>collect里一开头就有个判断，如果<code>should_do_concurrent_full_gc</code>返回true，那会执行collect_mostly_concurrent做并行的回收。</p><p>回到Kafka的服务端参数，KafKa最初的服务端启动脚本中，此参数实际为<code>-XX:+DisableExplicitGC</code>，但是后续被指出会影响直接内存的回收性能，并且很可能会导致<strong>直接内存无法被回收！</strong> </p><p>为什么会有这么严重 ? 这里先不急着分析，而是先看看作者的这个issue的提交：</p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwYWNoZS9rYWZrYS9wdWxsLzMzNzE=" title="https://github.com/apache/kafka/pull/3371">KAFKA-5470: Replace -XX:+DisableExplicitGC with -XX:+ExplicitGCInvokesConcurrent in kafka-run-class by ijuma · Pull Request #3371 · apache/kafka (github.com)<i class="fa fa-external-link"></i></span></p><p>提交者的原话是：</p><blockquote><p>This is important because <strong>Bits.reserveMemory calls System.gc()</strong> hoping to free native<br>memory in order to avoid throwing an OutOfMemoryException. This call is currently<br>a no-op due to -XX:+DisableExplicitGC.</p><p>It’s worth mentioning that -XX:MaxDirectMemorySize can be used to increase the<br>amount of native memory available for allocation of direct byte buffers.</p></blockquote><p>简单来说就是<strong>Bits.reserveMemory</strong>里面会有<code>System.gc()</code>调用，通过程序强制调用Full Gc来回收掉native内存，所以建议在JVM参数中删掉<code>-XX:+DisableExplicitGC</code>，开启<code>System.gc();</code>并且通过添加<code>-XX:+ExplicitGCInvokesConcurrent</code>让<code>System.gc()</code>调用效率更高一些。</p><blockquote><p> 另外大佬这里还提了一嘴<code>-XX:MaxDirectMemorySize</code>可以用来提高可用于分配直接字节缓冲区的本地内存的数量。<br> 大佬一句话就是一个知识点，牛呀。</p></blockquote><h4 id="Bits-reserveMemory"><a href="#Bits-reserveMemory" class="headerlink" title="Bits#reserveMemory"></a>Bits#reserveMemory</h4><p>既然提交者提到了<code>Bits#reserveMemory</code>，这里就顺带贴一下官方jdk8的<strong>java.nio.Bits#reserveMemory</strong>源码方便理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// These methods should be called whenever direct memory is allocated or</span></span><br><span class="line"><span class="comment">// freed.  They allow the user to control the amount of direct memory</span></span><br><span class="line"><span class="comment">// which a process may access.  All sizes are specified in bytes.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//每当分配直接内存或释放。 它们允许用户控制直接内存的数量进程可以访问的内容。 所有大小均以字节为单位指定。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reserveMemory</span><span class="params">(<span class="keyword">long</span> size, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!memoryLimitSet &amp;&amp; VM.isBooted()) &#123;</span><br><span class="line">        maxMemory = VM.maxDirectMemory();</span><br><span class="line">        memoryLimitSet = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// optimist!</span></span><br><span class="line">    <span class="keyword">if</span> (tryReserveMemory(size, cap)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> JavaLangRefAccess jlra = SharedSecrets.getJavaLangRefAccess();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// retry while helping enqueue pending Reference objects</span></span><br><span class="line">    <span class="comment">// which includes executing pending Cleaner(s) which includes</span></span><br><span class="line">    <span class="comment">// Cleaner(s) that free direct buffer memory</span></span><br><span class="line">    <span class="keyword">while</span> (jlra.tryHandlePendingReference()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReserveMemory(size, cap)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// trigger VM's Reference processing</span></span><br><span class="line">    System.gc();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a retry loop with exponential back-off delays</span></span><br><span class="line">    <span class="comment">// (this gives VM some time to do it's job)</span></span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> sleepTime = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sleeps = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tryReserveMemory(size, cap)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sleeps &gt;= MAX_SLEEPS) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!jlra.tryHandlePendingReference()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(sleepTime);</span><br><span class="line">                    sleepTime &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">                    sleeps++;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// no luck</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError(<span class="string">"Direct buffer memory"</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">            <span class="comment">// don't swallow interrupts</span></span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过阅读JDK8的Nio包的这部分用于分配DirectMememory的一段代码，发现<strong>每次</strong>Direct Mememory进行实际的分配动作之前，都会调用这个方法检测是否有足够空间分配时都被调用，不过里面的逻辑奇奇怪怪的，初看确实有点摸不着头脑。</p><p>国外有网友直接痛骂了这一段代码是一坨Shit：<span class="exturl" data-url="aHR0cHM6Ly9ncm91cHMuZ29vZ2xlLmNvbS9nL21lY2hhbmljYWwtc3ltcGF0aHkvYy8yMGFqamItWVVMdz9wbGk9MQ==" title="https://groups.google.com/g/mechanical-sympathy/c/20ajjb-YULw?pli=1">java.nio.Bits.reserveMemory uses a lock, calls System.gc, and is generally bad code… (google.com)<i class="fa fa-external-link"></i></span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.  ALL memory access <span class="keyword">requires</span> a lock.  That<span class="string">'s evil if you'</span>re allocating small chunks.</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.  The code to change the reserved memory counters is duplicated twice.  This is a great way to introduce bugs.  (how did <span class="keyword">this</span> even get approved? <span class="keyword">do</span> they not <span class="keyword">do</span> code audits or require that commits be approved?)</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.  If you are out of memory we call System.gc... EVIL.  The entire way direct memory is reclaimed via GC is a horrible design.</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>.  After GC they sleep <span class="number">100</span>ms.  What<span class="string">'s that about?  Why 100ms?  Why not 1ms?</span></span><br></pre></td></tr></table></figure><ol><li>所有的内存访问都需要一个锁。 如果你分配的是小块的内存简直就是噩梦。</li><li>改变保留内存计数器的代码重复了两次。 这是个引入错误的好方法。 (难道他们不进行代码审计或要求提交的代码必须得到批准吗？）</li><li>如果你没有内存了，我们就调用System.gc…  通过GC回收直接内存的整个方式是一个可怕的设计。</li><li>在GC之后，他们会休眠100ms。 那是什么意思？ 为什么是100ms？ 为什么不是1ms？ </li></ol><p>个人并不感冒这些评论，这里拎出<code>System.gc()</code>这行代码来分析具体意图。要看懂这一行代码的意图，我们需要了解DirectMemory关联的本机内存是如何清理的，这里就直接给出答案了。</p><p>JVM实际上是管不到DirectMemory的，需要依靠特殊的方式回收掉DirectMemory：</p><ul><li>手动调用<code>unsafe.freeMemory()</code>进行释放，<strong>netty</strong>中<code>ByteBuf.release()</code>就是这种方式实现的；</li><li>利用<strong>GC机制</strong>在GC的过程中自动调用<code>unsafe.freeMemory()</code>释放被引用的直接内存；</li></ul><p>这段代码作者的意图明显是显示调用<code>System.gc()</code>，尽可能回收不可达的<code>DirectByteBuffer</code>对象，也只有通过GC才会自动触发<code>unsafe.freeMemory()</code>的调用，释放直接内存。</p><p>至于其他代码…..这里不做过多评论。</p><h4 id="Fix-XX-DisableExplicitGC"><a href="#Fix-XX-DisableExplicitGC" class="headerlink" title="Fix -XX:+DisableExplicitGC"></a>Fix -XX:+DisableExplicitGC</h4><p>基于以上种种原因，Kafka官方最终提交了一个Commit修复这个问题：</p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvbmZsdWVudGluYy9rc3FsL3B1bGwvMTMyOQ==" title="https://github.com/confluentinc/ksql/pull/1329">Fix run class to work with Java 10 and use ExplicitGCInvokesConcurrent by ijuma · Pull Request #1329 · confluentinc/ksql (github.com)<i class="fa fa-external-link"></i></span></p><p>具体的调整细节可以看下面的连接，读者可以通过对比自己的下载Kafka启动脚本查看是否修复这个问题：</p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwYWNoZS9rYWZrYS9wdWxsLzMzNzEvY29tbWl0cy9hY2RkNmU5NzhjOWJlMTIzY2ZmYWZjMTZkMWU4NDk0MmQ2Y2Q0NDc3" title="https://github.com/apache/kafka/pull/3371/commits/acdd6e978c9be123cffafc16d1e84942d6cd4477">KAFKA-5470: Replace -XX:+DisableExplicitGC with -XX:+ExplicitGCInvokesConcurrent in kafka-run-class by ijuma · Pull Request #3371 · apache/kafka (github.com)<i class="fa fa-external-link"></i></span></p><h4 id="其他参考资料"><a href="#其他参考资料" class="headerlink" title="其他参考资料"></a>其他参考资料</h4><p>下面的这些参考资料可以帮助我们更深入的理解<code>-XX:+ExplicitGCInvokesConcurrent</code>参数附带的知识点：</p><p>-XX:+ExplicitGCInvokesConcurrent的含义：<span class="exturl" data-url="aHR0cHM6Ly9hbnN3ZXJzLnljcmFzaC5pby9xdWVzdGlvbi93aGF0LWlzLWp2bS1zdGFydHVwLXBhcmFtZXRlci0teHhleHBsaWNpdGdjaW52b2tlc2NvbmN1cnJlbnQ/cT03OTU=" title="https://answers.ycrash.io/question/what-is-jvm-startup-parameter--xxexplicitgcinvokesconcurrent?q=795">What is JVM startup parameter: -XX:+ExplicitGCInvokesConcurrent? - yCrash Answers<i class="fa fa-external-link"></i></span></p><p>官方的G1文档：<span class="exturl" data-url="aHR0cHM6Ly93d3cub3JhY2xlLmNvbS9qYXZhL3RlY2hub2xvZ2llcy9qYXZhc2UvaG90c3BvdC1nYXJiYWdlLWNvbGxlY3Rpb24uaHRtbA==" title="https://www.oracle.com/java/technologies/javase/hotspot-garbage-collection.html">Java HotSpot Garbage Collection (oracle.com)<i class="fa fa-external-link"></i></span></p><p>为什么仅限G1可以开启此参数来进行健康检查，其他垃圾收集器建议关闭此参数：<span class="exturl" data-url="aHR0cHM6Ly9jb25mbHVlbmNlLmF0bGFzc2lhbi5jb20vamlyYWtiL2hlYWx0aC1jaGVjay1leHBsaWNpdC1nYXJiYWdlLWNvbGxlY3Rpb24tOTc2Nzc4MTAwLmh0bWw=" title="https://confluence.atlassian.com/jirakb/health-check-explicit-garbage-collection-976778100.html">Health Check: Explicit Garbage Collection | Jira | Atlassian Documentation<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9oZWFwZHVtcC5jbi9hcnRpY2xlLzE1NDIzNQ==" title="https://heapdump.cn/article/154235">JVM源码分析之SystemGC完全解读 | HeapDump性能社区<i class="fa fa-external-link"></i></span></p><ul><li>为什么不能同时设置<code>-XX:+DisableExplicitGC</code>以及<code>-XX:+ExplicitGCInvokesConcurrent</code></li><li>为什么CMS GC下-XX:+ExplicitGCInvokesConcurrent这个参数加了之后会比真正的Full GC好？</li><li>它如何做到暂停整个进程？</li><li>堆外内存分配为什么有时候要配合System.gc？</li><li>Netty回收堆外内存的策略又是如何？</li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>笔者也没有想到一个简单的参数能牵扯出这么多内容，这里做一个大概的总结：</p><ul><li>Kafka官方曾经禁用过<code>System.gc()</code>。</li><li>后面有大神分析了脚本和JDK的NIO源码，发现禁用<code>System.gc()</code>这不是有问题嘛，你Kafka大量使用Java的直接内存，直接内存靠一般的Gc是回收不掉的，只能靠Ful Gc顺带回收，JDK官方代码又是靠频繁调用<code>System.gc()</code>强制腾出直接内存空间的，你<code>System.gc()</code>禁用了不是“找死”么，于是赶紧解释了一波<code>Bits#reserveMemory</code>写的“垃圾代码”来证实自己的观点，然后建议启用<code>System.gc()</code>，并且为了提高Full Gc效率使用<code>-XX:+ExplicitGCInvokesConcurrent</code>。</li><li>官方发现这个问题赶紧修复了一版并且提交了issue。</li></ul><h3 id="MaxInlineLevel"><a href="#MaxInlineLevel" class="headerlink" title="MaxInlineLevel"></a>MaxInlineLevel</h3><p><code>java</code> 有一个参数 <code>-XX:MaxInlineLevel</code>(JDK14之前默认值为 9)，这个值在JDK14之后默认值改为15。这个值的修改可以参考JDK官方的声明 <span class="exturl" data-url="aHR0cHM6Ly9idWdzLm9wZW5qZGsub3JnL2Jyb3dzZS9KREstODIzNDg2Mw==" title="https://bugs.openjdk.org/browse/JDK-8234863">https://bugs.openjdk.org/browse/JDK-8234863<i class="fa fa-external-link"></i></span>。</p><blockquote><p>下面的图Oracle官方对于JDK14版本之后修改<code>MaxInlineLevel=15</code>的Push。</p></blockquote><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230223221451.png" alt="调整MaxInlineLevel为15"></p><p>下面长篇大论源自网上收集的资料和个人理解，其实简单理解为现代硬件资源足以支持 <code>-XX:MaxInlineLevel</code>设置为15，更大的内联深度可以让JIT编译出更多的本地代码从而提高Java代码的运行效率即可。</p><blockquote><p>如果你的服务器还是古旧的四五年前的机器，或者生产机器确实渣的可以，那么还是建议把这个参数 <code>-XX:MaxInlineLevel</code>改回 9 比较妥当。</p></blockquote><p>长篇大论的部分：</p><p>链接<span class="exturl" data-url="aHR0cHM6Ly9idWdzLm9wZW5qZGsub3JnL2Jyb3dzZS9KREstODIzNDg2Mw==" title="https://bugs.openjdk.org/browse/JDK-8234863">https://bugs.openjdk.org/browse/JDK-8234863<i class="fa fa-external-link"></i></span>的声明指出，15这个值在scala上的性能测试是被认为最优结果。这个值在现代处理器速度以及性能优化较好的今天最为合适，默认值9这个数字显得非常<strong>过时</strong>。</p><p>Kafka作为激进压榨机器性能的典范，也遵从JDK官方的改动默认所有版本的JDK统一使用15这个默认值。</p><blockquote><p>这里额外插一嘴，个人认为实际上这个值Oracle官方在JDK11就可以修改为15。</p></blockquote><p>MaxInlineLevel本身的判断逻辑似乎更引起广大程序员的关注，StackFlow上有一篇关于这个参数的讨论：<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzI1MDM2Njkvd2h5LWRvZXMtdGhlLWp2bS1oYXZlLWEtbWF4aW11bS1pbmxpbmUtZGVwdGg=" title="https://stackoverflow.com/questions/32503669/why-does-the-jvm-have-a-maximum-inline-depth">https://stackoverflow.com/questions/32503669/why-does-the-jvm-have-a-maximum-inline-depth<i class="fa fa-external-link"></i></span> 比较有意思。</p><p>在评论中有网友指出在比较低的JDK8版本当中，MaxRecursiveInlineLevel对<strong>直接</strong>和<strong>间接</strong>的递归调用都进行计数，编译后的代码应该在运行时保持对整个内联树的跟踪（以便能够解压和去优化）。紧接着是其他人的一些个人观点，没人接这个人话茬=-=，尴尬。</p><p>继续翻阅，下面的评论有一位大佬解释了为什么会出现MaxInlineLevel这个参数，简单易懂这里就直接贴过来了：</p><blockquote><p>One reason is also that the inlining itself in the HotSpot JVM is implemented with recursion. Every time inlining of a method is started a new context is created on the native stack. Allowing an unlimited depth would eventually make the JIT-compiler crash when it runs out of stack. </p></blockquote><p><strong>（旧版保守的限制方法内联深度），其中一个原因是HotSpot JVM的内联本身是用递归实现的。每次对一个方法进行内联时，都会在本地堆栈中创建一个新的上下文。如果允许无限的深度，最终会使JIT-编译器在堆栈耗尽时崩溃。</strong></p><p>在过去硬件资源紧张的情况下，过度的方法内联有可能会出现比较深的堆栈调用，十分消耗程序内存，但是现代内存动不动就是32，64，128G 的今天，加上处理器的核心数量上来了之后，扩大默认的方法内联深度参数值确实非常有必要。</p><blockquote><p> 方法内联是JVM比较底层的优化，可以通过周大神的《深入理解JVM虚拟机第三版》了解。</p></blockquote><p>如果不懂方法内联直接无脑设置<code>MaxInlineLevel=15</code>即可，没有为什么，官方都已经在高版本JDK修改了默认值，JDK8忠实粉丝自然也可以这么干。</p><p>jdk14 hotspot 依赖的调整日志：<span class="exturl" data-url="aHR0cHM6Ly9oZy5vcGVuamRrLm9yZy9qZGs4dS9qZGs4dS9ob3RzcG90Lw==" title="https://hg.openjdk.org/jdk8u/jdk8u/hotspot/">https://hg.openjdk.org/jdk8u/jdk8u/hotspot/<i class="fa fa-external-link"></i></span></p><h3 id="Djava-awt-headless-true"><a href="#Djava-awt-headless-true" class="headerlink" title="-Djava.awt.headless=true"></a>-Djava.awt.headless=true</h3><p>这个参数比较奇怪，但是实际上在SpringBoot源码中也有同样的写法。</p><p>这算是一个不太被关注的优化参数，简单理解是<code>-Djava.awt.headless=true</code>可以屏蔽掉一些不必要的外置设备影响，告知程序当前没有外置设备，尽可能的让程序底层自己模拟，比如打印从图形显示变为控制台打印。</p><p>又是牵扯内容很多的一个点，具体解释可以看这篇文章：[[【Java】The Java Headless Mode]]，篇幅有限，这里就不多解释了。</p><h2 id="KAFKA-GC-LOG-OPTS"><a href="#KAFKA-GC-LOG-OPTS" class="headerlink" title="KAFKA_GC_LOG_OPTS"></a>KAFKA_GC_LOG_OPTS</h2><p>见名知意，就是JVM的日志参数配置，Kafka最终的日志格式为：<code>XXX-gc.log</code>，日志配置这一块和大部分以JAVA为底层的开源组件大差不差，简单的扫一眼差不多了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Log directory to use</span></span><br><span class="line"><span class="comment"># 获取log_dir，如果没配置就那 $base_dir 环境变量</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"x<span class="variable">$LOG_DIR</span>"</span> = <span class="string">"x"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="comment"># base_dir=$(dirname $0)/..</span></span><br><span class="line">  LOG_DIR=<span class="string">"<span class="variable">$base_dir</span>/logs"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># GC options</span></span><br><span class="line">GC_FILE_SUFFIX=<span class="string">'-gc.log'</span></span><br><span class="line">GC_LOG_FILE_NAME=<span class="string">''</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"x<span class="variable">$GC_LOG_ENABLED</span>"</span> = <span class="string">"xtrue"</span> ]; <span class="keyword">then</span></span><br><span class="line">  GC_LOG_FILE_NAME=<span class="variable">$DAEMON_NAME</span><span class="variable">$GC_FILE_SUFFIX</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># The first segment of the version number, which is '1' for releases before Java 9</span></span><br><span class="line">  <span class="comment"># it then becomes '9', '10', ...</span></span><br><span class="line">  <span class="comment"># Some examples of the first line of `java --version`:</span></span><br><span class="line">  <span class="comment"># 8 -&gt; java version "1.8.0_152"</span></span><br><span class="line">  <span class="comment"># 9.0.4 -&gt; java version "9.0.4"</span></span><br><span class="line">  <span class="comment"># 10 -&gt; java version "10" 2018-03-20</span></span><br><span class="line">  <span class="comment"># 10.0.1 -&gt; java version "10.0.1" 2018-04-17</span></span><br><span class="line">  <span class="comment"># We need to match to the end of the line to prevent sed from printing the characters that do not match</span></span><br><span class="line">  JAVA_MAJOR_VERSION=$(<span class="string">"<span class="variable">$JAVA</span>"</span> -version 2&gt;&amp;1 | sed -E -n <span class="string">'s/.* version "([0-9]*).*$/\1/p'</span>)</span><br><span class="line">  <span class="keyword">if</span> [[ <span class="string">"<span class="variable">$JAVA_MAJOR_VERSION</span>"</span> -ge <span class="string">"9"</span> ]] ; <span class="keyword">then</span></span><br><span class="line">    KAFKA_GC_LOG_OPTS=<span class="string">"-Xlog:gc*:file=<span class="variable">$LOG_DIR</span>/<span class="variable">$GC_LOG_FILE_NAME</span>:time,tags:filecount=10,filesize=100M"</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    KAFKA_GC_LOG_OPTS=<span class="string">"-Xloggc:<span class="variable">$LOG_DIR</span>/<span class="variable">$GC_LOG_FILE_NAME</span> -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=10 -XX:GCLogFileSize=100M"</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p><strong>JAVA_MAJOR_VERSION</strong>就是通过正则去除JDK的主版本号。</p><ul><li>如果主版本号大于或者等于JDK9，就使用JDK9新增的 <code>-xlog:gc*</code> 统一的日志参数作为启动参数，</li><li>如果是JDK8之前的版本，就需要用一大堆旧版的日志参数，学习和使用成本比较大：<ul><li>GCLogFileSize=100M，限制GC日志文件大小为100M。</li><li>NumberOfGCLogFiles=10，允许存在的GC日志文件数量为10个。</li><li>UseGCLogFileRotation，让GC日志不断循环，如果最后一个GC日志写满，将会从第一个文件重新开始写入</li><li><code>-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps</code> 是旧版本混乱的GC参数配置诞生的恶果，这些参数在JDK9之后被统统被<code>-xlog:gc*</code> 替代。<ul><li><code>-verbose:gc -XX:+PrintGCDetails</code>这两个参数经常在低版本JDK一起出现，最大的区别是前者是稳定版本，后者则是被认为是不稳定的日志启动参数（强制和其他GC参数配合出现显得不稳定）。</li><li><code>-XX:+PrintGCDateStamps</code>：每行开头显示当前绝对的日期及时间，打印GC发生时的时间戳，搭配 -XX:+PrintGCDetails 使用，不可以独立使用。</li><li><code>-XX:+PrintGCTimeStamps</code> <strong>自从JVM启动</strong>以来的时间。</li></ul></li></ul></li></ul><p><code>-XX:+PrintGCDateStamps</code>和<code>-XX:+PrintGCTimeStamps</code>可以直接看下面的例子对比：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line">日志输出示例：</span><br><span class="line"><span class="number">2014</span>-<span class="number">01</span>-<span class="number">03</span>T12:<span class="number">08</span>:<span class="number">38.102</span>-<span class="number">0100</span>: [GC <span class="number">66048</span>K-&gt;<span class="number">53077</span>K(<span class="number">251392</span>K), <span class="number">0</span>,<span class="number">0959470</span> secs]</span><br><span class="line"><span class="number">2014</span>-<span class="number">01</span>-<span class="number">03</span>T12:<span class="number">08</span>:<span class="number">38.239</span>-<span class="number">0100</span>: [GC <span class="number">119125</span>K-&gt;<span class="number">114661</span>K(<span class="number">317440</span>K), <span class="number">0</span>,<span class="number">1421720</span> secs]</span><br><span class="line"></span><br><span class="line">-XX:+PrintGCTimeStamps</span><br><span class="line">日志输出示例：</span><br><span class="line"><span class="number">0</span>,<span class="number">185</span>: [GC <span class="number">66048</span>K-&gt;<span class="number">53077</span>K(<span class="number">251392</span>K), <span class="number">0</span>,<span class="number">0977580</span> secs]</span><br><span class="line"><span class="number">0</span>,<span class="number">323</span>: [GC <span class="number">119125</span>K-&gt;<span class="number">114661</span>K(<span class="number">317440</span>K), <span class="number">0</span>,<span class="number">1448850</span> secs]</span><br></pre></td></tr></table></figure><blockquote><p>因为<code>-XX:+PrintGCDetails</code>被标记为manageable，所以可以通过如下三种方式修改：<br>1、com.sun.management.HotSpotDiagnosticMXBean API<br>2、JConsole<br>3、jinfo -flag</p></blockquote><p>最后再把英文注释部分简单翻译一下：</p><ol><li>第一个参数如果是1开头，代表是JDK9之后的版本。</li><li><code>java --version</code>产生的结果如下：<ul><li>8 -&gt; java version “1.8.0_152”</li><li>9.0.4 -&gt; java version “9.0.4”</li><li>10 -&gt; java version “10” 2018-03-20</li><li>10.0.1 -&gt; java version “10.0.1” 2018-04-17</li></ul></li><li>通过正则表达式匹配到行尾，以防止sed打印出不匹配的字符</li></ol><h2 id="KAFKA-JMX-OPTS"><a href="#KAFKA-JMX-OPTS" class="headerlink" title="KAFKA_JMX_OPTS"></a>KAFKA_JMX_OPTS</h2><p>JMX全称Java Management Extensions, 为Java应用提供管理扩展功能。在JDK 5的时候引入，Kafka设置启动参数让Kafka应用程序获得JMX远程调用的支持。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># JMX settings</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$KAFKA_JMX_OPTS</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  KAFKA_JMX_OPTS=<span class="string">"-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.authenticate=false  -Dcom.sun.management.jmxremote.ssl=false "</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>KAFKA_JMX_OPTS对应的value的含义参考自：<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC80MTQ2NDdjMTE3OWU=" title="https://www.jianshu.com/p/414647c1179e">https://www.jianshu.com/p/414647c1179e<i class="fa fa-external-link"></i></span>,此处列举一些有关JMX的相关参数：<br>| 参数名                                        | 类型 | 描述                                                         |<br>| :——————————————– | :— | :———————————————————– |<br>| -Dcom.sun.management.jmxremote                | 布尔 | 是否支持远程JMX访问，默认true                                |<br>| -Dcom.sun.management.jmxremote.port           | 数值 | 监听端口号，方便远程访问                                     |<br>| -Dcom.sun.management.jmxremote.authenticate   | 布尔 | 是否需要开启用户认证,默认开启                                |<br>| -Dcom.sun.management.jmxremote.ssl            | 布尔 | 是否对连接开启SSL加密，默认开启                              |<br>| -Dcom.sun.management.jmxremote.access.file    | 路径 | 对访问用户的权限授权的文件的路径，默认路径<code>JRE_HOME/lib/management/jmxremote.access</code> |<br>| -Dcom.sun.management.jmxremote. password.file | 路径 | 设置访问用户的用户名和密码，默认路径<code>JRE_HOME/lib/management/ jmxremote.password</code> |</p><h2 id="KAFKA-LOG4J-OPTS"><a href="#KAFKA-LOG4J-OPTS" class="headerlink" title="KAFKA_LOG4J_OPTS"></a>KAFKA_LOG4J_OPTS</h2><p>log4j的日志配置地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">"x$KAFKA_LOG4J_OPTS"</span> = <span class="string">"x"</span> ]; then  </span><br><span class="line">    export KAFKA_LOG4J_OPTS=<span class="string">"-Dlog4j.configuration=file:$base_dir/../config/log4j.properties"</span>  </span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p> 配置含义不需要记忆，在阅读的时候查阅相关资料即可：<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9jY2FmZGE0NWJjZWE=" title="https://www.jianshu.com/p/ccafda45bcea">https://www.jianshu.com/p/ccafda45bcea<i class="fa fa-external-link"></i></span>，这里直接贴过来作为注释部分供读者参考。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"># 根Log</span><br><span class="line"># 默认日志等级为INFO级别</span><br><span class="line"># NFO、WARN、ERROR和FATAL级别的日志信息都会输出</span><br><span class="line"># 日志最终输出到kafkaAppender</span><br><span class="line">log4j.rootLogger=INFO, stdout, kafkaAppender  </span><br><span class="line"># 控制台配置</span><br><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender  </span><br><span class="line"># 布局模式使用可以灵活模式</span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout  </span><br><span class="line"># 日志打印格式</span><br><span class="line"># [%d] 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，如：%d&#123;yyyy/MM/dd HH:mm:ss,SSS&#125;。</span><br><span class="line"># %m:：输出代码中指定的具体日志信息。</span><br><span class="line"># %p：输出日志信息的优先级，即DEBUG，INFO，WARN，ERROR，FATAL。</span><br><span class="line"># %c：输出日志信息所属的类目，通常就是所在类的全名。</span><br><span class="line"># %n：输出一个回车换行符，Windows平台为"\r\n"，Unix平台为"\n"。</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=[%d] %p %m (%c)%n  </span><br><span class="line"></span><br><span class="line"># DailyRollingFileAppender Kafka默认服务端日志</span><br><span class="line">log4j.appender.kafkaAppender=org.apache.log4j.DailyRollingFileAppender  </span><br><span class="line">log4j.appender.kafkaAppender.DatePattern=<span class="string">'.'</span>yyyy-MM-dd-HH  </span><br><span class="line"># server.log 存储位置</span><br><span class="line">log4j.appender.kafkaAppender.File=$&#123;kafka.logs.dir&#125;/server.log  </span><br><span class="line">log4j.appender.kafkaAppender.layout=org.apache.log4j.PatternLayout  </span><br><span class="line">log4j.appender.kafkaAppender.layout.ConversionPattern=[%d] %p %m (%c)%n  </span><br><span class="line"></span><br><span class="line"># DailyRollingFileAppender 状态机变更日志</span><br><span class="line">log4j.appender.stateChangeAppender=org.apache.log4j.DailyRollingFileAppender  </span><br><span class="line"># 按照每小时产生一个日志的方式</span><br><span class="line">log4j.appender.stateChangeAppender.DatePattern=<span class="string">'.'</span>yyyy-MM-dd-HH   </span><br><span class="line">log4j.appender.stateChangeAppender.File=$&#123;kafka.logs.dir&#125;/state-change.log  </span><br><span class="line">log4j.appender.stateChangeAppender.layout=org.apache.log4j.PatternLayout  </span><br><span class="line">log4j.appender.stateChangeAppender.layout.ConversionPattern=[%d] %p %m (%c)%n  </span><br><span class="line"></span><br><span class="line"># 请求日志</span><br><span class="line">log4j.appender.requestAppender=org.apache.log4j.DailyRollingFileAppender  </span><br><span class="line">log4j.appender.requestAppender.DatePattern=<span class="string">'.'</span>yyyy-MM-dd-HH  </span><br><span class="line">log4j.appender.requestAppender.File=$&#123;kafka.logs.dir&#125;/kafka-request.log  </span><br><span class="line">log4j.appender.requestAppender.layout=org.apache.log4j.PatternLayout  </span><br><span class="line">log4j.appender.requestAppender.layout.ConversionPattern=[%d] %p %m (%c)%n  </span><br><span class="line"></span><br><span class="line"># Log清理日志</span><br><span class="line">log4j.appender.cleanerAppender=org.apache.log4j.DailyRollingFileAppender  </span><br><span class="line">log4j.appender.cleanerAppender.DatePattern=<span class="string">'.'</span>yyyy-MM-dd-HH  </span><br><span class="line">log4j.appender.cleanerAppender.File=$&#123;kafka.logs.dir&#125;/log-cleaner.log  </span><br><span class="line">log4j.appender.cleanerAppender.layout=org.apache.log4j.PatternLayout  </span><br><span class="line">log4j.appender.cleanerAppender.layout.ConversionPattern=[%d] %p %m (%c)%n  </span><br><span class="line"></span><br><span class="line"># Controller 日志</span><br><span class="line">log4j.appender.controllerAppender=org.apache.log4j.DailyRollingFileAppender  </span><br><span class="line">log4j.appender.controllerAppender.DatePattern=<span class="string">'.'</span>yyyy-MM-dd-HH  </span><br><span class="line">log4j.appender.controllerAppender.File=$&#123;kafka.logs.dir&#125;/controller.log  </span><br><span class="line">log4j.appender.controllerAppender.layout=org.apache.log4j.PatternLayout  </span><br><span class="line">log4j.appender.controllerAppender.layout.ConversionPattern=[%d] %p %m (%c)%n  </span><br><span class="line"></span><br><span class="line"># 验证日志</span><br><span class="line">log4j.appender.authorizerAppender=org.apache.log4j.DailyRollingFileAppender  </span><br><span class="line">log4j.appender.authorizerAppender.DatePattern=<span class="string">'.'</span>yyyy-MM-dd-HH  </span><br><span class="line">log4j.appender.authorizerAppender.File=$&#123;kafka.logs.dir&#125;/kafka-authorizer.log  </span><br><span class="line">log4j.appender.authorizerAppender.layout=org.apache.log4j.PatternLayout  </span><br><span class="line">log4j.appender.authorizerAppender.layout.ConversionPattern=[%d] %p %m (%c)%n  </span><br><span class="line">  </span><br><span class="line"># Change the line below to adjust ZK client logging  </span><br><span class="line"># 修改下面的日志控制ZK的日志输出</span><br><span class="line">log4j.logger.org.apache.zookeeper=INFO  </span><br><span class="line">  </span><br><span class="line"># Change the two lines below to adjust the general broker logging level (output to server.log and stdout)  </span><br><span class="line"># 更改下面两行以调整一般代理日志记录级别（输出到 server.log 和 stdout）</span><br><span class="line">log4j.logger.kafka=INFO  </span><br><span class="line">log4j.logger.org.apache.kafka=INFO  </span><br><span class="line">  </span><br><span class="line"># Change to DEBUG or TRACE to enable request logging  </span><br><span class="line"># 修改日志级别为 DEBUG和TRACE获取请求日志</span><br><span class="line">log4j.logger.kafka.request.logger=WARN, requestAppender  </span><br><span class="line">log4j.additivity.kafka.request.logger=<span class="keyword">false</span>  </span><br><span class="line">  </span><br><span class="line"># Uncomment the lines below and change log4j.logger.kafka.network.RequestChannel$ to TRACE for additional output  </span><br><span class="line"># 取消注释下面的行并将 log4j.logger.kafka.network.RequestChannel$ 更改为 TRACE 以获得额外的输出</span><br><span class="line"># related to the handling of requests  </span><br><span class="line"># 与请求的处理相关</span><br><span class="line">#log4j.logger.kafka.network.Processor=TRACE, requestAppender  </span><br><span class="line">#log4j.logger.kafka.server.KafkaApis=TRACE, requestAppender  </span><br><span class="line">#log4j.additivity.kafka.server.KafkaApis=false  </span><br><span class="line"></span><br><span class="line">log4j.logger.kafka.network.RequestChannel$=WARN, requestAppender  </span><br><span class="line">log4j.additivity.kafka.network.RequestChannel$=<span class="keyword">false</span>  </span><br><span class="line">  </span><br><span class="line">log4j.logger.kafka.controller=TRACE, controllerAppender  </span><br><span class="line">log4j.additivity.kafka.controller=<span class="keyword">false</span>  </span><br><span class="line">  </span><br><span class="line">log4j.logger.kafka.log.LogCleaner=INFO, cleanerAppender  </span><br><span class="line">log4j.additivity.kafka.log.LogCleaner=<span class="keyword">false</span>  </span><br><span class="line">  </span><br><span class="line">log4j.logger.state.change.logger=INFO, stateChangeAppender  </span><br><span class="line">log4j.additivity.state.change.logger=<span class="keyword">false</span>  </span><br><span class="line">  </span><br><span class="line"># Access denials are logged at INFO level, change to DEBUG to also log allowed accesses </span><br><span class="line"># 拒绝访问记录在 INFO 级别，更改为 DEBUG 以记录允许的访问</span><br><span class="line">log4j.logger.kafka.authorizer.logger=INFO, authorizerAppender  </span><br><span class="line">log4j.additivity.kafka.authorizer.logger=<span class="keyword">false</span></span><br></pre></td></tr></table></figure><h2 id="KAFKA-OPTS"><a href="#KAFKA-OPTS" class="headerlink" title="KAFKA_OPTS"></a>KAFKA_OPTS</h2><p>KAFKA_OPTS 可以在这里设置自己的想要的通用配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Generic jvm settings you want to add</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$KAFKA_OPTS</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  KAFKA_OPTS=<span class="string">""</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h2 id="UPGRADE-KAFKA-STREAMS-TEST-VERSION"><a href="#UPGRADE-KAFKA-STREAMS-TEST-VERSION" class="headerlink" title="UPGRADE_KAFKA_STREAMS_TEST_VERSION"></a>UPGRADE_KAFKA_STREAMS_TEST_VERSION</h2><p>变量名称翻译过来是“升级kafka流的测试版本”，这里大致的意思是取出版本号进行一些判断之后设置到ClassPath当中。</p><p>说实话这部分内容看不太懂，但是不算是十分重要的东西，可以以后深入之后回来了解，这里直接忘记这个设置即可。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$UPGRADE_KAFKA_STREAMS_TEST_VERSION</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">"<span class="variable">$base_dir</span>"</span>/streams/examples/build/libs/kafka-streams-examples*.jar;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> should_include_file <span class="string">"<span class="variable">$file</span>"</span>; <span class="keyword">then</span></span><br><span class="line">      CLASSPATH=<span class="string">"<span class="variable">$CLASSPATH</span>"</span>:<span class="string">"<span class="variable">$file</span>"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  VERSION_NO_DOTS=`<span class="built_in">echo</span> <span class="variable">$UPGRADE_KAFKA_STREAMS_TEST_VERSION</span> | sed <span class="string">'s/\.//g'</span>`</span><br><span class="line">  SHORT_VERSION_NO_DOTS=<span class="variable">$&#123;VERSION_NO_DOTS:0:(($&#123;#VERSION_NO_DOTS&#125;</span> - 1))&#125; <span class="comment"># remove last char, ie, bug-fix number</span></span><br><span class="line">  <span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">"<span class="variable">$base_dir</span>"</span>/streams/upgrade-system-tests-<span class="variable">$SHORT_VERSION_NO_DOTS</span>/build/libs/kafka-streams-upgrade-system-tests*.jar;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> should_include_file <span class="string">"<span class="variable">$file</span>"</span>; <span class="keyword">then</span></span><br><span class="line">      CLASSPATH=<span class="string">"<span class="variable">$file</span>"</span>:<span class="string">"<span class="variable">$CLASSPATH</span>"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">"<span class="variable">$SHORT_VERSION_NO_DOTS</span>"</span> = <span class="string">"0100"</span> ]; <span class="keyword">then</span></span><br><span class="line">    CLASSPATH=<span class="string">"/opt/kafka-<span class="variable">$UPGRADE_KAFKA_STREAMS_TEST_VERSION</span>/libs/zkclient-0.8.jar"</span>:<span class="string">"<span class="variable">$CLASSPATH</span>"</span></span><br><span class="line">    CLASSPATH=<span class="string">"/opt/kafka-<span class="variable">$UPGRADE_KAFKA_STREAMS_TEST_VERSION</span>/libs/zookeeper-3.4.6.jar"</span>:<span class="string">"<span class="variable">$CLASSPATH</span>"</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">"<span class="variable">$SHORT_VERSION_NO_DOTS</span>"</span> = <span class="string">"0101"</span> ]; <span class="keyword">then</span></span><br><span class="line">    CLASSPATH=<span class="string">"/opt/kafka-<span class="variable">$UPGRADE_KAFKA_STREAMS_TEST_VERSION</span>/libs/zkclient-0.9.jar"</span>:<span class="string">"<span class="variable">$CLASSPATH</span>"</span></span><br><span class="line">    CLASSPATH=<span class="string">"/opt/kafka-<span class="variable">$UPGRADE_KAFKA_STREAMS_TEST_VERSION</span>/libs/zookeeper-3.4.8.jar"</span>:<span class="string">"<span class="variable">$CLASSPATH</span>"</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h2 id="CLASSPATH"><a href="#CLASSPATH" class="headerlink" title="CLASSPATH"></a>CLASSPATH</h2><p>运行 <code>./gradlew copyDependantLibs</code> 来获取本地目录下的所有依赖性jar。</p><p>注意这里划分了很多个子模块，所以使用了for循环加载到<strong>CLASSPATH</strong>当中，这会导致最终产生的命令会非常长。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># run ./gradlew copyDependantLibs to get all dependant jars in a local dir</span></span><br><span class="line"><span class="built_in">shopt</span> -s nullglob</span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$UPGRADE_KAFKA_STREAMS_TEST_VERSION</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">for</span> dir <span class="keyword">in</span> <span class="string">"<span class="variable">$base_dir</span>"</span>/core/build/dependant-libs-<span class="variable">$&#123;SCALA_VERSION&#125;</span>*;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    CLASSPATH=<span class="string">"<span class="variable">$CLASSPATH</span>:<span class="variable">$dir</span>/*"</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">"<span class="variable">$base_dir</span>"</span>/examples/build/libs/kafka-examples*.jar;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> should_include_file <span class="string">"<span class="variable">$file</span>"</span>; <span class="keyword">then</span></span><br><span class="line">    CLASSPATH=<span class="string">"<span class="variable">$CLASSPATH</span>"</span>:<span class="string">"<span class="variable">$file</span>"</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>个人尝试了一下注释介绍的<code>gradle copyDependantLibs</code>命令，本地执行结果如下，这个命令会在对应的模块构建依赖jar包：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ gradle copyDependantLibs</span><br><span class="line"></span><br><span class="line">&gt; Configure project :</span><br><span class="line">Building project <span class="string">'core'</span> with Scala version 2.13.3</span><br><span class="line">Building project <span class="string">'streams-scala'</span> with Scala version 2.13.3</span><br><span class="line"></span><br><span class="line">Deprecated Gradle features were used <span class="keyword">in</span> this build, making it incompatible with Gradle 7.0.</span><br><span class="line">Use <span class="string">'--warning-mode all'</span> to show the individual deprecation warnings.</span><br><span class="line">See https://docs.gradle.org/6.6.1/userguide/command_line_interface.html<span class="comment">#sec:command_line_warnings</span></span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL <span class="keyword">in</span> 2s</span><br><span class="line">55 actionable tasks: 3 executed, 52 up-to-date</span><br></pre></td></tr></table></figure><p>个人是win11的电脑，通过wox查找<code>dependant-libs</code>结果如下：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/image-20230224133728509.png" alt="image-20230224133728509"></p><p>对应的一堆依赖jar包</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/image-20230224133744539.png" alt="image-20230224133744539"></p><h2 id="CONSOLE-OUTPUT-FILE"><a href="#CONSOLE-OUTPUT-FILE" class="headerlink" title="CONSOLE_OUTPUT_FILE"></a>CONSOLE_OUTPUT_FILE</h2><p>日志的打印输出地址文件地址设置，注意不是GC的日志。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="variable">$COMMAND</span> <span class="keyword">in</span></span><br><span class="line">  -name)</span><br><span class="line">    DAEMON_NAME=<span class="variable">$2</span></span><br><span class="line">    CONSOLE_OUTPUT_FILE=<span class="variable">$LOG_DIR</span>/<span class="variable">$DAEMON_NAME</span>.out</span><br><span class="line">    <span class="built_in">shift</span> 2</span><br><span class="line">    ;;</span><br></pre></td></tr></table></figure><p>这里翻阅了一些有关<code>shift</code>的资料：</p><blockquote><p>关于Shift的作用可以参考：<span class="exturl" data-url="aHR0cHM6Ly9zczY0LmNvbS9iYXNoL3NoaWZ0Lmh0bWw=" title="https://ss64.com/bash/shift.html">https://ss64.com/bash/shift.html<i class="fa fa-external-link"></i></span>。Linux中通过<code>help shift</code>查看使用手册，但是会发现写的比较潦草和抽象。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shift</span>: <span class="built_in">shift</span> [n]</span><br><span class="line">    Shift positional parameters.</span><br><span class="line">    </span><br><span class="line">    Rename the positional parameters <span class="variable">$N</span>+1,<span class="variable">$N</span>+2 ... to <span class="variable">$1</span>,<span class="variable">$2</span> ...  If N is</span><br><span class="line">    not given, it is assumed to be 1.</span><br><span class="line">    </span><br><span class="line">    Exit Status:</span><br><span class="line">    Returns success unless N is negative or greater than <span class="variable">$#</span></span><br></pre></td></tr></table></figure><p>比如下面的程序：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$1</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">shift</span> 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[zxd@localhost ~]$ ./test.sh 1 2 3 5 6</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>shift 1 执行之后会弹出第一个参数</strong>，之后的运行参数会往前“推动”，$1变为$2的值，$2变为$3的值，以此类推。</p><h2 id="amp-后台启动和nohup挂起进程"><a href="#amp-后台启动和nohup挂起进程" class="headerlink" title="&amp; 后台启动和nohup挂起进程"></a>&amp; 后台启动和nohup挂起进程</h2><p>末尾部分是设置ClaassPath，用户自己自定义参数以及把标准输入和输出重定向到同一个位置，最后就是以后台模式启动并且最终通过nohup挂起整个进程。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-cp <span class="string">"<span class="variable">$CLASSPATH</span>"</span> <span class="variable">$KAFKA_OPTS</span> <span class="string">"<span class="variable">$@</span>"</span> &gt; <span class="string">"<span class="variable">$CONSOLE_OUTPUT_FILE</span>"</span> 2&gt;&amp;1 &lt; /dev/null &amp;</span><br></pre></td></tr></table></figure><p>这段脚本最前面把替代参数意义进行了替换。<code>-cp</code>是nohup命令的参数，接着是把输出的结果全部重定向到标准输出当中，这个地址对应<strong>CONSOLE_OUTPUT_FILE</strong>。</p><p>下面理解最后部分的<code>nohup和&amp;</code>、<code>2&gt;&amp;1</code>和<code>/dev/null</code>这几个常见的服务端脚本启动参数的含义。</p><h3 id="nohup和-amp"><a href="#nohup和-amp" class="headerlink" title="nohup和&amp;"></a>nohup和&amp;</h3><p>nohup：nohup指令会忽略所有挂断（SIGHUP）信号不挂断的运行。注意nohup命令本身并没有后台运行的功能，需要配合<code>&amp;</code>使用。它的实现原理是让命令不间断的运行实现挂机的效果。</p><p>&amp; 是指在后台运行，但当用户退出（解除挂起）的时候，命令自动也跟着退出，<code>nohup</code>和<code>&amp;</code>这两个指令通常会放到一起使用。</p><h3 id="dev-null"><a href="#dev-null" class="headerlink" title="/dev/null"></a>/dev/null</h3><p>这个空间属于Linux的一块特殊空间，UNIX系统中，它被称为空设备。以下内容摘自维基百科：</p><blockquote><p> /dev/null（或称空设备）在类Unix系统中是一个特殊的设备文件，它丢弃一切写入其中的数据（但报告写入操作成功），读取它则会立即得到一个EOF[1]。</p><p>在程序员行话，尤其是Unix行话中，/dev/null被称为比特桶或者<strong>黑洞</strong>。</p></blockquote><h3 id="2-gt-amp-1的问题"><a href="#2-gt-amp-1的问题" class="headerlink" title="2&gt;&amp;1的问题"></a>2&gt;&amp;1的问题</h3><p>前面的第一个数字2通常对应下面几种含义：</p><ul><li>0 – stdin (standard input) 标准输入</li><li>1 – stdout (standard output) 标准输出</li><li>2 – stderr (standard error) 标准错误输出</li></ul><p>&gt; 是重定向符号，而数字2的含义是标准错误输出，<code>&amp;1</code>指的就是标准输出，三个符号组合到一起就是把标准错误输出输入重定向到标准输出当中，这里可以理解为“合流”。</p><blockquote><p>注意命令<code>2&gt;&amp;1</code> 和<code>2&gt;1</code>是存在区别的，这里<code>&amp;</code>不能丢，后者的1代表输出代表错误重定向到一个<strong>文件1</strong>，不代表标准输出，只有<code>&amp;1</code>才代表标准输出。</p></blockquote><p>如果想要丢弃所有的标准错误输出和标准输出结果，下面是一个不错的例子：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup python3 getfile.py &gt; /dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p>如果想要写入到指定的位置，下面是又一个不错的例子：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup python3 getfile.py &gt; test.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p>最后是实际一点的例子：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 9 \* \* \* /usr/bin/python3 /opt/getFile.py &gt; /opt/file.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure><blockquote><p>上面的命令含义是放在crontab中的定时任务，每天9:00启动这个python的脚本，并把执行结果写入日志文件file.log中</p></blockquote><h2 id="exec-运行"><a href="#exec-运行" class="headerlink" title="exec 运行"></a>exec 运行</h2><p>如果不是守护进程的执行，则是使用<code>exec</code>在当前的shell中进行正常模式启动，此时整个shell会挂起运行kafka服务端。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> <span class="string">"<span class="variable">$JAVA</span>"</span> <span class="variable">$KAFKA_HEAP_OPTS</span> <span class="variable">$KAFKA_JVM_PERFORMANCE_OPTS</span> <span class="variable">$KAFKA_GC_LOG_OPTS</span> <span class="variable">$KAFKA_JMX_OPTS</span> <span class="variable">$KAFKA_LOG4J_OPTS</span> -cp <span class="string">"<span class="variable">$CLASSPATH</span>"</span> <span class="variable">$KAFKA_OPTS</span> <span class="string">"<span class="variable">$@</span>"</span></span><br></pre></td></tr></table></figure><h1 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h1><p>Lauch modes 使用到的变量设置包含了启动整个Kafka服务端的核心部分，下面再列觉其他的依赖配置以及“辅助”内容。</p><h2 id="Scala-版本选择"><a href="#Scala-版本选择" class="headerlink" title="Scala 版本选择"></a>Scala 版本选择</h2><p>Kafka是使用Java和Scala混合编写的，根据不同的Kafka版本需要不同版本的Scala版本支持，这里官方做了一个版本选择强制判断选择出最合适的Scala。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$SCALA_VERSION</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  SCALA_VERSION=2.13.3</span><br><span class="line">  <span class="keyword">if</span> [[ -f <span class="string">"<span class="variable">$base_dir</span>/gradle.properties"</span> ]]; <span class="keyword">then</span></span><br><span class="line">    SCALA_VERSION=`grep <span class="string">"^scalaVersion="</span> <span class="string">"<span class="variable">$base_dir</span>/gradle.properties"</span> | cut -d= -f 2`</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="gradle-properties"><a href="#gradle-properties" class="headerlink" title="gradle.properties"></a>gradle.properties</h3><p>Kafka 项目是基于gradle构建的，gradle 个人平时基本没啥接触机会，这里做一个大致配置了解。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">group</span>=<span class="string">org.apache.kafka  </span></span><br><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> When you change this version number, you should also make sure to update  </span></span><br><span class="line"><span class="comment"># the version numbers in  </span></span><br><span class="line"><span class="comment">#  - docs/js/templateData.js  </span></span><br><span class="line"><span class="comment">#  - tests/kafkatest/__init__.py  </span></span><br><span class="line"><span class="comment">#  - tests/kafkatest/version.py (variable DEV_VERSION)  </span></span><br><span class="line"><span class="comment">#  - kafka-merge-pr.py  </span></span><br><span class="line"><span class="attr">version</span>=<span class="string">2.7.2  </span></span><br><span class="line"><span class="attr">scalaVersion</span>=<span class="string">2.13.3  </span></span><br><span class="line"><span class="attr">task</span>=<span class="string">build  </span></span><br><span class="line"><span class="meta">org.gradle.jvmargs</span>=<span class="string">-Xmx2g -Xss4m -XX:+UseParallelGC</span></span><br></pre></td></tr></table></figure><p>gradle这里分配的是2g的堆内存，Xss4m每个线程的堆栈大小为4M，最后是使用<code>ParallelGC</code>垃圾收集器，也是JDK8的默认垃圾收集器。</p><h2 id="DEBUG模式"><a href="#DEBUG模式" class="headerlink" title="DEBUG模式"></a>DEBUG模式</h2><p>如果在启动参数里面设置了<code>KAFKA_DEBUG</code>，就可以开启DEBUG模式。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set Debug options if enabled</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"x<span class="variable">$KAFKA_DEBUG</span>"</span> != <span class="string">"x"</span> ]; <span class="keyword">then</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Use default ports</span></span><br><span class="line">    DEFAULT_JAVA_DEBUG_PORT=<span class="string">"5005"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$JAVA_DEBUG_PORT</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">        JAVA_DEBUG_PORT=<span class="string">"<span class="variable">$DEFAULT_JAVA_DEBUG_PORT</span>"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Use the defaults if JAVA_DEBUG_OPTS was not set</span></span><br><span class="line">    DEFAULT_JAVA_DEBUG_OPTS=<span class="string">"-agentlib:jdwp=transport=dt_socket,server=y,suspend=<span class="variable">$&#123;DEBUG_SUSPEND_FLAG:-n&#125;</span>,address=<span class="variable">$JAVA_DEBUG_PORT</span>"</span></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$JAVA_DEBUG_OPTS</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">        JAVA_DEBUG_OPTS=<span class="string">"<span class="variable">$DEFAULT_JAVA_DEBUG_OPTS</span>"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Enabling Java debug options: <span class="variable">$JAVA_DEBUG_OPTS</span>"</span></span><br><span class="line">    KAFKA_OPTS=<span class="string">"<span class="variable">$JAVA_DEBUG_OPTS</span> <span class="variable">$KAFKA_OPTS</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>我们需要了解的是 JAVA_DEBUG_OPTS 命令的含义。起初虽然不是很懂下面的参数含义，但是可以知道是JAVA调试应用程序用的。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-agentlib:jdwp=transport=dt_socket,server=y,<span class="built_in">suspend</span>=<span class="variable">$&#123;DEBUG_SUSPEND_FLAG:-n&#125;</span>,address=<span class="variable">$JAVA_DEBUG_PORT</span></span><br></pre></td></tr></table></figure><p>我们调试程序更多是在IDE里面，下面的内容来自网络资料整合参考和理解：</p><p>[Debugging Java applications](<span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9kb2NzL2VuL3Nkay1qYXZhLXRlY2hub2xvZ3kvOD90b3BpYz1hcHBsaWNhdGlvbnMtZGVidWdnaW5nLWphdmE=" title="https://www.ibm.com/docs/en/sdk-java-technology/8?topic=applications-debugging-java">Debugging Java applications - IBM Documentation<i class="fa fa-external-link"></i></span>) 这篇文章大概介绍了如何在JVM启动之后调试JAVA程序，以及如何在使用JDK调试应用程序。</p><p>若要调试 Java 进程，可以使用 Java 调试器 （JDB） 应用进程或其他调试器，这些调试器通过使用 SDK 为操作系统提供的 Java™ 平台调试器体系结构 （JPDA） 进行通信。</p><p>在Linux系统当中进行JAVA进程调试可以使用下面的命令。对于我们来说这些写法照着写就行，不需要过分追究具体的含义。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -agentlib:jdwp=transport=dt_socket,server=y,address=_&lt;port&gt;_ &lt;class&gt;</span><br></pre></td></tr></table></figure><p>调试远程服务器运行的JAVA应用程序，在Window中和Linux中调试方式如下：</p><ul><li>On Windows systems:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdb -connect com.sun.jdi.SocketAttach:hostname&#x3D;&lt;host&gt;,port&#x3D;&lt;port&gt;</span><br></pre></td></tr></table></figure><ul><li>On other systems:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdb -attach &lt;host&gt;:&lt;port&gt;</span><br></pre></td></tr></table></figure><p>此外Stack-Flow上还有一个写的更棒的帖子，这篇帖子的参数和Kafka的脚本部分基本一致了。</p><p><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTM4NTExL3doYXQtYXJlLWphdmEtY29tbWFuZC1saW5lLW9wdGlvbnMtdG8tc2V0LXRvLWFsbG93LWp2bS10by1iZS1yZW1vdGVseS1kZWJ1Z2dlZA==" title="https://stackoverflow.com/questions/138511/what-are-java-command-line-options-to-set-to-allow-jvm-to-be-remotely-debugged">debugging - What are Java command line options to set to allow JVM to be remotely debugged? - Stack Overflow<i class="fa fa-external-link"></i></span></p><p>Before Java 5.0, use <code>-Xdebug</code> and <code>-Xrunjdwp</code> arguments. These options will still work in later versions, but it will run in interpreted mode instead of JIT, which will be slower.</p><p>JDK5之前的版本这里可以直接忽略。（知道了也没啥用处）</p><p>From Java 5.0, it is better to use the <code>-agentlib:jdwp</code> single option:</p><p>JDK5之后使用下面的命令格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=<span class="number">1044</span></span><br></pre></td></tr></table></figure><p>Options on <code>-Xrunjdwp</code> or <code>agentlib:jdwp</code> arguments are :</p><ul><li><p><code>transport=dt_socket</code> : means the way used to connect to JVM (socket is a good choice, it can be used to debug a distant computer)</p></li><li><p><code>address=8000</code> : TCP/IP port exposed, to connect from the debugger,</p></li><li><p><code>suspend=y</code> : if ‘y’, tell the JVM to wait until debugger is attached to begin execution, otherwise (if ‘n’), starts execution right away.</p></li><li><p><code>transport=dt_socket</code> ：表示用于连接JVM的方式（socket是一个不错的选择，它可以用来调试远程计算机）</p></li><li><p><code>address=8000</code> ： TCP / IP端口公开，从调试器连接。</p></li><li><p><code>suspend=y</code> ：如果为“y”，则告诉 JVM 等到连接调试器后再开始执行，否则（如果为“n”），立即开始执行。</p></li></ul><p>最后对比一下Kafka的参数，豁然开朗。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-agentlib:jdwp=transport=dt_socket,server=y,<span class="built_in">suspend</span>=<span class="variable">$&#123;DEBUG_SUSPEND_FLAG:-n&#125;</span>,address=<span class="variable">$JAVA_DEBUG_PORT</span></span><br></pre></td></tr></table></figure><h2 id="Which-java-to-use"><a href="#Which-java-to-use" class="headerlink" title="Which java to use"></a>Which java to use</h2><p>如注释所言查找java命令在哪。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$JAVA_HOME</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  JAVA=<span class="string">"java"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  JAVA=<span class="string">"<span class="variable">$JAVA_HOME</span>/bin/java"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h2 id="Memory-options"><a href="#Memory-options" class="headerlink" title="Memory options"></a>Memory options</h2><p>内存配置选项如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$KAFKA_HEAP_OPTS</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  KAFKA_HEAP_OPTS=<span class="string">"-Xmx256M"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><blockquote><p>-Xmxn：指定内存分配池的最大大小（以字节为单位）。此值的倍数必须大于 2MB，1024 的倍数。</p></blockquote><p>这里设置最大的HEAP大小为256M。</p><h2 id="cc-pkg"><a href="#cc-pkg" class="headerlink" title="cc_pkg"></a>cc_pkg</h2><p>同样是jar包依赖的查找和引入到ClassPath当中，这里同样不知道干啥用的，简单理解是获取必要依赖项即可。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> cc_pkg <span class="keyword">in</span> <span class="string">"api"</span> <span class="string">"transforms"</span> <span class="string">"runtime"</span> <span class="string">"file"</span> <span class="string">"mirror"</span> <span class="string">"mirror-client"</span> <span class="string">"json"</span> <span class="string">"tools"</span> <span class="string">"basic-auth-extension"</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">"<span class="variable">$base_dir</span>"</span>/connect/<span class="variable">$&#123;cc_pkg&#125;</span>/build/libs/connect-<span class="variable">$&#123;cc_pkg&#125;</span>*.jar;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> should_include_file <span class="string">"<span class="variable">$file</span>"</span>; <span class="keyword">then</span></span><br><span class="line">      CLASSPATH=<span class="string">"<span class="variable">$CLASSPATH</span>"</span>:<span class="string">"<span class="variable">$file</span>"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">  <span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$base_dir</span>/connect/<span class="variable">$&#123;cc_pkg&#125;</span>/build/dependant-libs"</span> ] ; <span class="keyword">then</span></span><br><span class="line">    CLASSPATH=<span class="string">"<span class="variable">$CLASSPATH</span>:<span class="variable">$base_dir</span>/connect/<span class="variable">$&#123;cc_pkg&#125;</span>/build/dependant-libs/*"</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h2 id="Exclude-jars-not-necessary-for-running-commands"><a href="#Exclude-jars-not-necessary-for-running-commands" class="headerlink" title="Exclude jars not necessary for running commands."></a>Exclude jars not necessary for running commands.</h2><p>排除命令不需要的jar包，比如test和javadoc等。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">regex=<span class="string">"(-(test|test-sources|src|scaladoc|javadoc)\.jar|jar.asc)$"</span></span><br><span class="line"><span class="function"><span class="title">should_include_file</span></span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">"<span class="variable">$INCLUDE_TEST_JARS</span>"</span> = <span class="literal">true</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">return</span> 0</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  file=<span class="variable">$1</span></span><br><span class="line">  <span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$(echo "$file" | egrep "$regex")</span>"</span> ] ; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">return</span> 0</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">return</span> 1</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="INCLUDE-TEST-JARS"><a href="#INCLUDE-TEST-JARS" class="headerlink" title="INCLUDE_TEST_JARS"></a>INCLUDE_TEST_JARS</h2><p>判断是否开启了包含测试的jar包。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$INCLUDE_TEST_JARS</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  INCLUDE_TEST_JARS=<span class="literal">false</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>不得不感叹学无止境，知道的越多不知道的也就更多，一个脚本里面居然有这么多学问，本部分的核心毫无疑问是<strong>JVM的启动参数</strong>，其他的参数或者配置以及奇怪的脚本写法看不懂 也没啥关系，这里仅仅对于一些个人关注的核心部分进行介绍，对于一些细枝末节不做过多的追究和钻牛角尖，读者感兴趣可以对比参考资料做更多了解。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      Kafka-Server-start.sh启动脚本分析
    
    </summary>
    
    
      <category term="Kafka" scheme="https://whitestore.top/categories/Kafka/"/>
    
    
      <category term="Kafka" scheme="https://whitestore.top/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>【Java】The Java Headless Mode</title>
    <link href="https://whitestore.top/2023/02/27/headlessmode/"/>
    <id>https://whitestore.top/2023/02/27/headlessmode/</id>
    <published>2023-02-26T23:37:31.000Z</published>
    <updated>2023-03-02T01:34:33.622Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFlbGR1bmcuY29tL2phdmEtaGVhZGxlc3MtbW9kZQ==" title="https://www.baeldung.com/java-headless-mode">https://www.baeldung.com/java-headless-mode<i class="fa fa-external-link"></i></span></p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>这篇文章源自个人看到了Kafka的启动脚本中一个“奇怪”的参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Djava.awt.headless=<span class="keyword">true</span></span><br></pre></td></tr></table></figure><p>拿去谷歌一下发现网上的描述都大差不差，这里找了baeldung（类似国外的菜鸟教程）中的一篇文章，本文内容来自于英文博客原文。</p><p>这篇文章介绍了 <strong>-Djava.awt.headless</strong> 参数的作用，网上大部分的资料都是说“为了<strong>提高计算效率和适配性</strong>我们可以使用这种模式，关闭图形显示等功能可以大大节省设备的计算能力，而且对一些本身没有相关显示设备的机器也能适配，程序也可以正常运行。”，个人认为这些理论内容不太能理解。</p><p>当然也有诸如<strong>服务器没有显示屏什么的，你得告诉程序一声，你工作的地方没有这些设备</strong>这种说法 ，为此找了一篇国外的博客介绍。</p><a id="more"></a><h1 id="如何设置？"><a href="#如何设置？" class="headerlink" title="如何设置？"></a>如何设置？</h1><p>设置方式如下：</p><ul><li>在system property中设置 <em>java.awt.headless</em> 为 _true_。</li></ul><p>SpringBoot的源码中可以找到类似的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configureHeadlessProperty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.setProperty(<span class="string">"java.awt.headless"</span>, System.getProperty(<span class="string">"java.awt.headless"</span>, Boolean.toString(<span class="keyword">this</span>.headless)));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>启动脚本中进行设置<code>-Djava.awt.headless=true</code>：在Kafka的脚本当中存在类似的启动脚本。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KAFKA_JVM_PERFORMANCE_OPTS=<span class="string">"-server -XX:+UseG1GC -XX:MaxGCPauseMillis=20 -XX:InitiatingHeapOccupancyPercent=35 -XX:+ExplicitGCInvokesConcurrent -XX:MaxInlineLevel=15 -Djava.awt.headless=true"</span></span><br></pre></td></tr></table></figure><p>最后一个参数显示它使用headless模式。</p><ul><li>在执行命令的时候动态添加<code>-Djava.awt.headless=true</code>，这种方式和脚本设置启动的方式类似。</li></ul><h1 id="Headless-绕过重量级组件"><a href="#Headless-绕过重量级组件" class="headerlink" title="Headless 绕过重量级组件"></a>Headless 绕过重量级组件</h1><p>如果一个带有GUI组件的代码在开和关Headless模式下运行分别会有什么不同的效果？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FlexibleApp</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (GraphicsEnvironment.isHeadless()) &#123;  </span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        JOptionPane.showMessageDialog(<span class="keyword">null</span>, <span class="string">" showMessageDialog Hello World"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码如果关闭了Headless模式，则打印Hello World会变为图形化界面。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230223072911.png" alt=""></p><p>如果开启Headless，则会打印在控制台。</p><h1 id="Headless-Mode-在UI组件的应用案例"><a href="#Headless-Mode-在UI组件的应用案例" class="headerlink" title="Headless Mode 在UI组件的应用案例"></a>Headless Mode 在UI组件的应用案例</h1><p>Java Headless Mode 的典型案例可能是使用图形转化器，我们有时候可能需要图形数据进行图像处理，但是不一定需要实际显示。</p><p>下面通过一个单元测试来模拟这些情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Before</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUpHeadlessMode</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 通过注释掉下面的代码测试不同的效果  </span></span><br><span class="line"><span class="comment">//        System.setProperty("java.awt.headless", "true");  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Test</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenSetUpSuccessful_thenHeadlessIsTrue</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">boolean</span> headless = GraphicsEnvironment.isHeadless();  </span><br><span class="line">        Assert.assertTrue(headless);  </span><br><span class="line">    &#125;<span class="comment">/*  </span></span><br><span class="line"><span class="comment">    测试通过  </span></span><br><span class="line"><span class="comment">    注释下面的代码之后，单元测试不通过  </span></span><br><span class="line"><span class="comment">    //        System.setProperty("java.awt.headless", "true");    */</span></span><br></pre></td></tr></table></figure><p>使用awt的组件<code>java.awt.GraphicsEnvironment#isHeadless</code>，注意较高版本的JDK（例如 JDK11）中awk被直接干掉了，需要下载外部依赖导入才可以使用，建议选择JDK8以及以下的版本测试上面的程序。</p><p>上面的代码如果注释掉 headless模式，单元测试会直接不通过。下面简单构建了一个图形转化器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenHeadlessMode_thenImagesWork</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;  </span><br><span class="line">    <span class="keyword">try</span> (InputStream inStream = HeadlessModeUnitTest<span class="class">.<span class="keyword">class</span>.<span class="title">getResourceAsStream</span>(<span class="title">IN_FILE</span>)</span>;  </span><br><span class="line">         FileOutputStream outStream = <span class="keyword">new</span> FileOutputStream(OUT_FILE)) &#123;  </span><br><span class="line">        BufferedImage inputImage = ImageIO.read(inStream);  </span><br><span class="line">        result = ImageIO.write(inputImage, FORMAT, outStream);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    assertThat(result).isTrue();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在接下来的这个例子中，我们可以看到所有字体的信息，包括字体的度量，也可以让我们使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Test</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenHeadless_thenFontsWork</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();  </span><br><span class="line">        String fonts[] = ge.getAvailableFontFamilyNames();  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//        assertThat(fonts).isNotEmpty();  </span></span><br><span class="line">  </span><br><span class="line">        Font font = <span class="keyword">new</span> Font(fonts[<span class="number">0</span>], Font.BOLD, <span class="number">14</span>);  </span><br><span class="line">        FontMetrics fm = (<span class="keyword">new</span> Canvas()).getFontMetrics(font);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//        assertThat(fm.getHeight()).isGreaterThan(0);  </span></span><br><span class="line"><span class="comment">//        assertThat(fm.getAscent()).isGreaterThan(0);  </span></span><br><span class="line"><span class="comment">//        assertThat(fm.getDescent()).isGreaterThan(0);  </span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="HeadlessException"><a href="#HeadlessException" class="headerlink" title="HeadlessException"></a>HeadlessException</h1><p>有些设备是需要外部设备支持的，否则会抛出下面的异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.awt.HeadlessException</span><br><span class="line">at java.awt.GraphicsEnvironment.checkHeadless(GraphicsEnvironment.java:<span class="number">204</span>)</span><br><span class="line">at java.awt.Window.&lt;init&gt;(Window.java:<span class="number">536</span>)</span><br><span class="line">at java.awt.Frame.&lt;init&gt;(Frame.java:<span class="number">420</span>)</span><br></pre></td></tr></table></figure><p>可以使用Frame来进行验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">   <span class="meta">@Test</span>  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenHeadlessmode_thenFrameThrowsHeadlessException</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">       Frame frame = <span class="keyword">new</span> Frame();  </span><br><span class="line">       frame.setVisible(<span class="keyword">true</span>);  </span><br><span class="line">       frame.setSize(<span class="number">120</span>, <span class="number">120</span>);  </span><br><span class="line">   &#125;<span class="comment">/*  </span></span><br><span class="line"><span class="comment">   在开关Headless模式后会有不同的结果  </span></span><br><span class="line"><span class="comment">   开启：通过      </span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">   关闭  </span></span><br><span class="line"><span class="comment">   ava.awt.HeadlessExceptionat java.awt.GraphicsEnvironment.checkHeadless(GraphicsEnvironment.java:204)  </span></span><br><span class="line"><span class="comment">at java.awt.Window.&lt;init&gt;(Window.java:536)  </span></span><br><span class="line"><span class="comment">at java.awt.Frame.&lt;init&gt;(Frame.java:420)  </span></span><br><span class="line"><span class="comment">at java.awt.Frame.&lt;init&gt;(Frame.java:385)  </span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">   */</span></span><br></pre></td></tr></table></figure><p>作为一个经验法则，请记住，像Frame和Button这样的顶级组件总是需要一个交互式的环境，并且会抛出这个异常。然而，如果没有明确设置无头模式，它将被抛出，成为一个不可恢复的错误。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过代码和案例分析，我们大致了解Java Headless Mode模式是怎么一回事，说白了就是屏蔽掉外置设备比如GUI的额外开销，转而用程序自己去进行模拟。</p><p>Kafka设置这样的参数就是把性能发挥到机制，摈弃一切外部设备干扰，让服务器尽可能的通过自身程序模拟外部设备。</p><p>比如重量级组件控制台打印，在外部设计可以通过<code>JOptionPane</code>的GUI组件实现可视化效果，而Headless则是利用我们熟知的<code>System.out</code>控制台输入输出流完成打印功能的模拟。</p><p>以上就是关于 Java Headless Mode 的理解。</p><h1 id="程序demo"><a href="#程序demo" class="headerlink" title="程序demo"></a>程序demo</h1><p>本文的个人实验代码放到下面部分，文章提到的部分代码可能会无法编译通过（图形转化器的代码），个人理解代码意图之后就没有深究了，读者碰到报错问题忽略删除即可。</p><blockquote><p>PS：建议使用JDK8之前的版本，可以直接引入awt和swing的相关组件。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="keyword">import</span> jdk.nashorn.internal.ir.LiteralNode;  </span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;  </span><br><span class="line"><span class="keyword">import</span> org.junit.Before;  </span><br><span class="line"><span class="keyword">import</span> org.junit.Test;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> javax.imageio.ImageIO;  </span><br><span class="line"><span class="keyword">import</span> javax.swing.*;  </span><br><span class="line"><span class="keyword">import</span> java.awt.*;  </span><br><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;  </span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;  </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;  </span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.assertThat;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlessTest</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Before</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUpHeadlessMode</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 通过注释掉下面的代码测试不同的效果  </span></span><br><span class="line">        System.setProperty(<span class="string">"java.awt.headless"</span>, <span class="string">"true"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Test</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenSetUpSuccessful_thenHeadlessIsTrue</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">boolean</span> headless = GraphicsEnvironment.isHeadless();  </span><br><span class="line">        Assert.assertTrue(headless);  </span><br><span class="line">    &#125;<span class="comment">/*  </span></span><br><span class="line"><span class="comment">    测试通过  </span></span><br><span class="line"><span class="comment">    注释下面的代码之后，单元测试不通过  </span></span><br><span class="line"><span class="comment">    //        System.setProperty("java.awt.headless", "true");    */</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//@Test  </span></span><br><span class="line">    <span class="comment">//public void whenHeadlessMode_thenImagesWork() throws IOException &#123;  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//    boolean result = false;  </span></span><br><span class="line">    <span class="comment">//    try (InputStream inStream = HandlessTest.class.getResourceAsStream(IN_FILE);  </span></span><br><span class="line">    <span class="comment">//         FileOutputStream outStream = new FileOutputStream(OUT_FILE)) &#123;  </span></span><br><span class="line">    <span class="comment">//        BufferedImage inputImage = ImageIO.read(inStream);  </span></span><br><span class="line">    <span class="comment">//        result = ImageIO.write(inputImage, FORMAT, outStream);  </span></span><br><span class="line">    <span class="comment">//   &#125;  </span></span><br><span class="line">    <span class="comment">//    Assert.assertTrue(result);  </span></span><br><span class="line">    <span class="comment">//&#125;  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//    @Test  </span></span><br><span class="line"><span class="comment">//    public void whenHeadlessMode_thenImagesWork() &#123;  </span></span><br><span class="line"><span class="comment">//        boolean result = false;  </span></span><br><span class="line"><span class="comment">//        try (InputStream inStream = HeadlessModeUnitTest.class.getResourceAsStream(IN_FILE);  </span></span><br><span class="line"><span class="comment">//             FileOutputStream outStream = new FileOutputStream(OUT_FILE)) &#123;  </span></span><br><span class="line"><span class="comment">//            BufferedImage inputImage = ImageIO.read(inStream);  </span></span><br><span class="line"><span class="comment">//            result = ImageIO.write(inputImage, FORMAT, outStream);  </span></span><br><span class="line"><span class="comment">//        &#125;  </span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">//        assertThat(result).isTrue();  </span></span><br><span class="line"><span class="comment">//    &#125;  </span></span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Test</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenHeadless_thenFontsWork</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();  </span><br><span class="line">        String fonts[] = ge.getAvailableFontFamilyNames();  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//        assertThat(fonts).isNotEmpty();  </span></span><br><span class="line">  </span><br><span class="line">        Font font = <span class="keyword">new</span> Font(fonts[<span class="number">0</span>], Font.BOLD, <span class="number">14</span>);  </span><br><span class="line">        FontMetrics fm = (<span class="keyword">new</span> Canvas()).getFontMetrics(font);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//        assertThat(fm.getHeight()).isGreaterThan(0);  </span></span><br><span class="line"><span class="comment">//        assertThat(fm.getAscent()).isGreaterThan(0);  </span></span><br><span class="line"><span class="comment">//        assertThat(fm.getDescent()).isGreaterThan(0);  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Test</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenHeadlessmode_thenFrameThrowsHeadlessException</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        Frame frame = <span class="keyword">new</span> Frame();  </span><br><span class="line">        frame.setVisible(<span class="keyword">true</span>);  </span><br><span class="line">        frame.setSize(<span class="number">120</span>, <span class="number">120</span>);  </span><br><span class="line">    &#125;<span class="comment">/*  </span></span><br><span class="line"><span class="comment">    在开关Headless模式后会有不同的结果  </span></span><br><span class="line"><span class="comment">    开启：通过  </span></span><br><span class="line"><span class="comment">    关闭  </span></span><br><span class="line"><span class="comment">    ava.awt.HeadlessException   at java.awt.GraphicsEnvironment.checkHeadless(GraphicsEnvironment.java:204)   at java.awt.Window.&lt;init&gt;(Window.java:536)   at java.awt.Frame.&lt;init&gt;(Frame.java:420)   at java.awt.Frame.&lt;init&gt;(Frame.java:385)  </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Test</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FlexibleApp</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (GraphicsEnvironment.isHeadless()) &#123;  </span><br><span class="line">            System.out.println(<span class="string">"Hello World"</span>);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            JOptionPane.showMessageDialog(<span class="keyword">null</span>, <span class="string">"showMessageDialog Hello World"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC83MjQ4YjNmZjVjYTc=" title="https://www.jianshu.com/p/7248b3ff5ca7">https://www.jianshu.com/p/7248b3ff5ca7<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFlbGR1bmcuY29tL2phdmEtaGVhZGxlc3MtbW9kZQ==" title="https://www.baeldung.com/java-headless-mode">https://www.baeldung.com/java-headless-mode<i class="fa fa-external-link"></i></span>](<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFlbGR1bmcuY29tL2phdmEtaGVhZGxlc3MtbW9kZV0oaHR0cHM6Ly93d3cuYmFlbGR1bmcuY29tL2phdmEtaGVhZGxlc3MtbW9kZSk=" title="https://www.baeldung.com/java-headless-mode](https://www.baeldung.com/java-headless-mode)">https://www.baeldung.com/java-headless-mode](https://www.baeldung.com/java-headless-mode)<i class="fa fa-external-link"></i></span>)</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      Java被忽略的参数
    
    </summary>
    
    
      <category term="Java" scheme="https://whitestore.top/categories/Java/"/>
    
    
      <category term="Java" scheme="https://whitestore.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>What is /dev/null and How to Use It</title>
    <link href="https://whitestore.top/2023/02/27/devnull/"/>
    <id>https://whitestore.top/2023/02/27/devnull/</id>
    <published>2023-02-26T23:35:24.000Z</published>
    <updated>2023-03-02T01:34:33.621Z</updated>
    
    <content type="html"><![CDATA[<h1 id="What-is-dev-null-and-How-to-Use-It"><a href="#What-is-dev-null-and-How-to-Use-It" class="headerlink" title="What is /dev/null and How to Use It"></a>What is /dev/null and How to Use It</h1><p><span class="exturl" data-url="aHR0cHM6Ly9saW51eGhpbnQuY29tL3doYXRfaXNfZGV2X251bGwv" title="https://linuxhint.com/what_is_dev_null/">What is /dev/null and How to Use It (linuxhint.com)<i class="fa fa-external-link"></i></span></p><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><p>了解/dev/null需要先了解stdin、stdout等Linux输入输出流的概念：</p><p><span class="exturl" data-url="aHR0cHM6Ly9saW51eGhpbnQuY29tL2Jhc2hfc3RkaW5fc3RkZXJyX3N0ZG91dC8=" title="https://linuxhint.com/bash_stdin_stderr_stdout/">How to Use the Stdin, Stderr, and Stdout Streams in Bash (linuxhint.com)<i class="fa fa-external-link"></i></span></p><p>这里简单概括一下，默认情况下我们执行一个shell程序都会获得两种输出流，<strong>标准输出</strong>和 <strong>（标准）错误输出</strong>，分别叫做 <strong>stdout</strong> 以及 <strong>stderr</strong> 。</p><p>例如以下命令将打印出双引号内的字符串。在这里输出结果存储在标准输出中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xander@xander:~$ <span class="built_in">echo</span> <span class="string">"hello world"</span></span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>下一个命令将向我们显示先前运行的命令的退出状态。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xander@xander:~$ <span class="built_in">echo</span> $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>如果上一条指令存在错误输出，则结果是一个非0的值（不一定是127）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xander@xander:~$ <span class="built_in">echo</span> $?</span><br><span class="line">127</span><br></pre></td></tr></table></figure><p>如果是正确内容，命令的返回结果会是0：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">xander@xander:~$ lll</span><br><span class="line">Command <span class="string">'lll'</span> not found, did you mean:</span><br><span class="line">  <span class="built_in">command</span> <span class="string">'lld'</span> from deb lld (1:14.0-55~exp2)</span><br><span class="line">  <span class="built_in">command</span> <span class="string">'dll'</span> from deb brickos (0.9.0.dfsg-12.2)</span><br><span class="line">  <span class="built_in">command</span> <span class="string">'lli'</span> from deb llvm-runtime (1:14.0-55~exp2)</span><br><span class="line">  <span class="built_in">command</span> <span class="string">'llt'</span> from deb storebackup (3.2.1-2)</span><br><span class="line">  <span class="built_in">command</span> <span class="string">'llc'</span> from deb llvm (1:14.0-55~exp2)</span><br><span class="line">Try: sudo apt install &lt;deb name&gt;</span><br><span class="line">xander@xander:~$ <span class="built_in">echo</span> $?</span><br><span class="line">127</span><br><span class="line">xander@xander:~$ <span class="built_in">echo</span> <span class="string">"hello world"</span></span><br><span class="line"></span><br><span class="line">xander@xander:~$ <span class="built_in">echo</span> $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h1><p>在Linux当中存在文件描述符，所有 sdtout（=1） 和 stderr（=2） 都对应了特殊的文件描述符，前面的实验中我们没有指定文档描述符。如果未指定描述符，bash 将<strong>默认使用 stdout</strong>。也就是常说的标准输出。</p><p><strong>标准输出</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> “Hello World” &gt; log.txt</span><br></pre></td></tr></table></figure><p>输出结果如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xander@xander:~$ <span class="built_in">echo</span> “Hello World” &gt; log.txt</span><br><span class="line">xander@xander:~$ cat log.txt </span><br><span class="line">“Hello World”</span><br></pre></td></tr></table></figure><p><strong>错误输出</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asdasdasds 2&gt; error.txt</span><br></pre></td></tr></table></figure><p>输出结果如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xander@xander:~$ asdasdasds 2&gt; error.txt</span><br><span class="line">xander@xander:~$ cat error.txt </span><br><span class="line">asdasdasds: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure><h1 id="重定向输出流到-dev-null"><a href="#重定向输出流到-dev-null" class="headerlink" title="重定向输出流到/dev/null"></a>重定向输出流到/dev/null</h1><p>现在我们准备学习如何使用 <code>/dev/null</code>。首先让我们看看如何过滤正常输出和错误。在以下命令中，grep 将尝试在“/sys”目录中搜索字符串（在本例中为 hello）。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230225072922.png" alt=""></p><p><code>/sys/</code>通常只有具备root权限的角色才能访问，使用一般用户会出现无权限访问的页面，现在可以通过重定向输出流到 <code>/dev/null</code>，会发现所有<code>grep</code>错误流信息全部被丢弃。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xander@xander:~$ grep -r hello /sys/ 2&gt; /dev/null</span><br><span class="line">xander@xander:~$</span><br></pre></td></tr></table></figure><h2 id="ping-google-com"><a href="#ping-google-com" class="headerlink" title="ping google.com"></a>ping google.com</h2><p>有时候我们只想看错误的输出结果，可以把标准输出丢弃到<code>/dev/null</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping google.com 1&gt; /dev/null</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xander@xander:~$ ping google.com</span><br><span class="line">PING google.com (142.251.42.238) 56(84) bytes of data.</span><br><span class="line">--- google.com ping statistics ---</span><br><span class="line">210 packets transmitted, 0 received, 100% packet loss, time 214004ms</span><br></pre></td></tr></table></figure><h1 id="重定向所有流到-dev-null"><a href="#重定向所有流到-dev-null" class="headerlink" title="重定向所有流到/dev/null"></a>重定向所有流到/dev/null</h1><p>在某些情况下，输出可能根本没有用，使用重定向，我们可以将所有输出转储到空白中。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -r hello /sys/ &gt; /dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>上面命令所做的事情大致如下：</p><ul><li>标准输出丢弃到<code>/dev/null</code></li><li>标准错误输出重定向到标准输出</li><li>最终标准输出和错误输出一起被丢弃到<code>/dev/null</code></li></ul><p>当然如果觉得这种<code>2&gt;&amp;1</code>写法抽象和难以理解，也可以用下面的命令代替，这也是更为<strong>通用</strong>的写法：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -r hello /sys/ &amp;&gt; /dev/null</span><br></pre></td></tr></table></figure><p>执行这一串命令之后我们难免会有疑问，输出都丢弃了，<strong>如何判断命令是否执行成功？</strong> 这里就要使用之前介绍的一个技巧，那就是<code>ehco $?</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $?</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>在执行命令之后执行<code>ehco $?</code>，如果结果是0表示命令执行是正确的，如果类似值为 2则是该命令生成了错误结果。我们总是可以通过<code>$?</code> 验证命令是否执行正确。</p><h1 id="其他案例"><a href="#其他案例" class="headerlink" title="其他案例"></a>其他案例</h1><h2 id="dd和-dev-null"><a href="#dd和-dev-null" class="headerlink" title="dd和/dev/null"></a>dd和/dev/null</h2><p>使用 dd，我们可以测试磁盘的顺序读取速度。当然这不是一个非常准确的测量方式，但是对于快速测试它非常有用。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=&lt;big_file&gt; of=/dev/null status=progress bs=1M iflag=direct</span><br></pre></td></tr></table></figure><blockquote><p><big_file> 替换为某个比较大的文件的绝对路径</p></blockquote><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230225075430.png" alt=""></p><h2 id="测试下载速度"><a href="#测试下载速度" class="headerlink" title="测试下载速度"></a>测试下载速度</h2><p>相对应的也可以用来测试下载速度。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O /dev/null &lt;big_file_link&gt;</span><br></pre></td></tr></table></figure><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230225213519.png" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总是<code>/dev/null</code>是一个非常有用的空间，在很多开源组件的启动脚本中很容易见到这些命令的使用场景。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      Linux知识点
    
    </summary>
    
    
      <category term="Linux" scheme="https://whitestore.top/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://whitestore.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【RocketMq】NameServ启动脚本分析（Ver4.9.4）</title>
    <link href="https://whitestore.top/2023/02/20/rocketjiaoben/"/>
    <id>https://whitestore.top/2023/02/20/rocketjiaoben/</id>
    <published>2023-02-19T23:07:06.000Z</published>
    <updated>2023-03-02T01:34:33.623Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NameServ启动脚本分析"><a href="#NameServ启动脚本分析" class="headerlink" title="NameServ启动脚本分析"></a>NameServ启动脚本分析</h1><h2 id="mqnamesrv-启动命令"><a href="#mqnamesrv-启动命令" class="headerlink" title="mqnamesrv 启动命令"></a>mqnamesrv 启动命令</h2><p>这里直接摘录了官方文档：</p><p><strong>Start NameServer</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## Start Name Server first</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nohup sh mqnamesrv &amp;</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## Then verify that the Name Server starts successfully</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tail -f ~/logs/rocketmqlogs/namesrv.log</span></span><br><span class="line">The Name Server boot success...</span><br></pre></td></tr></table></figure><h2 id="mqnamesrv-脚本"><a href="#mqnamesrv-脚本" class="headerlink" title="mqnamesrv 脚本"></a>mqnamesrv 脚本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># 从环境变量当中获取RocketMq环境变量地址</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$ROCKETMQ_HOME</span>"</span> ] ; <span class="keyword">then</span></span><br><span class="line">  <span class="comment">## resolve links - $0 may be a link to maven's home</span></span><br><span class="line">  <span class="comment">## 解决链接问题 - $0 可能是maven的主页链接</span></span><br><span class="line">  <span class="comment"># PS：$0 是脚本的命令本身</span></span><br><span class="line">  PRG=<span class="string">"<span class="variable">$0</span>"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># need this for relative symlinks</span></span><br><span class="line">  <span class="comment"># 需要相关链接</span></span><br><span class="line">  <span class="keyword">while</span> [ -h <span class="string">"<span class="variable">$PRG</span>"</span> ] ; <span class="keyword">do</span></span><br><span class="line">    ls=`ls -ld <span class="string">"<span class="variable">$PRG</span>"</span>`</span><br><span class="line">    link=`expr <span class="string">"<span class="variable">$ls</span>"</span> : <span class="string">'.*-&gt; \(.*\)$'</span>`</span><br><span class="line">    <span class="keyword">if</span> expr <span class="string">"<span class="variable">$link</span>"</span> : <span class="string">'/.*'</span> &gt; /dev/null; <span class="keyword">then</span></span><br><span class="line">      PRG=<span class="string">"<span class="variable">$link</span>"</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      PRG=<span class="string">"`dirname "</span><span class="variable">$PRG</span><span class="string">"`/<span class="variable">$link</span>"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">  <span class="comment"># 暂存当前的执行路径</span></span><br><span class="line">  saveddir=`<span class="built_in">pwd</span>`</span><br><span class="line"></span><br><span class="line">  ROCKETMQ_HOME=`dirname <span class="string">"<span class="variable">$PRG</span>"</span>`/..</span><br><span class="line"></span><br><span class="line">  <span class="comment"># make it fully qualified</span></span><br><span class="line">  <span class="comment"># 拼接获取RocketMQ绝对路径</span></span><br><span class="line">  ROCKETMQ_HOME=`<span class="built_in">cd</span> <span class="string">"<span class="variable">$ROCKETMQ_HOME</span>"</span> &amp;&amp; <span class="built_in">pwd</span>`</span><br><span class="line">  <span class="comment"># 跳转到当前暂存的命令执行路径</span></span><br><span class="line">  <span class="built_in">cd</span> <span class="string">"<span class="variable">$saveddir</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> ROCKETMQ_HOME</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关键： 执行runserver.sh脚本，携带logback的日志xml配置，以及传递JVM的启动main方法的入口类绝对路径</span></span><br><span class="line">sh <span class="variable">$&#123;ROCKETMQ_HOME&#125;</span>/bin/runserver.sh </span><br><span class="line">-Drmq.logback.configurationFile=<span class="variable">$ROCKETMQ_HOME</span>/conf/rmq.namesrv.logback.xml </span><br><span class="line">org.apache.rocketmq.namesrv.NamesrvStartup <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p>最开始的<code>mqnamesrv.sh</code>脚本获取环境变量的部分看不懂其实没啥影响，大略有个印象即可，当然可以截取部分的命令到Linux运行测试一下就明白了，比如准备环境变量等等，最后一句话比较关键。</p><p>注意最后的两个字符<code>$@</code>，这两个字符的作用如下：</p><p><strong>$@</strong> ：表示所有脚本参数的内容。</p><p><strong>$#</strong> ：表示返回所有脚本参数的个数。</p><p>再次强调前面的一大坨获取环境变量看不懂没关系，看懂核心的执行脚本即可。</p><h1 id="runserver-sh-脚本"><a href="#runserver-sh-脚本" class="headerlink" title="runserver.sh 脚本"></a>runserver.sh 脚本</h1><p>runserver.sh 的脚本内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#===========================================================================================</span></span><br><span class="line"><span class="comment"># Java Environment Setting</span></span><br><span class="line"><span class="comment">#===========================================================================================</span></span><br><span class="line">error_exit ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"ERROR: <span class="variable">$1</span> !!"</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">find_java_home()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"># uname 是获取Linux内核参数的指令，不带任何参数获取当前操作系统的类型，比如Linux就是“Linux”的文本</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"`uname`"</span> <span class="keyword">in</span></span><br><span class="line">        Darwin)</span><br><span class="line">            JAVA_HOME=$(/usr/libexec/java_home)</span><br><span class="line">        ;;</span><br><span class="line">        *)</span><br><span class="line">        <span class="comment"># 可以简单认为获取到javac命令的绝对路径，然后执行两次cd..操作，以此作为JDK的路径</span></span><br><span class="line">        <span class="comment"># 比如 /opt/jdk/bin/javac dirname 两次之后就是 /opt/jdk</span></span><br><span class="line">            JAVA_HOME=$(dirname $(dirname $(readlink -f $(<span class="built_in">which</span> javac))))</span><br><span class="line">        ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">find_java_home</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取JAVA命令的执行地址</span></span><br><span class="line">[ ! -e <span class="string">"<span class="variable">$JAVA_HOME</span>/bin/java"</span> ] &amp;&amp; JAVA_HOME=<span class="variable">$HOME</span>/jdk/java</span><br><span class="line">[ ! -e <span class="string">"<span class="variable">$JAVA_HOME</span>/bin/java"</span> ] &amp;&amp; JAVA_HOME=/usr/java</span><br><span class="line">[ ! -e <span class="string">"<span class="variable">$JAVA_HOME</span>/bin/java"</span> ] &amp;&amp; error_exit <span class="string">"Please set the JAVA_HOME variable in your environment, We need java(x64)!"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># export 导出的临时环境变量，只适用当前SHELL连接</span></span><br><span class="line"><span class="comment"># JAVA 命令的执行地址,设置为环境变量</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME</span><br><span class="line"><span class="built_in">export</span> JAVA=<span class="string">"<span class="variable">$JAVA_HOME</span>/bin/java"</span></span><br><span class="line"><span class="comment"># $0 代表当前的请求传递的第一个参数，根据上一个脚本可以知道是：$&#123;ROCKETMQ_HOME&#125;/bin/runserver.sh</span></span><br><span class="line"><span class="built_in">export</span> BASE_DIR=$(dirname <span class="variable">$0</span>)/..</span><br><span class="line"><span class="comment"># 因为需要启动JVM进程，需要从ROCKETMQ_HOME的conf和lib路径告诉JDK找依赖包以及相关的配置文件</span></span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$&#123;BASE_DIR&#125;</span>/conf:<span class="variable">$&#123;BASE_DIR&#125;</span>/lib/*:<span class="variable">$&#123;CLASSPATH&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#===========================================================================================</span></span><br><span class="line"><span class="comment"># JVM Configuration</span></span><br><span class="line"><span class="comment">#===========================================================================================</span></span><br><span class="line"><span class="comment"># The RAMDisk initializing size in MB on Darwin OS for gc-log</span></span><br><span class="line"><span class="comment"># 在 Darwin OS 上为 gc-log 初始化 RAMDisk 的大小（以 MB 为单位）</span></span><br><span class="line">DIR_SIZE_IN_MB=600</span><br><span class="line"></span><br><span class="line">choose_gc_log_directory()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"># Darwin 操作系统需要特殊处理，忽略</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"`uname`"</span> <span class="keyword">in</span></span><br><span class="line">        Darwin)</span><br><span class="line">            <span class="keyword">if</span> [ ! -d <span class="string">"/Volumes/RAMDisk"</span> ]; <span class="keyword">then</span></span><br><span class="line">                <span class="comment"># create ram disk on Darwin systems as gc-log directory</span></span><br><span class="line">                DEV=`hdiutil attach -nomount ram://$((2 * 1024 * DIR_SIZE_IN_MB))` &gt; /dev/null</span><br><span class="line">                diskutil eraseVolume HFS+ RAMDisk <span class="variable">$&#123;DEV&#125;</span> &gt; /dev/null</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"Create RAMDisk /Volumes/RAMDisk for gc logging on Darwin OS."</span></span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">            GC_LOG_DIR=<span class="string">"/Volumes/RAMDisk"</span></span><br><span class="line">        ;;</span><br><span class="line">        *)</span><br><span class="line">         <span class="comment"># </span></span><br><span class="line">            <span class="comment"># check if /dev/shm exists on other systems</span></span><br><span class="line">            <span class="comment"># 检查 /dev/shm 是否存在于其他系统上</span></span><br><span class="line">            <span class="comment"># What Is /dev/shm And Its Practical Usage</span></span><br><span class="line">            <span class="comment"># https://www.cyberciti.biz/tips/what-is-devshm-and-its-practical-usage.html</span></span><br><span class="line">            <span class="keyword">if</span> [ -d <span class="string">"/dev/shm"</span> ]; <span class="keyword">then</span></span><br><span class="line">                GC_LOG_DIR=<span class="string">"/dev/shm"</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                GC_LOG_DIR=<span class="variable">$&#123;BASE_DIR&#125;</span></span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">        ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">choose_gc_options()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"># 根据JDK的版本选择合适的GC参数，RocketMq最低需要JDK8，所以如果是1开头就是10以及之后的JDK版本</span></span><br><span class="line">    <span class="comment"># Example of JAVA_MAJOR_VERSION value: '1', '9', '10', '11', ...</span></span><br><span class="line">    <span class="comment"># '1' means releases befor Java 9</span></span><br><span class="line">    JAVA_MAJOR_VERSION=$(<span class="string">"<span class="variable">$JAVA</span>"</span> -version 2&gt;&amp;1 | sed -r -n <span class="string">'s/.* version "([0-9]*).*$/\1/p'</span>)</span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$JAVA_MAJOR_VERSION</span>"</span> ] || [ <span class="string">"<span class="variable">$JAVA_MAJOR_VERSION</span>"</span> -lt <span class="string">"9"</span> ] ; <span class="keyword">then</span></span><br><span class="line">      <span class="comment"># 小于JDK 9 版本的参数</span></span><br><span class="line">      <span class="comment"># 堆内存（初始堆内存）为 4 g，新生代 2g，其他空间为 2g。元空间初始化128m，最大的扩容元空间为320mb</span></span><br><span class="line">      JAVA_OPT=<span class="string">"<span class="variable">$&#123;JAVA_OPT&#125;</span> -server -Xms4g -Xmx4g -Xmn2g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m"</span></span><br><span class="line">      <span class="comment"># g1收集器在jdk11得到并行Full GC能力，而zgc在jdk11版本处于实验状态，这里选择了比较稳妥的 CMS 老年代垃圾回收器</span></span><br><span class="line">      <span class="comment"># UseCMSCompactAtFullCollection：CMS垃圾在进行了Full GC时，对老年代进行压缩整理，处理掉内存碎片</span></span><br><span class="line">      <span class="comment"># CMSParallelRemarkEnabled 使用CMS老年代收集器</span></span><br><span class="line">      JAVA_OPT=<span class="string">"<span class="variable">$&#123;JAVA_OPT&#125;</span> -XX:+UseConcMarkSweepGC -XX:+UseCMSCompactAtFullCollection -XX:CMSInitiatingOccupancyFraction=70 -XX:+CMSParallelRemarkEnabled -XX:SoftRefLRUPolicyMSPerMB=0 -XX:+CMSClassUnloadingEnabled -XX:SurvivorRatio=8 -XX:-UseParNewGC"</span></span><br><span class="line">      JAVA_OPT=<span class="string">"<span class="variable">$&#123;JAVA_OPT&#125;</span> -verbose:gc -Xloggc:<span class="variable">$&#123;GC_LOG_DIR&#125;</span>/rmq_srv_gc_%p_%t.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps"</span></span><br><span class="line">      JAVA_OPT=<span class="string">"<span class="variable">$&#123;JAVA_OPT&#125;</span> -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=30m"</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">  <span class="comment"># JDK8 之后的参数</span></span><br><span class="line">      JAVA_OPT=<span class="string">"<span class="variable">$&#123;JAVA_OPT&#125;</span> -server -Xms4g -Xmx4g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m"</span></span><br><span class="line">      JAVA_OPT=<span class="string">"<span class="variable">$&#123;JAVA_OPT&#125;</span> -XX:+UseG1GC -XX:G1HeapRegionSize=16m -XX:G1ReservePercent=25 -XX:InitiatingHeapOccupancyPercent=30 -XX:SoftRefLRUPolicyMSPerMB=0"</span></span><br><span class="line">      JAVA_OPT=<span class="string">"<span class="variable">$&#123;JAVA_OPT&#125;</span> -Xlog:gc*:file=<span class="variable">$&#123;GC_LOG_DIR&#125;</span>/rmq_srv_gc_%p_%t.log:time,tags:filecount=5,filesize=30M"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">choose_gc_log_directory</span><br><span class="line">choose_gc_options</span><br><span class="line">JAVA_OPT=<span class="string">"<span class="variable">$&#123;JAVA_OPT&#125;</span> -XX:-OmitStackTraceInFastThrow"</span></span><br><span class="line">JAVA_OPT=<span class="string">"<span class="variable">$&#123;JAVA_OPT&#125;</span> -XX:-UseLargePages"</span></span><br><span class="line"><span class="comment">#JAVA_OPT="$&#123;JAVA_OPT&#125; -Xdebug -Xrunjdwp:transport=dt_socket,address=9555,server=y,suspend=n"</span></span><br><span class="line">JAVA_OPT=<span class="string">"<span class="variable">$&#123;JAVA_OPT&#125;</span> <span class="variable">$&#123;JAVA_OPT_EXT&#125;</span>"</span></span><br><span class="line">JAVA_OPT=<span class="string">"<span class="variable">$&#123;JAVA_OPT&#125;</span> -cp <span class="variable">$&#123;CLASSPATH&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$JAVA</span> <span class="variable">$&#123;JAVA_OPT&#125;</span> <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p><code>runserver.sh</code> 脚本的内容，内容比较多，这里拆分讲解。</p><h2 id="前置准备工作"><a href="#前置准备工作" class="headerlink" title="前置准备工作"></a>前置准备工作</h2><p>首先是有关环境变量的配置获取以及查找<strong>JAVA_HOME</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#===========================================================================================</span></span><br><span class="line"><span class="comment"># Java Environment Setting</span></span><br><span class="line"><span class="comment">#===========================================================================================</span></span><br><span class="line">error_exit ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"ERROR: <span class="variable">$1</span> !!"</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">find_java_home()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"># uname 是获取Linux内核参数的指令，不带任何参数获取当前操作系统的类型，比如Linux就是“Linux”的文本</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"`uname`"</span> <span class="keyword">in</span></span><br><span class="line">        Darwin)</span><br><span class="line">            JAVA_HOME=$(/usr/libexec/java_home)</span><br><span class="line">        ;;</span><br><span class="line">        *)</span><br><span class="line">        <span class="comment"># 可以简单认为获取到javac命令的绝对路径，然后执行两次cd..操作，以此作为JDK的路径</span></span><br><span class="line">        <span class="comment"># 比如 /opt/jdk/bin/javac dirname 两次之后就是 /opt/jdk</span></span><br><span class="line">            JAVA_HOME=$(dirname $(dirname $(readlink -f $(<span class="built_in">which</span> javac))))</span><br><span class="line">        ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">find_java_home</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取JAVA命令的执行地址</span></span><br><span class="line">[ ! -e <span class="string">"<span class="variable">$JAVA_HOME</span>/bin/java"</span> ] &amp;&amp; JAVA_HOME=<span class="variable">$HOME</span>/jdk/java</span><br><span class="line">[ ! -e <span class="string">"<span class="variable">$JAVA_HOME</span>/bin/java"</span> ] &amp;&amp; JAVA_HOME=/usr/java</span><br><span class="line">[ ! -e <span class="string">"<span class="variable">$JAVA_HOME</span>/bin/java"</span> ] &amp;&amp; error_exit <span class="string">"Please set the JAVA_HOME variable in your environment, We need java(x64)!"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># export 导出的临时环境变量，只适用当前SHELL连接</span></span><br><span class="line"><span class="comment"># JAVA 命令的执行地址,设置为环境变量</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME</span><br><span class="line"><span class="built_in">export</span> JAVA=<span class="string">"<span class="variable">$JAVA_HOME</span>/bin/java"</span></span><br><span class="line"><span class="comment"># $0 代表当前的请求传递的第一个参数，根据上一个脚本可以知道是：$&#123;ROCKETMQ_HOME&#125;/bin/runserver.sh</span></span><br><span class="line"><span class="built_in">export</span> BASE_DIR=$(dirname <span class="variable">$0</span>)/..</span><br><span class="line"><span class="comment"># 因为需要启动JVM进程，需要从ROCKETMQ_HOME的conf和lib路径告诉JDK找依赖包以及相关的配置文件</span></span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$&#123;BASE_DIR&#125;</span>/conf:<span class="variable">$&#123;BASE_DIR&#125;</span>/lib/*:<span class="variable">$&#123;CLASSPATH&#125;</span></span><br></pre></td></tr></table></figure><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>首先是开头部分，如果出现异常就打印错误参数。在SH脚本文件中，<code>$1</code>代表了跟在脚本后面的第一个参数，比如<code>./script.sh filename1 dir1</code>，则<code>$1 = filename1</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">error_exit ()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// $1 通常是调用函数传入的第一个参数，比如下文的：Please set the JAVA_HOME variable in your environment, We need java(x64)!</span></span><br><span class="line">    echo <span class="string">"ERROR: $1 !!"</span></span><br><span class="line">    exit <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找JDK-Home"><a href="#查找JDK-Home" class="headerlink" title="查找JDK Home"></a>查找JDK Home</h3><p>接着是查找 JAVA_HOME 的位置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">find_java_home()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"># uname 是获取Linux内核参数的指令，不带任何参数获取当前操作系统的类型，比如Linux就是“Linux”的文本</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"`uname`"</span> <span class="keyword">in</span></span><br><span class="line">        Darwin)</span><br><span class="line">            JAVA_HOME=$(/usr/libexec/java_home)</span><br><span class="line">        ;;</span><br><span class="line">        *)</span><br><span class="line">        <span class="comment"># 可以简单认为获取到javac命令的绝对路径，然后执行两次 cd.. 操作，以此作为JDK的路径</span></span><br><span class="line">        <span class="comment"># 比如 /opt/jdk/bin/javac dirname 两次之后就是 /opt/jdk</span></span><br><span class="line">            JAVA_HOME=$(dirname $(dirname $(readlink -f $(<span class="built_in">which</span> javac))))</span><br><span class="line">        ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>uname</strong> 是获取Linux内核参数的指令，不带任何参数获取当前操作系统的类型，比如Linux就是“Linux”的文本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xander@xander:~$ uname </span><br><span class="line">Linux</span><br></pre></td></tr></table></figure><p>这里通过uname 查找内核，如果是 darwin 的操作系统获取路径要特殊一些。而其他的方式则是<code>$(dirname $(dirname $(readlink -f $(which javac))))</code>层层查找：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zxd<span class="meta">@localhost</span> ~]$ echo $(dirname $(dirname $(readlink -f $(which javac))));</span><br><span class="line">/opt/jdk8</span><br></pre></td></tr></table></figure><p>这些可以简单认为获取到<code>javac</code>命令的绝对路径，然后执行两次<code>cd..</code>操作，以此作为JDK的路径。最简单的验证方法是放到Linux上执行一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zxd<span class="meta">@localhost</span> ~]$ echo $(readlink -f $(which javac))</span><br><span class="line">/opt/jdk8/bin/javac</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zxd<span class="meta">@localhost</span> ~]$ echo $(dirname $(dirname $(readlink -f $(which javac))));</span><br><span class="line">/opt/jdk8</span><br></pre></td></tr></table></figure><h3 id="取JAVA命令的执行地址"><a href="#取JAVA命令的执行地址" class="headerlink" title="取JAVA命令的执行地址"></a>取JAVA命令的执行地址</h3><p>这里比较简单，最后一句调用了error_exit函数，对应了第一个参数就是要打印的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 读取JAVA命令的执行地址</span><br><span class="line">[ ! -e <span class="string">"$JAVA_HOME/bin/java"</span> ] &amp;&amp; JAVA_HOME=$HOME/jdk/java</span><br><span class="line">[ ! -e <span class="string">"$JAVA_HOME/bin/java"</span> ] &amp;&amp; JAVA_HOME=/usr/java</span><br><span class="line">[ ! -e <span class="string">"$JAVA_HOME/bin/java"</span> ] &amp;&amp; error_exit <span class="string">"Please set the JAVA_HOME variable in your environment, We need java(x64)!"</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># export 导出的临时环境变量，只适用当前SHELL连接</span></span><br><span class="line"><span class="comment"># 取JAVA 命令的执行地址,设置为环境变量</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME</span><br><span class="line"><span class="built_in">export</span> JAVA=<span class="string">"<span class="variable">$JAVA_HOME</span>/bin/java"</span></span><br><span class="line"><span class="comment"># $0 通常代表脚本名称本身，这里获取出来的结果是：$&#123;ROCKETMQ_HOME&#125;</span></span><br><span class="line"><span class="built_in">export</span> BASE_DIR=$(dirname <span class="variable">$0</span>)/..</span><br><span class="line"><span class="comment"># 因为需要启动JVM进程，需要把ROCKETMQ_HOME的conf和lib路径告诉JDK找依赖包以及相关的配置文件</span></span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$&#123;BASE_DIR&#125;</span>/conf:<span class="variable">$&#123;BASE_DIR&#125;</span>/lib/*:<span class="variable">$&#123;CLASSPATH&#125;</span></span><br></pre></td></tr></table></figure><p>上面需要注意的点：</p><ol><li>export 导出的临时环境变量，只适用当前SHELL连接。</li><li><code>$0</code> 代表当前j脚本名称本身，<code>../</code>和<code>dirname</code> 结合类似<code>../../</code>效果，<code>$(dirname $0)/..</code>为Rocketmq的安装目录地址。</li><li>需要把<code>ROCKETMQ_HOME</code>的<code>conf</code>和<code>lib</code>路径告诉JDK找依赖包以及相关的配置文件。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JAVA=<span class="string">"$JAVA_HOME/bin/java"</span></span><br><span class="line">BASE_DIR=$&#123;ROCKETMQ_HOME&#125;/bin</span><br><span class="line">CLASSPATH=.:$&#123;ROCKETMQ_HOME&#125;/bin/conf:$&#123;BASE_DIR&#125;/lib<span class="comment">/*:$&#123;CLASSPATH&#125;</span></span><br></pre></td></tr></table></figure><h2 id="JVM-配置部分"><a href="#JVM-配置部分" class="headerlink" title="JVM 配置部分"></a>JVM 配置部分</h2><p>之后往下的部分是JVM的配置部分，这部分我们拆分成两个部分来讲，最关键的是JVM参数配置部分，最开始是获取JVM 的GC_LOG地址，这里用<code>uname</code>识别操作系统，</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 Darwin OS 上为 gc-log 初始化 RAMDisk 的大小（以 MB 为单位）</span></span><br><span class="line">DIR_SIZE_IN_MB=600</span><br><span class="line"></span><br><span class="line">choose_gc_log_directory()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"># Darwin 操作系统需要特殊处理，忽略</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"`uname`"</span> <span class="keyword">in</span></span><br><span class="line">        Darwin)</span><br><span class="line">            <span class="keyword">if</span> [ ! -d <span class="string">"/Volumes/RAMDisk"</span> ]; <span class="keyword">then</span></span><br><span class="line">                <span class="comment"># create ram disk on Darwin systems as gc-log directory</span></span><br><span class="line">                DEV=`hdiutil attach -nomount ram://$((2 * 1024 * DIR_SIZE_IN_MB))` &gt; /dev/null</span><br><span class="line">                diskutil eraseVolume HFS+ RAMDisk <span class="variable">$&#123;DEV&#125;</span> &gt; /dev/null</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"Create RAMDisk /Volumes/RAMDisk for gc logging on Darwin OS."</span></span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">            GC_LOG_DIR=<span class="string">"/Volumes/RAMDisk"</span></span><br><span class="line">        ;;</span><br><span class="line">        *)</span><br><span class="line">         <span class="comment"># </span></span><br><span class="line">            <span class="comment"># check if /dev/shm exists on other systems</span></span><br><span class="line">            <span class="comment"># 检查 /dev/shm 是否存在于其他系统上</span></span><br><span class="line">            <span class="comment"># What Is /dev/shm And Its Practical Usage</span></span><br><span class="line">            <span class="comment"># https://www.cyberciti.biz/tips/what-is-devshm-and-its-practical-usage.html</span></span><br><span class="line">            <span class="keyword">if</span> [ -d <span class="string">"/dev/shm"</span> ]; <span class="keyword">then</span></span><br><span class="line">                GC_LOG_DIR=<span class="string">"/dev/shm"</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                GC_LOG_DIR=<span class="variable">$&#123;BASE_DIR&#125;</span></span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">        ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Linux系统中，会检查 <code>/dev/shm</code>是否存在系统上，如果是就把GC_LOG挂载到<code>/dev/shm</code>，否则就当前RocketMQ的安装目录<code>GC_LOG_DIR=${BASE_DIR}</code>。</p><p>这里补充一下<code>/dev/shm</code>是什么？在Linux中，这块空间起很大的作用，因为他不是硬盘而是一块内存空间，默认为VM的一半大小，使用<code>df -h</code>命令可以看到：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">xander@xander:~$ df -h</span><br><span class="line">Filesystem                         Size  Used Avail Use% Mounted on</span><br><span class="line">tmpfs                              389M  1.7M  388M   1% /run</span><br><span class="line">/dev/mapper/ubuntu--vg-ubuntu--lv   14G  7.3G  5.8G  56% /</span><br><span class="line">tmpfs                              1.9G     0  1.9G   0% /dev/shm</span><br><span class="line">tmpfs                              5.0M     0  5.0M   0% /run/lock</span><br><span class="line">/dev/sda2                          2.0G  247M  1.6G  14% /boot</span><br><span class="line">tmpfs                              389M  4.0K  389M   1% /run/user/1000</span><br></pre></td></tr></table></figure><p>RocketMq为什么要使用这一块空间？</p><p>tmpfs有以下优势：</p><ol><li><p>动态文件系统的大小。</p></li><li><p>tmpfs 文件系统会完全驻留在 RAM 中，拥有近似内存的读写速度。</p></li></ol><p>而缺点仅仅是 tmpfs 数据在重新启动之后不会保留，可以做一些脚本备份的操作。</p><h4 id="tmpfs-和-dev-shm-解释"><a href="#tmpfs-和-dev-shm-解释" class="headerlink" title="tmpfs 和 /dev/shm 解释"></a>tmpfs 和 /dev/shm 解释</h4><p>这块空间的专业名词叫做：tmpfs（虚拟内存系统），<strong>tmpfs最大的特点就是它的存储空间在VM(virtual memory)，VM是由linux内核里面的vm子系统管理的</strong>。</p><p>VM中又划分为RM (real memory) 和 swap，RM 就是VM实际可用的内存空间，而swap是用于辅助VM在RM不够的时候牺牲硬盘作为内存空间使用，同样RM还会把不常用的数据放到Swap。</p><p>tmpfps = RM (real memory) + swap。</p><p>tmpfs默认的大小是RM的一半，假如你的物理内存是1024M，那么tmpfs默认的大小就是512M。可以通过mount命令扩大这块空间大小。</p><p>tmpfps的存在意义是可以动态的扩容和缩小，并且只要不使用这块空间它本身没有任何的内存占用（0字节）（零成本还好用），而一旦使用则可以把读写停留在内存保证数据瞬间完成，但是代价是这块空间不具备记忆功能，重启之后不会被保留。</p><p>参考资料：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY3liZXJjaXRpLmJpei90aXBzL3doYXQtaXMtZGV2c2htLWFuZC1pdHMtcHJhY3RpY2FsLXVzYWdlLmh0bWw=" title="https://www.cyberciti.biz/tips/what-is-devshm-and-its-practical-usage.html">What Is /dev/shm And Its Practical Usage<i class="fa fa-external-link"></i></span></li></ul><h2 id="JVM核心参数"><a href="#JVM核心参数" class="headerlink" title="JVM核心参数"></a>JVM核心参数</h2><p>核心参数的部分就是JVM的启动参数配置，也是脚本最为核心部分。</p><h2 id="小于JDK9的启动参数"><a href="#小于JDK9的启动参数" class="headerlink" title="小于JDK9的启动参数"></a>小于JDK9的启动参数</h2><p>对应了 <strong>gc_options</strong> 的上半部分，首先判断JDK版本小于9之前的情况：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$JAVA_MAJOR_VERSION</span>"</span> ] || [ <span class="string">"<span class="variable">$JAVA_MAJOR_VERSION</span>"</span> -lt <span class="string">"9"</span> ] ; <span class="keyword">then</span></span><br><span class="line">  <span class="comment"># 堆内存（初始堆内存）为 4 g，新生代 2g，其他空间为 2g。元空间初始化128m，最大的扩容元空间为320mb</span></span><br><span class="line">  JAVA_OPT=<span class="string">"<span class="variable">$&#123;JAVA_OPT&#125;</span> -server -Xms4g -Xmx4g -Xmn2g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m"</span></span><br><span class="line">  <span class="comment"># g1收集器在jdk11得到并行Full GC能力，而zgc在jdk11版本处于实验状态，这里选择了比较稳妥的 CMS 老年代垃圾回收器</span></span><br><span class="line">  <span class="comment"># UseCMSCompactAtFullCollection：CMS垃圾在进行了Full GC时，对老年代进行压缩整理，处理掉内存碎片</span></span><br><span class="line">  <span class="comment"># CMSParallelRemarkEnabled 使用CMS老年代收集器</span></span><br><span class="line">  JAVA_OPT=<span class="string">"<span class="variable">$&#123;JAVA_OPT&#125;</span> -XX:+UseConcMarkSweepGC -XX:+UseCMSCompactAtFullCollection -XX:CMSInitiatingOccupancyFraction=70 -XX:+CMSParallelRemarkEnabled -XX:SoftRefLRUPolicyMSPerMB=0 -XX:+CMSClassUnloadingEnabled -XX:SurvivorRatio=8 -XX:-UseParNewGC"</span></span><br><span class="line">  JAVA_OPT=<span class="string">"<span class="variable">$&#123;JAVA_OPT&#125;</span> -verbose:gc -Xloggc:<span class="variable">$&#123;GC_LOG_DIR&#125;</span>/rmq_srv_gc_%p_%t.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps"</span></span><br><span class="line">  JAVA_OPT=<span class="string">"<span class="variable">$&#123;JAVA_OPT&#125;</span> -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=30m"</span></span><br></pre></td></tr></table></figure><p>首先是JVM堆大小和元空间大小分配：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPT=<span class="string">"<span class="variable">$&#123;JAVA_OPT&#125;</span> -server -Xms4g -Xmx4g -Xmn2g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m"</span></span><br></pre></td></tr></table></figure><h3 id="server"><a href="#server" class="headerlink" title="-server"></a>-server</h3><p>启用<code>-server</code>时新生代默认采用<strong>并行收集</strong>，其他情况下，默认不启用。<code>-server</code>策略为：新生代使用并行清除，老年代使用单线程<code>Mark-Sweep-Compact</code>的垃圾收集器。</p><h3 id="堆大小设置"><a href="#堆大小设置" class="headerlink" title="堆大小设置"></a>堆大小设置</h3><p>设置JVM的堆大小，堆内存（初始堆内存）为 4g，新生代 2g，其他空间为 2g，元空间初始化128M，最大的扩容元空间为320M。</p><blockquote><p>如果是个人机器配置比较低，建议把这几个值调小一些。</p></blockquote><p>下面的参数比较关键，RocketMq在JDK8没有选择G1而是使用了CMS，因为G1收集器在jdk11才得到并行Full GC能力，而ZGC在JDK11版本处于实验状态，在JDK8 用不成熟的G1不太合适。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># UseCMSCompactAtFullCollection：CMS垃圾在进行了Full GC时，对老年代进行压缩整理，处理掉内存碎片</span></span><br><span class="line"><span class="comment"># CMSParallelRemarkEnabled 使用CMS老年代收集器</span></span><br><span class="line">JAVA_OPT=<span class="string">"<span class="variable">$&#123;JAVA_OPT&#125;</span> -XX:+UseConcMarkSweepGC -XX:+UseCMSCompactAtFullCollection -XX:CMSInitiatingOccupancyFraction=70 -XX:+CMSParallelRemarkEnabled -XX:SoftRefLRUPolicyMSPerMB=0 -XX:+CMSClassUnloadingEnabled -XX:SurvivorRatio=8 -XX:-UseParNewGC"</span></span><br></pre></td></tr></table></figure><h3 id="UseCMSCompactAtFullCollection"><a href="#UseCMSCompactAtFullCollection" class="headerlink" title="UseCMSCompactAtFullCollection"></a>UseCMSCompactAtFullCollection</h3><p>CMS垃圾在进行了Full GC时，对老年代进行压缩整理，处理掉内存碎片</p><h3 id="CMSParallelRemarkEnabled"><a href="#CMSParallelRemarkEnabled" class="headerlink" title="CMSParallelRemarkEnabled"></a>CMSParallelRemarkEnabled</h3><p>老年代收集器指定为CMS，在进行了Full GC时对老年代进行压缩整理，处理掉内存碎片。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseCMSCompactAtFullCollection</span><br></pre></td></tr></table></figure><h3 id="CMS垃圾收集器"><a href="#CMS垃圾收集器" class="headerlink" title="CMS垃圾收集器"></a>CMS垃圾收集器</h3><p>这里补充一下CMS垃圾收集器的知识点：</p><p>CMS是基于<strong>标记清除</strong>算法实现的多线程老年代垃圾回收器。CMS为<strong>响应时间优先</strong>的垃圾回收器，适合于应用服务器，如网络游戏，电商等和电信领域的应用。Rocketmq本身就是诞生于电商平台使用CMS是比较稳妥的。</p><h3 id="CMS垃圾收集器特点"><a href="#CMS垃圾收集器特点" class="headerlink" title="CMS垃圾收集器特点"></a>CMS垃圾收集器特点</h3><ul><li>FUll GC大部分时间和应用程序并行，代价是增加CPU开销。</li><li>并发FULL GC短暂停顿。</li><li>用户线程和回收线程并行。</li></ul><p>垃圾回收算法：标记清除算法</p><p>之后是对应的CMS常用优化参数。</p><h3 id="XX-UseCMSCompactAtFullCollection"><a href="#XX-UseCMSCompactAtFullCollection" class="headerlink" title="-XX:+UseCMSCompactAtFullCollection"></a>-XX:+UseCMSCompactAtFullCollection</h3><p>设置此参数之后，CMS垃圾在进行了Full GC时，对老年代进行压缩整理，处理掉内存碎片。RocketMq 的脚本也开启了每次Full Gc之后进行碎片整理。</p><h3 id="XX-CMSFullGCsBeforeCompaction-1"><a href="#XX-CMSFullGCsBeforeCompaction-1" class="headerlink" title="-XX:CMSFullGCsBeforeCompaction=1"></a>-XX:CMSFullGCsBeforeCompaction=1</h3><p>FUll GC 之后对老年代进行压缩整理，处理掉内存碎片。RocketMq 的默认应对策略是积极的进行内存碎片整理，缩小老年代的大小，因为RocketMq需要的是高响应时间。</p><h3 id="CMSInitiatingOccupancyFraction-70"><a href="#CMSInitiatingOccupancyFraction-70" class="headerlink" title="CMSInitiatingOccupancyFraction=70"></a>CMSInitiatingOccupancyFraction=70</h3><p><strong>CMSInitiatingOccupancyFraction=70</strong> 表示当老年代达到70%时，触发CMS垃圾回收。</p><ul><li>计算老年代最大使用率（_initiating_occupancy）</li><li>大于等于0则直接取百分号</li><li>小于0则根据公式来计算</li></ul><p>如果使用默认值，则老年代触发回收的比例是动态的，不同的JDK版本可能会有不同的默认值，</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">((100 - MinHeapFreeRatio) + </span><br><span class="line"> (double) ( CMSTriggerRatio * MinHeapFreeRatio) / 100.0) </span><br><span class="line"> / 100.0</span><br></pre></td></tr></table></figure><h2 id="XX-SoftRefLRUPolicyMSPerMB-0"><a href="#XX-SoftRefLRUPolicyMSPerMB-0" class="headerlink" title="-XX:SoftRefLRUPolicyMSPerMB=0"></a>-XX:SoftRefLRUPolicyMSPerMB=0</h2><p>官方解释是：Soft reference 在虚拟机中比在客户集中存活的更长一些。</p><p>先说一下结论，个人认为这个参数设置为0是<strong>不应该</strong>的，至少需要设置个1000或者500（半秒）的缓冲，为什么呢？</p><p>我们<strong>假设我们不小心把这个值设置为0有什么后果呢</strong>？</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230214080954.png" alt=""></p><p>如果<code>-XX:SoftRefLRUPolicyMSPerMB=0</code>，会导致上面clock公式的计算结果为0。</p><p>这个结果为0，就是软饮用被频繁回收导致触发频繁的GC，JVM发现每次反射分配的对象马上就会被回收掉，然后接着又会通过代理生成代理对象，<strong>导致每次soft软引用的对象一旦分配就会马上被回收</strong>.</p><p>结论就是这个值为0，<strong>反射机制导致动态代理类不断的被新增，但是这部分对象又被马上回收掉，导致方法区的垃圾对象越来越多</strong>，会导致很多垃圾无法完全回收。</p><p>为什么RocketMq默认要把<code>-XX:SoftRefLRUPolicyMSPerMB=0</code>值设置为0？</p><p>我们接着分析，<code>-XX:SoftRefLRUPolicyMSPerMB=0</code>，但是使用的是服务器模式（-server），在server模式下，会用 <strong>-Xmx</strong> 参数获取空闲空间大小。  </p><p>空闲的空间越大，软引用就会活的越久，如果设置的值过大，很可能因为框架反射类创建的软引用过多但是因为存在空闲时间计算又没法回收的情况。</p><p>把这个值设置为0，基本上就是说不让反射产生的一些meta对象在GC之后回收不掉，直接通过1次GC就给他摆平了。但是个人角度来看未免过于极端，个人认为设置为0是不合适的。</p><blockquote><p>参考案例：<br>这里在网上找到电子表格缓存业务因为设置 <strong>-XX:SoftRefLRUPolicyMSPerMB=0</strong> 导致的问题例子。<br>当JVM参数中配置了 <strong>-XX:SoftRefLRUPolicyMSPerMB=0</strong> 参数，这个参数是控制SoftReference缓存时间，而我们的电子表格的缓存都是存储SoftReference里边的，当设置了这个参数设置为0的时候，任意操作，只要是触发了gc，这时候就会清空了电子表格缓存，导致即使在内存足够的情况下，缓存也不生效了。</p></blockquote><p>清除频率可以用命令行参数<code>-XX:SoftRefLRUPolicyMSPerMB=&lt;N&gt;</code>来控制，可以指定每兆堆空闲空间的 Soft reference 保持存活（一旦它饮用后不可达了）的毫秒数，这意味着每兆堆中的空闲空间中的 soft reference 会（在最后一个强引用被回收之后）存活1秒钟。</p><p>当然并不是什么时候 <strong>-XX:SoftRefLRUPolicyMSPerMB=0</strong>都是错的，因为 soft reference 只会在垃圾回收时才会被清除，而垃圾回收并不总在发生。系统默认为一秒，如果觉得客户端不需要任何保留，改为 <code>-XX:SoftRefLRUPolicyMSPerMB=0</code> 可以及时清理干净数据。</p><p>RocketMq的做法个人理解为想要让垃圾回收尽可能的回收干净对象，因为RocketMq并不是十分吃JVM堆内存，更多的是需要页缓存，况且NameServ本身比较轻量级。</p><p>还有一个原因是软引用这东西能不用就尽量不用，风险比较大。</p><h3 id="XX-CMSClassUnloadingEnabled"><a href="#XX-CMSClassUnloadingEnabled" class="headerlink" title="-XX:+CMSClassUnloadingEnabled"></a>-XX:+CMSClassUnloadingEnabled</h3><p>老年代启用CMS，但默认是不会回收永久代(Perm)的。此处启用对Perm区启用类回收，防止Perm区内存垃圾对象堆满（<strong>需要与+CMSPermGenSweepingEnabled同时启用</strong>）。</p><blockquote><p><strong>-XX:+CMSPermGenSweepingEnabled</strong>：</p><p>同上，为了避免Perm区满引起的Full GC，开启并发收集器回收Perm区选项。</p></blockquote><p>但是实际上这篇帖子上指出 <span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzcxNzkzNy9jbXNwZXJtZ2Vuc3dlZXBpbmdlbmFibGVkLXZzLWNtc2NsYXNzdW5sb2FkaW5nZW5hYmxlZA==" title="https://stackoverflow.com/questions/3717937/cmspermgensweepingenabled-vs-cmsclassunloadingenabled">https://stackoverflow.com/questions/3717937/cmspermgensweepingenabled-vs-cmsclassunloadingenabled<i class="fa fa-external-link"></i></span></p><p><code>-XX：+CMSClassUnloadEnabled</code>和 <code>-XX：+CMSPermGenSweepingEnabled</code> 在 Java 1.7 中不可用，但是选项<code>-XX：+CMSClassUnloadEnabled</code>对于Java 1.7仍然有效。换句话说在JDK1.7之后被建议使用<code>-XX：+CMSClassUnloadEnabled</code>。</p><p>JVM1.7之前是什么情况？为什么会<strong>需要与+CMSPermGenSweepingEnabled同时启用</strong></p><p>下面这篇文章有评论进行了解释：</p><p><span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXNrL3NvZi8xMTQxODUvYW5zd2VyLzEwMjQxNTA5OA==" title="https://cloud.tencent.com/developer/ask/sof/114185/answer/102415098">用户对问题“CMSPermGenSweepingEnabled vs CMSClassUnloadingEnabled”的回答 - 问答 - 腾讯云开发者社区-腾讯云 (tencent.com)<i class="fa fa-external-link"></i></span></p><p>1.6 JVM的<code>CMSPermGenSweepingEnabled</code>参数做的唯一事情就是打印消息，它的处理方式与1.5不同。要使<code>CMSClassUnloadingEnabled</code>生效，还必须设置<code>UseConcMarkSweepGC</code>。</p><h3 id="XX-SurvivorRatio-8"><a href="#XX-SurvivorRatio-8" class="headerlink" title="-XX:SurvivorRatio=8"></a>-XX:SurvivorRatio=8</h3><p>CMS 用的是标记清除的算法，使用CMS还是传统的<strong>新生代和老年代的分代概念</strong>，这里RocketMq用的是默认的分代分区策略，给了新生代更多的使用空间。它定义了新生代中Eden区域和Survivor区域（From幸存区或To幸存区）的比例，默认为8，也就是说Eden占新生代的8/10，From幸存区和To幸存区各占新生代的1/10.</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230219212846.png" alt=""></p><h3 id="UseParNewGC"><a href="#UseParNewGC" class="headerlink" title="-UseParNewGC"></a>-UseParNewGC</h3><p><code>-XX:+UseParNewGC</code> 设置年轻代为多线程收集。可与CMS收集同时使用，ParNew 在Serial基础上实现的<strong>多线程收集器</strong>。</p><h3 id="日志参数配置"><a href="#日志参数配置" class="headerlink" title="日志参数配置"></a>日志参数配置</h3><p>总得来说 RocketMq 在JDK8的版本使用了老牌的<code>-XX:+UseConcMarkSweepGC</code> CMS垃圾收集器 和<code>-XX:+UseParNewGC</code> CMS垃圾 垃圾收集器。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-verbose:gc -Xloggc:<span class="variable">$&#123;GC_LOG_DIR&#125;</span>/rmq_srv_gc_%p_%t.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps<span class="string">"</span></span><br></pre></td></tr></table></figure><p><code>-verbose:gc</code>和<code>-XX:+PrintGCDetails</code>在官方文档中有说明两者<strong>功能一样</strong>，都用于<strong>垃圾收集时的信息打印</strong>。</p><p>但是也有不同点：</p><p><strong>-verbose:gc</strong> 是 稳定版本，参见：<span class="exturl" data-url="aHR0cDovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2UvNy9kb2NzL3RlY2hub3Rlcy90b29scy93aW5kb3dzL2phdmEuaHRtbA==" title="http://docs.oracle.com/javase/7/docs/technotes/tools/windows/java.html">http://docs.oracle.com/javase/7/docs/technotes/tools/windows/java.html<i class="fa fa-external-link"></i></span></p><p><strong>-XX:+PrintGC</strong> 是非稳定版本。</p><p><strong>-XX:+PrintGCDateStamps</strong>，日志中添加时间标志（日志每行开头显示自从JVM启动以来的时间，单位为秒）</p><p>注意<code>-XX:+PrintGCDateStamps</code>  打印GC发生时的<span class="exturl" data-url="aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT3ml7bpl7TmiLMmc3BtPTEwMDEuMjEwMS4zMDAxLjcwMjA=" title="https://so.csdn.net/so/search?q=时间戳&spm=1001.2101.3001.7020">时间戳<i class="fa fa-external-link"></i></span>，搭配<code>-XX:+PrintGCDetails</code> 使用，<strong>不可以独立使用</strong></p><p>日志输出示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2014-01-03T12:08:38.102-0100: [GC 66048K-&gt;53077K(251392K), 0,0959470 secs]</span><br><span class="line"></span><br><span class="line">2014-01-03T12:08:38.239-0100: [GC 119125K-&gt;114661K(317440K), 0,1421720 secs]</span><br></pre></td></tr></table></figure><p><code>-XX:+UseGCLogFileRotation</code> 、<code>-XX:NumberOfGCLogFiles=5</code>、 <code>-XX:GCLogFileSize=30m</code>。UseGCLogFileRotation 会根据后面两个参数的设置不断的<strong>轮询替换GC日志</strong>，这里最多保留了150M的GC日志，后续再进行写入就会从第一个文件开始替换。</p><blockquote><p> 150M日志足够及时处理大部分问题，并且不会出现历史日志长期驻留磁盘的问题。但是这个参数需要谨慎设置，如果设置过小容易导致关键GC 日志丢失。</p></blockquote><h2 id="JDK9之后的启动参数"><a href="#JDK9之后的启动参数" class="headerlink" title="JDK9之后的启动参数"></a>JDK9之后的启动参数</h2><p>应该说是比较关键的版本，很明显都是围绕G1垃圾收集器做的优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">  JAVA_OPT=<span class="string">"$&#123;JAVA_OPT&#125; -server -Xms4g -Xmx4g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m"</span></span><br><span class="line">  JAVA_OPT=<span class="string">"$&#123;JAVA_OPT&#125; -XX:+UseG1GC -XX:G1HeapRegionSize=16m -XX:G1ReservePercent=25 -XX:InitiatingHeapOccupancyPercent=30 -XX:SoftRefLRUPolicyMSPerMB=0"</span></span><br><span class="line">  JAVA_OPT=<span class="string">"$&#123;JAVA_OPT&#125; -Xlog:gc*:file=$&#123;GC_LOG_DIR&#125;/rmq_srv_gc_%p_%t.log:time,tags:filecount=5,filesize=30M"</span></span><br></pre></td></tr></table></figure><p>第一行</p><p>堆内存分配基本没啥区别：堆内存（初始堆内存）为 4g，新生代 2g，其他空间为 2g。元空间初始化128m，最大的扩容元空间为320mb。</p><p>第二行</p><p>垃圾回收器的关键配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseG1GC -XX:G1HeapRegionSize=<span class="number">16</span>m -XX:G1ReservePercent=<span class="number">25</span> -XX:InitiatingHeapOccupancyPercent=<span class="number">30</span> -XX:SoftRefLRUPolicyMSPerMB=<span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="XX-UseG1GC"><a href="#XX-UseG1GC" class="headerlink" title="-XX:+UseG1GC"></a>-XX:+UseG1GC</h3><p>使用G1垃圾收集器。需要注意JDK8的G1垃圾收集器是“残血”版本。</p><h3 id="XX-G1HeapRegionSize"><a href="#XX-G1HeapRegionSize" class="headerlink" title="-XX:G1HeapRegionSize"></a>-XX:G1HeapRegionSize</h3><p>一个Region的大小可以通过参数<code>-XX:G1HeapRegionSize</code>设定，取值范围从1M到32M，且是2的指数。如果不设定，那么G1会根据Heap大小自动决定。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230219215610.png" alt=""></p><p>关键部分为<code>region_size = 1 &lt;&lt; region_size_log</code>，左移的操作也就是2的倍数的概念。最后的参数判断会让region最大为32M，最小为1M，不允许超过这个范围。</p><h3 id="XX-G1ReservePercent"><a href="#XX-G1ReservePercent" class="headerlink" title="-XX:G1ReservePercent"></a>-XX:G1ReservePercent</h3><p>`-XX:G1ReservePercent G1会保留一部分堆内存用来防止分配不了的情况，默认是10。</p><p>官方对于这个参数的介绍如下：</p><blockquote><p>-XX:G1ReservePercent=10<br>Sets the percentage of reserve memory to keep free so as to reduce the risk of to-space overflows. The default is 10 percent. When you increase or decrease the percentage, make sure to adjust the total Java heap by the same amount. This setting is not available in Java HotSpot VM, build&#x20;<br>设置保留内存的百分比，以减少到空间溢出的风险。默认是10%。当你增加或减少这个百分比时，请确保预留足够的空间并且调整Java堆大小。注意这个设置在Java HotSpot VM中是不可用的。</p></blockquote><p>扩大这个数值可以保证在进行GC 的时候提供更多堆内存保证存活空间存放晋升老年代的Region.</p><p><strong>G1为分配担保预留的空间比例</strong>：通过<code>-XX:G1ReservePercent</code>指定，默认<strong>10%</strong>。也就是老年代会预留10%的空间来给新生代的对象晋升，如果经常发生新生代晋升失败而导致 Full GC，那么可以适当调高此阈值。但是调高此值同时也意味着<strong>降低了老年代的实际可用空间</strong>。</p><h3 id="XX-InitiatingHeapOccupancyPercent-30"><a href="#XX-InitiatingHeapOccupancyPercent-30" class="headerlink" title="-XX:InitiatingHeapOccupancyPercent=30"></a>-XX:InitiatingHeapOccupancyPercent=30</h3><p><strong>触发全局并发标记的老年代使用占比</strong>，默认值45%。</p><p>默认值45%的含义是也就是老年代占堆的比例超过45%。如果Mixed GC周期结束后老年代使用率还是超过45%,那么会再次触发全局并发标记过程，这样就会导致频繁的老年代GC，影响应用吞吐量。</p><p>当然调大这个值的代价是可能导致年轻代谨升失败而导致FULL GC。RocketMq使用30的设置是让老年代提早的触发GC并且回收垃圾。</p><h3 id="XX-SoftRefLRUPolicyMSPerMB-0-1"><a href="#XX-SoftRefLRUPolicyMSPerMB-0-1" class="headerlink" title="-XX:SoftRefLRUPolicyMSPerMB=0"></a>-XX:SoftRefLRUPolicyMSPerMB=0</h3><p><code>-XX:SoftRefLRUPolicyMSPerMB=N</code>这个参数在是JVM系统参数和垃圾收集器无关。</p><p><code>-XX:SoftRefLRUPolicyMSPerMB</code>参数，可以指定每兆堆空闲空间的软引用的存活时间，默认值是1000，也就是1秒。可以调低这个参数来触发更早的回收软引用。如果调高的话会有更多的存活数据，可能在GC后堆占用空间比会增加。 对于软引用，还是建议尽量少用，会增加存活数据量，增加GC的处理时间。</p><h3 id="日志参数配置-1"><a href="#日志参数配置-1" class="headerlink" title="日志参数配置"></a>日志参数配置</h3><p>配置和之前的版本是一样的，这里直接忽略了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;JAVA_OPT&#125;</span> -Xlog:gc*:file=<span class="variable">$&#123;GC_LOG_DIR&#125;</span>/rmq_srv_gc_%p_%t.log:time,tags:filecount=5,filesize=30M<span class="string">"</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>整个NameServ的启动脚本不算太复杂，这里简单归纳一下比较重要的点：</p><ul><li>JDK9之前没有用G1，因为不成熟，选择传统的CMS+ParNew经典组合。</li><li>JDK9之后使用的是G1垃圾收集器，并且参数都是尽可能的给新生代预留空间。</li><li>NameServ 新生代的压力会比较大，整体思路是尽可能的减少垃圾，通过积极的GC保证垃圾尽可能被回收。</li></ul><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>个人认为这种学习方式一举多得，还可以看到不少Shell脚本的使用技巧，挺不错的。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      NameServ启动脚本分析
    
    </summary>
    
    
      <category term="RocketMq" scheme="https://whitestore.top/categories/RocketMq/"/>
    
    
      <category term="RocketMq" scheme="https://whitestore.top/tags/RocketMq/"/>
    
  </entry>
  
  <entry>
    <title>【JVM】Try to Avoid -XX UseGCLogFileRotation</title>
    <link href="https://whitestore.top/2023/02/02/usegclogfilerotation/"/>
    <id>https://whitestore.top/2023/02/02/usegclogfilerotation/</id>
    <published>2023-02-02T04:14:30.000Z</published>
    <updated>2023-02-02T04:17:06.315Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Try-to-Avoid-XX-UseGCLogFileRotation"><a href="#Try-to-Avoid-XX-UseGCLogFileRotation" class="headerlink" title="Try to Avoid -XX:+UseGCLogFileRotation"></a>Try to Avoid -XX:+UseGCLogFileRotation</h1><p>Source：<span class="exturl" data-url="aHR0cHM6Ly9kem9uZS5jb20vYXJ0aWNsZXMvdHJ5LXRvLWF2b2lkLXh4dXNlZ2Nsb2dmaWxlcm90YXRpb24=" title="https://dzone.com/articles/try-to-avoid-xxusegclogfilerotation">https://dzone.com/articles/try-to-avoid-xxusegclogfilerotation<i class="fa fa-external-link"></i></span></p><p>Developers take advantage of the JVM argument -XX:+UseGCLogFileRotation to rotate GC log files.</p><p>开发人员利用JVM参数-XX:+UseGCLogFileRotation来递换GC日志文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:/home/GCEASY/gc.log -</span><br><span class="line">XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=<span class="number">5</span> -XX:GCLogFileSize=<span class="number">20</span>M<span class="string">"</span></span><br></pre></td></tr></table></figure><p>As shown above, the JVM will rotate the GC log file whenever its size reaches 20MB. It will generate up to five files, with extensions <code>gc.log.0</code>,  <code>gc.log.1</code>, <code>gc.log.2</code>, <code>gc.log.3</code>, and <code>gc.log.4</code>.</p><p>如上所示的配置会产生5个日志文件，并且每个日志文件有20M。</p><a id="more"></a><h1 id="Losing-Old-GC-Logs-日志丢失"><a href="#Losing-Old-GC-Logs-日志丢失" class="headerlink" title="Losing Old GC Logs 日志丢失"></a>Losing Old GC Logs 日志丢失</h1><p>Suppose you configured  <code>-XX:NumberOfGCLogFiles=5</code>, then over a period of time, five GC log files will be created:</p><p>假设你配置了<code>-XX:NumberOfGCLogFiles=5</code>，那么在一段时期内，将创建五个GC日志文件。</p><ul><li><strong>gc.log.0</strong> ← <em>oldest GC Log content</em></li><li><strong>gc.log.1</strong></li><li><strong>gc.log.2</strong></li><li><strong>gc.log.3</strong></li><li><strong>gc.log.4</strong> ← <em>latest GC Log content</em></li></ul><p>The most recent GC log contents will be written to <code>gc.log.4</code> and old GC log contents will be present in <code>gc.log.0</code>.</p><p>最新的GC日志内容将被写入<code>gc.log.4</code>，旧的GC日志内容将出现在<code>gc.log.0</code>。</p><p>When the application starts to generate more GC logs than the configured  <code>-XX:NumberOfGCLogFiles</code>, in this case, five, then old GC log contents in <code>gc.log.0</code> will be deleted. New GC events will be written to  <code>gc.log.0</code>. It means that you will end up not having all the generated GC logs. You will lose the visibility of all events.</p><p>当应用程序配置的<code>-XX:NumberOfGCLogFiles</code>产生更多的GC日志时（在本例中是5个），<code>gc.log.0</code>中的旧GC日志内容将被删除。新的GC日志将被写入<code>gc.log.0</code>。这意味着会存在旧日志文件的覆盖现象，将<strong>失去所有日志的可见性</strong>。</p><h1 id="Mixed-Up-GC-Logs-混杂日志"><a href="#Mixed-Up-GC-Logs-混杂日志" class="headerlink" title="Mixed-Up GC Logs 混杂日志"></a>Mixed-Up GC Logs 混杂日志</h1><p>Suppose an application has created five GC log files, including:</p><p>假设一个应用程序创建了五个GC日志文件，包括：</p><ul><li><strong>gc.log.0</strong></li><li><strong>gc.log.1</strong></li><li><strong>gc.log.2</strong></li><li><strong>gc.log.3</strong></li><li><strong>gc.log.4</strong></li></ul><p>Then, let’s say you are restarting the application. Now, new GC logs will be written to <code>gc.log.0</code> file and old GC log content will be present in <code>gc.log.1</code>, <code>gc.log.2</code>, <code>gc.log.3</code>, <code>gc.log.4</code>, etc.</p><p>然后，假设你正在重启应用程序。现在新的GC日志将被写入<code>gc.log.0</code>文件，而旧的GC日志内容将出现在<code>gc.log.1</code>、<code>gc.log.2</code>、<code>gc.log.3</code>、<code>gc.log.4</code>。</p><ul><li><strong>gc.log.0</strong> ← GC log file content after restart</li><li><strong>gc.log.1</strong> ← GC log file content before restart</li><li><strong>gc.log.2</strong> ← GC log file content before restart</li><li><strong>gc.log.3</strong> ← GC log file content before restart</li><li><strong>gc.log.4</strong> ← GC log file content before restart</li></ul><p>So, your new GC log contents get mixed up with old GC logs. Thus, to mitigate this problem, you might have to move all the old GC logs to a different folder before you restart the application.</p><p>所以新GC日志和旧的GC日志会混合在一起，为了缓解这个问题，你可能要在重启应用程序之前把所有旧的GC日志移到一个不同的文件夹里。</p><h1 id="Forwarding-GC-Logs-to-a-Central-Location-将GC日志转发到一个中心位置"><a href="#Forwarding-GC-Logs-to-a-Central-Location-将GC日志转发到一个中心位置" class="headerlink" title="Forwarding GC Logs to a Central Location 将GC日志转发到一个中心位置"></a>Forwarding GC Logs to a Central Location 将GC日志转发到一个中心位置</h1><p>In this approach, the current active file to which GC logs are written is marked with the extension  <code>.current</code>. For example, if GC events are currently written to the file <code>gc.log.3</code>, it would be named as: <code>gc.log.3.current</code>.</p><p>在这种方法中，当前写入GC日志的活动文件被标记为扩展名<code>.current</code>。例如，如果GC事件当前被写入文件<code>gc.log.3</code>，它将被命名为。 <code>gc.log.3.current</code>。</p><p>If you want to forward GC logs from each server to a central location, then most DevOps engineers use  <code>rsyslog</code>. However, this file naming convention poses a significant challenge to use <code>rsyslog</code>, as <span class="exturl" data-url="aHR0cDovL3d3dy5wbGFuZXRjb2JhbHQubmV0L3NkYi9mb3J3YXJkX2djX2xvZ3Muc2h0bWw=" title="http://www.planetcobalt.net/sdb/forward_gc_logs.shtml">described in this blog<i class="fa fa-external-link"></i></span>.</p><p>如果你想把每台服务器的GC日志转发到一个中心位置，那么大多数DevOps工程师会使用<code>rsyslog</code>。然而，这种文件命名惯例给使用<code>rsyslog</code>带来了巨大的挑战，正如<span class="exturl" data-url="aHR0cDovL3d3dy5wbGFuZXRjb2JhbHQubmV0L3NkYi9mb3J3YXJkX2djX2xvZ3Muc2h0bWw=" title="http://www.planetcobalt.net/sdb/forward_gc_logs.shtml">这篇博客所述<i class="fa fa-external-link"></i></span>。</p><h1 id="Tooling-工具"><a href="#Tooling-工具" class="headerlink" title="Tooling 工具"></a>Tooling 工具</h1><p>Now, to analyze the GC log file using the GC tools such as (<span class="exturl" data-url="aHR0cHM6Ly9nY2Vhc3kuaW8v" title="https://gceasy.io/">GCeasy<i class="fa fa-external-link"></i></span>, GCViewer, etc.), you will have to upload multiple GC log files instead of just one single GC Log file.</p><p>现在，为了使用GC工具分析GC日志文件，如（<span class="exturl" data-url="aHR0cHM6Ly9nY2Vhc3kuaW8v" title="https://gceasy.io/">GCeasy<i class="fa fa-external-link"></i></span>, GCViewer等），将不得不上传多个GC日志文件，而不是只有一个GC日志文件。</p><blockquote><p>显然非常麻烦并且非常反人类。</p></blockquote><h1 id="Recommended-Solution-推荐方案"><a href="#Recommended-Solution-推荐方案" class="headerlink" title="Recommended Solution 推荐方案"></a>Recommended Solution 推荐方案</h1><p>We can suffix the GC log file with the time stamp at which the JVM was restarted, then the GC Log file locations will become unique. Then, new GC logs will not override the old GC logs. It can be achieved by suffixing <code>%t</code> to the GC log file name, as shown below:</p><p>我们可以在GC日志文件后缀加入<strong>JVM重启的时间戳</strong>（解决这个问题），那么GC日志文件的位置将变得独一无二。然后新的GC日志就不会覆盖旧的GC日志了。这可以通过在GC日志文件名后缀<code>%t</code>来实现，如下所示：</p><blockquote><p>“-XX:+PrintGCDetails -XX:+PrintGCDateStamps <strong>-Xloggc:/home/GCEASY/gc-%t.log</strong>“</p></blockquote><p> <code>%t</code> suffixes timestamp to the GC log file in the format:  <code>YYYY-MM-DD_HH-MM-SS</code>. So, the generated GC log file name will start to look like: <code>gc-2019-01-29_20-41-47.log</code>.</p><p> <code>%t</code>后缀为GC日志文件的时间戳，格式为:  <code>yyyy-mm-dd_hh-mm-ss</code>。因此，生成的GC日志文件名将开始看起来像： <code>gc-2019-01-29_20-41-47.log</code>.</p><p>This simple solution addresses all the shortcomings of <code>-XX:+UseGCLogFileRotation</code>.</p><p><strong>这个简单的解决方案解决了<code>-XX:+UseGCLogFileRotation</code>的所有缺点。</strong></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      JVM相关参数解释
    
    </summary>
    
    
      <category term="java-jvm" scheme="https://whitestore.top/categories/java-jvm/"/>
    
    
      <category term="jvm" scheme="https://whitestore.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】Linux命令快速学习神器tldr、cheat介绍和使用</title>
    <link href="https://whitestore.top/2023/01/28/tldrcheat/"/>
    <id>https://whitestore.top/2023/01/28/tldrcheat/</id>
    <published>2023-01-28T03:42:10.000Z</published>
    <updated>2023-01-28T03:43:26.380Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>本文介绍tldr和Cheat等实用工具的安装和使用，这些工具虽然本身不能替代<code>man</code>、<code>info</code>等命令，但是在很多时候想要快速学习和掌握命令但是忘记常见用法非常有帮助。</p><blockquote><p>个人看法：对于非运维人员简直是神器。</p></blockquote><p><strong>tldr</strong>：全称 too long, Don’t read，翻译成中文就是太长不想阅读，比–help或者man这些传统手册更便捷、更便于使用。<br><strong>cheat</strong>：作弊。</p><p>这两个命令有什么用？这里简单举个例子就知道了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-8-8-ubuntu:~$ sudo tldr ls</span><br><span class="line"></span><br><span class="line">  ls</span><br><span class="line"></span><br><span class="line">  List directory contents.</span><br><span class="line">  More information: https://www.gnu.org/software/coreutils/ls.</span><br><span class="line"></span><br><span class="line">  - List files one per line:</span><br><span class="line">    ls -1</span><br><span class="line"></span><br><span class="line">  - List all files, including hidden files:</span><br><span class="line">    ls -a</span><br><span class="line"></span><br><span class="line">  - List all files, with trailing / added to directory names:</span><br><span class="line">    ls -F</span><br><span class="line"></span><br><span class="line">  - Long format list (permissions, ownership, size, and modification date) of all files:</span><br><span class="line">    ls -la</span><br><span class="line"></span><br><span class="line">  - Long format list with size displayed using human-readable units (KiB, MiB, GiB):</span><br><span class="line">    ls -lh</span><br><span class="line"></span><br><span class="line">  - Long format list sorted by size (descending):</span><br><span class="line">    ls -lS</span><br><span class="line"></span><br><span class="line">  - Long format list of all files, sorted by modification date (oldest first):</span><br><span class="line">    ls -ltr</span><br><span class="line"></span><br><span class="line">  - Only list directories:</span><br><span class="line">    ls -d */</span><br></pre></td></tr></table></figure><h1 id="内容概览"><a href="#内容概览" class="headerlink" title="内容概览"></a>内容概览</h1><ol><li>Ubuntu和CenterOs介绍和安装<strong>tldr</strong>命令。<ol><li>CenterOs和Ubuntu的安装方式使用</li><li>Ubuntu的常见问题和解决方案。</li></ol></li><li>Ubuntu和CenterOs介绍和安装<strong>cheat</strong>命令。<ol><li>安装验证和使用</li><li>Ubuntu和CenterOs处理方式一致</li></ol></li><li>类似项目列举。</li></ol><a id="more"></a><h1 id="官方资料"><a href="#官方资料" class="headerlink" title="官方资料"></a>官方资料</h1><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230125221920.png" alt=""></p><p>在线wiki搜索：<span class="exturl" data-url="aHR0cHM6Ly90bGRyLm9zdGVyYS5pby8=" title="https://tldr.ostera.io/">tldr | simplified, community driven man pages (ostera.io)<i class="fa fa-external-link"></i></span><br>（注意国内访问比较慢，需要自带魔法）</p><p>官方的安装介绍页面地址：<span class="exturl" data-url="aHR0cHM6Ly90bGRyLnNoLyNpbnN0YWxsYXRpb24=" title="https://tldr.sh/#installation">https://tldr.sh/#installation<i class="fa fa-external-link"></i></span></p><p>tldr项目地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RsZHItcGFnZXMvdGxkcg==" title="https://github.com/tldr-pages/tldr">https://github.com/tldr-pages/tldr<i class="fa fa-external-link"></i></span></p><h1 id="tldr"><a href="#tldr" class="headerlink" title="tldr"></a>tldr</h1><h2 id="Ubuntu安装tldr"><a href="#Ubuntu安装tldr" class="headerlink" title="Ubuntu安装tldr"></a>Ubuntu安装tldr</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Ubuntu 安装比较简单，直接使用<code>sudo apt-get install tldr</code>安装。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install tldr</span><br></pre></td></tr></table></figure><p>如果上面的命令安装之后依然无法使用，可以按照下面的命令进行安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install npm</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nodejs-legacy</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install n -g</span><br></pre></td></tr></table></figure><p>注意这里有两种方式，一种是使用latest版本，另外一种是使用stable版本，个人建议使用stable版本，如果Ubuntu的系统版本比较低，则需要降低node版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo n stable</span><br><span class="line">（或 sudo n latest）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g tldr</span><br></pre></td></tr></table></figure><p>当然也可以不使用nodeJS，也可以使用<code>pip</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install tldr</span><br></pre></td></tr></table></figure><p>如果是Mac系统就十分简单了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install tldr</span><br></pre></td></tr></table></figure><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>在ubuntu当中验证直接使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-8-8-ubuntu:~$ tldr</span><br><span class="line">tldr - Simplified and community-driven man pages</span><br><span class="line"></span><br><span class="line">Usage: tldr [-v|--version] </span><br><span class="line">            ((-u|--update) | [-p|--platform PLATFORM] COMMAND | (-a|--about))</span><br><span class="line">  tldr Client program</span><br><span class="line"></span><br><span class="line">Available options:</span><br><span class="line">  -h,--help                Show this help text</span><br><span class="line">  -v,--version             Show version</span><br><span class="line">  -u,--update              Update offline cache of tldr pages</span><br><span class="line">  -p,--platform PLATFORM   Prioritize specfic platform while searching. Valid</span><br><span class="line">                           values include linux, osx, windows, sunos</span><br><span class="line">  COMMAND                  name of the command</span><br><span class="line">  -a,--about               About this program</span><br></pre></td></tr></table></figure><h2 id="Ubuntu安装常见问题"><a href="#Ubuntu安装常见问题" class="headerlink" title="Ubuntu安装常见问题"></a>Ubuntu安装常见问题</h2><h3 id="No-tldr-entry-for-xxx"><a href="#No-tldr-entry-for-xxx" class="headerlink" title="No tldr entry for xxx"></a>No tldr entry for xxx</h3><p>Ubuntu安装tldr使用<code>tldr ls</code>之后，很有可能出现类似<code>No tldr entry for ls</code>的命令，出现这种情况可能有下面两种情况：</p><ul><li>首次安装需要更新tldr的“数据库”。</li><li>当天用户安装使用<code>sudo</code>，tldr的数据库没法访问。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-8-8-ubuntu:~$ tldr ls</span><br><span class="line">No tldr entry <span class="keyword">for</span> ls</span><br></pre></td></tr></table></figure><p>更新tldr的数据库：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-8-8-ubuntu:~$ sudo tldr --update</span><br><span class="line">✔ Updating...</span><br><span class="line">✔ Creating index...</span><br></pre></td></tr></table></figure><p>当然也可以使用<code>tldr -u</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-8-8-ubuntu:~$ sudo tldr --u</span><br></pre></td></tr></table></figure><p><strong>sudo安装使用</strong></p><p>个人的云服务器ubuntu使用了<code>sudo</code>安装之后，需要使用<code>sudo tldr</code>才可以正常使用，因为日常登录的用户为<code>ubuntu</code>用户，安装的过程全部使用<code>sudo</code>，查询某个命令也需要使用root身份进行查询。</p><p>如果出现<code>No tldr entry for xxx</code>，有可能是你用的<code>sudo</code>安装但是当前的用户却没有<code>sudo</code>的权限。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-8-8-ubuntu:~$ sudo tldr ls</span><br><span class="line"></span><br><span class="line">  ls</span><br><span class="line"></span><br><span class="line">  List directory contents.</span><br><span class="line">  More information: https://www.gnu.org/software/coreutils/ls.</span><br><span class="line"></span><br><span class="line">  - List files one per line:</span><br><span class="line">    ls -1</span><br><span class="line"></span><br><span class="line">  - List all files, including hidden files:</span><br><span class="line">    ls -a</span><br><span class="line"></span><br><span class="line">  - List all files, with trailing / added to directory names:</span><br><span class="line">    ls -F</span><br><span class="line"></span><br><span class="line">  - Long format list (permissions, ownership, size, and modification date) of all files:</span><br><span class="line">    ls -la</span><br><span class="line"></span><br><span class="line">  - Long format list with size displayed using human-readable units (KiB, MiB, GiB):</span><br><span class="line">    ls -lh</span><br><span class="line"></span><br><span class="line">  - Long format list sorted by size (descending):</span><br><span class="line">    ls -lS</span><br><span class="line"></span><br><span class="line">  - Long format list of all files, sorted by modification date (oldest first):</span><br><span class="line">    ls -ltr</span><br><span class="line"></span><br><span class="line">  - Only list directories:</span><br><span class="line">    ls -d */</span><br></pre></td></tr></table></figure><h3 id="nodeJs版本降级"><a href="#nodeJs版本降级" class="headerlink" title="nodeJs版本降级"></a>nodeJs版本降级</h3><p>版本降级相关资料参考自：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZhYnVsb3VzMTExMS9hcnRpY2xlL2RldGFpbHMvODQ5ODM4Njk=" title="https://blog.csdn.net/Fabulous1111/article/details/84983869">https://blog.csdn.net/Fabulous1111/article/details/84983869<i class="fa fa-external-link"></i></span></p><h4 id="（1）安装node版本管理模块n"><a href="#（1）安装node版本管理模块n" class="headerlink" title="（1）安装node版本管理模块n"></a>（1）安装node版本管理模块n</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install n -g</span><br></pre></td></tr></table></figure><p>下边步骤请根据自己需要选择</p><h4 id="（2）安装稳定版"><a href="#（2）安装稳定版" class="headerlink" title="（2）安装稳定版"></a>（2）安装稳定版</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo n stable</span><br></pre></td></tr></table></figure><h4 id="（3）安装最新版"><a href="#（3）安装最新版" class="headerlink" title="（3）安装最新版"></a>（3）安装最新版</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo n latest</span><br></pre></td></tr></table></figure><h4 id="（4）-版本降级-升级"><a href="#（4）-版本降级-升级" class="headerlink" title="（4） 版本降级/升级"></a>（4） 版本降级/升级</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo n 版本号</span><br></pre></td></tr></table></figure><h4 id="（5）检测目前安装了哪些版本的node"><a href="#（5）检测目前安装了哪些版本的node" class="headerlink" title="（5）检测目前安装了哪些版本的node"></a>（5）检测目前安装了哪些版本的node</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n</span><br></pre></td></tr></table></figure><p>提示内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  ο node&#x2F;16.15.1</span><br><span class="line">    node&#x2F;18.13.0</span><br><span class="line">    node&#x2F;19.5.0</span><br><span class="line"></span><br><span class="line">Use up&#x2F;down arrow keys to select a version, return key to install, d to delete, q to quit</span><br></pre></td></tr></table></figure><h4 id="切换版本（不会删除已经安装的其他版本）"><a href="#切换版本（不会删除已经安装的其他版本）" class="headerlink" title="切换版本（不会删除已经安装的其他版本）"></a>切换版本（不会删除已经安装的其他版本）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n 版本号</span><br></pre></td></tr></table></figure><p>比如：<code>n 16.15.1</code></p><h4 id="（7）删除版本"><a href="#（7）删除版本" class="headerlink" title="（7）删除版本"></a>（7）删除版本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo n rm 版本号</span><br></pre></td></tr></table></figure><h4 id="（8）直接移除Nodejs"><a href="#（8）直接移除Nodejs" class="headerlink" title="（8）直接移除Nodejs"></a>（8）直接移除Nodejs</h4><p>PS：注意不同的操作系统命令会有差别，这里为Ubuntu的卸载方式</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove nodejs</span><br></pre></td></tr></table></figure><h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g n</span><br><span class="line"></span><br><span class="line">sudo n install 16.15.1 <span class="comment"># 太新的也会有问题</span></span><br></pre></td></tr></table></figure><p>以上就是ubuntu常见问题和处理。</p><h2 id="CenterOs-安装-tldr"><a href="#CenterOs-安装-tldr" class="headerlink" title="CenterOs 安装 tldr"></a>CenterOs 安装 tldr</h2><p>CenterOs的安装方式和Ubuntu类似，这里展示安装Node环境之后安装tldr并使用的过程。</p><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><ol><li>安装NodeJs，如果嫌麻烦可以直接安装<code>sudo yum install -y npm</code>。</li></ol><p>[[【Linux】NodeJs 安装和环境变量配置]]</p><ol start="2"><li>我们使用官方提供的命令安装。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g tldr</span><br></pre></td></tr></table></figure><ol start="3"><li>如果是使用NodeJs环境变量设置的方式安装，需要设置软链接，tldr命令默认会安装到<code>nodeJs</code>安装路径的<strong>Bin</strong>目录下面，如果不好理解，可以参考下面的软链接构建命令。</li></ol><blockquote><p>还有一种方式是在Path中设置<code>/xx/nodejs/bin</code> 为环境变量</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zxd@localhost ~]$ sudo ln -s /opt/nodeJs/bin/tldr /usr/<span class="built_in">local</span>/bin</span><br><span class="line">[sudo] password <span class="keyword">for</span> zxd:</span><br></pre></td></tr></table></figure><blockquote><p>如果软链接路径构建错误，可以使用<code>sudo ln -fs /opt/nodeJs/bin/tldr /usr/local/bin</code>加入 <code>-f</code>参数强制覆盖之前的软链接。</p></blockquote><h3 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h3><p>因为构建了<code>tldr</code>软链接，我们可以再任意路径使用这个命令。如果敲入<code>tldr</code>命令出现下面的提示证明安装成功：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">[zxd@localhost bin]$ tldr</span><br><span class="line">Usage: tldr <span class="built_in">command</span> [options]</span><br><span class="line"></span><br><span class="line">Simplified and community-driven man pages</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -v, --version            Display version</span><br><span class="line">  -l, --list               List all commands <span class="keyword">for</span> the chosen platform <span class="keyword">in</span> the cache</span><br><span class="line">  -a, --list-all           List all commands <span class="keyword">in</span> the cache</span><br><span class="line">  -1, --single-column      List single <span class="built_in">command</span> per line (use with options -l or -a)</span><br><span class="line">  -r, --random             Show a random <span class="built_in">command</span></span><br><span class="line">  -e, --random-example     Show a random example</span><br><span class="line">  -f, --render [file]      Render a specific markdown [file]</span><br><span class="line">  -m, --markdown           Output <span class="keyword">in</span> markdown format</span><br><span class="line">  -o, --os [<span class="built_in">type</span>]          Override the operating system [linux, osx, sunos, windows]</span><br><span class="line">  --linux                  Override the operating system with Linux</span><br><span class="line">  --osx                    Override the operating system with OSX</span><br><span class="line">  --sunos                  Override the operating system with SunOS</span><br><span class="line">  --windows                Override the operating system with Windows</span><br><span class="line">  -t, --theme [theme]      Color theme (simple, base16, ocean)</span><br><span class="line">  -s, --search [keywords]  Search pages using keywords</span><br><span class="line">  -u, --update             Update the <span class="built_in">local</span> cache</span><br><span class="line">  -c, --clear-cache        Clear the <span class="built_in">local</span> cache</span><br><span class="line">  -h, --<span class="built_in">help</span>               Show this <span class="built_in">help</span> message</span><br><span class="line"></span><br><span class="line">  Examples:</span><br><span class="line"></span><br><span class="line">    $ tldr tar</span><br><span class="line">    $ tldr du --os=linux</span><br><span class="line">    $ tldr --search <span class="string">"create symbolic link to file"</span></span><br><span class="line">    $ tldr --list</span><br><span class="line">    $ tldr --list-all</span><br><span class="line">    $ tldr --random</span><br><span class="line">    $ tldr --random-example</span><br><span class="line"></span><br><span class="line">  To control the cache:</span><br><span class="line"></span><br><span class="line">    $ tldr --update</span><br><span class="line">    $ tldr --clear-cache</span><br><span class="line"></span><br><span class="line">  To render a <span class="built_in">local</span> file (<span class="keyword">for</span> testing):</span><br><span class="line"></span><br><span class="line">    $ tldr --render /path/to/file.md</span><br></pre></td></tr></table></figure><p>我们使用<code>tldr ls</code>查看<code>ls</code>命令的用法，确实赏心悦目。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[zxd@localhost ~]$ tldr ls</span><br><span class="line">✔ Page not found. Updating cache...</span><br><span class="line">⠴ Creating index...</span><br><span class="line">✔ Creating index...</span><br><span class="line"></span><br><span class="line">  ls</span><br><span class="line"></span><br><span class="line">  List directory contents.</span><br><span class="line">  More information: https://www.gnu.org/software/coreutils/ls.</span><br><span class="line"></span><br><span class="line">  - List files one per line:</span><br><span class="line">    ls -1</span><br><span class="line"></span><br><span class="line">  - List all files, including hidden files:</span><br><span class="line">    ls -a</span><br><span class="line"></span><br><span class="line">  - List all files, with trailing / added to directory names:</span><br><span class="line">    ls -F</span><br><span class="line"></span><br><span class="line">  - Long format list (permissions, ownership, size, and modification date) of all files:</span><br><span class="line">    ls -la</span><br><span class="line"></span><br><span class="line">  - Long format list with size displayed using human-readable units (KiB, MiB, GiB):</span><br><span class="line">    ls -lh</span><br><span class="line"></span><br><span class="line">  - Long format list sorted by size (descending):</span><br><span class="line">    ls -lS</span><br><span class="line"></span><br><span class="line">  - Long format list of all files, sorted by modification date (oldest first):</span><br><span class="line">    ls -ltr</span><br><span class="line"></span><br><span class="line">  - Only list directories:</span><br><span class="line">    ls -d */</span><br></pre></td></tr></table></figure><h1 id="Cheat"><a href="#Cheat" class="headerlink" title="Cheat"></a>Cheat</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>这个漫画是Cheat恶搞man命令查一个命令需要翻几本书的时间，挺有意思的。</p><blockquote><p>cheat：有欺骗的意思，可以直接理解为<strong>舞弊</strong>或者<strong>作弊</strong>。</p></blockquote><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230124231214.png" alt=""></p><h2 id="官方资料-1"><a href="#官方资料-1" class="headerlink" title="官方资料"></a>官方资料</h2><p>github项目地址：<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NoZWF0L2NoZWF0" title="https://github.com/cheat/cheat">cheat/cheat: cheat allows you to create and view interactive cheatsheets on the command-line. It was designed to help remind *nix system administrators of options for commands that they use frequently, but not frequently enough to remember. (github.com)<i class="fa fa-external-link"></i></span></p><p>官方安装教程：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NoZWF0L2NoZWF0L2Jsb2IvbWFzdGVyL0lOU1RBTExJTkcubWQ=" title="https://github.com/cheat/cheat/blob/master/INSTALLING.md">cheat/INSTALLING.md at master · cheat/cheat (github.com)<i class="fa fa-external-link"></i></span></p><h2 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h2><h3 id="类Unix"><a href="#类Unix" class="headerlink" title="类Unix"></a>类Unix</h3><p>类Unix系统可以使用下面一串命令解决。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp \</span><br><span class="line">  &amp;&amp; wget https://github.com/cheat/cheat/releases/download/4.4.0/cheat-linux-amd64.gz \</span><br><span class="line">  &amp;&amp; gunzip cheat-linux-amd64.gz \</span><br><span class="line">  &amp;&amp; chmod +x cheat-linux-amd64 \</span><br><span class="line">  &amp;&amp; sudo mv cheat-linux-amd64 /usr/<span class="built_in">local</span>/bin/cheat</span><br></pre></td></tr></table></figure><p>个人的CenterOs实验如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[zxd@localhost ~]$ <span class="built_in">cd</span> /tmp \</span><br><span class="line">&gt;   &amp;&amp; wget https://github.com/cheat/cheat/releases/download/4.4.0/cheat-linux-amd64.gz \</span><br><span class="line">&gt;   &amp;&amp; gunzip cheat-linux-amd64.gz \</span><br><span class="line">&gt;   &amp;&amp; chmod +x cheat-linux-amd64 \</span><br><span class="line">&gt;   &amp;&amp; sudo mv cheat-linux-amd64 /usr/<span class="built_in">local</span>/bin/cheat</span><br><span class="line">--2023-01-28 18:34:35--  https://github.com/cheat/cheat/releases/download/4.4.0/cheat-linux-amd64.gz</span><br><span class="line">Resolving github.com (github.com)... 20.205.243.166</span><br><span class="line">Connecting to github.com (github.com)|20.205.243.166|:443... connected.</span><br><span class="line">Unable to establish SSL connection.</span><br><span class="line">[zxd@localhost tmp]$ <span class="built_in">cd</span> /tmp   &amp;&amp; wget https://github.com/cheat/cheat/releases/download/4.4.0/cheat-linux-amd64.gz   &amp;&amp; gunzip cheat-linux-amd64.gz   &amp;&amp; chmod +x cheat-linux-amd64   &amp;&amp; sudo mv cheat-linux-amd64 /usr/<span class="built_in">local</span>/bin/cheat</span><br><span class="line">--2023-01-28 18:34:59--  https://github.com/cheat/cheat/releases/download/4.4.0/cheat-linux-amd64.gz</span><br><span class="line">Resolving github.com (github.com)... </span><br><span class="line">... 省略一些安装提示信息</span><br><span class="line"></span><br><span class="line">... github访问比较慢，耐心等待</span><br><span class="line">100%[=============================================================================&gt;] 4,696,443   9.87KB/s   <span class="keyword">in</span> 6m 11s </span><br><span class="line"></span><br><span class="line">2023-01-28 18:41:13 (12.4 KB/s) - ‘cheat-linux-amd64.gz’ saved [4696443/4696443]</span><br></pre></td></tr></table></figure><p>个人的Ubuntu云服务器的实验如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-8-8-ubuntu:~$ <span class="built_in">cd</span> /tmp \</span><br><span class="line">  &amp;&amp; wget https://github.com/cheat/cheat/releases/download/4.4.0/cheat-linux-amd64.gz \</span><br><span class="line">  &amp;&amp; gunzip cheat-linux-amd64.gz \</span><br><span class="line">  &amp;&amp; chmod +x cheat-linux-amd64 \</span><br><span class="line">  &amp;&amp; sudo mv cheat-linux-amd64 /usr/<span class="built_in">local</span>/bin/cheat</span><br><span class="line">--2023-01-28 10:56:00--  https://github.com/cheat/cheat/releases/download/4.4.0/cheat-linux-amd64.gz</span><br><span class="line">... 省略信息</span><br><span class="line">Saving to: ‘cheat-linux-amd64.gz’</span><br><span class="line"></span><br><span class="line">cheat-linux-amd64.gz              100%[==========================================================&gt;]   4.48M   871KB/s    <span class="keyword">in</span> 1m 42s  </span><br><span class="line"></span><br><span class="line">2023-01-28 10:57:43 (44.9 KB/s) - ‘cheat-linux-amd64.gz’ saved [4696443/4696443]</span><br><span class="line"></span><br><span class="line">ubuntu@VM-8-8-ubuntu:/tmp$ cheat</span><br><span class="line">A config file was not found. Would you like to create one now? [Y/n]: y</span><br><span class="line">Would you like to download the community cheatsheets? [Y/n]: y</span><br><span class="line">Cloning community cheatsheets to /home/ubuntu/.config/cheat/cheatsheets/community.</span><br><span class="line">Enumerating objects: 335, <span class="keyword">done</span>.</span><br><span class="line">Counting objects: 100% (335/335), <span class="keyword">done</span>.</span><br><span class="line">Compressing objects: 100% (314/314), <span class="keyword">done</span>.</span><br><span class="line">Total 335 (delta 36), reused 274 (delta 19), pack-reused 0</span><br><span class="line">Cloning personal cheatsheets to /home/ubuntu/.config/cheat/cheatsheets/personal.</span><br><span class="line">Created config file: /home/ubuntu/.config/cheat/conf.yml</span><br><span class="line">Please <span class="built_in">read</span> this file <span class="keyword">for</span> advanced configuration information.</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里可能需要更改版本号（“4.4.0”）和存档（“cheat-linux-amd64.gz”），具体取决于安装平台。</p></blockquote><p>可以阅读 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NoZWF0L2NoZWF0L3JlbGVhc2Vz" title="https://github.com/cheat/cheat/releases">releases page<i class="fa fa-external-link"></i></span> 了解当前命令支持的平台。</p><h3 id="通过-go-install安装"><a href="#通过-go-install安装" class="headerlink" title="通过 go install安装"></a>通过 <code>go install</code>安装</h3><p>如果有GO 1.17 以上的版本，可以通过<code>go install</code>安装cheat。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> install github.com/cheat/cheat/cmd/cheat@latest</span><br></pre></td></tr></table></figure><h3 id="其他安装方式"><a href="#其他安装方式" class="headerlink" title="其他安装方式"></a>其他安装方式</h3><p>下面是官方介绍的其他安装方式。</p><table><thead><tr><th>Package manager</th><th>Package(s)</th></tr></thead><tbody><tr><td>aur</td><td><span class="exturl" data-url="aHR0cHM6Ly9hdXIuYXJjaGxpbnV4Lm9yZy9wYWNrYWdlcy9jaGVhdA==" title="https://aur.archlinux.org/packages/cheat">cheat<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly9hdXIuYXJjaGxpbnV4Lm9yZy9wYWNrYWdlcy9jaGVhdC1iaW4=" title="https://aur.archlinux.org/packages/cheat-bin">cheat-bin<i class="fa fa-external-link"></i></span></td></tr><tr><td>brew</td><td><span class="exturl" data-url="aHR0cHM6Ly9mb3JtdWxhZS5icmV3LnNoL2Zvcm11bGEvY2hlYXQ=" title="https://formulae.brew.sh/formula/cheat">cheat<i class="fa fa-external-link"></i></span></td></tr><tr><td>docker</td><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Jhbm5tYW5uL2RvY2tlci1jaGVhdA==" title="https://github.com/bannmann/docker-cheat">docker-cheat<i class="fa fa-external-link"></i></span></td></tr><tr><td>nix</td><td><span class="exturl" data-url="aHR0cHM6Ly9zZWFyY2gubml4b3Mub3JnL3BhY2thZ2VzP2NoYW5uZWw9dW5zdGFibGUmc2hvdz1jaGVhdCZmcm9tPTAmc2l6ZT01MCZzb3J0PXJlbGV2YW5jZSZ0eXBlPXBhY2thZ2VzJnF1ZXJ5PWNoZWF0" title="https://search.nixos.org/packages?channel=unstable&show=cheat&from=0&size=50&sort=relevance&type=packages&query=cheat">nixos.cheat<i class="fa fa-external-link"></i></span></td></tr><tr><td>snap</td><td><span class="exturl" data-url="aHR0cHM6Ly9zbmFwY3JhZnQuaW8vY2hlYXQ=" title="https://snapcraft.io/cheat">cheat<i class="fa fa-external-link"></i></span></td></tr></tbody></table><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><p>和tldr类似，第一次使用cheat也需要构建“数据库”，但是cheat比tldr的使用体验更好，我们只需要按照提示输入两次<code>y</code>确认即可：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[zxd@localhost tmp]$ cheat </span><br><span class="line">A config file was not found. Would you like to create one now? [Y/n]: y</span><br><span class="line">Would you like to download the community cheatsheets? [Y/n]: y</span><br><span class="line">Cloning community cheatsheets to /home/zxd/.config/cheat/cheatsheets/community.</span><br><span class="line">Enumerating objects: 335, <span class="keyword">done</span>.</span><br><span class="line">Counting objects: 100% (335/335), <span class="keyword">done</span>.</span><br><span class="line">Compressing objects: 100% (314/314), <span class="keyword">done</span>.</span><br><span class="line">Total 335 (delta 36), reused 274 (delta 19), pack-reused 0</span><br><span class="line">Cloning personal cheatsheets to /home/zxd/.config/cheat/cheatsheets/personal.</span><br><span class="line">Created config file: /home/zxd/.config/cheat/conf.yml</span><br><span class="line">Please <span class="built_in">read</span> this file <span class="keyword">for</span> advanced configuration information.</span><br></pre></td></tr></table></figure><p>最后是直接使用，个人感觉要比tldr麻烦事情少很多：</p><blockquote><p>和 tldr的区别是排版的方式有点不同</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[zxd@localhost tmp]$ cheat ls</span><br><span class="line"><span class="comment"># To display everything in &lt;dir&gt;, excluding hidden files:</span></span><br><span class="line">ls &lt;dir&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># To display everything in &lt;dir&gt;, including hidden files:</span></span><br><span class="line">ls -a &lt;dir&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># To display all files, along with the size (with unit suffixes) and timestamp:</span></span><br><span class="line">ls -lh &lt;dir&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># To display files, sorted by size:</span></span><br><span class="line">ls -S &lt;dir&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># To display directories only:</span></span><br><span class="line">ls -d */ &lt;dir&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># To display directories only, include hidden:</span></span><br><span class="line">ls -d .*/ */ &lt;dir&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># To display all files sorted by changed date, most recent first:</span></span><br><span class="line">ls -ltc </span><br><span class="line"></span><br><span class="line"><span class="comment"># To display files sorted by create time:</span></span><br><span class="line">ls -lt</span><br><span class="line"></span><br><span class="line"><span class="comment"># To display files in a single column:</span></span><br><span class="line">ls -1</span><br><span class="line"></span><br><span class="line"><span class="comment"># To show ACLs (MacOS):</span></span><br><span class="line"><span class="comment"># see also `cheat chmod` for `/bin/chmod` options for ACLs</span></span><br><span class="line">/bin/ls -le</span><br><span class="line"></span><br><span class="line"><span class="comment"># To show all the subtree files (Recursive Mode):</span></span><br><span class="line">ls -R</span><br></pre></td></tr></table></figure><p>Uuntu的使用类似：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础使用</span></span><br><span class="line">ubuntu@VM-8-8-ubuntu:/tmp$ cheat cp</span><br><span class="line"><span class="comment"># To copy a file:</span></span><br><span class="line">cp ~/Desktop/foo.txt ~/Downloads/foo.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># To copy a directory:</span></span><br><span class="line">cp -r ~/Desktop/cruise_pics/ ~/Pictures/</span><br><span class="line"></span><br><span class="line"><span class="comment"># To create a copy but ask to overwrite if the destination file already exists:</span></span><br><span class="line">cp -i ~/Desktop/foo.txt ~/Documents/foo.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># To create a backup file with date:</span></span><br><span class="line">cp foo.txt&#123;,.<span class="string">"<span class="variable">$(date +%Y%m%d-%H%M%S)</span>"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># To copy a symlink that points to a directory (and is thus soft) and not</span></span><br><span class="line"><span class="comment"># 'expand' the symlink (aka, preserve its nature as a symlink):</span></span><br><span class="line"><span class="comment"># Note this does NOT work (note trailing '/'):  cp -P /path/to/symlink-dir/</span></span><br><span class="line">cp -P &lt;symlink-dir&gt; &lt;dest-dir&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># To copy sparsely:</span></span><br><span class="line">cp --sparse=always &lt;src&gt; &lt;dest&gt;</span><br></pre></td></tr></table></figure><h1 id="类似项目"><a href="#类似项目" class="headerlink" title="类似项目"></a>类似项目</h1><p>还有更多和cheat以及tldr类似的项目，这里就不过多介绍了。</p><p><a href="https://github.com/cheat/cheat" target="_blank" rel="noopener"><strong>Cheat</strong></a> 允许您在命令行上创建和查看交互式备忘单。它旨在帮助提醒 Linux 系统管理员他们经常使用但不够频繁而无法记住的命令的选项。</p><p><a href="https://cheat.sh/" target="_blank" rel="noopener"><strong>cheat.sh</strong></a> 将来自多个来源（包括 tldr-pages）的备忘单聚合到 1 个统一界面中。</p><p><a href="https://devhints.io/" target="_blank" rel="noopener"><strong>devhints Rico</strong></a> 的备忘单不仅仅关注命令行，还包括大量与编程相关的其他备忘单。</p><p><a href="https://github.com/srsudar/eg" target="_blank" rel="noopener"><strong>eg</strong></a> 在命令行上提供了详细的示例和解释。示例来自存储库，但例如支持显示自定义示例和命令以及默认值。</p><p><a href="https://github.com/gnebbia/kb" target="_blank" rel="noopener"><strong>kb</strong></a> 是一个极简的命令行知识库管理器。 kb 可用于以极简主义和干净的方式组织您的笔记和备忘单。它还支持非文本文档。</p><p><a href="https://github.com/denisidoro/navi" target="_blank" rel="noopener"><strong>navi</strong></a> 是一个交互式备忘单工具，它允许您即时浏览特定示例或完整命令。</p><p><span class="exturl" data-url="aHR0cDovL2Jyb3BhZ2VzLm9yZy8=" title="http://bropages.org/">bropages（已弃用）<i class="fa fa-external-link"></i></span>是对手册页的高度可读性补充。它显示了 Unix 命令的简明、常见示例。这些示例由用户群提交，可以投票赞成或反对；最好的条目是人们在查找命令时最先看到的内容。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>整体体验下来个人比较偏向cheat一点，类Unix系统安装官方的教程一个名称就可以完成，而tldr需要Node环境，同时因为Node更新速度就像喝汤容易导致Linux系统版本或者内核版本低而不支持的问题。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      Linux命令行学习和使用
    
    </summary>
    
    
      <category term="Linux" scheme="https://whitestore.top/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://whitestore.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【Ubuntu】Win11 VmWare虚拟机安装Ubuntu 22.04.1-server</title>
    <link href="https://whitestore.top/2023/01/26/ubuntuvm/"/>
    <id>https://whitestore.top/2023/01/26/ubuntuvm/</id>
    <published>2023-01-26T03:07:39.000Z</published>
    <updated>2023-01-26T03:09:17.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>如标题所说，属于个人虚拟机安装Ubuntu的笔记记录。</p><h1 id="VM安装"><a href="#VM安装" class="headerlink" title="VM安装"></a>VM安装</h1><p>这里建议使用果核的PJ版本，实乃国产良心。</p><a id="more"></a><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2h4aS5jb20vdm13YXJlMTUuaHRtbA==" title="https://www.ghxi.com/vmware15.html">VMware Workstation Pro v16.2.3 官方版+激活密钥 - 果核剥壳 (ghxi.com)<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2h4aS5jb20vdm13YXJlMTUuaHRtbA==" title="https://www.ghxi.com/vmware15.html">VMware Workstation Pro(VM虚拟机) v16.2.5 官方版+激活密钥 - 果核剥壳 (ghxi.com)<i class="fa fa-external-link"></i></span></p><p>新版vmware安装包下载链接：<span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMTBEQm1OUjBiOXhwclUxcXJNOWtYM0E=" title="https://pan.baidu.com/s/10DBmNR0b9xprU1qrM9kX3A">https://pan.baidu.com/s/10DBmNR0b9xprU1qrM9kX3A<i class="fa fa-external-link"></i></span></p><p>提取码：w94s</p><p>vmware16许可证密钥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ZF3R0-FHED2-M80TY-8QYGC-NPKYF</span><br><span class="line"></span><br><span class="line">YF390-0HF8P-M81RQ-2DXQE-M2UT6</span><br><span class="line"></span><br><span class="line">ZF71R-DMX85-08DQY-8YMNC-PPHV8</span><br><span class="line"></span><br><span class="line">FF31K-AHZD1-H8ETZ-8WWEZ-WUUVA</span><br><span class="line"></span><br><span class="line">CV7T2-6WY5Q-48EWP-ZXY7X-QGUWD</span><br><span class="line"></span><br><span class="line">5A02H-AU243-TZJ49-GTC7K-3C61N</span><br><span class="line"></span><br><span class="line">VF5XA-FNDDJ-085GZ-4NXZ9-N20E6</span><br><span class="line"></span><br><span class="line">UC5MR-8NE16-H81WY-R7QGV-QG2D8</span><br><span class="line"></span><br><span class="line">ZG1WH-ATY96-H80QP-X7PEX-Y30V4</span><br><span class="line"></span><br><span class="line">AA3E0-0VDE1-0893Z-KGZ59-QGAVF</span><br></pre></td></tr></table></figure><p>这些都是破解密钥</p><h2 id="下载Ubuntu-22-04-1-server"><a href="#下载Ubuntu-22-04-1-server" class="headerlink" title="下载Ubuntu 22.04.1-server"></a>下载Ubuntu 22.04.1-server</h2><p>进入Ubuntu的中文网站：<span class="exturl" data-url="aHR0cHM6Ly9jbi51YnVudHUuY29tL2Rvd25sb2Fk" title="https://cn.ubuntu.com/download">Ubuntu系统下载 | Ubuntu<i class="fa fa-external-link"></i></span></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108110118.png" alt=""></p><p>根据最新的版本下载即可。本次使用使用USB或者DVD的物理镜像安装。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108110130.png" alt=""></p><h1 id="VM安装Ubuntu"><a href="#VM安装Ubuntu" class="headerlink" title="VM安装Ubuntu"></a>VM安装Ubuntu</h1><p>Vm安装完成之后，我们直接去官方网站下载Ubuntu 22.04.1 的Sever版本，在VM当中我们选择直接创建的新的镜像。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108102308.png" alt=""></p><p>在磁盘中选择下载下来的ISO镜像文件。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108102325.png" alt=""></p><p>选择直接下一步</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108102651.png" alt=""></p><p>选择磁盘大小，这里个人磁盘空间比较充足，选择了30GB。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108102709.png" alt=""></p><h2 id="选择语言"><a href="#选择语言" class="headerlink" title="选择语言"></a>选择语言</h2><p>这里建议使用英文语言：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108102733.png" alt=""></p><h2 id="选择键盘"><a href="#选择键盘" class="headerlink" title="选择键盘"></a>选择键盘</h2><p>下面是选择键盘的方式，默认下一步即可：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108103052.png" alt=""></p><h2 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a>配置网络</h2><p>注意：如果这里配置网络一会安装系统速度可能会较慢，因为ubuntu会从网络上下载更新。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108103137.png" alt=""></p><p>可以选择DHCP获取 IP，有利于新手快速学习，如果读者有IP知识也可以按tab键配置IP相关 地址，如上图中标记。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108103204.png" alt=""></p><p>比如可以参考下面的方式配置网络IP</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108103220.png" alt=""></p><p>配置的固定IP地址如上图所示，地址段根据vm默认即可，DNS为公共可用DNS。</p><h2 id="选择代理"><a href="#选择代理" class="headerlink" title="选择代理"></a>选择代理</h2><p>选择代理，这里直接使用默认的设置即可。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108104922.png" alt=""></p><h2 id="选择软件源"><a href="#选择软件源" class="headerlink" title="选择软件源"></a>选择软件源</h2><p>如果开启联网，ubuntu 默认会选择根据软件源进行下载。如果需要联网更新这里可以配置清华源的地址：</p><p><span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLnR1bmEudHNpbmdodWEuZWR1LmNuL3VidW50dQ==" title="https://mirrors.tuna.tsinghua.edu.cn/ubuntu">https://mirrors.tuna.tsinghua.edu.cn/ubuntu<i class="fa fa-external-link"></i></span></p><blockquote><p>注意：可以选择VM外的粘贴功能粘贴进去，清华源有ubuntu20,有的源没有，此处也可安装完毕配置。</p></blockquote><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108105023.png" alt=""></p><h2 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h2><p>新手建议直接使用官方给的默认分区配置。这里就选择默认的使用整块磁盘自动分区。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108105404.png" alt=""></p><h2 id="磁盘分区信息预览"><a href="#磁盘分区信息预览" class="headerlink" title="磁盘分区信息预览"></a>磁盘分区信息预览</h2><p>最后是分区的信息预览，这里直接<code>Done</code>即可。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108105455.png" alt=""></p><blockquote><p>提示：确认是否继续，继续后会对磁盘进行格式化<strong>会破坏磁盘数据</strong>，如果是宿主机系统重装建议提前备份。</p></blockquote><h2 id="配置系统信息"><a href="#配置系统信息" class="headerlink" title="配置系统信息"></a>配置系统信息</h2><p>配置系统主机名、登录用户和密码。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108105927.png" alt=""></p><h2 id="OpenSSL安装"><a href="#OpenSSL安装" class="headerlink" title="OpenSSL安装"></a>OpenSSL安装</h2><p>这里需要手动勾选一下，按空格键勾选图中的小方框内为小叉子，然后按tab键选择Done继续。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108110443.png" alt=""></p><h2 id="可选安装"><a href="#可选安装" class="headerlink" title="可选安装"></a>可选安装</h2><p>Ubuntu提供一些流行的常见运维工具提供默认安装，比如云服务器的构建，K8S，Docker的软件。</p><blockquote><p>这里个人勾选了docker和powershell。</p></blockquote><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108110611.png" alt=""></p><p>最后等待安装即可。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108110647.png" alt=""></p><p>注意安装过程中可能出现报错，此处为卸载光驱失败了，因为是虚拟机安装，可不用理会，按回车重启即可。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108111357.png" alt=""></p><p>当安装完成之后，最下方的界面会提示重启或者查看全部日志。我们选择重启然后等待Ubuntu做最后的初始化操作即可。</p><p>重启完成之后使用上面系统信息配置的用户登陆即可。注意这个用户<strong>不是ROOT</strong>，但是具备和ROOT相同的权限。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108114929.png" alt=""></p><h1 id="Root用户配置"><a href="#Root用户配置" class="headerlink" title="Root用户配置"></a>Root用户配置</h1><p>Ubuntu 在第一次登陆之后需要设置ROOT用户的密码，切换Root和重新设置密码的命令如下：</p><p>修改root密码</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd root</span><br></pre></td></tr></table></figure><p>切换root账户</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br></pre></td></tr></table></figure><p>注意默认情况下无法用Root远程登陆。</p><h2 id="Root-远程登陆"><a href="#Root-远程登陆" class="headerlink" title="Root 远程登陆"></a>Root 远程登陆</h2><p>默认Ubuntu不允许root远程登录，后期如果想通过root登陆系统则必须修改SSH配置文件中的相关参数 才行。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ssh/sshd_config PermitRootLogin yes</span><br></pre></td></tr></table></figure><p>修改之后需要重启SSHD后台进程：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart sshd</span><br></pre></td></tr></table></figure><h1 id="Xshell-远程连接"><a href="#Xshell-远程连接" class="headerlink" title="Xshell 远程连接"></a>Xshell 远程连接</h1><h2 id="检查设置"><a href="#检查设置" class="headerlink" title="检查设置"></a>检查设置</h2><p>如果在之前的安装步骤中没有安装OpenSSL，可以使用下面的命令安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure><p>在连接之前，需要保证 xshell 所在主机 和 ubuntu( 虚拟机 ) 相互能平通，因为ssh远程连接是通过网络连接的，如果网络不通，就无法连接。</p><p>Ubuntu 系统使用<code>ip addr</code>命令查看网络IP，Windows主机使用<code>ipconfig</code>查看网络IP：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr</span><br></pre></td></tr></table></figure><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108114023.png" alt=""></p><p>Window主机地址如下：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108114350.png" alt=""></p><p>双方向主机Ping一下，如果都能联通，可以进行下一步，否则需要检查网卡配置是否正确。</p><h2 id="Xshell连接配置"><a href="#Xshell连接配置" class="headerlink" title="Xshell连接配置"></a>Xshell连接配置</h2><p>个人使用的版本为Xshell7教育版，在下面的界面中新建一个SSH远程连接，配置如下：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108114709.png" alt=""></p><p>第一次连接Xshell会警告安全性，直接同意即可，接着是提示输入用户名和密码。注意在默认情况下Ubuntu是不能用Root登陆的。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Connecting to 192.168.110.128:22...</span><br><span class="line">Connection established.</span><br><span class="line">To escape to <span class="built_in">local</span> shell, press <span class="string">'Ctrl+Alt+]'</span>.</span><br><span class="line"></span><br><span class="line">Welcome to Ubuntu 22.04.1 LTS (GNU/Linux 5.15.0-57-generic x86_64)</span><br><span class="line"></span><br><span class="line"> * Documentation:  https://help.ubuntu.com</span><br><span class="line"> * Management:     https://landscape.canonical.com</span><br><span class="line"> * Support:        https://ubuntu.com/advantage</span><br><span class="line"></span><br><span class="line">  System information as of Sun Jan  8 06:45:58 AM UTC 2023</span><br><span class="line"></span><br><span class="line">  System load:  0.0078125          Processes:                226</span><br><span class="line">  Usage of /:   41.8% of 13.67GB   Users logged <span class="keyword">in</span>:          1</span><br><span class="line">  Memory usage: 12%                IPv4 address <span class="keyword">for</span> docker0: 172.17.0.1</span><br><span class="line">  Swap usage:   0%                 IPv4 address <span class="keyword">for</span> ens33:   192.168.110.128</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">60 updates can be applied immediately.</span><br><span class="line">To see these additional updates run: apt list --upgradable</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Last login: Sun Jan  8 03:46:40 2023 from 192.168.110.1</span><br><span class="line">xander@xander:~$</span><br></pre></td></tr></table></figure><h1 id="配置apt源"><a href="#配置apt源" class="headerlink" title="配置apt源"></a>配置apt源</h1><p>Ubuntu 使用的是apt命令进行安装的，如果之前未进行软件源，会使用Ubuntu的官网镜像默认的地址，基本等于说是在国外，如果要替换，可以使用下面的方案。</p><p><strong>清华大学</strong>的镜像站的配置网站如下：</p><p><span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLnR1bmEudHNpbmdodWEuZWR1LmNuL2hlbHAvdWJ1bnR1Lw==" title="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">ubuntu | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror<i class="fa fa-external-link"></i></span></p><h2 id="清华大学开源软件源配置方式"><a href="#清华大学开源软件源配置方式" class="headerlink" title="清华大学开源软件源配置方式"></a>清华大学开源软件源配置方式</h2><p>下面直接拷贝网站的内容。</p><p>本镜像仅包含 32/64 位 x86 架构处理器的软件包，在 ARM(arm64, armhf)、PowerPC(ppc64el)、RISC-V(riscv64) 和 S390x 等架构的设备上（对应官方源为ports.ubuntu.com）请使用 <span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLnR1bmEudHNpbmdodWEuZWR1LmNuL2hlbHAvdWJ1bnR1LXBvcnRzLw==" title="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu-ports/">ubuntu-ports 镜像<i class="fa fa-external-link"></i></span>。</p><p><strong>手动替换</strong></p><p>Ubuntu 的软件源配置文件是 <code>/etc/apt/sources.list</code>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">xander@xander:~$ sudo vim /etc/apt/sources.list</span><br><span class="line"><span class="comment"># See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to</span></span><br><span class="line"><span class="comment"># newer versions of the distribution.</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu jammy main restricted</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu jammy main restricted</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Major bug fix updates produced after the final release of the</span></span><br><span class="line"><span class="comment">## distribution.</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu jammy-updates main restricted</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu jammy-updates main restricted</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu</span></span><br><span class="line"><span class="comment">## team. Also, please note that software in universe WILL NOT receive any</span></span><br><span class="line"><span class="comment">## review or updates from the Ubuntu security team.</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu jammy universe</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu jammy universe</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu jammy-updates universe</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu jammy-updates universe</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu</span></span><br><span class="line"><span class="comment">## team, and may not be under a free licence. Please satisfy yourself as to</span></span><br><span class="line"><span class="comment">## your rights to use the software. Also, please note that software in</span></span><br><span class="line"><span class="comment">## multiverse WILL NOT receive any review or updates from the Ubuntu</span></span><br><span class="line"><span class="comment">## security team.</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu jammy multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu jammy multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu jammy-updates multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu jammy-updates multiverse</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## N.B. software from this repository may not have been tested as</span></span><br><span class="line"><span class="comment">## extensively as that contained in the main release, although it includes</span></span><br><span class="line"><span class="comment">## newer versions of some applications which may provide useful features.</span></span><br><span class="line"><span class="comment">## Also, please note that software in backports WILL NOT receive any review</span></span><br><span class="line"><span class="comment">## or updates from the Ubuntu security team.</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu jammy-backports main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu jammy-backports main restricted universe multiverse</span></span><br><span class="line"></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu jammy-security main restricted</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu jammy-security main restricted</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu jammy-security universe</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu jammy-security universe</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu jammy-security multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu jammy-security multiverse</span></span><br></pre></td></tr></table></figure><p>手动替换的方式可以参考网站，因为不同的版本替换方式不太一样，这里为<code>22.04LTS</code>的版本。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预发布软件源，不建议启用</span></span><br><span class="line"><span class="comment"># deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse</span></span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse</span></span><br></pre></td></tr></table></figure><p><strong>命令替换</strong></p><p>命令替换的方式使用下面的命令即可。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo sed -i <span class="string">"s@http://.*archive.ubuntu.com@https://mirrors.tuna.tsinghua.edu.cn@g"</span> /etc/apt/sources.list</span><br><span class="line">sudo sed -i <span class="string">"s@http://.*security.ubuntu.com@https://mirrors.tuna.tsinghua.edu.cn@g"</span> /etc/apt/sources.list</span><br></pre></td></tr></table></figure><h1 id="apt简介"><a href="#apt简介" class="headerlink" title="apt简介"></a>apt简介</h1><ul><li>apt等同于Centos7的yum命令</li><li>apt-get是第一代的包管理工具，最稳定</li><li>apt是改进的包管理工具，比apt-get要先进，官方推荐使用apt来管理软件</li></ul><p>apt和CenterOs系统的区别如下：</p><table><thead><tr><th>操作内容</th><th>Centos6/7</th><th>Debian/Ubuntu</th></tr></thead><tbody><tr><td>1.软件包后缀</td><td>*.rpm</td><td>*.deb</td></tr><tr><td>2.软件源配置文件</td><td>/etc/yum.conf</td><td>/etc/apt/sources.list</td></tr><tr><td>3.更新软件包列表</td><td>yum makecache fast</td><td>apt update</td></tr><tr><td>4.从软件仓库安装软件</td><td>yum install package</td><td>apt install package</td></tr><tr><td>5.安装本地软件包</td><td>rpm -i pkg.rpm</td><td>dpkg -i pkg.deb</td></tr><tr><td>6.删除软件包</td><td>yum remove package</td><td>apt remove package</td></tr><tr><td>7.获取某软件包的信息</td><td>yum search package</td><td>apt search package</td></tr></tbody></table><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><span class="exturl" data-url="aHR0cHM6Ly9tZWZqLmNvbS5jbi9sdXIzNDM3Lmh0bWw=" title="https://mefj.com.cn/lur3437.html">Ubuntu 20.04 live server版安装(详细版) | 运维密码 (mefj.com.cn)<i class="fa fa-external-link"></i></span></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      请输入描述信息
    
    </summary>
    
    
      <category term="Linux" scheme="https://whitestore.top/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://whitestore.top/tags/Linux/"/>
    
  </entry>
  
</feed>
