<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>爱看书的阿东</title>
  
  <subtitle>赐他一块白色石头，石头上写着新名</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://whitestore.top/"/>
  <updated>2023-02-28T09:19:06.634Z</updated>
  <id>https://whitestore.top/</id>
  
  <author>
    <name>阿东</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Linux】getline解释</title>
    <link href="https://whitestore.top/2023/02/28/getlines/"/>
    <id>https://whitestore.top/2023/02/28/getlines/</id>
    <published>2023-02-28T09:18:00.000Z</published>
    <updated>2023-02-28T09:19:06.634Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><p>先说一下重要的知识点：</p><ul><li><code>getline;</code>在<code>awk</code>中可以用于控制“循环”。</li><li><code>getline;</code>之后，awk会改变对应的NF，NR，FNR和$0等内部变量</li><li><code>getline;</code>拿到的是<strong>下一行</strong>而不是当前行，概念想象为<code>++i</code>操作即可。</li></ul><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>getline命令改变了awk的运行逻辑，是awk命令不可或缺的一部分。awk本质上就是一个for循环，它每次对输入文件的一行进行处理，然后转而执行下一行，直到整个文件的每一行都被执行完毕。整个过程是自动的无需做什么。</p><p><code>getline</code>命令却可以让你去<strong>控制循环</strong>。当然，getline命令执行后，awk会设置NF，NR，FNR和$0等这些<strong>内部变量</strong>。</p><a id="more"></a><h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><p>我们先看一个简单的例子，打印出从1到10之间的偶数：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[zxd@localhost kafka2.<span class="number">8</span>.X]$ seq <span class="number">10</span> <span class="params">| awk '&#123;getline; print $0&#125;'</span></span><br><span class="line"><span class="params">2</span></span><br><span class="line"><span class="params">4</span></span><br><span class="line"><span class="params">6</span></span><br><span class="line"><span class="params">8</span></span><br><span class="line"><span class="params">10</span></span><br></pre></td></tr></table></figure><p>这个命令的的执行逻辑是执行一个for循环从1到10，在循环内部先执行<code>getline;</code>然后打印<code>$0</code>，<code>$0</code>指向的就是当前的变量，注意<code>getline;</code>获取的是<strong>获取当前行的下一行</strong>，类似我们编程语言的<code>++i</code>，注意<code>getline;</code>之后，awk会改变对应的NF，NR，FNR和$0等内部变量，所以<code>$0</code>值会随着遍历改变，最后实现打印偶数效果。</p><p>根据上面的介绍我们可以推导出打印奇数的逻辑：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[zxd@localhost kafka2.8.X]$ seq 10 | awk <span class="string">'&#123; print $0;getline;&#125;'</span></span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">7</span><br><span class="line">9</span><br></pre></td></tr></table></figure><h1 id="临时变量使用"><a href="#临时变量使用" class="headerlink" title="临时变量使用"></a>临时变量使用</h1><p>奇偶行对调打印，原来在奇数行的内容将其打印在偶数行，原来在偶数行的内容将其打印在奇数行，要实现这个功能，需要在循环中使用临时变量：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seq 10 | awk <span class="string">'&#123;getline tmp; print tmp; print $0&#125;'</span></span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[zxd@localhost kafka2.8.X]$ seq 10 | awk <span class="string">'&#123;getline tmp; print tmp; print $0&#125;'</span></span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">8</span><br><span class="line">7</span><br><span class="line">10</span><br><span class="line">9</span><br></pre></td></tr></table></figure><h1 id="文件合并"><a href="#文件合并" class="headerlink" title="文件合并"></a>文件合并</h1><p>在上面的例子当中<code>tmp</code>变量是不会改变的。</p><p>getline也可以从另外一个文件中读取内容。下面例子实现将两个文件的每一行都打印在一行上：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vim b.txt</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">vim c.txt</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">[zxd@localhost ~]$ awk <span class="string">'&#123;printf "%s ", $0; getline &lt; "c.txt"; print $0&#125;'</span> b.txt </span><br><span class="line">1 6</span><br><span class="line">2 7</span><br><span class="line">3 8</span><br><span class="line">4 9</span><br><span class="line">5 10</span><br></pre></td></tr></table></figure><h1 id="日期获取"><a href="#日期获取" class="headerlink" title="日期获取"></a>日期获取</h1><p>getline也可以用来执行一个UNIX命令，并得到它的输出。下面例子通过getline得到系统的当前时间：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN &#123;"date" | getline; close("date"); print $0&#125;'</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zxd@localhost ~]$ awk <span class="string">'BEGIN &#123;"date" | getline; close("date"); print $0&#125;'</span></span><br><span class="line">Wed Mar  1 00:34:01 CST 2023</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYmVpY2hlbmdmL2FydGljbGUvZGV0YWlscy81MTM2NzMxMQ==" title="https://blog.csdn.net/xibeichengf/article/details/51367311"># awk getline命令解析<i class="fa fa-external-link"></i></span></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      getline介绍）
    
    </summary>
    
    
      <category term="Linux" scheme="https://whitestore.top/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://whitestore.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】awk命令介绍</title>
    <link href="https://whitestore.top/2023/02/28/awkstudy/"/>
    <id>https://whitestore.top/2023/02/28/awkstudy/</id>
    <published>2023-02-28T09:16:48.000Z</published>
    <updated>2023-02-28T09:19:26.986Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p><code>Awk</code>是一种用于高级文本处理的通用脚本语言，其主要用作报告和分析工具，与大多数其他程序性编程语言不同，<code>Awk</code>是数据驱动的，也就是说需要定义一组针对输入文本要执行的操作，然后其获取输入数据，对其进行转换，然后将结果发送到标准输出。</p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk [ -F fs ] [ -v <span class="keyword">var</span>=value ] [ <span class="string">'prog'</span> | -f progfile ] [ file ... ]</span><br></pre></td></tr></table></figure><h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><ul><li><code>-F fs</code>: 将输入字段分隔符设置为正则表达式<code>fs</code>。</li><li><code>-v var=value</code>: 在执行<code>awk</code>程序之前，将值赋值给变量<code>var</code>。</li><li><code>&#39;prog&#39;</code>: <code>awk</code>程序。</li><li><code>-f progfile</code>: 指定文件<code>progfile</code>，其中包含要执行的<code>awk</code>程序。</li><li><code>file ...</code>: 由指定的<code>awk</code>程序处理的文件。</li></ul><a id="more"></a><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>示例文件<code>example.txt</code>文件内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Bucks Milwaukee    <span class="number">60</span> <span class="number">22</span> <span class="number">0.732</span> </span><br><span class="line">Raptors Toronto    <span class="number">55</span> <span class="number">24</span> <span class="number">0.707</span> </span><br><span class="line"><span class="number">76</span>ers Philadelphia <span class="number">51</span> <span class="number">31</span> <span class="number">0.622</span></span><br><span class="line">Celtics Boston     <span class="number">33</span> <span class="number">33</span> <span class="number">0.598</span></span><br><span class="line">Pacers Indiana     <span class="number">30</span> <span class="number">34</span> <span class="number">0.585</span></span><br></pre></td></tr></table></figure><p>输出<code>example.txt</code>的第<code>3</code>个字段。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'&#123; print $3 &#125;'</span> example.txt</span><br><span class="line"># 60</span><br><span class="line"># 55</span><br><span class="line"># 51</span><br><span class="line"># 33</span><br><span class="line"># 30</span><br></pre></td></tr></table></figure><p>使用正则表达式匹配出以<code>R</code>开头的组。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'/^R/ &#123; print $1,$2,$3,$4 &#125;'</span> example.txt</span><br><span class="line"># Raptors Toronto 55 24</span><br></pre></td></tr></table></figure><p>使用<code>BEGIN</code>以及<code>END</code>输出在处理记录之前与之后执行的操作，处理过程为输出第二个字段包含<code>Tor</code>的组。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN &#123; print "Start Processing" &#125;; $2 ~ /Tor/ &#123;print $1,$2,$3,$4 &#125;; END &#123; print "End Processing" &#125;'</span> example.txt</span><br><span class="line"># Start Processing</span><br><span class="line"># Raptors Toronto 55 24</span><br><span class="line"># End Processing</span><br></pre></td></tr></table></figure><h1 id="每日一题"><a href="#每日一题" class="headerlink" title="每日一题"></a>每日一题</h1><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1dpbmRydW5uZXJNYXgvRXZlcnlEYXkvYmxvYi9tYXN0ZXIvTGludXgvYXdrJUU1JTkxJUJEJUU0JUJCJUE0Lm1k" title="https://github.com/WindrunnerMax/EveryDay/blob/master/Linux/awk%E5%91%BD%E4%BB%A4.md">EveryDay/awk命令.md at master · WindrunnerMax/EveryDay · GitHub<i class="fa fa-external-link"></i></span></p><h1 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h1><p>[[【Linux】getline解释]]</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><span class="exturl" data-url="aHR0cHM6Ly9saW51eGl6ZS5jb20vcG9zdC9hd2stY29tbWFuZC8=" title="https://linuxize.com/post/awk-command/">https://linuxize.com/post/awk-command/<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY29tcHV0ZXJob3BlLmNvbS91bml4L3Vhd2suaHRt" title="https://www.computerhope.com/unix/uawk.htm">https://www.computerhope.com/unix/uawk.htm<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS9saW51eC9saW51eC1jb21tLWF3ay5odG1s" title="https://www.runoob.com/linux/linux-comm-awk.html">https://www.runoob.com/linux/linux-comm-awk.html<i class="fa fa-external-link"></i></span></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      awk
    
    </summary>
    
    
      <category term="Linux" scheme="https://whitestore.top/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://whitestore.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【JVM】Try to Avoid -XX UseGCLogFileRotation</title>
    <link href="https://whitestore.top/2023/02/02/usegclogfilerotation/"/>
    <id>https://whitestore.top/2023/02/02/usegclogfilerotation/</id>
    <published>2023-02-02T04:14:30.000Z</published>
    <updated>2023-02-02T04:17:21.940Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Try-to-Avoid-XX-UseGCLogFileRotation"><a href="#Try-to-Avoid-XX-UseGCLogFileRotation" class="headerlink" title="Try to Avoid -XX:+UseGCLogFileRotation"></a>Try to Avoid -XX:+UseGCLogFileRotation</h1><p>Source：<span class="exturl" data-url="aHR0cHM6Ly9kem9uZS5jb20vYXJ0aWNsZXMvdHJ5LXRvLWF2b2lkLXh4dXNlZ2Nsb2dmaWxlcm90YXRpb24=" title="https://dzone.com/articles/try-to-avoid-xxusegclogfilerotation">https://dzone.com/articles/try-to-avoid-xxusegclogfilerotation<i class="fa fa-external-link"></i></span></p><p>Developers take advantage of the JVM argument -XX:+UseGCLogFileRotation to rotate GC log files.</p><p>开发人员利用JVM参数-XX:+UseGCLogFileRotation来递换GC日志文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:/home/GCEASY/gc.log -</span><br><span class="line">XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=<span class="number">5</span> -XX:GCLogFileSize=<span class="number">20</span>M<span class="string">"</span></span><br></pre></td></tr></table></figure><p>As shown above, the JVM will rotate the GC log file whenever its size reaches 20MB. It will generate up to five files, with extensions <code>gc.log.0</code>,  <code>gc.log.1</code>, <code>gc.log.2</code>, <code>gc.log.3</code>, and <code>gc.log.4</code>.</p><p>如上所示的配置会产生5个日志文件，并且每个日志文件有20M。</p><a id="more"></a><h1 id="Losing-Old-GC-Logs-日志丢失"><a href="#Losing-Old-GC-Logs-日志丢失" class="headerlink" title="Losing Old GC Logs 日志丢失"></a>Losing Old GC Logs 日志丢失</h1><p>Suppose you configured  <code>-XX:NumberOfGCLogFiles=5</code>, then over a period of time, five GC log files will be created:</p><p>假设你配置了<code>-XX:NumberOfGCLogFiles=5</code>，那么在一段时期内，将创建五个GC日志文件。</p><ul><li><strong>gc.log.0</strong> ← <em>oldest GC Log content</em></li><li><strong>gc.log.1</strong></li><li><strong>gc.log.2</strong></li><li><strong>gc.log.3</strong></li><li><strong>gc.log.4</strong> ← <em>latest GC Log content</em></li></ul><p>The most recent GC log contents will be written to <code>gc.log.4</code> and old GC log contents will be present in <code>gc.log.0</code>.</p><p>最新的GC日志内容将被写入<code>gc.log.4</code>，旧的GC日志内容将出现在<code>gc.log.0</code>。</p><p>When the application starts to generate more GC logs than the configured  <code>-XX:NumberOfGCLogFiles</code>, in this case, five, then old GC log contents in <code>gc.log.0</code> will be deleted. New GC events will be written to  <code>gc.log.0</code>. It means that you will end up not having all the generated GC logs. You will lose the visibility of all events.</p><p>当应用程序配置的<code>-XX:NumberOfGCLogFiles</code>产生更多的GC日志时（在本例中是5个），<code>gc.log.0</code>中的旧GC日志内容将被删除。新的GC日志将被写入<code>gc.log.0</code>。这意味着会存在旧日志文件的覆盖现象，将<strong>失去所有日志的可见性</strong>。</p><h1 id="Mixed-Up-GC-Logs-混杂日志"><a href="#Mixed-Up-GC-Logs-混杂日志" class="headerlink" title="Mixed-Up GC Logs 混杂日志"></a>Mixed-Up GC Logs 混杂日志</h1><p>Suppose an application has created five GC log files, including:</p><p>假设一个应用程序创建了五个GC日志文件，包括：</p><ul><li><strong>gc.log.0</strong></li><li><strong>gc.log.1</strong></li><li><strong>gc.log.2</strong></li><li><strong>gc.log.3</strong></li><li><strong>gc.log.4</strong></li></ul><p>Then, let’s say you are restarting the application. Now, new GC logs will be written to <code>gc.log.0</code> file and old GC log content will be present in <code>gc.log.1</code>, <code>gc.log.2</code>, <code>gc.log.3</code>, <code>gc.log.4</code>, etc.</p><p>然后，假设你正在重启应用程序。现在新的GC日志将被写入<code>gc.log.0</code>文件，而旧的GC日志内容将出现在<code>gc.log.1</code>、<code>gc.log.2</code>、<code>gc.log.3</code>、<code>gc.log.4</code>。</p><ul><li><strong>gc.log.0</strong> ← GC log file content after restart</li><li><strong>gc.log.1</strong> ← GC log file content before restart</li><li><strong>gc.log.2</strong> ← GC log file content before restart</li><li><strong>gc.log.3</strong> ← GC log file content before restart</li><li><strong>gc.log.4</strong> ← GC log file content before restart</li></ul><p>So, your new GC log contents get mixed up with old GC logs. Thus, to mitigate this problem, you might have to move all the old GC logs to a different folder before you restart the application.</p><p>所以新GC日志和旧的GC日志会混合在一起，为了缓解这个问题，你可能要在重启应用程序之前把所有旧的GC日志移到一个不同的文件夹里。</p><h1 id="Forwarding-GC-Logs-to-a-Central-Location-将GC日志转发到一个中心位置"><a href="#Forwarding-GC-Logs-to-a-Central-Location-将GC日志转发到一个中心位置" class="headerlink" title="Forwarding GC Logs to a Central Location 将GC日志转发到一个中心位置"></a>Forwarding GC Logs to a Central Location 将GC日志转发到一个中心位置</h1><p>In this approach, the current active file to which GC logs are written is marked with the extension  <code>.current</code>. For example, if GC events are currently written to the file <code>gc.log.3</code>, it would be named as: <code>gc.log.3.current</code>.</p><p>在这种方法中，当前写入GC日志的活动文件被标记为扩展名<code>.current</code>。例如，如果GC事件当前被写入文件<code>gc.log.3</code>，它将被命名为。 <code>gc.log.3.current</code>。</p><p>If you want to forward GC logs from each server to a central location, then most DevOps engineers use  <code>rsyslog</code>. However, this file naming convention poses a significant challenge to use <code>rsyslog</code>, as <span class="exturl" data-url="aHR0cDovL3d3dy5wbGFuZXRjb2JhbHQubmV0L3NkYi9mb3J3YXJkX2djX2xvZ3Muc2h0bWw=" title="http://www.planetcobalt.net/sdb/forward_gc_logs.shtml">described in this blog<i class="fa fa-external-link"></i></span>.</p><p>如果你想把每台服务器的GC日志转发到一个中心位置，那么大多数DevOps工程师会使用<code>rsyslog</code>。然而，这种文件命名惯例给使用<code>rsyslog</code>带来了巨大的挑战，正如<span class="exturl" data-url="aHR0cDovL3d3dy5wbGFuZXRjb2JhbHQubmV0L3NkYi9mb3J3YXJkX2djX2xvZ3Muc2h0bWw=" title="http://www.planetcobalt.net/sdb/forward_gc_logs.shtml">这篇博客所述<i class="fa fa-external-link"></i></span>。</p><h1 id="Tooling-工具"><a href="#Tooling-工具" class="headerlink" title="Tooling 工具"></a>Tooling 工具</h1><p>Now, to analyze the GC log file using the GC tools such as (<span class="exturl" data-url="aHR0cHM6Ly9nY2Vhc3kuaW8v" title="https://gceasy.io/">GCeasy<i class="fa fa-external-link"></i></span>, GCViewer, etc.), you will have to upload multiple GC log files instead of just one single GC Log file.</p><p>现在，为了使用GC工具分析GC日志文件，如（<span class="exturl" data-url="aHR0cHM6Ly9nY2Vhc3kuaW8v" title="https://gceasy.io/">GCeasy<i class="fa fa-external-link"></i></span>, GCViewer等），将不得不上传多个GC日志文件，而不是只有一个GC日志文件。</p><blockquote><p>显然非常麻烦并且非常反人类。</p></blockquote><h1 id="Recommended-Solution-推荐方案"><a href="#Recommended-Solution-推荐方案" class="headerlink" title="Recommended Solution 推荐方案"></a>Recommended Solution 推荐方案</h1><p>We can suffix the GC log file with the time stamp at which the JVM was restarted, then the GC Log file locations will become unique. Then, new GC logs will not override the old GC logs. It can be achieved by suffixing <code>%t</code> to the GC log file name, as shown below:</p><p>我们可以在GC日志文件后缀加入<strong>JVM重启的时间戳</strong>（解决这个问题），那么GC日志文件的位置将变得独一无二。然后新的GC日志就不会覆盖旧的GC日志了。这可以通过在GC日志文件名后缀<code>%t</code>来实现，如下所示：</p><blockquote><p>“-XX:+PrintGCDetails -XX:+PrintGCDateStamps <strong>-Xloggc:/home/GCEASY/gc-%t.log</strong>“</p></blockquote><p> <code>%t</code> suffixes timestamp to the GC log file in the format:  <code>YYYY-MM-DD_HH-MM-SS</code>. So, the generated GC log file name will start to look like: <code>gc-2019-01-29_20-41-47.log</code>.</p><p> <code>%t</code>后缀为GC日志文件的时间戳，格式为:  <code>yyyy-mm-dd_hh-mm-ss</code>。因此，生成的GC日志文件名将开始看起来像： <code>gc-2019-01-29_20-41-47.log</code>.</p><p>This simple solution addresses all the shortcomings of <code>-XX:+UseGCLogFileRotation</code>.</p><p><strong>这个简单的解决方案解决了<code>-XX:+UseGCLogFileRotation</code>的所有缺点。</strong></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      JVM相关参数解释
    
    </summary>
    
    
      <category term="java-jvm" scheme="https://whitestore.top/categories/java-jvm/"/>
    
    
      <category term="jvm" scheme="https://whitestore.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】Linux命令快速学习神器tldr、cheat介绍和使用</title>
    <link href="https://whitestore.top/2023/01/28/tldrcheat/"/>
    <id>https://whitestore.top/2023/01/28/tldrcheat/</id>
    <published>2023-01-28T03:42:10.000Z</published>
    <updated>2023-01-28T03:43:26.380Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>本文介绍tldr和Cheat等实用工具的安装和使用，这些工具虽然本身不能替代<code>man</code>、<code>info</code>等命令，但是在很多时候想要快速学习和掌握命令但是忘记常见用法非常有帮助。</p><blockquote><p>个人看法：对于非运维人员简直是神器。</p></blockquote><p><strong>tldr</strong>：全称 too long, Don’t read，翻译成中文就是太长不想阅读，比–help或者man这些传统手册更便捷、更便于使用。<br><strong>cheat</strong>：作弊。</p><p>这两个命令有什么用？这里简单举个例子就知道了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-8-8-ubuntu:~$ sudo tldr ls</span><br><span class="line"></span><br><span class="line">  ls</span><br><span class="line"></span><br><span class="line">  List directory contents.</span><br><span class="line">  More information: https://www.gnu.org/software/coreutils/ls.</span><br><span class="line"></span><br><span class="line">  - List files one per line:</span><br><span class="line">    ls -1</span><br><span class="line"></span><br><span class="line">  - List all files, including hidden files:</span><br><span class="line">    ls -a</span><br><span class="line"></span><br><span class="line">  - List all files, with trailing / added to directory names:</span><br><span class="line">    ls -F</span><br><span class="line"></span><br><span class="line">  - Long format list (permissions, ownership, size, and modification date) of all files:</span><br><span class="line">    ls -la</span><br><span class="line"></span><br><span class="line">  - Long format list with size displayed using human-readable units (KiB, MiB, GiB):</span><br><span class="line">    ls -lh</span><br><span class="line"></span><br><span class="line">  - Long format list sorted by size (descending):</span><br><span class="line">    ls -lS</span><br><span class="line"></span><br><span class="line">  - Long format list of all files, sorted by modification date (oldest first):</span><br><span class="line">    ls -ltr</span><br><span class="line"></span><br><span class="line">  - Only list directories:</span><br><span class="line">    ls -d */</span><br></pre></td></tr></table></figure><h1 id="内容概览"><a href="#内容概览" class="headerlink" title="内容概览"></a>内容概览</h1><ol><li>Ubuntu和CenterOs介绍和安装<strong>tldr</strong>命令。<ol><li>CenterOs和Ubuntu的安装方式使用</li><li>Ubuntu的常见问题和解决方案。</li></ol></li><li>Ubuntu和CenterOs介绍和安装<strong>cheat</strong>命令。<ol><li>安装验证和使用</li><li>Ubuntu和CenterOs处理方式一致</li></ol></li><li>类似项目列举。</li></ol><a id="more"></a><h1 id="官方资料"><a href="#官方资料" class="headerlink" title="官方资料"></a>官方资料</h1><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230125221920.png" alt=""></p><p>在线wiki搜索：<span class="exturl" data-url="aHR0cHM6Ly90bGRyLm9zdGVyYS5pby8=" title="https://tldr.ostera.io/">tldr | simplified, community driven man pages (ostera.io)<i class="fa fa-external-link"></i></span><br>（注意国内访问比较慢，需要自带魔法）</p><p>官方的安装介绍页面地址：<span class="exturl" data-url="aHR0cHM6Ly90bGRyLnNoLyNpbnN0YWxsYXRpb24=" title="https://tldr.sh/#installation">https://tldr.sh/#installation<i class="fa fa-external-link"></i></span></p><p>tldr项目地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RsZHItcGFnZXMvdGxkcg==" title="https://github.com/tldr-pages/tldr">https://github.com/tldr-pages/tldr<i class="fa fa-external-link"></i></span></p><h1 id="tldr"><a href="#tldr" class="headerlink" title="tldr"></a>tldr</h1><h2 id="Ubuntu安装tldr"><a href="#Ubuntu安装tldr" class="headerlink" title="Ubuntu安装tldr"></a>Ubuntu安装tldr</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Ubuntu 安装比较简单，直接使用<code>sudo apt-get install tldr</code>安装。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install tldr</span><br></pre></td></tr></table></figure><p>如果上面的命令安装之后依然无法使用，可以按照下面的命令进行安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install npm</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nodejs-legacy</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install n -g</span><br></pre></td></tr></table></figure><p>注意这里有两种方式，一种是使用latest版本，另外一种是使用stable版本，个人建议使用stable版本，如果Ubuntu的系统版本比较低，则需要降低node版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo n stable</span><br><span class="line">（或 sudo n latest）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g tldr</span><br></pre></td></tr></table></figure><p>当然也可以不使用nodeJS，也可以使用<code>pip</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install tldr</span><br></pre></td></tr></table></figure><p>如果是Mac系统就十分简单了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install tldr</span><br></pre></td></tr></table></figure><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>在ubuntu当中验证直接使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-8-8-ubuntu:~$ tldr</span><br><span class="line">tldr - Simplified and community-driven man pages</span><br><span class="line"></span><br><span class="line">Usage: tldr [-v|--version] </span><br><span class="line">            ((-u|--update) | [-p|--platform PLATFORM] COMMAND | (-a|--about))</span><br><span class="line">  tldr Client program</span><br><span class="line"></span><br><span class="line">Available options:</span><br><span class="line">  -h,--help                Show this help text</span><br><span class="line">  -v,--version             Show version</span><br><span class="line">  -u,--update              Update offline cache of tldr pages</span><br><span class="line">  -p,--platform PLATFORM   Prioritize specfic platform while searching. Valid</span><br><span class="line">                           values include linux, osx, windows, sunos</span><br><span class="line">  COMMAND                  name of the command</span><br><span class="line">  -a,--about               About this program</span><br></pre></td></tr></table></figure><h2 id="Ubuntu安装常见问题"><a href="#Ubuntu安装常见问题" class="headerlink" title="Ubuntu安装常见问题"></a>Ubuntu安装常见问题</h2><h3 id="No-tldr-entry-for-xxx"><a href="#No-tldr-entry-for-xxx" class="headerlink" title="No tldr entry for xxx"></a>No tldr entry for xxx</h3><p>Ubuntu安装tldr使用<code>tldr ls</code>之后，很有可能出现类似<code>No tldr entry for ls</code>的命令，出现这种情况可能有下面两种情况：</p><ul><li>首次安装需要更新tldr的“数据库”。</li><li>当天用户安装使用<code>sudo</code>，tldr的数据库没法访问。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-8-8-ubuntu:~$ tldr ls</span><br><span class="line">No tldr entry <span class="keyword">for</span> ls</span><br></pre></td></tr></table></figure><p>更新tldr的数据库：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-8-8-ubuntu:~$ sudo tldr --update</span><br><span class="line">✔ Updating...</span><br><span class="line">✔ Creating index...</span><br></pre></td></tr></table></figure><p>当然也可以使用<code>tldr -u</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-8-8-ubuntu:~$ sudo tldr --u</span><br></pre></td></tr></table></figure><p><strong>sudo安装使用</strong></p><p>个人的云服务器ubuntu使用了<code>sudo</code>安装之后，需要使用<code>sudo tldr</code>才可以正常使用，因为日常登录的用户为<code>ubuntu</code>用户，安装的过程全部使用<code>sudo</code>，查询某个命令也需要使用root身份进行查询。</p><p>如果出现<code>No tldr entry for xxx</code>，有可能是你用的<code>sudo</code>安装但是当前的用户却没有<code>sudo</code>的权限。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-8-8-ubuntu:~$ sudo tldr ls</span><br><span class="line"></span><br><span class="line">  ls</span><br><span class="line"></span><br><span class="line">  List directory contents.</span><br><span class="line">  More information: https://www.gnu.org/software/coreutils/ls.</span><br><span class="line"></span><br><span class="line">  - List files one per line:</span><br><span class="line">    ls -1</span><br><span class="line"></span><br><span class="line">  - List all files, including hidden files:</span><br><span class="line">    ls -a</span><br><span class="line"></span><br><span class="line">  - List all files, with trailing / added to directory names:</span><br><span class="line">    ls -F</span><br><span class="line"></span><br><span class="line">  - Long format list (permissions, ownership, size, and modification date) of all files:</span><br><span class="line">    ls -la</span><br><span class="line"></span><br><span class="line">  - Long format list with size displayed using human-readable units (KiB, MiB, GiB):</span><br><span class="line">    ls -lh</span><br><span class="line"></span><br><span class="line">  - Long format list sorted by size (descending):</span><br><span class="line">    ls -lS</span><br><span class="line"></span><br><span class="line">  - Long format list of all files, sorted by modification date (oldest first):</span><br><span class="line">    ls -ltr</span><br><span class="line"></span><br><span class="line">  - Only list directories:</span><br><span class="line">    ls -d */</span><br></pre></td></tr></table></figure><h3 id="nodeJs版本降级"><a href="#nodeJs版本降级" class="headerlink" title="nodeJs版本降级"></a>nodeJs版本降级</h3><p>版本降级相关资料参考自：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZhYnVsb3VzMTExMS9hcnRpY2xlL2RldGFpbHMvODQ5ODM4Njk=" title="https://blog.csdn.net/Fabulous1111/article/details/84983869">https://blog.csdn.net/Fabulous1111/article/details/84983869<i class="fa fa-external-link"></i></span></p><h4 id="（1）安装node版本管理模块n"><a href="#（1）安装node版本管理模块n" class="headerlink" title="（1）安装node版本管理模块n"></a>（1）安装node版本管理模块n</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install n -g</span><br></pre></td></tr></table></figure><p>下边步骤请根据自己需要选择</p><h4 id="（2）安装稳定版"><a href="#（2）安装稳定版" class="headerlink" title="（2）安装稳定版"></a>（2）安装稳定版</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo n stable</span><br></pre></td></tr></table></figure><h4 id="（3）安装最新版"><a href="#（3）安装最新版" class="headerlink" title="（3）安装最新版"></a>（3）安装最新版</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo n latest</span><br></pre></td></tr></table></figure><h4 id="（4）-版本降级-升级"><a href="#（4）-版本降级-升级" class="headerlink" title="（4） 版本降级/升级"></a>（4） 版本降级/升级</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo n 版本号</span><br></pre></td></tr></table></figure><h4 id="（5）检测目前安装了哪些版本的node"><a href="#（5）检测目前安装了哪些版本的node" class="headerlink" title="（5）检测目前安装了哪些版本的node"></a>（5）检测目前安装了哪些版本的node</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n</span><br></pre></td></tr></table></figure><p>提示内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  ο node&#x2F;16.15.1</span><br><span class="line">    node&#x2F;18.13.0</span><br><span class="line">    node&#x2F;19.5.0</span><br><span class="line"></span><br><span class="line">Use up&#x2F;down arrow keys to select a version, return key to install, d to delete, q to quit</span><br></pre></td></tr></table></figure><h4 id="切换版本（不会删除已经安装的其他版本）"><a href="#切换版本（不会删除已经安装的其他版本）" class="headerlink" title="切换版本（不会删除已经安装的其他版本）"></a>切换版本（不会删除已经安装的其他版本）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n 版本号</span><br></pre></td></tr></table></figure><p>比如：<code>n 16.15.1</code></p><h4 id="（7）删除版本"><a href="#（7）删除版本" class="headerlink" title="（7）删除版本"></a>（7）删除版本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo n rm 版本号</span><br></pre></td></tr></table></figure><h4 id="（8）直接移除Nodejs"><a href="#（8）直接移除Nodejs" class="headerlink" title="（8）直接移除Nodejs"></a>（8）直接移除Nodejs</h4><p>PS：注意不同的操作系统命令会有差别，这里为Ubuntu的卸载方式</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove nodejs</span><br></pre></td></tr></table></figure><h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g n</span><br><span class="line"></span><br><span class="line">sudo n install 16.15.1 <span class="comment"># 太新的也会有问题</span></span><br></pre></td></tr></table></figure><p>以上就是ubuntu常见问题和处理。</p><h2 id="CenterOs-安装-tldr"><a href="#CenterOs-安装-tldr" class="headerlink" title="CenterOs 安装 tldr"></a>CenterOs 安装 tldr</h2><p>CenterOs的安装方式和Ubuntu类似，这里展示安装Node环境之后安装tldr并使用的过程。</p><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><ol><li>安装NodeJs，如果嫌麻烦可以直接安装<code>sudo yum install -y npm</code>。</li></ol><p>[[【Linux】NodeJs 安装和环境变量配置]]</p><ol start="2"><li>我们使用官方提供的命令安装。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g tldr</span><br></pre></td></tr></table></figure><ol start="3"><li>如果是使用NodeJs环境变量设置的方式安装，需要设置软链接，tldr命令默认会安装到<code>nodeJs</code>安装路径的<strong>Bin</strong>目录下面，如果不好理解，可以参考下面的软链接构建命令。</li></ol><blockquote><p>还有一种方式是在Path中设置<code>/xx/nodejs/bin</code> 为环境变量</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zxd@localhost ~]$ sudo ln -s /opt/nodeJs/bin/tldr /usr/<span class="built_in">local</span>/bin</span><br><span class="line">[sudo] password <span class="keyword">for</span> zxd:</span><br></pre></td></tr></table></figure><blockquote><p>如果软链接路径构建错误，可以使用<code>sudo ln -fs /opt/nodeJs/bin/tldr /usr/local/bin</code>加入 <code>-f</code>参数强制覆盖之前的软链接。</p></blockquote><h3 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h3><p>因为构建了<code>tldr</code>软链接，我们可以再任意路径使用这个命令。如果敲入<code>tldr</code>命令出现下面的提示证明安装成功：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">[zxd@localhost bin]$ tldr</span><br><span class="line">Usage: tldr <span class="built_in">command</span> [options]</span><br><span class="line"></span><br><span class="line">Simplified and community-driven man pages</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -v, --version            Display version</span><br><span class="line">  -l, --list               List all commands <span class="keyword">for</span> the chosen platform <span class="keyword">in</span> the cache</span><br><span class="line">  -a, --list-all           List all commands <span class="keyword">in</span> the cache</span><br><span class="line">  -1, --single-column      List single <span class="built_in">command</span> per line (use with options -l or -a)</span><br><span class="line">  -r, --random             Show a random <span class="built_in">command</span></span><br><span class="line">  -e, --random-example     Show a random example</span><br><span class="line">  -f, --render [file]      Render a specific markdown [file]</span><br><span class="line">  -m, --markdown           Output <span class="keyword">in</span> markdown format</span><br><span class="line">  -o, --os [<span class="built_in">type</span>]          Override the operating system [linux, osx, sunos, windows]</span><br><span class="line">  --linux                  Override the operating system with Linux</span><br><span class="line">  --osx                    Override the operating system with OSX</span><br><span class="line">  --sunos                  Override the operating system with SunOS</span><br><span class="line">  --windows                Override the operating system with Windows</span><br><span class="line">  -t, --theme [theme]      Color theme (simple, base16, ocean)</span><br><span class="line">  -s, --search [keywords]  Search pages using keywords</span><br><span class="line">  -u, --update             Update the <span class="built_in">local</span> cache</span><br><span class="line">  -c, --clear-cache        Clear the <span class="built_in">local</span> cache</span><br><span class="line">  -h, --<span class="built_in">help</span>               Show this <span class="built_in">help</span> message</span><br><span class="line"></span><br><span class="line">  Examples:</span><br><span class="line"></span><br><span class="line">    $ tldr tar</span><br><span class="line">    $ tldr du --os=linux</span><br><span class="line">    $ tldr --search <span class="string">"create symbolic link to file"</span></span><br><span class="line">    $ tldr --list</span><br><span class="line">    $ tldr --list-all</span><br><span class="line">    $ tldr --random</span><br><span class="line">    $ tldr --random-example</span><br><span class="line"></span><br><span class="line">  To control the cache:</span><br><span class="line"></span><br><span class="line">    $ tldr --update</span><br><span class="line">    $ tldr --clear-cache</span><br><span class="line"></span><br><span class="line">  To render a <span class="built_in">local</span> file (<span class="keyword">for</span> testing):</span><br><span class="line"></span><br><span class="line">    $ tldr --render /path/to/file.md</span><br></pre></td></tr></table></figure><p>我们使用<code>tldr ls</code>查看<code>ls</code>命令的用法，确实赏心悦目。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[zxd@localhost ~]$ tldr ls</span><br><span class="line">✔ Page not found. Updating cache...</span><br><span class="line">⠴ Creating index...</span><br><span class="line">✔ Creating index...</span><br><span class="line"></span><br><span class="line">  ls</span><br><span class="line"></span><br><span class="line">  List directory contents.</span><br><span class="line">  More information: https://www.gnu.org/software/coreutils/ls.</span><br><span class="line"></span><br><span class="line">  - List files one per line:</span><br><span class="line">    ls -1</span><br><span class="line"></span><br><span class="line">  - List all files, including hidden files:</span><br><span class="line">    ls -a</span><br><span class="line"></span><br><span class="line">  - List all files, with trailing / added to directory names:</span><br><span class="line">    ls -F</span><br><span class="line"></span><br><span class="line">  - Long format list (permissions, ownership, size, and modification date) of all files:</span><br><span class="line">    ls -la</span><br><span class="line"></span><br><span class="line">  - Long format list with size displayed using human-readable units (KiB, MiB, GiB):</span><br><span class="line">    ls -lh</span><br><span class="line"></span><br><span class="line">  - Long format list sorted by size (descending):</span><br><span class="line">    ls -lS</span><br><span class="line"></span><br><span class="line">  - Long format list of all files, sorted by modification date (oldest first):</span><br><span class="line">    ls -ltr</span><br><span class="line"></span><br><span class="line">  - Only list directories:</span><br><span class="line">    ls -d */</span><br></pre></td></tr></table></figure><h1 id="Cheat"><a href="#Cheat" class="headerlink" title="Cheat"></a>Cheat</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>这个漫画是Cheat恶搞man命令查一个命令需要翻几本书的时间，挺有意思的。</p><blockquote><p>cheat：有欺骗的意思，可以直接理解为<strong>舞弊</strong>或者<strong>作弊</strong>。</p></blockquote><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230124231214.png" alt=""></p><h2 id="官方资料-1"><a href="#官方资料-1" class="headerlink" title="官方资料"></a>官方资料</h2><p>github项目地址：<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NoZWF0L2NoZWF0" title="https://github.com/cheat/cheat">cheat/cheat: cheat allows you to create and view interactive cheatsheets on the command-line. It was designed to help remind *nix system administrators of options for commands that they use frequently, but not frequently enough to remember. (github.com)<i class="fa fa-external-link"></i></span></p><p>官方安装教程：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NoZWF0L2NoZWF0L2Jsb2IvbWFzdGVyL0lOU1RBTExJTkcubWQ=" title="https://github.com/cheat/cheat/blob/master/INSTALLING.md">cheat/INSTALLING.md at master · cheat/cheat (github.com)<i class="fa fa-external-link"></i></span></p><h2 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h2><h3 id="类Unix"><a href="#类Unix" class="headerlink" title="类Unix"></a>类Unix</h3><p>类Unix系统可以使用下面一串命令解决。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp \</span><br><span class="line">  &amp;&amp; wget https://github.com/cheat/cheat/releases/download/4.4.0/cheat-linux-amd64.gz \</span><br><span class="line">  &amp;&amp; gunzip cheat-linux-amd64.gz \</span><br><span class="line">  &amp;&amp; chmod +x cheat-linux-amd64 \</span><br><span class="line">  &amp;&amp; sudo mv cheat-linux-amd64 /usr/<span class="built_in">local</span>/bin/cheat</span><br></pre></td></tr></table></figure><p>个人的CenterOs实验如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[zxd@localhost ~]$ <span class="built_in">cd</span> /tmp \</span><br><span class="line">&gt;   &amp;&amp; wget https://github.com/cheat/cheat/releases/download/4.4.0/cheat-linux-amd64.gz \</span><br><span class="line">&gt;   &amp;&amp; gunzip cheat-linux-amd64.gz \</span><br><span class="line">&gt;   &amp;&amp; chmod +x cheat-linux-amd64 \</span><br><span class="line">&gt;   &amp;&amp; sudo mv cheat-linux-amd64 /usr/<span class="built_in">local</span>/bin/cheat</span><br><span class="line">--2023-01-28 18:34:35--  https://github.com/cheat/cheat/releases/download/4.4.0/cheat-linux-amd64.gz</span><br><span class="line">Resolving github.com (github.com)... 20.205.243.166</span><br><span class="line">Connecting to github.com (github.com)|20.205.243.166|:443... connected.</span><br><span class="line">Unable to establish SSL connection.</span><br><span class="line">[zxd@localhost tmp]$ <span class="built_in">cd</span> /tmp   &amp;&amp; wget https://github.com/cheat/cheat/releases/download/4.4.0/cheat-linux-amd64.gz   &amp;&amp; gunzip cheat-linux-amd64.gz   &amp;&amp; chmod +x cheat-linux-amd64   &amp;&amp; sudo mv cheat-linux-amd64 /usr/<span class="built_in">local</span>/bin/cheat</span><br><span class="line">--2023-01-28 18:34:59--  https://github.com/cheat/cheat/releases/download/4.4.0/cheat-linux-amd64.gz</span><br><span class="line">Resolving github.com (github.com)... </span><br><span class="line">... 省略一些安装提示信息</span><br><span class="line"></span><br><span class="line">... github访问比较慢，耐心等待</span><br><span class="line">100%[=============================================================================&gt;] 4,696,443   9.87KB/s   <span class="keyword">in</span> 6m 11s </span><br><span class="line"></span><br><span class="line">2023-01-28 18:41:13 (12.4 KB/s) - ‘cheat-linux-amd64.gz’ saved [4696443/4696443]</span><br></pre></td></tr></table></figure><p>个人的Ubuntu云服务器的实验如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-8-8-ubuntu:~$ <span class="built_in">cd</span> /tmp \</span><br><span class="line">  &amp;&amp; wget https://github.com/cheat/cheat/releases/download/4.4.0/cheat-linux-amd64.gz \</span><br><span class="line">  &amp;&amp; gunzip cheat-linux-amd64.gz \</span><br><span class="line">  &amp;&amp; chmod +x cheat-linux-amd64 \</span><br><span class="line">  &amp;&amp; sudo mv cheat-linux-amd64 /usr/<span class="built_in">local</span>/bin/cheat</span><br><span class="line">--2023-01-28 10:56:00--  https://github.com/cheat/cheat/releases/download/4.4.0/cheat-linux-amd64.gz</span><br><span class="line">... 省略信息</span><br><span class="line">Saving to: ‘cheat-linux-amd64.gz’</span><br><span class="line"></span><br><span class="line">cheat-linux-amd64.gz              100%[==========================================================&gt;]   4.48M   871KB/s    <span class="keyword">in</span> 1m 42s  </span><br><span class="line"></span><br><span class="line">2023-01-28 10:57:43 (44.9 KB/s) - ‘cheat-linux-amd64.gz’ saved [4696443/4696443]</span><br><span class="line"></span><br><span class="line">ubuntu@VM-8-8-ubuntu:/tmp$ cheat</span><br><span class="line">A config file was not found. Would you like to create one now? [Y/n]: y</span><br><span class="line">Would you like to download the community cheatsheets? [Y/n]: y</span><br><span class="line">Cloning community cheatsheets to /home/ubuntu/.config/cheat/cheatsheets/community.</span><br><span class="line">Enumerating objects: 335, <span class="keyword">done</span>.</span><br><span class="line">Counting objects: 100% (335/335), <span class="keyword">done</span>.</span><br><span class="line">Compressing objects: 100% (314/314), <span class="keyword">done</span>.</span><br><span class="line">Total 335 (delta 36), reused 274 (delta 19), pack-reused 0</span><br><span class="line">Cloning personal cheatsheets to /home/ubuntu/.config/cheat/cheatsheets/personal.</span><br><span class="line">Created config file: /home/ubuntu/.config/cheat/conf.yml</span><br><span class="line">Please <span class="built_in">read</span> this file <span class="keyword">for</span> advanced configuration information.</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里可能需要更改版本号（“4.4.0”）和存档（“cheat-linux-amd64.gz”），具体取决于安装平台。</p></blockquote><p>可以阅读 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NoZWF0L2NoZWF0L3JlbGVhc2Vz" title="https://github.com/cheat/cheat/releases">releases page<i class="fa fa-external-link"></i></span> 了解当前命令支持的平台。</p><h3 id="通过-go-install安装"><a href="#通过-go-install安装" class="headerlink" title="通过 go install安装"></a>通过 <code>go install</code>安装</h3><p>如果有GO 1.17 以上的版本，可以通过<code>go install</code>安装cheat。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> install github.com/cheat/cheat/cmd/cheat@latest</span><br></pre></td></tr></table></figure><h3 id="其他安装方式"><a href="#其他安装方式" class="headerlink" title="其他安装方式"></a>其他安装方式</h3><p>下面是官方介绍的其他安装方式。</p><table><thead><tr><th>Package manager</th><th>Package(s)</th></tr></thead><tbody><tr><td>aur</td><td><span class="exturl" data-url="aHR0cHM6Ly9hdXIuYXJjaGxpbnV4Lm9yZy9wYWNrYWdlcy9jaGVhdA==" title="https://aur.archlinux.org/packages/cheat">cheat<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly9hdXIuYXJjaGxpbnV4Lm9yZy9wYWNrYWdlcy9jaGVhdC1iaW4=" title="https://aur.archlinux.org/packages/cheat-bin">cheat-bin<i class="fa fa-external-link"></i></span></td></tr><tr><td>brew</td><td><span class="exturl" data-url="aHR0cHM6Ly9mb3JtdWxhZS5icmV3LnNoL2Zvcm11bGEvY2hlYXQ=" title="https://formulae.brew.sh/formula/cheat">cheat<i class="fa fa-external-link"></i></span></td></tr><tr><td>docker</td><td><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Jhbm5tYW5uL2RvY2tlci1jaGVhdA==" title="https://github.com/bannmann/docker-cheat">docker-cheat<i class="fa fa-external-link"></i></span></td></tr><tr><td>nix</td><td><span class="exturl" data-url="aHR0cHM6Ly9zZWFyY2gubml4b3Mub3JnL3BhY2thZ2VzP2NoYW5uZWw9dW5zdGFibGUmc2hvdz1jaGVhdCZmcm9tPTAmc2l6ZT01MCZzb3J0PXJlbGV2YW5jZSZ0eXBlPXBhY2thZ2VzJnF1ZXJ5PWNoZWF0" title="https://search.nixos.org/packages?channel=unstable&show=cheat&from=0&size=50&sort=relevance&type=packages&query=cheat">nixos.cheat<i class="fa fa-external-link"></i></span></td></tr><tr><td>snap</td><td><span class="exturl" data-url="aHR0cHM6Ly9zbmFwY3JhZnQuaW8vY2hlYXQ=" title="https://snapcraft.io/cheat">cheat<i class="fa fa-external-link"></i></span></td></tr></tbody></table><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><p>和tldr类似，第一次使用cheat也需要构建“数据库”，但是cheat比tldr的使用体验更好，我们只需要按照提示输入两次<code>y</code>确认即可：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[zxd@localhost tmp]$ cheat </span><br><span class="line">A config file was not found. Would you like to create one now? [Y/n]: y</span><br><span class="line">Would you like to download the community cheatsheets? [Y/n]: y</span><br><span class="line">Cloning community cheatsheets to /home/zxd/.config/cheat/cheatsheets/community.</span><br><span class="line">Enumerating objects: 335, <span class="keyword">done</span>.</span><br><span class="line">Counting objects: 100% (335/335), <span class="keyword">done</span>.</span><br><span class="line">Compressing objects: 100% (314/314), <span class="keyword">done</span>.</span><br><span class="line">Total 335 (delta 36), reused 274 (delta 19), pack-reused 0</span><br><span class="line">Cloning personal cheatsheets to /home/zxd/.config/cheat/cheatsheets/personal.</span><br><span class="line">Created config file: /home/zxd/.config/cheat/conf.yml</span><br><span class="line">Please <span class="built_in">read</span> this file <span class="keyword">for</span> advanced configuration information.</span><br></pre></td></tr></table></figure><p>最后是直接使用，个人感觉要比tldr麻烦事情少很多：</p><blockquote><p>和 tldr的区别是排版的方式有点不同</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[zxd@localhost tmp]$ cheat ls</span><br><span class="line"><span class="comment"># To display everything in &lt;dir&gt;, excluding hidden files:</span></span><br><span class="line">ls &lt;dir&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># To display everything in &lt;dir&gt;, including hidden files:</span></span><br><span class="line">ls -a &lt;dir&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># To display all files, along with the size (with unit suffixes) and timestamp:</span></span><br><span class="line">ls -lh &lt;dir&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># To display files, sorted by size:</span></span><br><span class="line">ls -S &lt;dir&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># To display directories only:</span></span><br><span class="line">ls -d */ &lt;dir&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># To display directories only, include hidden:</span></span><br><span class="line">ls -d .*/ */ &lt;dir&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># To display all files sorted by changed date, most recent first:</span></span><br><span class="line">ls -ltc </span><br><span class="line"></span><br><span class="line"><span class="comment"># To display files sorted by create time:</span></span><br><span class="line">ls -lt</span><br><span class="line"></span><br><span class="line"><span class="comment"># To display files in a single column:</span></span><br><span class="line">ls -1</span><br><span class="line"></span><br><span class="line"><span class="comment"># To show ACLs (MacOS):</span></span><br><span class="line"><span class="comment"># see also `cheat chmod` for `/bin/chmod` options for ACLs</span></span><br><span class="line">/bin/ls -le</span><br><span class="line"></span><br><span class="line"><span class="comment"># To show all the subtree files (Recursive Mode):</span></span><br><span class="line">ls -R</span><br></pre></td></tr></table></figure><p>Uuntu的使用类似：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础使用</span></span><br><span class="line">ubuntu@VM-8-8-ubuntu:/tmp$ cheat cp</span><br><span class="line"><span class="comment"># To copy a file:</span></span><br><span class="line">cp ~/Desktop/foo.txt ~/Downloads/foo.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># To copy a directory:</span></span><br><span class="line">cp -r ~/Desktop/cruise_pics/ ~/Pictures/</span><br><span class="line"></span><br><span class="line"><span class="comment"># To create a copy but ask to overwrite if the destination file already exists:</span></span><br><span class="line">cp -i ~/Desktop/foo.txt ~/Documents/foo.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># To create a backup file with date:</span></span><br><span class="line">cp foo.txt&#123;,.<span class="string">"<span class="variable">$(date +%Y%m%d-%H%M%S)</span>"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># To copy a symlink that points to a directory (and is thus soft) and not</span></span><br><span class="line"><span class="comment"># 'expand' the symlink (aka, preserve its nature as a symlink):</span></span><br><span class="line"><span class="comment"># Note this does NOT work (note trailing '/'):  cp -P /path/to/symlink-dir/</span></span><br><span class="line">cp -P &lt;symlink-dir&gt; &lt;dest-dir&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># To copy sparsely:</span></span><br><span class="line">cp --sparse=always &lt;src&gt; &lt;dest&gt;</span><br></pre></td></tr></table></figure><h1 id="类似项目"><a href="#类似项目" class="headerlink" title="类似项目"></a>类似项目</h1><p>还有更多和cheat以及tldr类似的项目，这里就不过多介绍了。</p><p><a href="https://github.com/cheat/cheat" target="_blank" rel="noopener"><strong>Cheat</strong></a> 允许您在命令行上创建和查看交互式备忘单。它旨在帮助提醒 Linux 系统管理员他们经常使用但不够频繁而无法记住的命令的选项。</p><p><a href="https://cheat.sh/" target="_blank" rel="noopener"><strong>cheat.sh</strong></a> 将来自多个来源（包括 tldr-pages）的备忘单聚合到 1 个统一界面中。</p><p><a href="https://devhints.io/" target="_blank" rel="noopener"><strong>devhints Rico</strong></a> 的备忘单不仅仅关注命令行，还包括大量与编程相关的其他备忘单。</p><p><a href="https://github.com/srsudar/eg" target="_blank" rel="noopener"><strong>eg</strong></a> 在命令行上提供了详细的示例和解释。示例来自存储库，但例如支持显示自定义示例和命令以及默认值。</p><p><a href="https://github.com/gnebbia/kb" target="_blank" rel="noopener"><strong>kb</strong></a> 是一个极简的命令行知识库管理器。 kb 可用于以极简主义和干净的方式组织您的笔记和备忘单。它还支持非文本文档。</p><p><a href="https://github.com/denisidoro/navi" target="_blank" rel="noopener"><strong>navi</strong></a> 是一个交互式备忘单工具，它允许您即时浏览特定示例或完整命令。</p><p><span class="exturl" data-url="aHR0cDovL2Jyb3BhZ2VzLm9yZy8=" title="http://bropages.org/">bropages（已弃用）<i class="fa fa-external-link"></i></span>是对手册页的高度可读性补充。它显示了 Unix 命令的简明、常见示例。这些示例由用户群提交，可以投票赞成或反对；最好的条目是人们在查找命令时最先看到的内容。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>整体体验下来个人比较偏向cheat一点，类Unix系统安装官方的教程一个名称就可以完成，而tldr需要Node环境，同时因为Node更新速度就像喝汤容易导致Linux系统版本或者内核版本低而不支持的问题。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      Linux命令行学习和使用
    
    </summary>
    
    
      <category term="Linux" scheme="https://whitestore.top/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://whitestore.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【Ubuntu】Win11 VmWare虚拟机安装Ubuntu 22.04.1-server</title>
    <link href="https://whitestore.top/2023/01/26/ubuntuvm/"/>
    <id>https://whitestore.top/2023/01/26/ubuntuvm/</id>
    <published>2023-01-26T03:07:39.000Z</published>
    <updated>2023-01-26T03:09:17.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>如标题所说，属于个人虚拟机安装Ubuntu的笔记记录。</p><h1 id="VM安装"><a href="#VM安装" class="headerlink" title="VM安装"></a>VM安装</h1><p>这里建议使用果核的PJ版本，实乃国产良心。</p><a id="more"></a><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2h4aS5jb20vdm13YXJlMTUuaHRtbA==" title="https://www.ghxi.com/vmware15.html">VMware Workstation Pro v16.2.3 官方版+激活密钥 - 果核剥壳 (ghxi.com)<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2h4aS5jb20vdm13YXJlMTUuaHRtbA==" title="https://www.ghxi.com/vmware15.html">VMware Workstation Pro(VM虚拟机) v16.2.5 官方版+激活密钥 - 果核剥壳 (ghxi.com)<i class="fa fa-external-link"></i></span></p><p>新版vmware安装包下载链接：<span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMTBEQm1OUjBiOXhwclUxcXJNOWtYM0E=" title="https://pan.baidu.com/s/10DBmNR0b9xprU1qrM9kX3A">https://pan.baidu.com/s/10DBmNR0b9xprU1qrM9kX3A<i class="fa fa-external-link"></i></span></p><p>提取码：w94s</p><p>vmware16许可证密钥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ZF3R0-FHED2-M80TY-8QYGC-NPKYF</span><br><span class="line"></span><br><span class="line">YF390-0HF8P-M81RQ-2DXQE-M2UT6</span><br><span class="line"></span><br><span class="line">ZF71R-DMX85-08DQY-8YMNC-PPHV8</span><br><span class="line"></span><br><span class="line">FF31K-AHZD1-H8ETZ-8WWEZ-WUUVA</span><br><span class="line"></span><br><span class="line">CV7T2-6WY5Q-48EWP-ZXY7X-QGUWD</span><br><span class="line"></span><br><span class="line">5A02H-AU243-TZJ49-GTC7K-3C61N</span><br><span class="line"></span><br><span class="line">VF5XA-FNDDJ-085GZ-4NXZ9-N20E6</span><br><span class="line"></span><br><span class="line">UC5MR-8NE16-H81WY-R7QGV-QG2D8</span><br><span class="line"></span><br><span class="line">ZG1WH-ATY96-H80QP-X7PEX-Y30V4</span><br><span class="line"></span><br><span class="line">AA3E0-0VDE1-0893Z-KGZ59-QGAVF</span><br></pre></td></tr></table></figure><p>这些都是破解密钥</p><h2 id="下载Ubuntu-22-04-1-server"><a href="#下载Ubuntu-22-04-1-server" class="headerlink" title="下载Ubuntu 22.04.1-server"></a>下载Ubuntu 22.04.1-server</h2><p>进入Ubuntu的中文网站：<span class="exturl" data-url="aHR0cHM6Ly9jbi51YnVudHUuY29tL2Rvd25sb2Fk" title="https://cn.ubuntu.com/download">Ubuntu系统下载 | Ubuntu<i class="fa fa-external-link"></i></span></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108110118.png" alt=""></p><p>根据最新的版本下载即可。本次使用使用USB或者DVD的物理镜像安装。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108110130.png" alt=""></p><h1 id="VM安装Ubuntu"><a href="#VM安装Ubuntu" class="headerlink" title="VM安装Ubuntu"></a>VM安装Ubuntu</h1><p>Vm安装完成之后，我们直接去官方网站下载Ubuntu 22.04.1 的Sever版本，在VM当中我们选择直接创建的新的镜像。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108102308.png" alt=""></p><p>在磁盘中选择下载下来的ISO镜像文件。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108102325.png" alt=""></p><p>选择直接下一步</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108102651.png" alt=""></p><p>选择磁盘大小，这里个人磁盘空间比较充足，选择了30GB。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108102709.png" alt=""></p><h2 id="选择语言"><a href="#选择语言" class="headerlink" title="选择语言"></a>选择语言</h2><p>这里建议使用英文语言：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108102733.png" alt=""></p><h2 id="选择键盘"><a href="#选择键盘" class="headerlink" title="选择键盘"></a>选择键盘</h2><p>下面是选择键盘的方式，默认下一步即可：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108103052.png" alt=""></p><h2 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a>配置网络</h2><p>注意：如果这里配置网络一会安装系统速度可能会较慢，因为ubuntu会从网络上下载更新。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108103137.png" alt=""></p><p>可以选择DHCP获取 IP，有利于新手快速学习，如果读者有IP知识也可以按tab键配置IP相关 地址，如上图中标记。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108103204.png" alt=""></p><p>比如可以参考下面的方式配置网络IP</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108103220.png" alt=""></p><p>配置的固定IP地址如上图所示，地址段根据vm默认即可，DNS为公共可用DNS。</p><h2 id="选择代理"><a href="#选择代理" class="headerlink" title="选择代理"></a>选择代理</h2><p>选择代理，这里直接使用默认的设置即可。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108104922.png" alt=""></p><h2 id="选择软件源"><a href="#选择软件源" class="headerlink" title="选择软件源"></a>选择软件源</h2><p>如果开启联网，ubuntu 默认会选择根据软件源进行下载。如果需要联网更新这里可以配置清华源的地址：</p><p><span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLnR1bmEudHNpbmdodWEuZWR1LmNuL3VidW50dQ==" title="https://mirrors.tuna.tsinghua.edu.cn/ubuntu">https://mirrors.tuna.tsinghua.edu.cn/ubuntu<i class="fa fa-external-link"></i></span></p><blockquote><p>注意：可以选择VM外的粘贴功能粘贴进去，清华源有ubuntu20,有的源没有，此处也可安装完毕配置。</p></blockquote><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108105023.png" alt=""></p><h2 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h2><p>新手建议直接使用官方给的默认分区配置。这里就选择默认的使用整块磁盘自动分区。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108105404.png" alt=""></p><h2 id="磁盘分区信息预览"><a href="#磁盘分区信息预览" class="headerlink" title="磁盘分区信息预览"></a>磁盘分区信息预览</h2><p>最后是分区的信息预览，这里直接<code>Done</code>即可。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108105455.png" alt=""></p><blockquote><p>提示：确认是否继续，继续后会对磁盘进行格式化<strong>会破坏磁盘数据</strong>，如果是宿主机系统重装建议提前备份。</p></blockquote><h2 id="配置系统信息"><a href="#配置系统信息" class="headerlink" title="配置系统信息"></a>配置系统信息</h2><p>配置系统主机名、登录用户和密码。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108105927.png" alt=""></p><h2 id="OpenSSL安装"><a href="#OpenSSL安装" class="headerlink" title="OpenSSL安装"></a>OpenSSL安装</h2><p>这里需要手动勾选一下，按空格键勾选图中的小方框内为小叉子，然后按tab键选择Done继续。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108110443.png" alt=""></p><h2 id="可选安装"><a href="#可选安装" class="headerlink" title="可选安装"></a>可选安装</h2><p>Ubuntu提供一些流行的常见运维工具提供默认安装，比如云服务器的构建，K8S，Docker的软件。</p><blockquote><p>这里个人勾选了docker和powershell。</p></blockquote><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108110611.png" alt=""></p><p>最后等待安装即可。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108110647.png" alt=""></p><p>注意安装过程中可能出现报错，此处为卸载光驱失败了，因为是虚拟机安装，可不用理会，按回车重启即可。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108111357.png" alt=""></p><p>当安装完成之后，最下方的界面会提示重启或者查看全部日志。我们选择重启然后等待Ubuntu做最后的初始化操作即可。</p><p>重启完成之后使用上面系统信息配置的用户登陆即可。注意这个用户<strong>不是ROOT</strong>，但是具备和ROOT相同的权限。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108114929.png" alt=""></p><h1 id="Root用户配置"><a href="#Root用户配置" class="headerlink" title="Root用户配置"></a>Root用户配置</h1><p>Ubuntu 在第一次登陆之后需要设置ROOT用户的密码，切换Root和重新设置密码的命令如下：</p><p>修改root密码</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd root</span><br></pre></td></tr></table></figure><p>切换root账户</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br></pre></td></tr></table></figure><p>注意默认情况下无法用Root远程登陆。</p><h2 id="Root-远程登陆"><a href="#Root-远程登陆" class="headerlink" title="Root 远程登陆"></a>Root 远程登陆</h2><p>默认Ubuntu不允许root远程登录，后期如果想通过root登陆系统则必须修改SSH配置文件中的相关参数 才行。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ssh/sshd_config PermitRootLogin yes</span><br></pre></td></tr></table></figure><p>修改之后需要重启SSHD后台进程：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart sshd</span><br></pre></td></tr></table></figure><h1 id="Xshell-远程连接"><a href="#Xshell-远程连接" class="headerlink" title="Xshell 远程连接"></a>Xshell 远程连接</h1><h2 id="检查设置"><a href="#检查设置" class="headerlink" title="检查设置"></a>检查设置</h2><p>如果在之前的安装步骤中没有安装OpenSSL，可以使用下面的命令安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure><p>在连接之前，需要保证 xshell 所在主机 和 ubuntu( 虚拟机 ) 相互能平通，因为ssh远程连接是通过网络连接的，如果网络不通，就无法连接。</p><p>Ubuntu 系统使用<code>ip addr</code>命令查看网络IP，Windows主机使用<code>ipconfig</code>查看网络IP：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr</span><br></pre></td></tr></table></figure><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108114023.png" alt=""></p><p>Window主机地址如下：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108114350.png" alt=""></p><p>双方向主机Ping一下，如果都能联通，可以进行下一步，否则需要检查网卡配置是否正确。</p><h2 id="Xshell连接配置"><a href="#Xshell连接配置" class="headerlink" title="Xshell连接配置"></a>Xshell连接配置</h2><p>个人使用的版本为Xshell7教育版，在下面的界面中新建一个SSH远程连接，配置如下：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230108114709.png" alt=""></p><p>第一次连接Xshell会警告安全性，直接同意即可，接着是提示输入用户名和密码。注意在默认情况下Ubuntu是不能用Root登陆的。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Connecting to 192.168.110.128:22...</span><br><span class="line">Connection established.</span><br><span class="line">To escape to <span class="built_in">local</span> shell, press <span class="string">'Ctrl+Alt+]'</span>.</span><br><span class="line"></span><br><span class="line">Welcome to Ubuntu 22.04.1 LTS (GNU/Linux 5.15.0-57-generic x86_64)</span><br><span class="line"></span><br><span class="line"> * Documentation:  https://help.ubuntu.com</span><br><span class="line"> * Management:     https://landscape.canonical.com</span><br><span class="line"> * Support:        https://ubuntu.com/advantage</span><br><span class="line"></span><br><span class="line">  System information as of Sun Jan  8 06:45:58 AM UTC 2023</span><br><span class="line"></span><br><span class="line">  System load:  0.0078125          Processes:                226</span><br><span class="line">  Usage of /:   41.8% of 13.67GB   Users logged <span class="keyword">in</span>:          1</span><br><span class="line">  Memory usage: 12%                IPv4 address <span class="keyword">for</span> docker0: 172.17.0.1</span><br><span class="line">  Swap usage:   0%                 IPv4 address <span class="keyword">for</span> ens33:   192.168.110.128</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">60 updates can be applied immediately.</span><br><span class="line">To see these additional updates run: apt list --upgradable</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Last login: Sun Jan  8 03:46:40 2023 from 192.168.110.1</span><br><span class="line">xander@xander:~$</span><br></pre></td></tr></table></figure><h1 id="配置apt源"><a href="#配置apt源" class="headerlink" title="配置apt源"></a>配置apt源</h1><p>Ubuntu 使用的是apt命令进行安装的，如果之前未进行软件源，会使用Ubuntu的官网镜像默认的地址，基本等于说是在国外，如果要替换，可以使用下面的方案。</p><p><strong>清华大学</strong>的镜像站的配置网站如下：</p><p><span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLnR1bmEudHNpbmdodWEuZWR1LmNuL2hlbHAvdWJ1bnR1Lw==" title="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">ubuntu | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror<i class="fa fa-external-link"></i></span></p><h2 id="清华大学开源软件源配置方式"><a href="#清华大学开源软件源配置方式" class="headerlink" title="清华大学开源软件源配置方式"></a>清华大学开源软件源配置方式</h2><p>下面直接拷贝网站的内容。</p><p>本镜像仅包含 32/64 位 x86 架构处理器的软件包，在 ARM(arm64, armhf)、PowerPC(ppc64el)、RISC-V(riscv64) 和 S390x 等架构的设备上（对应官方源为ports.ubuntu.com）请使用 <span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLnR1bmEudHNpbmdodWEuZWR1LmNuL2hlbHAvdWJ1bnR1LXBvcnRzLw==" title="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu-ports/">ubuntu-ports 镜像<i class="fa fa-external-link"></i></span>。</p><p><strong>手动替换</strong></p><p>Ubuntu 的软件源配置文件是 <code>/etc/apt/sources.list</code>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">xander@xander:~$ sudo vim /etc/apt/sources.list</span><br><span class="line"><span class="comment"># See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to</span></span><br><span class="line"><span class="comment"># newer versions of the distribution.</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu jammy main restricted</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu jammy main restricted</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Major bug fix updates produced after the final release of the</span></span><br><span class="line"><span class="comment">## distribution.</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu jammy-updates main restricted</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu jammy-updates main restricted</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu</span></span><br><span class="line"><span class="comment">## team. Also, please note that software in universe WILL NOT receive any</span></span><br><span class="line"><span class="comment">## review or updates from the Ubuntu security team.</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu jammy universe</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu jammy universe</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu jammy-updates universe</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu jammy-updates universe</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu</span></span><br><span class="line"><span class="comment">## team, and may not be under a free licence. Please satisfy yourself as to</span></span><br><span class="line"><span class="comment">## your rights to use the software. Also, please note that software in</span></span><br><span class="line"><span class="comment">## multiverse WILL NOT receive any review or updates from the Ubuntu</span></span><br><span class="line"><span class="comment">## security team.</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu jammy multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu jammy multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu jammy-updates multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu jammy-updates multiverse</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## N.B. software from this repository may not have been tested as</span></span><br><span class="line"><span class="comment">## extensively as that contained in the main release, although it includes</span></span><br><span class="line"><span class="comment">## newer versions of some applications which may provide useful features.</span></span><br><span class="line"><span class="comment">## Also, please note that software in backports WILL NOT receive any review</span></span><br><span class="line"><span class="comment">## or updates from the Ubuntu security team.</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu jammy-backports main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu jammy-backports main restricted universe multiverse</span></span><br><span class="line"></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu jammy-security main restricted</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu jammy-security main restricted</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu jammy-security universe</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu jammy-security universe</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu jammy-security multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu jammy-security multiverse</span></span><br></pre></td></tr></table></figure><p>手动替换的方式可以参考网站，因为不同的版本替换方式不太一样，这里为<code>22.04LTS</code>的版本。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预发布软件源，不建议启用</span></span><br><span class="line"><span class="comment"># deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse</span></span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse</span></span><br></pre></td></tr></table></figure><p><strong>命令替换</strong></p><p>命令替换的方式使用下面的命令即可。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo sed -i <span class="string">"s@http://.*archive.ubuntu.com@https://mirrors.tuna.tsinghua.edu.cn@g"</span> /etc/apt/sources.list</span><br><span class="line">sudo sed -i <span class="string">"s@http://.*security.ubuntu.com@https://mirrors.tuna.tsinghua.edu.cn@g"</span> /etc/apt/sources.list</span><br></pre></td></tr></table></figure><h1 id="apt简介"><a href="#apt简介" class="headerlink" title="apt简介"></a>apt简介</h1><ul><li>apt等同于Centos7的yum命令</li><li>apt-get是第一代的包管理工具，最稳定</li><li>apt是改进的包管理工具，比apt-get要先进，官方推荐使用apt来管理软件</li></ul><p>apt和CenterOs系统的区别如下：</p><table><thead><tr><th>操作内容</th><th>Centos6/7</th><th>Debian/Ubuntu</th></tr></thead><tbody><tr><td>1.软件包后缀</td><td>*.rpm</td><td>*.deb</td></tr><tr><td>2.软件源配置文件</td><td>/etc/yum.conf</td><td>/etc/apt/sources.list</td></tr><tr><td>3.更新软件包列表</td><td>yum makecache fast</td><td>apt update</td></tr><tr><td>4.从软件仓库安装软件</td><td>yum install package</td><td>apt install package</td></tr><tr><td>5.安装本地软件包</td><td>rpm -i pkg.rpm</td><td>dpkg -i pkg.deb</td></tr><tr><td>6.删除软件包</td><td>yum remove package</td><td>apt remove package</td></tr><tr><td>7.获取某软件包的信息</td><td>yum search package</td><td>apt search package</td></tr></tbody></table><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><span class="exturl" data-url="aHR0cHM6Ly9tZWZqLmNvbS5jbi9sdXIzNDM3Lmh0bWw=" title="https://mefj.com.cn/lur3437.html">Ubuntu 20.04 live server版安装(详细版) | 运维密码 (mefj.com.cn)<i class="fa fa-external-link"></i></span></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      请输入描述信息
    
    </summary>
    
    
      <category term="Linux" scheme="https://whitestore.top/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://whitestore.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【PHP】英文博客专栏PHP快速入门个人笔记</title>
    <link href="https://whitestore.top/2023/01/24/php_study1/"/>
    <id>https://whitestore.top/2023/01/24/php_study1/</id>
    <published>2023-01-24T03:41:12.000Z</published>
    <updated>2023-01-24T03:44:44.915Z</updated>
    
    <content type="html"><![CDATA[<h1 id="英文博客专栏PHP快速入门"><a href="#英文博客专栏PHP快速入门" class="headerlink" title="英文博客专栏PHP快速入门"></a>英文博客专栏PHP快速入门</h1><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><pre><code>本文是对于英文原始博客的一个PHP入门专栏的个人笔记摘录，因为非常入门并且自身有JAVA语言基础，看的比较快并且会忽略很多共同点，建议读者有能力可以看看博客的原文顺带提升英文能力，作者文字表达能力非常强，写的非常棒。这篇专栏介绍了PHP8入门，专栏写于2022年中旬，不管是单词还是语法句式都十分通俗易懂，**学技术的同时提升英语水平并且有助于提升自信心**。</code></pre><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#介绍">介绍</a></li><li><a href="#过往历史">过往历史</a></li><li><a href="#php是一个怎么样的语言">php是一个怎么样的语言</a></li><li><a href="#设置PHP">设置PHP</a></li><li><a href="#第一个PHP程序">第一个PHP程序</a></li><li><a href="#基本类型">基本类型</a></li><li><a href="#操作符">操作符</a><ul><li><a href="#字符串操作">字符串操作</a></li></ul></li><li><a href="#编写注释">编写注释</a></li><li><a href="#和数字有关的内置函数">和数字有关的内置函数</a></li><li><a href="#Array数组">Array数组</a><ul><li><a href="#arrays常用函数">arrays常用函数</a></li></ul></li><li><a href="#关联数组">关联数组</a></li><li><a href="#条件语句">条件语句</a></li><li><a href="#循环">循环</a></li><li><a href="#函数">函数</a><ul><li><a href="#匿名函数">匿名函数</a></li><li><a href="#值传递和地址传递">值传递和地址传递</a></li><li><a href="#箭头函数">箭头函数</a></li><li><a href="#使用mapreducefilter函数循环数组处理">使用map,reduce,filter函数循环数组处理</a></li></ul></li><li><a href="#面向对象">面向对象</a><ul><li><a href="#面向对象讨论">面向对象讨论</a></li><li><a href="#如何构建对象">如何构建对象</a></li><li><a href="#属性和方法">属性和方法</a></li><li><a href="#继承">继承</a></li><li><a href="#重写">重写</a></li><li><a href="#静态">静态</a></li><li><a href="#对象比较">对象比较</a></li><li><a href="#对象遍历">对象遍历</a></li><li><a href="#对象克隆">对象克隆</a></li><li><a href="#魔术方法">魔术方法</a></li></ul></li><li><a href="#文件包含">文件包含</a></li><li><a href="#文档系统的有用常量函数和变量">文档系统的有用常量、函数和变量</a></li><li><a href="#错误">错误</a></li><li><a href="#异常">异常</a></li><li><a href="#日期">日期</a></li><li><a href="#常量和枚举">常量和枚举</a></li><li><a href="#PHP-web平台部署">PHP web平台部署</a><ul><li><a href="#处理HTTP请求">处理HTTP请求</a></li><li><a href="#_SEVER-对象">$_SEVER 对象</a></li><li><a href="#使用cookies">使用cookies</a></li><li><a href="#Sessions">Sessions</a></li><li><a href="#IO">IO</a></li><li><a href="#database">database</a></li><li><a href="#JSON">JSON</a></li><li><a href="#email">email</a></li></ul></li><li><a href="#Composer">Composer</a></li><li><a href="#部署PHP应用">部署PHP应用</a></li></ul><a id="more"></a><h1 id="原始博客地址"><a href="#原始博客地址" class="headerlink" title="原始博客地址"></a>原始博客地址</h1><p><span class="exturl" data-url="aHR0cHM6Ly90aGV2YWxsZXlvZmNvZGUuY29tL3BocC8=" title="https://thevalleyofcode.com/php/">https://thevalleyofcode.com/php/<i class="fa fa-external-link"></i></span></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>PHP是一个两级分化的语言，觉得它好的人称赞它简单，PHP的语法比较自由上手非常简单。而不好的人则会像我一样认为是个<strong>四不像</strong>语言，既有前端脚本的影子，但是同时支持面向对象的方式组合代码，总是会有种奇怪的感觉。</p><p>但是不得不承认，世界上绝大多数WEB网站都是PHP构建的，PHP是web领域当之无愧的佼佼者。虽然这语言现在在国内是一潭死水，但是在国外它是能排进前十的热门编程语言。</p><p>PHP在短短的几年内快速发展，从最开始几年的PHP4和PHP5的膨胀，到现在PHP8的版本发布，更新迭代的速度还是很快的。</p><h1 id="过往历史"><a href="#过往历史" class="headerlink" title="过往历史"></a>过往历史</h1><p>PHP起源于1994年的个人博客网站，作者是rasmus lerdorf，PHP在1997到2000随着互联网的快速崛起并且爆炸式增长。</p><p>用途：</p><ul><li>和HTML存在一点点交互动态的HTML语言，以及web应用程序当中对外提供访问。</li><li>Facebook就是构建在PHP网站之上的，早期微微博也同样用的PHP语言</li><li>wiki百科同样使用PHP构建</li></ul><h2 id="PHP是一个怎么样的语言"><a href="#PHP是一个怎么样的语言" class="headerlink" title="PHP是一个怎么样的语言"></a>PHP是一个怎么样的语言</h2><p>虽然PHP被戏称脚本语言，但是实际上它是解释型语言，和广大编译运行的服务端语言没什么区别。只不过和其他大部分解释型语言不同点是PHP<strong>不需要编译</strong>就可以运行，或者可以认为编译的动作本身就是<strong>自动</strong>的。这和Java，GO以及c语言等等都有很大不同。在JAVA领域PHP非常像JSP，但是实际对比会发现要比JSP更灵活和方便，也更好用。</p><blockquote><p>这个语言内部可自动通过编译器把代码翻译成机器可以认识以及可以运行的语言。</p></blockquote><p>从个人角度看PHP被称作脚本语言是比较合适的词，因为它在web领域如鱼得水。此外因为PHP是动态类型语言，开发者不需要关注变量类型，但是有时候又因为类型转化的问题出现一些难以察觉的错误。</p><p>动态类型语言是高级编程语言的趋势这一点毋庸置疑。就连JDK11也实现了 <strong>var</strong> 关键词的动态类型语法糖定义就可以看出端倪。</p><p>最后用作者的原文总结：PHP是一门很像JavaScript的语言，不同的是它有动态类型，灵活类型的解释型<strong>后端</strong>语言。</p><h1 id="设置PHP"><a href="#设置PHP" class="headerlink" title="设置PHP"></a>设置PHP</h1><p>本部分作者介绍了mamp的安装使用，个人没有使用经验就不详细记录了，对于PHP作者推荐使用VScode 编辑器开发，个人使用下来发现确实好用，当然Jerbrian的PHP IDE也不错，对于常年使用IDEA的开发人员基本可以无缝衔接。</p><p>PHP 开发一般依赖<strong>套件</strong>，PHP本身就是起源于个人博客专职于WEB Application领域，所以他需要最为根本的软件比如<strong>Apach，Mysql</strong>，<strong>Redis</strong>等等。</p><p>PHP开源套件软件很多，这里就不过多展开了。当然套件开发不是强制的，当然开发者开发过程中也可以单独部署中间件和数据库。</p><p>对于php的web应用，必备组件无外乎下面几个：</p><ul><li>PHP语言环境变量，推荐最新版的PHP8。</li><li>数据库，通常以MySQL为主。</li><li>apache或者nignix作为web服务器。</li></ul><p>PHP是面向http web应用程序开发语言，很多时候都需要和HTML页面配合，这和古老的JSP语言有点类似，但是实际使用的时候更多是和模板引擎以及框架配合。</p><h1 id="第一个PHP程序"><a href="#第一个PHP程序" class="headerlink" title="第一个PHP程序"></a>第一个PHP程序</h1><p>PHP的Helloworld非常简单，只需要在mamp或者其他PHP程序的开发软件根目录创建<code>index.html</code>的文件即可。很多web server服务器基本都使用<strong>index.html</strong>作为默认的访问页面，所以如果直接访问localhost端口的webserver根路径，那么就会展示对应<code>index.html</code>页面。</p><p>PHP代码通常以及<code>&lt;?php</code>开头以及<code>?&gt;</code>结尾，中间编写有关PHP语言代码即可，我们可以在<code>index.html</code>文件全文替换成下面的代码。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">'World'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p> 虽然访问的是html页面，但是里面的PHP代码却会被识别翻译并且执行。</p></blockquote><h1 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h1><p>PHP是动态类型语言，定义变量方式如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$a = <span class="number">5</span>;</span><br><span class="line">$b = <span class="string">'444'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>PHP支持下面的基础类型：</p><ul><li><code>bool</code> boolean values (true/false)</li><li><code>int</code> integer numbers (no decimals)</li><li><code>float</code> floating-point numbers (decimals)</li><li><code>string</code> strings</li><li><code>array</code> arrays</li><li><code>object</code> objects</li><li><code>null</code> a value that means “no value assigned”</li></ul><p>如果要知道变量的数据类型，可以使用<code>var_dump()</code>的方法检查：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">var_dump($age);</span><br></pre></td></tr></table></figure><h1 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h1><p>PHP的基础操作符：</p><p>算数操作： <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> (division), <code>%</code> (remainder) and <code>**</code> (exponential).</p><p>赋值操作：<code>=</code></p><p>比较操作：<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>，此外还有相等和全等操作，含义和JS的类似，相等可以类型不匹配比如 5==’5’，全等类型必须一致，比如5===’5’就是false。</p><ul><li><p><code>==</code> returns true if the two operands are equal.</p></li><li><p><code>===</code> returns true if the two operands are identical.</p></li></ul><p>和比较操作相反的有!==以及!=符号。</p><p>自增操作：++和 - - 操作。</p><p>特殊符号：think new lines <code>\n</code> or tabs <code>\t</code></p><p>拼接操作：PHP和其他语言比较大的区别，那就是类似字符串拼接用的是 “.”</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$fullName = $firstName . <span class="string">' '</span> . $lastName;</span><br></pre></td></tr></table></figure><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><p>字符串的操作和其他后端语言类似，下面简单列举博客中的一些实验，这里直接上代码就不过多解释了：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$name = <span class="string">'Flavio'</span>;</span><br><span class="line">strlen($name); <span class="comment">//6</span></span><br><span class="line"></span><br><span class="line">$name = <span class="string">'Flavio'</span>;</span><br><span class="line">substr($name, <span class="number">3</span>); <span class="comment">//"vio" - start at position 3, get all the rest</span></span><br><span class="line">substr($name, <span class="number">2</span>, <span class="number">2</span>); <span class="comment">//"av" - start at position 2, get 2 items</span></span><br><span class="line"></span><br><span class="line">$name = <span class="string">'Flavio'</span>;</span><br><span class="line">str_replace(<span class="string">'avio'</span>, <span class="string">'ower'</span>, $name); <span class="comment">//"Flower"</span></span><br><span class="line"></span><br><span class="line">$name = <span class="string">'Flavio'</span>;</span><br><span class="line">$itemObserved = str_replace(<span class="string">'avio'</span>, <span class="string">'ower'</span>, $name); <span class="comment">//"Flower"</span></span><br></pre></td></tr></table></figure><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucGhwLm5ldC9tYW51YWwvZW4vZnVuY3Rpb24udHJpbS5waHA=" title="https://www.php.net/manual/en/function.trim.php">trim()<i class="fa fa-external-link"></i></span> strips white space at the beginning and end of a string</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucGhwLm5ldC9tYW51YWwvZW4vZnVuY3Rpb24uc3RydG91cHBlci5waHA=" title="https://www.php.net/manual/en/function.strtoupper.php">strtoupper()<i class="fa fa-external-link"></i></span> makes a string uppercase</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucGhwLm5ldC9tYW51YWwvZW4vZnVuY3Rpb24uc3RydG9sb3dlci5waHA=" title="https://www.php.net/manual/en/function.strtolower.php">strtolower()<i class="fa fa-external-link"></i></span> makes a string lowercase</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucGhwLm5ldC9tYW51YWwvZW4vZnVuY3Rpb24udWNmaXJzdC5waHA=" title="https://www.php.net/manual/en/function.ucfirst.php">ucfirst()<i class="fa fa-external-link"></i></span> makes the first character uppercase</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucGhwLm5ldC9tYW51YWwvZW4vZnVuY3Rpb24uc3RycG9zLnBocA==" title="https://www.php.net/manual/en/function.strpos.php">strpos()<i class="fa fa-external-link"></i></span> finds the firsts occurrence of a substring in the string</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucGhwLm5ldC9tYW51YWwvZW4vZnVuY3Rpb24uZXhwbG9kZS5waHA=" title="https://www.php.net/manual/en/function.explode.php">explode()<i class="fa fa-external-link"></i></span> to split a string into an array</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucGhwLm5ldC9tYW51YWwvZW4vZnVuY3Rpb24uaW1wbG9kZS5waHA=" title="https://www.php.net/manual/en/function.implode.php">implode()<i class="fa fa-external-link"></i></span> to join array elements in a string</li></ul><h1 id="编写注释"><a href="#编写注释" class="headerlink" title="编写注释"></a>编写注释</h1><p>编写注释的方法如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// single comment</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">this is a comment</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * this is a comment</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//or to comment out a portion of code inside a line:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* this is a comment */</span></span><br></pre></td></tr></table></figure><h1 id="和数字有关的内置函数"><a href="#和数字有关的内置函数" class="headerlink" title="和数字有关的内置函数"></a>和数字有关的内置函数</h1><p>作者事先列举一些和数字或者数学计算有关函数：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucGhwLm5ldC9tYW51YWwvZW4vZnVuY3Rpb24ucm91bmQucGhw" title="https://www.php.net/manual/en/function.round.php">round()<i class="fa fa-external-link"></i></span> to round a decimal number, up/down depending if the value is &gt; 0.5 or smaller</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucGhwLm5ldC9tYW51YWwvZW4vZnVuY3Rpb24uY2VpbC5waHA=" title="https://www.php.net/manual/en/function.ceil.php">ceil()<i class="fa fa-external-link"></i></span> to round a a decimal number up</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucGhwLm5ldC9tYW51YWwvZW4vZnVuY3Rpb24uZmxvb3IucGhw" title="https://www.php.net/manual/en/function.floor.php">floor()<i class="fa fa-external-link"></i></span> to round a decimal number down</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucGhwLm5ldC9tYW51YWwvZW4vZnVuY3Rpb24ucmFuZC5waHA=" title="https://www.php.net/manual/en/function.rand.php">rand()<i class="fa fa-external-link"></i></span> generates a random integer</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucGhwLm5ldC9tYW51YWwvZW4vZnVuY3Rpb24ubWluLnBocA==" title="https://www.php.net/manual/en/function.min.php">min()<i class="fa fa-external-link"></i></span> finds the lowest number in the numbers passed as arguments</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucGhwLm5ldC9tYW51YWwvZW4vZnVuY3Rpb24ubWF4LnBocA==" title="https://www.php.net/manual/en/function.max.php">max()<i class="fa fa-external-link"></i></span> finds the highest number in the numbers passed as arguments</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucGhwLm5ldC9tYW51YWwvZW4vZnVuY3Rpb24uaXMtbmFuLnBocA==" title="https://www.php.net/manual/en/function.is-nan.php">is_nan()<i class="fa fa-external-link"></i></span> returns true if the number is not a number</li></ul><h1 id="Array数组"><a href="#Array数组" class="headerlink" title="Array数组"></a>Array数组</h1><p>数组定义可以用方括号或者array函数，数组可以当做其他编程语言的列表（容器）看待，不需要定义长度并且容量自动增长。</p><p>列表里面的元素类型可以不一致，甚至元素可以是另一个列表。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组定义</span></span><br><span class="line">$list = [];</span><br><span class="line"></span><br><span class="line">$list = <span class="keyword">array</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化定义</span></span><br><span class="line">$list = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">$list = <span class="keyword">array</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">$list = [<span class="string">'a'</span>, <span class="string">'b'</span>];</span><br><span class="line">$list[<span class="number">0</span>]; <span class="comment">//'a' --the index starts at 0</span></span><br><span class="line">$list[<span class="number">1</span>]; <span class="comment">//'b'</span></span><br><span class="line"></span><br><span class="line">$list = [<span class="number">1</span>, [<span class="number">2</span>, <span class="string">'test'</span>]];</span><br></pre></td></tr></table></figure><p>添加元素可以使用空方括号的方式设置值，这时候参数会自动在末尾追加。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$list = [<span class="string">'a'</span>, <span class="string">'b'</span>];</span><br><span class="line">$list[] = <span class="string">'c'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">$list == [</span></span><br><span class="line"><span class="comment">  "a",</span></span><br><span class="line"><span class="comment">  "b",</span></span><br><span class="line"><span class="comment">  "c",</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>使用<strong>array_unshift</strong> 添加元素到列表头部：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$list = [<span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">array_unshift($list, <span class="string">'a'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">$list == [</span></span><br><span class="line"><span class="comment">  "a",</span></span><br><span class="line"><span class="comment">  "b",</span></span><br><span class="line"><span class="comment">  "c",</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>使用count函数计算数组的元素数量：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$list = [<span class="string">'a'</span>, <span class="string">'b'</span>];</span><br><span class="line"></span><br><span class="line">count($list); <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>检查元素是否在数组，使用<strong>in_array</strong> 函数`：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$list = [<span class="string">'a'</span>, <span class="string">'b'</span>];</span><br><span class="line"></span><br><span class="line">in_array(<span class="string">'b'</span>, $list); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h2 id="arrays常用函数"><a href="#arrays常用函数" class="headerlink" title="arrays常用函数"></a>arrays常用函数</h2><p>常用函数根据作者笔记记录即可。</p><ul><li><code>is_array()</code> to check if a variable is an array</li><li><code>array_unique()</code> to remove duplicate values from an array</li><li><code>array_search()</code> to search a value in the array and returns the key</li><li><code>array_reverse()</code> to reverse an array</li><li><code>array_reduce()</code> to reduce an array to a single value using a callback function</li><li><code>array_map()</code> to apply a callback function to each item in the array. Typically used to create a new array by modifying the values of an existing array, without altering that.</li><li><code>array_filter()</code> to filter an array to a single value using a callback function</li><li><code>max()</code> to get the maximum value contained in the array</li><li><code>min()</code> to get the minimum value contained in the array</li><li><code>array_rand()</code> to get a random item from the array</li><li><code>array_count_values()</code> to count all the values in the array</li><li><code>implode()</code> to turn an array into a string</li><li><code>array_pop()</code> to remove the last item of the array and return its value</li><li><code>array_shift()</code> same as <code>array_pop()</code> but removes the first item instead of the last</li><li><code>sort()</code> to sort an array</li><li><code>rsort()</code> to sort an array in reversing order</li><li><code>array_walk()</code> similarly to <code>array_map()</code> does something for every item in the array, but in addition it can change values in the existing array</li></ul><p>&#x20;</p><h1 id="关联数组"><a href="#关联数组" class="headerlink" title="关联数组"></a>关联数组</h1><p>到目前为止，我们已经使用了带有增量数字索引的数组：0、1、2… 您还可以使用带有命名索引（键）的数组，我们称它们为关联数组：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$list = [<span class="string">'first'</span> =&gt; <span class="string">'a'</span>, <span class="string">'second'</span> =&gt; <span class="string">'b'</span>];</span><br><span class="line"></span><br><span class="line">$list[<span class="string">'first'</span>] <span class="comment">//'a'</span></span><br><span class="line">$list[<span class="string">'second'</span>] <span class="comment">//'b'</span></span><br></pre></td></tr></table></figure><p>可以通过关联数组进行标记key以及value，关联数组同样有比较多的操作方法：</p><ul><li><code>array_key_exists()</code> to check if a key exists in the array</li><li><code>array_keys()</code> to get all the keys from the array</li><li><code>array_values()</code> to get all the values from the array</li><li><code>asort()</code> to sort an associative array by value</li><li><code>arsort()</code> to sort an associative array in descending order by value</li><li><code>ksort()</code> to sort an associative array by key</li><li><code>krsort()</code> to sort an associative array in descending order by key</li></ul><p>在此处查看所有有关联数组函数：<span class="exturl" data-url="aHR0cHM6Ly93d3cucGhwLm5ldC9tYW51YWwvZW4vcmVmLmFycmF5LnBocA==" title="https://www.php.net/manual/en/ref.array.php"> https://www.php.net/manual/en/ref.array.php<i class="fa fa-external-link"></i></span></p><h1 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h1><p>条件语句的最基础用法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$age = <span class="number">17</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ($age &gt; <span class="number">18</span>) &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">'You can enter the pub'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">'You cannot enter the pub'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用了cannot而不是can’t是因为单引号嵌套会出现“截断”导致报错，需要单引号内部嵌套需要使用转义符<code>\</code><strong>反斜杠</strong>。</p><p><code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>==</code>, <code>===</code> , <code>!=</code>, <code>!==</code> 这些符号在实际使用和条件语句一起使用：</p><p>这里需要注意PHP提供了专门的 elseif，而不能像其他语言一样使用 <code>else[空格]if</code> 的语法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$age = <span class="number">17</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ($age &gt; <span class="number">20</span>) &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">'You are 20+'</span>;</span><br><span class="line">&#125; <span class="keyword">elseif</span> ($age &gt; <span class="number">18</span>) &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">'You are 18+'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">'You are &lt;18'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Swtich的语法和其他编程语言是一致的：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$age = <span class="number">17</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>($age) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">15</span>:</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'You are 15'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'You are 16'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">17</span>:</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'You are 17'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">18</span>:</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'You are 18'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"You are $age"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><p>PHP的循环语句语法有<code>while</code>, <code>do while</code>, <code>for</code>, and <code>foreach</code>，<code>while</code>和<code>do while</code>的方法和大部分编程语言没什么不同。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ($counter &lt; <span class="number">10</span>) &#123;</span><br><span class="line">  <span class="keyword">echo</span> $counter;</span><br><span class="line">  $counter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">echo</span> $counter;</span><br><span class="line">  $counter++;</span><br><span class="line">&#125; <span class="keyword">while</span> ($counter &lt; <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>主要差别是<code>foreach</code>语法，可以用他遍历列表，也可以用来遍历列表获取索引，也就遍历关联数组的<code>key/value</code>值。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> ($list <span class="keyword">as</span> $value) &#123;</span><br><span class="line">  <span class="keyword">echo</span> $value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> ($list <span class="keyword">as</span> $key =&gt; $value) &#123;</span><br><span class="line">  <span class="keyword">echo</span> $key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于普通for循环，可以使用count函数计算数组长度的size。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; count($list); $i++) &#123;</span><br><span class="line">  <span class="keyword">echo</span> $list[$i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//result: abc</span></span><br></pre></td></tr></table></figure><p>和循环搭配使用的break和continue语法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; count($list); $i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> ($list[$i] == <span class="string">'b'</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">echo</span> $list[$i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// result a</span></span><br><span class="line"></span><br><span class="line">$list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; count($list); $i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> ($list[$i] == <span class="string">'b'</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">echo</span> $list[$i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//result: ac</span></span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>PHP函数的主要特点：</p><ul><li>PHP的函数只支持单返回值。</li><li>如果没有返回值或者省略则接收为null，注意这里是有陷阱的，如果调用一个无返回值的方法，会获得null的结果，PHP并不会对此报错。</li><li>参数可以等号设置默认值。</li><li>可以指定参数类型，也可以省略，省略会自动根据上下文猜测类型。</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendEmail</span><span class="params">($to)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"send an email to $to"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sendEmail(<span class="string">'test@test.com'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// result: send an email to test@test.com</span></span><br></pre></td></tr></table></figure><p>可以手动指定参数的类型，当然绝大多数情况下不会这样写（很啰嗦还浪费时间），所以看一下就可以直接忘记：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendEmail</span><span class="params">(string $to, string $subject, string $body)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PHP函数的参数支持定义的时候指定默认值，如果调用方没有传值就使用默认值：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendEmail</span><span class="params">($to, $subject = <span class="string">'test'</span>, $body = <span class="string">'test'</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sendEmail(<span class="string">'test@test.com'</span>)</span><br></pre></td></tr></table></figure><p>带返回值的函数定义如下，我们同样可以手动指定函数的返回值类型：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendEmail</span><span class="params">($to)</span>: <span class="title">bool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendEmail</span><span class="params">($to)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$success = sendEmail(<span class="string">'test@test.com'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ($success) &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">'email sent successfully'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">'error sending the email'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>PHP的匿名函数和JavaScript的写法是类似的，使用变量接收不带名字的<code>function</code>方法，由于不带返回值的函数默认返回Null，所以可以认为匿名函数的变量就是Null。</p><p>匿名函数是支持变量传递的，语法是在匿名方法后面追加<strong>use</strong>和<strong>括号</strong>。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$test = <span class="string">'test'</span>;</span><br><span class="line"></span><br><span class="line">$myfunction = <span class="function"><span class="keyword">function</span><span class="params">()</span> <span class="title">use</span> <span class="params">($test)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">echo</span> $test;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'ok'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$myfunction()</span><br></pre></td></tr></table></figure><h2 id="值传递和地址传递"><a href="#值传递和地址传递" class="headerlink" title="值传递和地址传递"></a>值传递和地址传递</h2><p>PHP默认情况下的参数传递都是<strong>值传递</strong>，也就是说外部的参数传递在函数内部出现改变是<strong>不会</strong>一并改变的，因为值传递是用了一份变量副本进行数据操作。</p><p>地址传递或者说引用传递需要在参数前面加<strong>取地址</strong>的符号，这里的写法就类似C语言的指针了。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$character = <span class="string">'a'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">(&amp;$c)</span> </span>&#123;</span><br><span class="line">  $c = <span class="string">'b'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test($character);</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> $character; <span class="comment">//'b'</span></span><br></pre></td></tr></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>PHP的箭头函数相当于JS的<strong>函数式编程</strong>，和Java的箭头函数类似，但是箭头函数用了等号而已。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$printTest = fn() =&gt; <span class="string">'test'</span>;</span><br><span class="line"></span><br><span class="line">$printTest(); <span class="comment">//'test'</span></span><br><span class="line"></span><br><span class="line">$multiply = fn($a, $b) =&gt; $a * $b;</span><br><span class="line"></span><br><span class="line">$multiply(<span class="number">2</span>, <span class="number">4</span>) <span class="comment">//8</span></span><br></pre></td></tr></table></figure><p>前面提到过匿名函数需要使用 <code>use</code>语句接收外部参数，而箭头函数就<strong>不需要</strong>如此定义便可以直接接收外部参数，写法方便和简洁易懂：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$a = <span class="number">2</span>;</span><br><span class="line">$b = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">$multiply = fn() =&gt; $a * $b;</span><br><span class="line"></span><br><span class="line">$multiply()</span><br></pre></td></tr></table></figure><p>总之PHP的函数有三种定义方法，普通函数，箭头函数和匿名函数。</p><h2 id="使用map-reduce-filter函数循环数组处理"><a href="#使用map-reduce-filter函数循环数组处理" class="headerlink" title="使用map,reduce,filter函数循环数组处理"></a>使用map,reduce,filter函数循环数组处理</h2><p><strong>array_map</strong>：函数可以对于每个元素调用回调函数并且返回结果，最后会返回一个全新的列表。首个参数是回调函数，其次是列表。</p><p><strong>array_filter</strong>：函数则是对于每个元素调用回调函数并且过滤掉不符合的元素，注意第一个参数是数组，然后第二个参数是回调函数，filter是符合函数回调结果的可以认为是有效的。</p><p><strong>array_reduce</strong>：函数比较特殊一些，最后有一个参数有一个初始值，函数会从初始化的值对后续的每个元素进行回调函数合并，比如计算阶乘的值就可以用这个函数。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">$doubles = array_map(fn($value) =&gt; $value * <span class="number">2</span>, $numbers);</span><br><span class="line"></span><br><span class="line"><span class="comment">//$doubles is now [2, 4, 6, 8]</span></span><br><span class="line"></span><br><span class="line">$numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">$even = array_filter($numbers, fn($value) =&gt; $value % <span class="number">2</span> === <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//$even is now [2, 4]</span></span><br><span class="line"></span><br><span class="line">$numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">$result = array_reduce($numbers, fn($carry, $value) =&gt; $carry * $value, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="面向对象讨论"><a href="#面向对象讨论" class="headerlink" title="面向对象讨论"></a>面向对象讨论</h2><p>PHP的面向对象和JAVA的比较相似，可以说大部分语法都可以通用。</p><h2 id="如何构建对象"><a href="#如何构建对象" class="headerlink" title="如何构建对象"></a>如何构建对象</h2><p>构建对象在PHP当中也是使用new的方式，可以通过new构建多个对象，但是对象名称不能重复。</p><h2 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h2><p>属性和方法常常配合使用，这里一并介绍魔术方法构造参数。方法可以指定构造函数 <code>__construction</code>，其中可以添加初始化对象的行为，PHP 当中对象有很多内置函数都以 <strong>双下划线</strong>开头。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> $name;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;name = $name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">bark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;name . <span class="string">' barked!'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$roger = <span class="keyword">new</span> Dog(<span class="string">'Roger'</span>);</span><br><span class="line">$roger-&gt;bark();</span><br></pre></td></tr></table></figure><p>每个类默认有一个不执行任何工作的空构造器，重写之后如果无空构造函数，需要传入指定参数才能初始化，否则会出现PHP的error异常。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> string $name;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;name = $name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">bark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;name . <span class="string">' barked!'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$roger = <span class="keyword">new</span> Dog(<span class="string">'Roger'</span>);</span><br><span class="line">$roger-&gt;name; <span class="comment">//'Roger'</span></span><br><span class="line">$roger-&gt;bark(); <span class="comment">//'Roger barked!'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// result</span></span><br><span class="line">TypeError: Dog::__construct():</span><br><span class="line">Argument <span class="comment">#1 ($name) must be of type int,</span></span><br><span class="line">string given on line <span class="number">14</span></span><br></pre></td></tr></table></figure><p>对象属性在PHP中存在三个限定符号，可以手动指定下面三个级别：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span></span><br></pre></td></tr></table></figure><p>这几个类别分别对应了继承对象可见，私有，对外公开，和JAVA、Python语言类似，这里就不过多扩展含义和更多用法案例了。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> $name;</span><br><span class="line">  <span class="keyword">public</span> $age;</span><br><span class="line">  <span class="keyword">public</span> $color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$roger = <span class="keyword">new</span> Dog();</span><br><span class="line"></span><br><span class="line">$roger-&gt;name = <span class="string">'Roger'</span>;</span><br><span class="line">$roger-&gt;age = <span class="number">10</span>;</span><br><span class="line">$roger-&gt;color = <span class="string">'gray'</span>;</span><br><span class="line"></span><br><span class="line">var_dump($roger);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">object(Dog)#1 (3) &#123;</span></span><br><span class="line"><span class="comment">  ["name"]=&gt; string(5) "Roger"</span></span><br><span class="line"><span class="comment">  ["age"]=&gt; int(10)</span></span><br><span class="line"><span class="comment">  ["color"]=&gt; string(4) "gray"</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>如果需要外部访问，多数情况建议用get和set的方式，对于类内部的属性首先需要定义public，其次引用需要使用<strong>this→xxx</strong>的方式，注意这个this是不能省略的，也是和JAVA差别比较大的点，而外部则为对象的变量引用设置的名称加上→符号，比如<strong>dog→bark()</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$roger = <span class="keyword">new</span> Dog(<span class="string">'Roger'</span>);</span><br><span class="line">$roger-&gt;name; <span class="comment">//'Roger'</span></span><br><span class="line">$roger-&gt;bark(); <span class="comment">//'Roger barked!'</span></span><br></pre></td></tr></table></figure><p>属性只有在<strong>public</strong>修饰符描述的情况下才能对外访问和修改，如果为private或者protected则不行，限定符的安全访问和Java的没什么区别。</p><blockquote><p> 方法内部的$this比较特殊，代表当前对象本身引用，和后端编程语言JAVA等类似。</p></blockquote><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>PHP的对象支持继承，具体语法如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$roger = <span class="keyword">new</span> Dog();</span><br><span class="line">$roger-&gt;eat();</span><br></pre></td></tr></table></figure><h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><p>PHP重写和JAVA的规则类似，所以我们按照JAVA的对象继承理解即可：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> $age;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'the animal is eating'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'the dog is eating'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h2><p>静态方法和静态属性都是在属性或者方法名称前面加static。对于static类或者对象内部使用self来定义，引用方式为两个冒号，比如<strong>User::getName</strong>。</p><p><strong>User::getName</strong>标识静态变量的写法是强制规定的，否则编译器会报错<code>Undefined variable &#39;$version&#39;.intelephense(1008)</code>。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Utils</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> $version = <span class="string">'1.0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 静态常量的对象内部引用</span></span><br><span class="line"><span class="keyword">self</span>::$version;</span><br><span class="line"><span class="comment">// 静态常量的外部引用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Utils</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">version</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'1.0'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Utils::version</span><br></pre></td></tr></table></figure><h2 id="对象比较"><a href="#对象比较" class="headerlink" title="对象比较"></a>对象比较</h2><p>前面的操作符提到过双等号和三等号有不同的含义，对于大部分情况下对象的比较<code>==</code>和<code>===</code>会返回true和false，下面的例子就是很好的解释。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> $name = <span class="string">'Good dog'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$roger = <span class="keyword">new</span> Dog();</span><br><span class="line">$syd = <span class="keyword">new</span> Dog();</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> $roger == $syd; <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> $roger === $syd; <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h2 id="对象遍历"><a href="#对象遍历" class="headerlink" title="对象遍历"></a>对象遍历</h2><p>对象遍历通常是遍历所有的内部属性值，可以使用关联循环的写法，这个对象遍历是PHP的一些语法特性，算是比较有意思的东西。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> $name = <span class="string">'Good dog'</span>;</span><br><span class="line">  <span class="keyword">public</span> $age = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">public</span> $color = <span class="string">'gray'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog = <span class="keyword">new</span> Dog();</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> ($dog <span class="keyword">as</span> $key =&gt; $value) &#123;</span><br><span class="line">  <span class="keyword">echo</span> $key . <span class="string">': '</span> . $value . <span class="string">'&lt;br&gt;'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象克隆"><a href="#对象克隆" class="headerlink" title="对象克隆"></a>对象克隆</h2><p>PHP的<code>clone</code> 方法和JAVA一样属于浅拷贝，深入拷贝需要额外编写一些代码。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> $name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$roger = <span class="keyword">new</span> Dog();</span><br><span class="line">$roger-&gt;name = <span class="string">'Roger'</span>;</span><br><span class="line"></span><br><span class="line">$syd = <span class="keyword">clone</span> $roger;</span><br></pre></td></tr></table></figure><h2 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h2><p>魔术方法可以理解为PHP为了方便开发者管理对象而提供的一些”切面“，开发者可以通过重写对象的特定方法控制行为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> $name;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;cloned = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$roger = <span class="keyword">new</span> Dog();</span><br><span class="line">$roger-&gt;name = <span class="string">'Roger'</span>;</span><br><span class="line"></span><br><span class="line">$syd = <span class="keyword">clone</span> $roger;</span><br><span class="line"><span class="keyword">echo</span> $syd-&gt;cloned;</span><br></pre></td></tr></table></figure><p>其他的魔术方法包含：<code>__call()</code>, <code>__get()</code>, <code>__set()</code>, <code>__isset()</code>, <code>__toString()</code>。</p><h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><p>文件包含的操作在PHP中有四种写法：<code>include</code>, <code>include_once</code>, <code>require</code>, <code>require_once</code>.</p><blockquote><p><code>include</code> loads the content of another PHP file, using a relative path.</p><p><code>require</code> does the same, but if there’s any error doing so, the program halts. <code>include</code> will only generate a warning.</p></blockquote><p>“include”：使用相对路径加载另一个PHP文档的内容。</p><p>“require”：执行相同的操作，但如果载入有任何错误进程将停止。注意“include”<strong>只会生成警告</strong>，require会直接抛出异常信息。</p><p><strong><code>include_once</code>和<code>require_once</code>在没有<code>_once</code>的情况下执行与其相应函数相同的操作，但它们额外确保在进程执行期间仅包含一次文件。</strong></p><p>按照作者的经验法则是经验法则永远不要使用包含或要求，因为您可能会加载同一个文档2次，include_once和require_once帮助您避免此问题。</p><p>下面介绍文件包含的相关操作：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require_once</span>(<span class="string">'test.php'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//now we have access to the functions, classes</span></span><br><span class="line"><span class="comment">//and variables defined in the `test.php` file</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">'../test.php'</span>);</span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">'test/test.php'</span>);</span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">'/var/www/test/file.php'</span>);</span><br></pre></td></tr></table></figure><h1 id="文档系统的有用常量、函数和变量"><a href="#文档系统的有用常量、函数和变量" class="headerlink" title="文档系统的有用常量、函数和变量"></a>文档系统的有用常量、函数和变量</h1><p>有关文件的魔法常量：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">__FILE__</span></span><br></pre></td></tr></table></figure><p>还有一个和服务器有关的全局常量：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$_SERVER[<span class="string">'SCRIPT_FILENAME'</span>]</span><br></pre></td></tr></table></figure><p>除此之外其他的一些常用常量或者函数：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getcwd():内置函数</span><br><span class="line"><span class="keyword">__DIR__</span>：另一个神奇常量</span><br><span class="line">将<span class="keyword">__FILE__</span>与 dirname（） 组合以获得</span><br><span class="line"></span><br><span class="line">当前文档夹的完整路径：dirname(<span class="keyword">__FILE__</span>)</span><br><span class="line">使用 $_SERVER[“DOCUMENT_ROOT”]</span><br></pre></td></tr></table></figure><h1 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h1><p>PHP的错误或者说异常信息分为下面三类：</p><ul><li>Warnings</li><li>Notices</li><li>Errors</li></ul><p>前面两个错误都是警告类似的，虽然有可能在程序运行过程中会出现问题但是不影响程序运行，而最后一个error则是会由PHP的解释器直接返回报错信息。</p><p>默认情况下PHP是不展示错误信息的，我们可以修改`<code>php.ini</code>`的配置进行调整。为了更快的了解配置文件的位置和相关信息，我们可以使用 phpinfo()方法和查看：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">phpinfo();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230124105203.png" alt=""></p><p>原作者案例的对应的路径为：<code>/Applications/MAMP/bin/php/php8.1.0/conf/php.ini</code>，默认情况下为off，意味着错误将不再显示在网站中，但在这种情况下将在 MAMP（如果是别的开发脚手架则为其他的路径） 的 logs 文档夹的php_error.log文档中看到它们。</p><p>个人的wampServer的对应错误日志信息如下：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230124105234.png" alt=""></p><p>我们可以指定错误日志重定向到特定的目录：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">; Log errors to specified file. PHP<span class="string">'s default behavior is to leave this value</span></span><br><span class="line"><span class="string">; empty.</span></span><br><span class="line"><span class="string">; http://php.net/error-log</span></span><br><span class="line"><span class="string">; Example:</span></span><br><span class="line"><span class="string">;error_log = php_errors.log</span></span><br></pre></td></tr></table></figure><p>添加错误信息可以通过方法error_log(‘test’);处理，下面截取框架的用法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Logs user information to webserver logs.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> string $user   user name</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> string $status status message</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">logUser</span><span class="params">($user, $status = <span class="string">'ok'</span>)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (function_exists(<span class="string">'apache_note'</span>)) &#123;</span><br><span class="line">           apache_note(<span class="string">'userID'</span>, $user);</span><br><span class="line">           apache_note(<span class="string">'userStatus'</span>, $status);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/* Do not log successful authentications */</span></span><br><span class="line">       <span class="keyword">if</span> (! $GLOBALS[<span class="string">'PMA_Config'</span>]-&gt;get(<span class="string">'AuthLogSuccess'</span>) &amp;&amp; $status == <span class="string">'ok'</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       $log_file = <span class="keyword">self</span>::getLogDestination();</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">empty</span>($log_file)) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       $message = <span class="keyword">self</span>::getLogMessage($user, $status);</span><br><span class="line">       <span class="keyword">if</span> ($log_file == <span class="string">'syslog'</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (function_exists(<span class="string">'syslog'</span>)) &#123;</span><br><span class="line">               @openlog(<span class="string">'phpMyAdmin'</span>, LOG_NDELAY | LOG_PID, LOG_AUTHPRIV);</span><br><span class="line">               @syslog(LOG_WARNING, $message);</span><br><span class="line">               closelog();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">elseif</span> ($log_file == <span class="string">'php'</span>) &#123;</span><br><span class="line">           @error_log($message);</span><br><span class="line">       &#125; <span class="keyword">elseif</span> ($log_file == <span class="string">'sapi'</span>) &#123;</span><br><span class="line">           @error_log($message, <span class="number">4</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           @error_log(</span><br><span class="line">               date(<span class="string">'M d H:i:s'</span>) . <span class="string">' phpmyadmin: '</span> . $message . <span class="string">"\n"</span>,</span><br><span class="line">               <span class="number">3</span>, $log_file</span><br><span class="line">           );</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>异常通常是除开编程语言语法之外的可控错误，PHP和JAVA一样使用了<code>try{...}catch(Exception $e)</code>的方式进行处理：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable $e) &#123;</span><br><span class="line"><span class="comment">//we can do something here if an exception happens</span></span><br><span class="line">  <span class="keyword">echo</span> $e-&gt;getMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验中我们可以使用除0的异常检查异常信息的打印：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="number">1</span> / <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230124105147.png" alt=""></p><p>异常处理的原则是细分不同的具体异常给出不同的提示，PHP的异常捕获规则和JAVA一致：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (DivisionByZeroError $e) &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">'Ooops I divided by zero!'</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable $e) &#123;</span><br><span class="line">  <span class="keyword">echo</span> $e-&gt;getMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PHP同样支持finally的写法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (DivisionByZeroError $e) &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">'Ooops I divided by zero!'</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable $e) &#123;</span><br><span class="line">  <span class="keyword">echo</span> $e-&gt;getMessage();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">' ...done!'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多异常处理可以参考下面的网站：</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucGhwLm5ldC9tYW51YWwvZW4vcmVzZXJ2ZWQuZXhjZXB0aW9ucy5waHA=" title="https://www.php.net/manual/en/reserved.exceptions.php">https://www.php.net/manual/en/reserved.exceptions.php<i class="fa fa-external-link"></i></span></p><h1 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h1><h1 id="常量和枚举"><a href="#常量和枚举" class="headerlink" title="常量和枚举"></a>常量和枚举</h1><p>我们可以在 PHP 中使用 define（） 内置函数定义常量，使用语法如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">'TEST'</span>, <span class="string">'some value'</span>);</span><br></pre></td></tr></table></figure><p>这种常量定义在使用的时候不需要使用$符号：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">'TEST'</span>, <span class="string">'some value'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> TEST;</span><br></pre></td></tr></table></figure><p><code>define</code> 类似 C 语言的 typeof。</p><p>其他定义常量的方法是const：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> BREED = <span class="string">'Siberian Husky'</span>;</span><br></pre></td></tr></table></figure><p>第三种定义常量的方法是定义枚举：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum Status &#123;</span><br><span class="line">  <span class="keyword">case</span> EATING;</span><br><span class="line">  <span class="keyword">case</span> SLEEPING;</span><br><span class="line">  <span class="keyword">case</span> RUNNING;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举常量的使用方法如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> Status $status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog = <span class="keyword">new</span> Dog();</span><br><span class="line"></span><br><span class="line">$dog-&gt;status = Status::RUNNING;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ($dog-&gt;status == Status::SLEEPING) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="PHP-web平台部署"><a href="#PHP-web平台部署" class="headerlink" title="PHP web平台部署"></a>PHP web平台部署</h1><p>PHP 是一种服务器端语言，通常以 2 种方式使用。</p><ol><li>第一种方法是类似JSP一样在HTML中嵌入PHP后端语言代码达到动态数据展示的效果。</li><li>第二种是PHP更像是负责生成“应用进程”的引擎，模板语言来生成HTML，并且所有内容都由我们所谓的框架管理。（推荐）</li></ol><h2 id="处理HTTP请求"><a href="#处理HTTP请求" class="headerlink" title="处理HTTP请求"></a>处理HTTP请求</h2><p>本部分介绍了在没有任何框架的情况下如何接收和处理HTTP请求，我们可以在webroot的路径创建一个test.php文件，此时如果对于脚手架配置伪静态，可以直接通过/test访问。</p><p>WEB应用绝大部分都是POST和GET请求，PHP提供了<code>$_GET</code>, <code>$_POST</code> and <code>$_REQUEST</code> 这些方法</p><blockquote><p>$ <em>GET：对于任何请求，您可以使用  $\</em> GET 对象访问所有查询字符串数据，该对象称为超全局，并在我们所有的 PHP 文档中自动可用。<br>$_ POST：对于 POST、PUT 和 DELETE 请求，更有可能需要以<code>urlencoding</code> 数据的形式发布的数据或使用 FormData 对象，PHP 使用<code>$_POST</code>为您提供该对象。<br>$<em>REQUEST：$\</em> REQUEST囊括了上面两个魔法常量的内容。</p></blockquote><p>下面的案例介绍了有关这些魔法常量的用法</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (<span class="keyword">isset</span>($_GET[<span class="string">'tables'</span>])) &#123;</span><br><span class="line">    $constrains = $GLOBALS[<span class="string">'dbi'</span>]-&gt;getForeignKeyConstrains(</span><br><span class="line">        $_REQUEST[<span class="string">'db'</span>],</span><br><span class="line">        $_GET[<span class="string">'tables'</span>]</span><br><span class="line">    );</span><br><span class="line">    $response = Response::getInstance();</span><br><span class="line">    $response-&gt;addJSON(<span class="string">'foreignKeyConstrains'</span>,$constrains);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用cookies-SEVER-对象"><a href="#使用cookies-SEVER-对象" class="headerlink" title="使用cookies$_SEVER 对象"></a>使用cookies$_SEVER 对象</h2><p><code>$_SERVER</code> 包含了许多非常有用的服务器信息，我们可以使用Phpinfo方法获取服务器内容：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">phpinfo();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230124105136.png" alt=""></p><p>下面是基本用法：</p><ul><li><code>$_SERVER[&#39;HTTP_HOST&#39;]</code></li><li><code>$_SERVER[&#39;HTTP_USER_AGENT&#39;]</code></li><li><code>$_SERVER[&#39;SERVER_NAME&#39;]</code></li><li><code>$_SERVER[&#39;SERVER_ADDR&#39;]</code></li><li><code>$_SERVER[&#39;SERVER_PORT&#39;]</code></li><li><code>$_SERVER[&#39;DOCUMENT_ROOT&#39;]</code></li><li><code>$_SERVER[&#39;REQUEST_URI&#39;]</code></li><li><code>$_SERVER[&#39;SCRIPT_NAME&#39;]</code></li><li><code>$_SERVER[&#39;REMOTE_ADDR&#39;]</code></li></ul><p>$_GET方法的使用案例如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">  &lt;input type=<span class="string">"text"</span> name=<span class="string">"name"</span> /&gt;</span><br><span class="line">  &lt;input type=<span class="string">"submit"</span> /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_GET[<span class="string">'name'</span>])) &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">'&lt;p&gt;The name is '</span> . $_GET[<span class="string">'name'</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>$_POST方法的使用案例如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;form **method=<span class="string">"POST"</span>**&gt;</span><br><span class="line">  &lt;input type=<span class="string">"text"</span> name=<span class="string">"name"</span> /&gt;</span><br><span class="line">  &lt;input type=<span class="string">"submit"</span> /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">'name'</span>])) &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">'&lt;p&gt;The name is '</span> . $_POST[<span class="string">'name'</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>这些内容直接使用的情况比较少，通常在框架中可以看到类似的引用。</p><h2 id="使用cookies"><a href="#使用cookies" class="headerlink" title="使用cookies"></a>使用cookies</h2><p>PHP通过<code>$_COOKIE</code>变量可以获取到所有和Cookie有关的信息。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_COOKIE[<span class="string">'name'</span>])) &#123;</span><br><span class="line">  $name = $_COOKIE[<span class="string">'name'</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.php.net/manual/en/function.setcookie.php" target="_blank" rel="noopener"><code>setcookie()</code></a> 方法可以设置cookie信息，我们可以添加第三个参数来说明 cookie 何时过期。如果省略，Cookie 将在会话结束时/浏览器关闭时过期。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setcookie(<span class="string">'name'</span>, <span class="string">'Flavio'</span>);</span><br></pre></td></tr></table></figure><p>比如下面的代码可以设置7天之后过期：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setcookie(<span class="string">'name'</span>, <span class="string">'Flavio'</span>, time() + <span class="number">3600</span> * <span class="number">24</span> * <span class="number">7</span>);</span><br></pre></td></tr></table></figure><p>我们只能在 Cookie 中存储有限数量的数据，用户在清除浏览器数据时可以在客户端清除 Cookie。下面是Cookie使用的一些简单例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">'name'</span>])) &#123;</span><br><span class="line">  setcookie(<span class="string">'name'</span>, $_POST[<span class="string">'name'</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">'name'</span>])) &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">'&lt;p&gt;Hello '</span> . $_POST[<span class="string">'name'</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">isset</span>($_COOKIE[<span class="string">'name'</span>])) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'&lt;p&gt;Hello '</span> . $_COOKIE[<span class="string">'name'</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;form method=<span class="string">"POST"</span>&gt;</span><br><span class="line">  &lt;input type=<span class="string">"text"</span> name=<span class="string">"name"</span> /&gt;</span><br><span class="line">  &lt;input type=<span class="string">"submit"</span> /&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><h2 id="Sessions"><a href="#Sessions" class="headerlink" title="Sessions"></a>Sessions</h2><p>Cookie 的一个非常有趣的用例是基于 cookie 的会话。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">session_start();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>你会发现访问对应文件之后，你将会看到一个新cookie名称（<strong>PHPSESSID</strong>）被定义。这个ID就是我们常说的<strong>session ID</strong>。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/image-20230123212351539.png" alt="image-20230123212351539"></p><p>与我们使用 cookie 的方式类似，我们现在可以使用 $_SESSION 来存储用户发送的信息，但这次它不存储在客户端。只有PHPSESSID会被存储到客户端。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">session_start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">'name'</span>])) &#123;</span><br><span class="line">  $_SESSION[<span class="string">'name'</span>] = $_POST[<span class="string">'name'</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">'name'</span>])) &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">'&lt;p&gt;Hello '</span> . $_POST[<span class="string">'name'</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">isset</span>($_SESSION[<span class="string">'name'</span>])) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'&lt;p&gt;Hello '</span> . $_SESSION[<span class="string">'name'</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;form method=<span class="string">"POST"</span>&gt;</span><br><span class="line">  &lt;input type=<span class="string">"text"</span> name=<span class="string">"name"</span> /&gt;</span><br><span class="line">  &lt;input type=<span class="string">"submit"</span> /&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/image-20230123212507500.png" alt="image-20230123212507500"></p><p>可以使用<code>session_unset()</code>方法删除Session当中的信息，如果需要移除session的cookie信息，可以使用下面的方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setcookie(session_name(), <span class="string">''</span>);</span><br></pre></td></tr></table></figure><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><p>PHP服务端访问可以使用下面的方法：</p><p>文件是否存在<code>file_exists()</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_exists(<span class="string">'test.txt'</span>) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>文件大小获取：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filesize(<span class="string">'test.txt'</span>)</span><br></pre></td></tr></table></figure><p>PHP的文件读写使用同一个方法，不同的是提供访问参数使用了 读模式和写模式：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$file = fopen(<span class="string">'test.txt'</span>, <span class="string">'r'</span>)</span><br></pre></td></tr></table></figure><p>上面的方法为只读模式，同时提供描述信息作为返回值。我们可以调用 <code>fclose($fd)</code> 终止文件读写。</p><p>下面是把文件内容读取到变量的方法，这里吐槽一下使用要比JAVA的套版代码简单很多，也比较符合新生高级编程语言的设计思路。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$file = fopen(<span class="string">'test.txt'</span>, <span class="string">'r'</span>)</span><br><span class="line"></span><br><span class="line">fread($file, filesize(<span class="string">'test.txt'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!feof($file)) &#123;</span><br><span class="line">$data .= fgets($file, <span class="number">5000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：feof() 检查我们是否尚未到达文档末尾，因为 <strong>fgets 一次读取 5000 字节</strong></p></blockquote><p>逐行扫描文件套版代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$file = fopen(<span class="string">'test.txt'</span>, <span class="string">'r'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!feof($file)) &#123;</span><br><span class="line">  $line = fgets($file);</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要写入文件，必须一开始打开文件的时候指定写入模式，同时配合<code>fwrite</code>函数以及<code>fclose</code>形成完整的文件读写。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$data = <span class="string">'test'</span>;</span><br><span class="line">$file = fopen(<span class="string">'test.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line">fwrite($file, $data);</span><br><span class="line">fclose($file);</span><br></pre></td></tr></table></figure><p>删除文件的方法如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlink(<span class="string">'test.txt'</span>)</span><br></pre></td></tr></table></figure><p>更多文件读写方法参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cucGhwLm5ldC9tYW51YWwvZW4vcmVmLmZpbGVzeXN0ZW0ucGhw" title="https://www.php.net/manual/en/ref.filesystem.php">https://www.php.net/manual/en/ref.filesystem.php<i class="fa fa-external-link"></i></span></p><h2 id="database"><a href="#database" class="headerlink" title="database"></a>database</h2><p>所有后端语言必备的东西，这里列举了几个常用的database：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucGhwLm5ldC9tYW51YWwvZW4vYm9vay5wZ3NxbC5waHA=" title="https://www.php.net/manual/en/book.pgsql.php">PostgreSQL<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucGhwLm5ldC9tYW51YWwvZW4vc2V0Lm15c3FsaW5mby5waHA=" title="https://www.php.net/manual/en/set.mysqlinfo.php">MySQL<i class="fa fa-external-link"></i></span> / MariaDB</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucGhwLm5ldC9tYW51YWwvZW4vc2V0Lm1vbmdvZGIucGhw" title="https://www.php.net/manual/en/set.mongodb.php">MongoDB<i class="fa fa-external-link"></i></span></li></ul><p>绝大多数情况如果你需要一个数据库，你应该使用<strong>框架或ORM</strong>，这将节省SQL注入的安全问题，比如比较常见的<span class="exturl" data-url="aHR0cHM6Ly9sYXJhdmVsLmNvbS9kb2NzL2Vsb3F1ZW50" title="https://laravel.com/docs/eloquent">Laravel’s Eloquent<i class="fa fa-external-link"></i></span> 框架。</p><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p><span class="exturl" data-url="aHR0cHM6Ly9mbGF2aW9jb3Blcy5jb20vanNvbi8=" title="https://flaviocopes.com/json/">JSON<i class="fa fa-external-link"></i></span> 是一种可移植的数据格式，我们用于表示数据并将数据从客户端发送到服务器。PHP提供了下面两个常用方法来实现JSON字符串和对象之间的转化：</p><ul><li><code>json_encode()</code> to encode a variable into JSON</li><li><code>json_decode()</code> to decode a JSON string into a data type (object, array…)</li></ul><p>下面是一些简单使用例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$test = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"></span><br><span class="line">$encoded = json_encode($test); <span class="comment">// "["a","b","c"]" (a string)</span></span><br><span class="line"></span><br><span class="line">$decoded = json_decode($encoded); <span class="comment">// [ "a", "b", "c" ] (an array)</span></span><br></pre></td></tr></table></figure><h2 id="email"><a href="#email" class="headerlink" title="email"></a>email</h2><p>发送邮件可以使用下面的方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mail(<span class="string">'test@test.com'</span>, <span class="string">'this subject'</span>, <span class="string">'the body'</span>);</span><br></pre></td></tr></table></figure><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1BIUE1haWxlci9QSFBNYWlsZXI=" title="https://github.com/PHPMailer/PHPMailer">https://github.com/PHPMailer/PHPMailer<i class="fa fa-external-link"></i></span> 提供了更多有邮件相关的实用API。</p><h1 id="部署PHP应用Composer"><a href="#部署PHP应用Composer" class="headerlink" title="部署PHP应用Composer"></a>部署PHP应用Composer</h1><p>Composer类似NodeJS的 NPM，和大部分的一站式依赖管理是类似的。Composer安装之后的页面内容如下：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230124105104.png" alt=""></p><p>可以使用<code>composer require nesbot/carbon</code> 命令对于项目进行依赖导入。正确导入之后会出现<code>composer.json</code>以及<code>composer.lock</code>文件，<code>composer.lock</code>文件可以对于依赖版本进行锁定。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"require"</span>: &#123;</span><br><span class="line">        <span class="attr">"nesbot/carbon"</span>: <span class="string">"^2.58"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当对应目录引入依赖之后，在PHP文件当中可以使用下面的用法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'vendor/autoload.php'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Carbon</span>\<span class="title">Carbon</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> Carbon::now();</span><br></pre></td></tr></table></figure><p>最终访问对应页面的展示内容如下：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230124105041.png" alt=""></p><p><strong>“require ‘vendor/autoload.php’;</strong>”行作用是<strong>启用自动加载</strong>。这里顺带提一下还记得我们谈论require_once（）和include_once（）吗？我们不需要手动搜索要包含的文档，我们只需使用 <strong>use</strong>  关键字将库导入我们的代码即可。</p><h1 id="部署PHP应用"><a href="#部署PHP应用" class="headerlink" title="部署PHP应用"></a>部署PHP应用</h1><p>最后作者写了一篇从零开始搭建GIT的文章比较有意思，本部分内容建议结合一些框架项目学习，博客提到的内容比较入门这里就不记录了。</p><p>See <span class="exturl" data-url="aHR0cHM6Ly9mbGF2aW9jb3Blcy5jb20vZ2l0aHViLXNldHVwLWZyb20temVyby8=" title="https://flaviocopes.com/github-setup-from-zero/">how to setup Git and GitHub from zero<i class="fa fa-external-link"></i></span></p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>更多的当作英文学习资料看待，顺带能学到一些技术内容，挺不错的。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      php英文内容了解
    
    </summary>
    
    
      <category term="PHP" scheme="https://whitestore.top/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://whitestore.top/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>Java collection of high-frequency interview questions</title>
    <link href="https://whitestore.top/2022/12/01/interviewcollection/"/>
    <id>https://whitestore.top/2022/12/01/interviewcollection/</id>
    <published>2022-12-01T09:37:41.000Z</published>
    <updated>2022-12-01T09:39:08.588Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h1><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDA0MTEwMTkzMC9lbg==" title="https://segmentfault.com/a/1190000041101930/en">java - Java collection of high-frequency interview questions_个人文章 - SegmentFault 思否<i class="fa fa-external-link"></i></span></p><h1 id="This-article-catalog"><a href="#This-article-catalog" class="headerlink" title="This article catalog"></a>This article catalog</h1><ul><li>What are the common collections? </li><li>The difference between List, Set and Map</li><li>Do you understand ArrayList?</li><li>What is the expansion mechanism of ArrayList?</li><li>How to remove an element while traversing the ArrayList?</li><li>The difference between Arraylist and Vector</li><li>The difference between Arraylist and LinkedList</li><li>HashMap<ul><li>What are the ways to resolve hash conflicts? What kind of HashMap is used?</li><li>The hash algorithm used?</li><li>Expansion process?</li><li>Put method flow?</li><li>The characteristics of red-black trees?</li><li>Why use red-black trees instead of AVL trees?</li><li>When resolving hash conflicts, why choose to use the linked list first, and then switch to the red-black tree?</li><li>Why is the length of HashMap a power of 2?</li><li>What is the default load factor of HashMap? Why is it 0.75?</li><li>What is generally used as the key of HashMap?</li><li>Why is HashMap thread unsafe?</li><li>The difference between HashMap and HashTable?</li></ul></li><li>The underlying principle of LinkedHashMap?</li><li>Tell me about TreeMap?</li><li>The underlying principle of HashSet?</li><li>What is the difference between HashSet, LinkedHashSet and TreeSet?</li><li>What is fail fast?</li><li>What is fail safe?</li><li>Tell me about ArrayDeque?</li><li>Which collection classes are thread safe? What is unsafe?</li><li>What is Iterator?</li><li>What is the difference between Iterator and ListIterator?</li><li>Concurrent container<ul><li>ConcurrentHashMap<ul><li>Put execution flow?</li><li>How to expand?</li><li>The difference between ConcurrentHashMap and Hashtable?</li></ul></li><li>CopyOnWrite</li><li>ConcurrentLinkedQueue</li><li>Blocking queue<ul><li>Blocking queue provided by JDK</li><li>principle</li></ul></li></ul></li></ul><a id="more"></a><h1 id="What-are-the-common-collections"><a href="#What-are-the-common-collections" class="headerlink" title="What are the common collections?"></a>What are the common collections?</h1><p>The Java collection class is mainly derived from two interfaces <strong>Collection</strong> and <strong>Map</strong> . Collection has three sub-interfaces: <strong>List</strong>, <strong>Set</strong>, and <strong>Queue</strong>.</p><p><strong>List</strong>：List represents an ordered and repeatable collection, which can be accessed directly according to the index of the element;</p><p><strong>Set</strong>：Set represents an unordered and non-repeatable collection, which can only be accessed according to the element itself</p><p>Image source<span class="exturl" data-url="aHR0cDovL3d3dy5qdXN0ZG9qYXZhLmNvbS8yMDE5LzA5LzE2L2phdmEtY29sbGVjdGlvbi0xLw==" title="http://www.justdojava.com/2019/09/16/java-collection-1/">【集合系列】- 初探 java 集合框架图 | Just Do Java<i class="fa fa-external-link"></i></span></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20221201164716.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20221201164721.png" alt=""></p><h1 id="The-difference-between-List-Set-and-Map"><a href="#The-difference-between-List-Set-and-Map" class="headerlink" title="The difference between List, Set and Map"></a>The difference between List, Set and Map</h1><ul><li>List accesses elements by index, in order, elements are allowed to be repeated, and multiple nulls can be inserted;</li><li>Set <strong>cannot store repeated elements</strong>, unordered, only one null is allowed;</li><li>Map saves the key-value pair mapping;</li><li>The bottom layer of List has two implementations: <strong>array and linked list;</strong> Set and Map containers have two implementations, based on hash storage and red-black tree.</li><li>Set is implemented based on Map, and the element value in <strong>Set is the key value of Map</strong>.</li></ul><h1 id="Do-you-understand-ArrayList"><a href="#Do-you-understand-ArrayList" class="headerlink" title="Do you understand ArrayList?"></a>Do you understand ArrayList?</h1><p><code>ArrayList</code> is a dynamic array, and its capacity can grow dynamically. Before adding a large number of elements, the application can use the <code>ensureCapacity</code> operation to increase the capacity of the <code>ArrayList</code> ArrayList inherits AbstractList and implements the List interface.</p><h1 id="What-is-the-expansion-mechanism-of-ArrayList"><a href="#What-is-the-expansion-mechanism-of-ArrayList" class="headerlink" title="What is the expansion mechanism of ArrayList?"></a>What is the expansion mechanism of ArrayList?</h1><p><strong>By default, the new capacity will be 1.5 times the original capacity</strong>. Take JDK1.8 as an example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//Determine whether e can be accommodated, if so, add it directly at the end; if not, expand it and then add e at the end  </span></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!  </span></span><br><span class="line">        <span class="comment">//Add e to the end of the array        elementData[size++] = e;  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;    </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Each time an element is added, the arraylist needs to make a determination about the capacity of the list. The ensureCapacityInternal() method ensures that the array currently maintained by the ArrayList has the capacity to store new elements, and then stores the elements at the end of the array elementData after processing  </span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;  </span><br><span class="line">        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//If an empty array is passed in, the minimum capacity is the maximum between the default capacity and minCapacity  </span></span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;  </span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> minCapacity;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;  </span><br><span class="line">        modCount++;  </span><br><span class="line">        <span class="comment">// If the storage capacity of the ArrayList meets the minimum storage requirements, then return add to add the elements directly; if the minimum required storage capacity &gt; the storage capacity of the ArrayList, this means that the storage capacity of the ArrayList is insufficient, so you need to call the grow(); method to expand the capacity  </span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)  </span><br><span class="line">            grow(minCapacity);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 获取elementData数组的内存空间长度  </span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;  </span><br><span class="line">        <span class="comment">// 扩容至原来的1.5倍  </span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);  </span><br><span class="line">        <span class="comment">//校验容量是否够  </span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)  </span><br><span class="line">            newCapacity = minCapacity;  </span><br><span class="line">        <span class="comment">//若预设值大于默认的最大值，检查是否溢出  </span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)  </span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);  </span><br><span class="line">        <span class="comment">// 调用Arrays.copyOf方法将elementData数组指向新的内存空间  </span></span><br><span class="line">        <span class="comment">//并将elementData的数据复制到新的内存空间  </span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>The essence of ArrayList expansion is to calculate the size of the new expanded array and instantiate it, and copy the contents of the original array to the new array.</p><h1 id="How-to-remove-an-element-while-traversing-the-ArrayList"><a href="#How-to-remove-an-element-while-traversing-the-ArrayList" class="headerlink" title="How to remove an element while traversing the ArrayList?"></a>How to remove an element while traversing the ArrayList?</h1><p>Foreach delete will cause fast failure problem, you can use the remove() method of the iterator.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Iterator itr = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(itr.hasNext()) &#123;</span><br><span class="line">      <span class="keyword">if</span>(itr.next().equals(<span class="string">"jay"</span>) &#123;</span><br><span class="line">        itr.remove();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="The-difference-between-Arraylist-and-Vector"><a href="#The-difference-between-Arraylist-and-Vector" class="headerlink" title="The difference between Arraylist and Vector"></a>The difference between Arraylist and Vector</h1><ol><li>When the memory is insufficient, ArrayList is <strong>expanded by 50% + 1 by default</strong>, and Vector is <strong>expanded by 1 times by default</strong>.</li><li>Vector belongs to the <strong>thread-safe level</strong>, but in most cases, Vector is not used because it is relatively inefficient to operate on Vector.</li></ol><h1 id="The-difference-between-Arraylist-and-LinkedList"><a href="#The-difference-between-Arraylist-and-LinkedList" class="headerlink" title="The difference between Arraylist and LinkedList"></a>The difference between Arraylist and LinkedList</h1><ol><li>ArrayList is implemented based on a <strong>dynamic array</strong>; LinkedList is implemented based on a <strong>linked list</strong>.</li><li>For the get and set methods of <strong>random index access</strong>, <strong>ArrayList is faster than LinkedList.</strong> Because ArrayList finds elements directly through the array subscript; LinkedList moves the pointer to traverse each element until it finds it.</li><li><strong>Adding and deleting elements, LinkedList is faster than ArrayList</strong>. Because ArrayList may expand and copy the array when adding and deleting elements; LinkedList needs time to instantiate objects, and only needs to modify the pointer.</li></ol><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>HashMap is implemented <strong>using array + linked list + red-black tree</strong> (JDK1.8 adds the red-black tree part). When the length of the linked list is <strong>greater than 8 (TREEIFY_THRESHOLD)</strong>（阈值）, the linked list will be converted to a red-black tree, and the number of red-black tree nodes is less <strong>than 6 ( UNTREEIFY_THRESHOLD) is converted to a linked list</strong> to prevent frequent conversion.</p><h2 id="What-are-the-ways-to-resolve-hash-conflicts-What-kind-of-HashMap-is-used"><a href="#What-are-the-ways-to-resolve-hash-conflicts-What-kind-of-HashMap-is-used" class="headerlink" title="What are the ways to resolve hash conflicts? What kind of HashMap is used?"></a>What are the ways to resolve hash conflicts? What kind of HashMap is used?</h2><p>Methods to resolve Hash conflicts include: <strong>open addressing</strong>, <strong>rehashing</strong>, and <strong>chain addressing.</strong> The chain address method is used in HashMap.</p><ul><li>The basic idea of <strong>open addressing</strong> method is that if <code>p=H(key)</code> event of a conflict（冲突）, places <code>p</code> basis, hash again, <code>p1=H(p)</code> , if p1 conflict again, places p1-based, and so on, until you find a hash address that does not conflict <code>pi</code> . Therefore, the length of the hash table required by the open addressing method <strong>must be greater than or equal to the elements that need to be stored</strong>, and because there is another hash, <strong>can only mark the deleted node, but cannot actually delete the node.</strong></li><li><strong>And then hashing a plurality（多个） of different hash function, when <code>R1=H1(key1)</code> conflict occurs, then calculate <code>R2=H2(key1)</code> , until there is no conflict. Although this is not easy to produce a pile, but it increases（增加） the calculation time.</strong></li><li>The <strong>chain address</strong> method composes a singly linked list of synonyms with the same hash value, and stores the <strong>head pointer of the singly linked list in the i-th unit of the hash table.</strong> The search, insertion and deletion are mainly performed in the synonym linked list. The linked list method is suitable for frequent insertions and deletions.</li></ul><h2 id="The-hash-algorithm-used"><a href="#The-hash-algorithm-used" class="headerlink" title="The hash algorithm used?"></a>The hash algorithm used?</h2><p>Hash algorithm: take the <strong>hashCode value of the key</strong>, <strong>high-order operation</strong>, and <strong>modulo operation</strong>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">h=key.hashCode() <span class="comment">//Step 1. Get the hashCode value</span></span><br><span class="line">h^(h&gt;&gt;&gt;<span class="number">16</span>)  <span class="comment">//Step 2 High-level participation in computing to reduce conflicts</span></span><br><span class="line"><span class="keyword">return</span> h&amp;(length-<span class="number">1</span>);  <span class="comment">//Step 3 Modulo operation</span></span><br></pre></td></tr></table></figure><p>In the implementation of <strong>JDK1.8</strong>, the algorithm for high-order operations is optimized, <strong>which is implemented by the high-order 16-bit XOR of hashCode(): this can be done when the array is relatively small</strong>, and it can also ensure that both high and low bits are taken into account. In the calculation of Hash, conflicts can be reduced without too much overhead.</p><h2 id="Put-method-process"><a href="#Put-method-process" class="headerlink" title="Put method process?"></a>Put method process?</h2><ol><li><code>If the table is not initialized, the initialization process is performed first</code></li><li><code>Use the hash algorithm to calculate the index of the key</code></li><li><code>Determine whether there is an element at the index, and insert it directly if not</code></li><li><code>If there is an element at the index, then traverse the insertion. There are two cases. One is the linked list form and the insertion is directly traversed to the end, and the other is the red-black tree and inserts according to the red-black tree structure.</code></li><li><code>If the number of linked lists is greater than the threshold 8, it must be converted into a red-black tree structure</code></li><li><code>After the addition is successful, it will check whether it needs expansion</code></li></ol><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20221201162736.png" alt=""></p><h2 id="The-characteristics-of-red-black-trees"><a href="#The-characteristics-of-red-black-trees" class="headerlink" title="The characteristics of red-black trees?"></a>The characteristics of red-black trees?</h2><ul><li>Each node is either black or red.</li><li>The root node is black.</li><li>Each leaf node (NIL) is black.</li><li>If a node is red, its child nodes <strong>must</strong> be black.</li><li>All paths from a node to the descendants of that node contain the <strong>same number of black nodes.</strong></li></ul><h2 id="Why-use-red-black-trees-instead-of-AVL-trees"><a href="#Why-use-red-black-trees-instead-of-AVL-trees" class="headerlink" title="Why use red-black trees instead of AVL trees?"></a>Why use red-black trees instead of AVL trees?</h2><p>ConcurrentHashMap will be locked when put, using the red-black tree to insert faster, which can reduce the time waiting for the lock to be released. <strong>The red-black tree is an optimization of the AVL tree</strong>. It only requires partial balance. The non-strict balance is used to reduce the number of rotations when adding and deleting nodes, which improves the performance of insertion and deletion.</p><h2 id="When-resolving-hash-conflicts-why-choose-to-use-the-linked-list-first-and-then-switch-to-the-red-black-tree"><a href="#When-resolving-hash-conflicts-why-choose-to-use-the-linked-list-first-and-then-switch-to-the-red-black-tree" class="headerlink" title="When resolving hash conflicts, why choose to use the linked list first, and then switch to the red-black tree?"></a>When resolving hash conflicts, why choose to use the linked list first, and then switch to the red-black tree?</h2><p><strong>Because red-black trees need to perform left-handed（左旋）</strong>, right-handed, and color-changing operations to maintain balance, <strong>singly linked lists do not</strong>. </p><ul><li>When the number of elements is less than 8, the linked list structure can guarantee query performance. </li><li>When there are more than <strong>8 elements</strong>, the search time complexity of the red-black tree is <strong>O(logn)</strong>, while the linked list is O(n). At this time, the red-black tree is needed to speed up the query, but the efficiency（效率） of inserting and deleting nodes becomes <strong>slower</strong>. . </li><li>If the red-black tree structure is used at the beginning, there are too few elements, and the efficiency of inserting and deleting nodes is slow, and performance is wasted.</li></ul><h2 id="Why-is-the-length-of-HashMap-a-power-of-2"><a href="#Why-is-the-length-of-HashMap-a-power-of-2" class="headerlink" title="Why is the length of HashMap a power of 2?"></a>Why is the length of HashMap a power of 2?</h2><p>The Hash value has a relatively（比较） large range value. Before using it, you need to perform a modulo（模数） operation on the length of the array, and the remainder obtained （获得）is the location where the element is stored, which is the corresponding array subscript. The calculation method for the subscript of this array is <strong>(n - 1) &amp; hash</strong> . </p><p><strong>Set the length of HashMap to the power of 2, so that you can use (n - 1)&amp;hash bit operation instead of% remainder operation to improve performance.</strong></p><h2 id="What-is-the-default-load-factor-of-HashMap-Why-is-it-0-75"><a href="#What-is-the-default-load-factor-of-HashMap-Why-is-it-0-75" class="headerlink" title="What is the default load factor of HashMap? Why is it 0.75?"></a>What is the default load factor of HashMap? Why is it 0.75?</h2><p>First look at the default constructor of HashMap:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> threshold;             <span class="comment">// Accommodates the maximum value of the key-value pair</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;    <span class="comment">// Load Factor</span></span><br><span class="line"><span class="keyword">int</span> modCount;  </span><br><span class="line"><span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><p>The initial length of the Node[] table is <strong>16</strong>, and the default loadFactor is <strong>0.75</strong>. <strong>0.75 is a balanced choice for space and time efficiency</strong>. According to the Poisson distribution, loadFactor 0.75 is the smallest collision（碰撞）. Generally, it will not be modified, except under special circumstances（情况） in time and space:</p><ul><li>If there is a lot of memory space and time efficiency is very high, you can reduce the value of Load factor（负载因子）.</li><li>If the memory space is tight and the time efficiency is not high, you can increase the value of the load factor, <strong>which can be greater than 1</strong>.</li><li>In most cases it is recommended to set the initialization size as much as possible.</li><li></li></ul><h2 id="What-is-generally-used-as-the-key-of-HashMap"><a href="#What-is-generally-used-as-the-key-of-HashMap" class="headerlink" title="What is generally used as the key of HashMap?"></a>What is generally used as the key of HashMap?</h2><p>Generally, immutable classes such as Integer and String are used as HashMap as the key. The String class is more commonly（通常） used.</p><ul><li>Because <strong>String is immutable</strong>, the hashcode is cached when it is created and does not need to be recalculated（重新计算） This is why the keys in HashMap often use strings.</li><li>The <strong>equals()</strong> and <strong>hashCode()</strong> methods are used when obtaining objects, and the Integer and String classes have already rewritten the <strong>hashCode()</strong> and <strong>equals()</strong> methods, so <strong>you don’t need to rewrite these two methods yourself.</strong></li></ul><h2 id="Why-is-HashMap-thread-unsafe"><a href="#Why-is-HashMap-thread-unsafe" class="headerlink" title="Why is HashMap thread unsafe?"></a>Why is HashMap thread unsafe?</h2><p>Infinite loop of expansion under multi-threading. The HashMap in JDK1.7 uses the header insertion method to insert elements. In a multi-threaded environment, the circular linked list may appear when the capacity is expanded, forming an endless loop.</p><p>In JDK1.8, in a multithreaded environment, data <strong>will overwrite</strong> .</p><h2 id="The-difference-between-HashMap-and-HashTable"><a href="#The-difference-between-HashMap-and-HashTable" class="headerlink" title="The difference between HashMap and HashTable?"></a>The difference between HashMap and HashTable?</h2><ol><li><strong>HashMap can accept null keys and values</strong>. Key-value pairs with null keys are placed in the linked list of the head node with subscript 0, while <strong>Hashtable cannot</strong>.</li><li>HashMap is not thread-safe, HashTable is thread-safe. Jdk1.5 provides ConcurrentHashMap, which is a replacement for HashTable.</li><li>Many methods of Hashtable are synchronous methods, which are slower than HashMap in a single-threaded environment.</li><li>The use of hash value is different, HashTable directly uses the hashCode of the object. The HashMap recalculates the hash value.</li></ol><h1 id="The-underlying-principle-of-LinkedHashMap"><a href="#The-underlying-principle-of-LinkedHashMap" class="headerlink" title="The underlying principle of LinkedHashMap?"></a>The underlying principle of LinkedHashMap?</h1><p>HashMap is unordered, and the order of the elements obtained by iterating the HashMap is not the order in which they were originally placed in the HashMap, that is, their insertion order cannot be maintained.</p><p>LinkedHashMap inherits from HashMap and is a fusion of HashMap and LinkedList, with the characteristics of both. Each put operation will insert the entry into the end of the doubly linked list.</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20221201163907.png" alt=""></p><h1 id="Tell-me-about-TreeMap"><a href="#Tell-me-about-TreeMap" class="headerlink" title="Tell me about TreeMap?"></a>Tell me about TreeMap?</h1><p>TreeMap is a Map collection that can <strong>compare the size of elements</strong>, and <strong>sorts the incoming keys by size.</strong> You can use the natural order of the elements, or you can use a custom comparator in the collection to sort.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> Inheritance structure of TreeMap：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20221122065938.png" alt=""></p><p>TreeMap features:</p><p>TreeMap is an ordered set of key-values, implemented through <strong>red-black trees</strong>. Sort according to the natural order（自然排序） of the keys or according to the provided Comparator.</p><p>TreeMap inherits AbstractMap, implements the NavigableMap interface, and supports a series of navigation methods. Given a specific search target, it can return the closest match. For example, floorEntry() and ceilingEntry() return Map.Entry() objects that are less than or equal to or greater than or equal to a given key, respectively（各自的）, and return null if they do not exist. lowerKey(), floorKey, ceilingKey, and higherKey() only return the <strong>associated key</strong>.</p><h1 id="The-underlying（根本）-principle-of-HashSet"><a href="#The-underlying（根本）-principle-of-HashSet" class="headerlink" title="The underlying（根本） principle of HashSet?"></a>The underlying（根本） principle of HashSet?</h1><p><strong>HashSet is implemented based on HashMap</strong>. The elements put into the HashSet are actually stored by the key of the HashMap, and the value of the HashMap stores a static Object object.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5024744406713321676L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map; <span class="comment">//HashMap-based implementation</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="What-is-the-difference-between-HashSet-LinkedHashSet-and-TreeSet"><a href="#What-is-the-difference-between-HashSet-LinkedHashSet-and-TreeSet" class="headerlink" title="What is the difference between HashSet, LinkedHashSet and TreeSet"></a>What is the difference between <strong>HashSet</strong>, <strong>LinkedHashSet</strong> and <strong>TreeSet</strong></h1><p><strong>HashSet</strong> is Set main interface implementation class, HashSet bottom is HashMap , thread-safe, a null value may be stored;</p><p><strong>LinkedHashSet</strong> is HashSet , which can be traversed in the order of addition;</p><p><strong>TreeSet</strong> uses a red-black tree at the bottom layer, which can be traversed in the order of adding elements, and the sorting method can be customized（自定义）.</p><h1 id="What-is-fail-fast"><a href="#What-is-fail-fast" class="headerlink" title="What is fail fast?"></a>What is fail fast?</h1><p>Fast-fail is an error mechanism of <strong>Java collections</strong>. When multiple threads operate on the same collection, fast-fail events may occur.</p><p>For example: when thread a is traversing the collection through iterator, another thread b modifies the content of the collection. At this time modCount (the number of modifications to the collection operation process) will increase by 1, which is not equal to expectedModCount, then when thread a accesses the collection, ConcurrentModificationException will be thrown.</p><p>For example2: Modifying the collection while traversing will also generate fast-fail events.</p><p>Solution：</p><ol><li><p>Use the Colletions.synchronizedList method || add synchronized to the place where the content of the collection is modified.</p><blockquote><p>Impact：<strong>block</strong> the traversal operation and <strong>affect performance</strong>（影响性能）.</p></blockquote></li><li><p>Use CopyOnWriteArrayList to replace ArrayList.</p><p> When the CopyOnWriteArrayList is <strong>modified</strong>, a <strong>new array</strong> is copied, the new array is operated, and the reference is moved to the new array after the operation is completed.</p></li></ol><p>We can see the following code to confirm（Version JDK 1.8）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            <span class="comment">// The old array will be copied and then operated on in the new array</span></span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">            newElements[len] = e;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="What-is-fail-safe"><a href="#What-is-fail-safe" class="headerlink" title="What is fail safe?"></a>What is fail safe?</h1><p>The containers under the java.util.concurrent package are safe to fail, and can be used and modified concurrently in multiple threads.</p><p><strong>Principle</strong> : Since the copy of the original collection is traversed during iteration, the modification of the original collection during the traversal process cannot be detected by the iterator, so Concurrent Modification Exception will not be triggered.</p><p><strong>Disadvantages</strong> : The advantage（好处） of copying content is to avoid Concurrent Modification Exception, but similarly, the iterator cannot access the modified content, that is: the iterator traverses the copy of the collection obtained at the moment of traversal. During this period, the modification iterator of the original collection is not known.</p><h1 id="Tell-me-about-ArrayDeque"><a href="#Tell-me-about-ArrayDeque" class="headerlink" title="Tell me about ArrayDeque?"></a>Tell me about ArrayDeque?</h1><p>ArrayDeque implements a <strong>double-ended queue</strong>（双端队列）, using a circular array internally, and the default size is 16.</p><p>characteristics：</p><ol><li>more efficient to <strong>add</strong> and <strong>delete</strong> elements at both ends</li><li>The efficiency of searching and deleting <strong>based on element</strong>（基于元素） content is relatively low.</li><li>There is <strong>no concept（概念） of index position</strong>, and operations cannot be performed based on （基于）index position.</li></ol><blockquote><p>Both ArrayDeque and LinkedList implement the Deque interface. Both ArrayDeque and LinkedList are not thread-safe<br>We can be converted to <strong>thread synchronization</strong> using <strong>synchronizedXxx()</strong> in the <strong>Collections tool</strong> class.<br>For Example：<code>java.util.Collections#synchronizedCollection(java.util.Collection&lt;T&gt;)</code></p></blockquote><p>Hsow to choose them?</p><ul><li>If you only need to operate from <strong>both ends</strong>, ArrayDeque is more efficient.</li><li>If you need to operate according to the index position at the same time, or often need to insert and delete in the middle , you should choose LinkedList</li></ul><h1 id="Which-collection-classes-are-thread-safe-What-is-unsafe"><a href="#Which-collection-classes-are-thread-safe-What-is-unsafe" class="headerlink" title="Which collection classes are thread safe? What is unsafe?"></a>Which collection classes are thread safe? What is unsafe?</h1><p>Thread safe collection class:</p><ul><li>Vector: It has more synchronization mechanism than ArrayList.</li><li>Hashtable`</li><li>ConcurrentHashMap: is an efficient and thread-safe collection.</li><li>Stack: Stack is also thread-safe, inherited from Vector.</li><li>ConcurrentHashMap<br>….（more java.util..current.*）</li></ul><p>Thread unsafe  collection class:`</p><ul><li>Hashmap</li><li>Arraylist</li><li>LinkedList</li><li>HashSet</li><li>TreeSet</li><li>TreeMap</li></ul><h1 id="What-is-Iterator"><a href="#What-is-Iterator" class="headerlink" title="What is Iterator?"></a>What is Iterator?</h1><p>The Iterator pattern uses the same logic to iterate through collections.  It can abstract the access logic from different types of collection classes.</p><p>With an iterator, <strong>you can traverse collection elements without knowing the internal implementation of the collection,</strong> using the interface provided by Iterator to unify traversal.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>There are three main methods: hasNext(), next() and remove().</p><h1 id="What-is-the-difference-between-Iterator-and-ListIterator"><a href="#What-is-the-difference-between-Iterator-and-ListIterator" class="headerlink" title="What is the difference between Iterator and ListIterator?"></a>What is the difference between Iterator and ListIterator?</h1><p>ListIterator is an enhanced（强化） version of Iterator.</p><ul><li>ListIterator traversal can be reversed, because there are <strong>previous()</strong> and <strong>hasPrevious()</strong> methods, but Iterator cannot.</li><li>ListIterator has <strong>add()</strong> method, which can add objects to List, but Iterator cannot.</li><li>ListIterator can locate（定位） the current index position because of the <strong>nextIndex()</strong> and <strong>previousIndex()</strong> methods, but Iterator cannot.</li><li>ListIterator can realize the modification of the object, and the set() method can be realized. Iierator can only be traversed and cannot be modified.</li><li>ListIterator can only be used to traverse List and its subclasses, and Iterator can be used to traverse all collections.</li></ul><h1 id="Concurrent-container"><a href="#Concurrent-container" class="headerlink" title="Concurrent container"></a>Concurrent container</h1><p>Most of these containers provided by the JDK are in the java.util.concurrent package.</p><ul><li><strong>ConcurrentHashMap</strong>：thread-safe HashMap</li><li><strong>CopyOnWriteArrayList</strong>： thread-safe List that performs（执行） very well in situations where more reads and less writes are performed, <strong>far better than Vector</strong>.</li><li><strong>ConcurrentLinkedQueue</strong>:：efficient（高效） concurrent queue, implemented using a linked list. It can be seen as a thread-safe LinkedList, which is a <strong>non-blocking queue</strong>.</li><li><strong>BlockingQueue</strong>: blocking queue interface, which is implemented in the JDK through linked lists, arrays, etc（..等等）. Very suitable for use as a data sharing channel.</li><li><strong>ConcurrentSkipListMap</strong>：The <strong>jump table</strong>. Use the data structure of the jump table for quick search.</li></ul><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>In a multi-threaded environment, using Hashmap for <strong>put operations will cause an endless</strong> loop, and ConcurrentHashMap that supports multi-threading should be used.</p><blockquote><p>Why put operations will cause an endless？If you want to know the third case What mean is, I recommend the english article：</p><p><span class="exturl" data-url="aHR0cHM6Ly9tYWlsaW5hdG9yLmJsb2dzcG90LmNvbS8yMDA5LzA2L2JlYXV0aWZ1bC1yYWNlLWNvbmRpdGlvbi5odG1s" title="https://mailinator.blogspot.com/2009/06/beautiful-race-condition.html">The Mailinator(tm) Blog: A Beautiful Race Condition<i class="fa fa-external-link"></i></span></p><p>If you English is not so good, You also can see the article</p><p><span class="exturl" data-url="aHR0cHM6Ly9jb29sc2hlbGwuY24vYXJ0aWNsZXMvOTYwNi5odG1s" title="https://coolshell.cn/articles/9606.html">疫苗：Java HashMap的死循环 | 酷 壳 - CoolShell<i class="fa fa-external-link"></i></span></p></blockquote><p>JDK1.8 ConcurrentHashMap cancels the segment lock, and uses <strong>CAS</strong> and <strong>synchronized</strong> to ensure concurrency safety. </p><p>The data structure adopts array + linked list/red-black binary tree. Synchronized only locks the first node of the current linked list or red-black binary tree.</p><p><strong>Compared with JDK1.7 locking the HashEntry array</strong>, the lock granularity（颗粒度） is smaller and supports a higher amount of concurrency（并发性）.</p><h3 id="Put-execution-flow"><a href="#Put-execution-flow" class="headerlink" title="Put execution flow?"></a>Put execution flow?</h3><p>The segment needs to be locked during put to ensure concurrency safety.</p><p>The segment needs to be locked during put to ensure（确保） concurrency safety. When calling get, do not lock it because the node array member val and pointer next are modified with <strong>volatile</strong> and the modified values are immediately refreshed in main memory for visibility（可见）, and the node array table is also modified with volatile to ensure that its running process is visible to other threads.</p><p>Here is the relevant code</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Put operation process:</p><ol><li>If the table is not initialized, the initialization process is performed first.</li><li>Use the hash algorithm to calculate the location of the key.</li><li>If this position is empty, CAS is inserted directly（直接）, if it is not empty, then this node is taken out</li><li>If the hash value of the retrieved node is MOVED(-1), it means that the array is currently being expanded and copied to the new array, and the current thread will also help copy</li><li>If this node is not empty or expanding, it will be locked through synchronized to perform the addition operation. There are two cases here<ol><li>one is that the linked list is directly traversed to the end to insert or overwrite the same key, </li><li>the other is If it is a red-black tree, insert it according to the red-black tree structure`</li></ol></li><li>If the number of linked lists is greater than the threshold 8, it will be converted into a <strong>red-black tree</strong> structure or expanded (table length is less than 64)</li><li>After the addition is successful, it will check whether it needs expansion</li></ol><p>Code：<code>java.util.concurrent.ConcurrentHashMap#putVal</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;  </span><br><span class="line"><span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) </span><br><span class="line"><span class="comment">// If the table is not initialized, the initialization process is performed first.</span></span><br><span class="line">    tab = initTable();  </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;  <span class="comment">//Use the hash algorithm to calculate the location of the key.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// If this position is empty, CAS is inserted directly（直接）, if it is not empty, then this node is taken out</span></span><br><span class="line">    <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,  </span><br><span class="line">                 <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))  </span><br><span class="line">        <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)  </span><br><span class="line"><span class="comment">// If the hash value of the retrieved node is MOVED(-1), it means that the array is currently being expanded and copied to the new array, and the current thread will also help copy</span></span><br><span class="line">    tab = helpTransfer(tab, f);  </span><br><span class="line"><span class="keyword">else</span> &#123;  </span><br><span class="line">    V oldVal = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="comment">// If this node is not empty or expanding, it will be locked through synchronized to perform the addition operation. There are two cases here</span></span><br><span class="line">    <span class="keyword">synchronized</span> (f) &#123;  </span><br><span class="line">    <span class="comment">//one is that the linked list is directly traversed to the end to insert or overwrite the same key, </span></span><br><span class="line">        <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;  </span><br><span class="line">                binCount = <span class="number">1</span>;  </span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;  </span><br><span class="line">                    K ek;  </span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;  </span><br><span class="line">                        ((ek = e.key) == key ||  </span><br><span class="line">                         (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;  </span><br><span class="line">                        oldVal = e.val;  </span><br><span class="line">                        <span class="keyword">if</span> (!onlyIfAbsent)  </span><br><span class="line">                            e.val = value;  </span><br><span class="line">                        <span class="keyword">break</span>;                    &#125;  </span><br><span class="line">                    Node&lt;K,V&gt; pred = e;  </span><br><span class="line">                    <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                        pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,  </span><br><span class="line">                                                  value, <span class="keyword">null</span>);  </span><br><span class="line">                        <span class="keyword">break</span>;                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">// the other is If it is a red-black tree, insert it according to the red-black tree structure</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;  </span><br><span class="line">                Node&lt;K,V&gt; p;  </span><br><span class="line">                binCount = <span class="number">2</span>;  </span><br><span class="line">                <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,  </span><br><span class="line">                                               value)) != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                    oldVal = p.val;  </span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent)  </span><br><span class="line">                        p.val = value;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123; </span><br><span class="line">    <span class="comment">//   If the number of linked lists is greater than the threshold 8, it will be converted into a red-black tree structure or expanded (table length is less than 64)</span></span><br><span class="line">        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)  </span><br><span class="line">            treeifyBin(tab, i);  </span><br><span class="line">        <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)  </span><br><span class="line">            <span class="keyword">return</span> oldVal;  </span><br><span class="line">        <span class="keyword">break</span>;    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  After the addition is successful, it will check whether it needs expansion</span></span><br><span class="line"><span class="keyword">if</span> (delta != <span class="number">0</span>)  </span><br><span class="line">    addCount((<span class="keyword">long</span>)delta, binCount);</span><br></pre></td></tr></table></figure><h3 id="How-to-expand"><a href="#How-to-expand" class="headerlink" title="How to expand?"></a>How to expand?</h3><p>In the array expansion transfer method, a step size is set to indicate the length of the array processed by a thread, and the minimum value is 16. <strong>Only one thread will copy and move it in a step range.</strong></p><h3 id="The-difference-between-ConcurrentHashMap-and-Hashtable"><a href="#The-difference-between-ConcurrentHashMap-and-Hashtable" class="headerlink" title="The difference between ConcurrentHashMap and Hashtable?"></a>The difference between ConcurrentHashMap and Hashtable?</h3><ol><li><p>Hashtable achieves（实现） multi-thread synchronization by using the synchronized modification method. Therefore, the synchronization of Hashtable will <strong>lock the entire array.</strong> </p><p> In the case of high concurrency, the performance will be very poor. ConcurrentHashMap uses more fine-grained locks to improve efficiency in concurrent situations（并发情况）. </p><blockquote><p>Note: Synchronized container (synchronized container) also achieves thread safety through the synchronized keyword, and locks all data when in use.</p></blockquote></li><li><p>The default size of Hashtable is 11. When the threshold（阈值） is reached, the capacity is expanded according to the following formula（公式） each time: newCapacity = oldCapacity * 2 + 1. The default size of ConcurrentHashMap is 16, and the capacity is <strong>doubled</strong> when expanding.</p></li></ol><h2 id="CopyOnWrite"><a href="#CopyOnWrite" class="headerlink" title="CopyOnWrite"></a>CopyOnWrite</h2><p>Copy-on-write. When we add elements to the container, we do not directly add to the container, but first copy the current container, <strong>copy out（导出） a new container</strong>, and then add elements to the new container, after adding the elements, then point the reference to the original container New container.</p><p>The advantage of this is that the CopyOnWrite container can be <strong>read concurrently without locking</strong>, <strong>because the current container will not be modified</strong>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// ensure synchronization and avoid copying multiple copies when writing in multiple threads</span></span><br><span class="line">    lock.lock(); <span class="comment">//The add method requires a lock</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>); <span class="comment">//Copying a new array</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements); <span class="comment">//The reference of the original container points to the new container</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Since JDK1.5, the Java Concurrency Package provides two concurrent containers implemented using the <strong>CopyOnWrite</strong> mechanism（机制）. They are <strong>CopyOnWriteArrayList</strong> and <strong>CopyOnWriteArraySet</strong>.</p><p>When the add method in <strong>CopyOnWriteArrayList</strong> is added, it needs to be locked to ensure synchronization and avoid copying multiple copies when writing in multiple threads.</p><p>There is no need to lock when reading. If other threads are adding data to <strong>CopyOnWriteArrayList</strong> when reading, the old data can still be read.</p><blockquote><p>这里有点像是模仿操作系统写时复制的理念。写操作在一份“虚拟空间”操作。</p></blockquote><p><strong>Disadvantages</strong>（缺点）：</p><ul><li><strong>Memory usage</strong> problem. Due to the copy-on-write mechanism of CopyOnWrite, the memory of <strong>two objects</strong> resides in the memory at the same time when the write operation is performed.</li><li>The CopyOnWrite container cannot guarantee（保证） the real-time consistency of the data, and old data may be read.</li></ul><h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><p>Non-blocking queue. Efficient（高效） concurrent queues are implemented using linked lists. It can be seen as a thread-safe LinkedList, implemented through <strong>CAS operations</strong>.</p><p>If the cost of locking the queue is high, it is suitable（适合） to use a lock-free <strong>ConcurrentLinkedQueue</strong> instead. It is suitable for scenarios（场景） where the performance requirements are relatively high and there are multiple threads to read and write to the queue <strong>at the same time</strong>.</p><h4 id="non-blocking-queue"><a href="#non-blocking-queue" class="headerlink" title="non-blocking queue"></a>non-blocking queue</h4><ul><li><strong>add(E e)</strong>: Insert element e to the end of the queue. If the insertion is successful, it returns true; if the insertion fails (ie, the queue is full), an exception will be thrown;</li><li><strong>remove()</strong>: Remove the element at the head of the queue. If the removal（移除） is successful, it will return true; if the removal fails (the queue is empty), an exception will be thrown;</li><li><strong>offer(E e)</strong>: Insert the element e at the end of the queue, if the insertion is successful, it returns true; if the insertion fails (that is, the queue is full), it returns false;</li><li><strong>poll()</strong>: Remove and get the first element of the queue, if successful, return the first element of the team; otherwise, return null;  </li><li><strong>peek():</strong> Get the first element of the queue, if successful, return the first element of the queue; otherwise, return null;</li></ul><p>For non-blocking queues, it is generally recommended（一般推荐） to use the three methods of offer, <strong>poll and peek</strong>, and it is not recommended to use the add and remove methods.</p><blockquote><p>Because the three methods of offer, poll, and peek can be used to determine whether the operation is successful or not through the return value, but the use of add and remove methods cannot achieve this effect.</p></blockquote><h2 id="Blocking-queue"><a href="#Blocking-queue" class="headerlink" title="Blocking queue"></a>Blocking queue</h2><p>The blocking queue is an important data structure under the <code>java.util.concurrent</code> package.</p><p>BlockingQueue provides a <strong>thread-safe</strong> queue access method: when the blocking queue is inserting data, if the queue is full, the thread will block and wait until the queue is not full; When the queue fetches data, there is no blocking. if the queue is empty, the thread will block and wait <strong>until the queue is not empty</strong>.</p><p>Many implementations of advanced（高级） synchronization classes under the Concurrency package are based on BlockingQueue, which is <strong>suitable for use as a data-sharing channel.</strong></p><p>The difference between a blocking queue and a general queue is:</p><ol><li>（blocking queue）Multi-thread support, multiple threads can safely access the queue.</li><li>Blocking operation. When the queue is empty, the consumer thread will block and wait for the queue to be not empty; when the queue is full, the production thread will block until the queue is not full.</li></ol><table><thead><tr><th>Method\Processing Method</th><th>Throw an exception</th><th>Return special value</th><th>Keeps blocking</th><th>Timeout exit</th></tr></thead><tbody><tr><td>Insert method</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e,time,unit)</td></tr><tr><td>Removal method</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time,unit)</td></tr><tr><td>Inspection Method</td><td>element()</td><td>peek()</td><td>unavailable</td><td>unavailable</td></tr></tbody></table><h3 id="Blocking-queue-provided-by-JDK"><a href="#Blocking-queue-provided-by-JDK" class="headerlink" title="Blocking queue provided by JDK"></a>Blocking queue provided by JDK</h3><p>JDK7 provides 7 blocking queues, as follows</p><h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><p>Bounded blocking queue, the bottom layer is implemented by array. Once the ArrayBlockingQueue is created, <strong>the capacity cannot be changed</strong>. The concurrency control adopts（采用） reentrant（可重入） locks to control, whether it is an insert operation or a read operation, a lock must be acquired（获得） before the operation can be performed.</p><p>This queue sorts the elements according to the <strong>first-in-first-out (FIFO)</strong> principle.</p><p>By default, the fairness（公平性） of thread access to the queue is <strong>not guaranteed</strong>（保证）. The parameter <code>fair</code> can be used to set whether the thread accesses the queue fairly. In order to ensure fairness, throughput is usually reduced.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayBlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Integer&gt;(<span class="number">10</span>,<span class="keyword">true</span>);<span class="comment">//fair</span></span><br></pre></td></tr></table></figure><h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><p>LinkedBlockingQueue is a bounded blocking queue implemented with a singly linked list, which can be used as an unbounded queue or a bounded queue. </p><p>Usually when creating a LinkedBlockingQueue object, the maximum capacity of the queue is specified. <strong>The default and maximum length of this queue is <code>Integer.MAX_VALUE</code></strong> . This queue sorts the elements according to the first-in-first-out principle. Compared with ArrayBlockingQueue, it has higher throughput.</p><h4 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h4><p>Support priority <strong>unbounded</strong> blocking queue. By default, the elements are arranged in ascending order（升序） in natural order.</p><p>You can also customize the class to implement the <code>compareTo()</code> method to specify the element sorting rules, or when you initialize the PriorityBlockingQueue, specify the construction parameter <code>Comparator</code> for sorting.</p><p>PriorityBlockingQueue can only specify the initial queue size. When inserting elements later, if there is not enough space, <strong>will automatically expand to</strong>.</p><p>A thread-safe version of PriorityQueue. <strong>No null value can be inserted</strong>.  At the same time, the object inserted into the queue must be comparable in size (comparable), otherwise a ClassCastException will be reported. Its insert operation put method will not block, because it is an unbounded queue (the take method will block when the queue is empty).</p><h4 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h4><p>Unbounded blocking queue that supports delayed acquisition of elements. The queue is implemented using <strong>PriorityBlockingQueue</strong>. The elements in the queue must implement the <strong>Delayed interface.</strong> When creating the element, you can specify how long it takes to get the current element from the queue. Only when the delay expires can elements be extracted from the queue.</p><h4 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h4><p>In a blocking queue that does not store elements, each put must wait for a take operation, otherwise it cannot continue to add elements. Support fair access queue.</p><p><strong>SynchronousQueue</strong> can be regarded（被视为） as a passer, responsible for passing the data processed by the producer thread directly to the consumer thread. </p><p><strong>The queue itself does not store any elements</strong>, which is very suitable（适合） for transitive scenarios. The throughput of SynchronousQueue is higher than that of LinkedBlockingQueue and ArrayBlockingQueue.</p><h4 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h4><p>An unbounded（无界） blocking TransferQueue queue composed of（组成） a linked list structure. Compared with other blocking queues, there are more tryTransfer and transfer methods.</p><p><strong>Transfer method</strong>: If there is currently a consumer waiting to receive an element (take or time-limited poll method), transfer can immediately transfer the element passed by the producer to the consumer. </p><p><strong>If there is no consumer waiting to receive the element</strong>, put the element in the tail node of the queue, and wait <strong>until</strong> the element is consumed by the consumer before returning.</p><p><strong>tryTransfer method</strong>: used to test whether the elements passed by the producer can be directly passed to the consumer. If no consumers are waiting, <strong>return false</strong>. The difference with the above method is that the method returns immediately regardless（不论如何） of whether the consumer <strong>receives it or not</strong>. The transfer method must wait until the consumer has consumed it before returning.</p><h3 id="principle"><a href="#principle" class="headerlink" title="principle"></a>principle</h3><p>JDK uses the notification mode（通知模式） to implement blocking queues. The so-called notification mode is that when the producer adds elements to the full queue, the producer will be blocked. When the consumer consumes（消費） the elements in a queue, the producer will be notified that the current queue is available.</p><p>ArrayBlockingQueue uses Condition to achieve:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) <span class="comment">// When the queue is empty, block the current consumer</span></span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">          putIndex = <span class="number">0</span>;</span><br><span class="line">     count++;</span><br><span class="line">     notEmpty.signal(); <span class="comment">// Notify the consumer to get the element when the queue is not empty</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      有关JAVA的面试题
    
    </summary>
    
    
      <category term="面试" scheme="https://whitestore.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="https://whitestore.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>&#39;如何实现B站网页下载视频&#39;</title>
    <link href="https://whitestore.top/2022/11/16/bdownload/"/>
    <id>https://whitestore.top/2022/11/16/bdownload/</id>
    <published>2022-11-16T03:05:20.000Z</published>
    <updated>2022-11-16T03:06:25.187Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>此方法建议不要随意在网上传播，虽然本意想让更多人知道，但是确实比较怕菊爆党。</p><a id="more"></a><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ol><li>先下载油猴插件（需要梯子插件搜 <strong>Tampermonkey</strong>）。</li></ol><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20221116110048.png" alt=""></p><p>网站地址：<span class="exturl" data-url="aHR0cHM6Ly93d3cudGFtcGVybW9ua2V5Lm5ldC9zY3JpcHRzLnBocA==" title="https://www.tampermonkey.net/scripts.php">Tampermonkey • Userscript Sources<i class="fa fa-external-link"></i></span></p><p>之后前往下面的搜索页面，搜索B站[空格]下载</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20221109143839.png" alt=""></p><ol start="2"><li>找到排序的第一个插件：</li></ol><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20221109143929.png" alt=""></p><ol start="3"><li><p>进入页面下载即可，详细介绍这里就这里不贴图了，低调低调，另外脚本的介绍页还藏了福利，不想错过请仔细阅读</p></li><li><p>进入到自己想要下载视频的页面<s>先来个一键三连</s>，然后就可以看到下载视频的按钮，点击之：</p></li></ol><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20221109144052.png" alt=""></p><ol start="5"><li>进入下面的页面需要做这几件事情：</li></ol><ul><li>安装下面提到的依赖软件</li><li>把RPC网址进行切换</li><li>设置自己的下载位置</li><li>全选批量下载，然后等待即可。</li></ul><p><strong>默认RPC默认地址</strong><br>(1)、Motrix RPC默认地址：ws://localhost:16800/jsonrpc<br>(2)、Aria2 RPC默认地址：ws://localhost:6800/jsonrpc</p><h1 id="依赖软件"><a href="#依赖软件" class="headerlink" title="依赖软件"></a>依赖软件</h1><h2 id="Motrix"><a href="#Motrix" class="headerlink" title="Motrix"></a>Motrix</h2><p>简单好用的开源软件： <span class="exturl" data-url="aHR0cHM6Ly9tb3RyaXguYXBwL3poLUNOLw==" title="https://motrix.app/zh-CN/">Motrix<i class="fa fa-external-link"></i></span>。有点像绿色版某雷。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20221109150021.png" alt=""></p><p>安装之后的下载效果如下：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20221109140515.png" alt=""></p><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>虽然B站下载器也可以做到，但是个人更喜欢网页无缝下载。另外插件介绍里面也提示了不单单是B站下载视频，个人没那么多心思去折腾其他网站，这里就留给读者自己尝试了</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      B站下载视频
    
    </summary>
    
    
      <category term="其他" scheme="https://whitestore.top/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="其他" scheme="https://whitestore.top/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>14岁懂社会 -《虽然人人都说暴力不好》读书笔记</title>
    <link href="https://whitestore.top/2022/11/09/suiranrenren/"/>
    <id>https://whitestore.top/2022/11/09/suiranrenren/</id>
    <published>2022-11-08T22:38:00.000Z</published>
    <updated>2022-11-16T03:04:34.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="14岁懂社会-14岁懂社会-《虽然人人都说暴力不好》读书笔记"><a href="#14岁懂社会-14岁懂社会-《虽然人人都说暴力不好》读书笔记" class="headerlink" title="#14岁懂社会 14岁懂社会 -《虽然人人都说暴力不好》读书笔记"></a>#14岁懂社会 14岁懂社会 -《虽然人人都说暴力不好》读书笔记</h1><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220912211411.png" alt="封面"></p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>不知道能否发出这篇文章出来，斗胆试一下。</p><p>很久没写非技术的内容了，这次写一个长文读书笔记。书名叫做《虽然人人都说暴力不好》，但是实际上人人内心并不反对暴力（我自己加的）。</p><p>这本书给14岁的学生看未免有点过早，它具备一定的深度，以这本书为媒介，可以借此拓展出很多有意思的话题，比如国家和暴力，道德和法律，暴力和自我意识，政治世界和国家的本质等。</p><p>这本书的笔记会涉及一些哲学讨论，如果觉得枯燥可以看结尾的“国家的本质”部分。</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>这本书是个人认为《14岁懂社会》整个系列里面最需要反思的一本书，作者从儿时受到体罚的暴力体验，到阐述暴力的讨论，从杀人是否合法，到引入了三位大人物：康德、霍布斯、黑格尔，讲述他们的思想和暴力的关联。</p><p>以康德的“定言命令式”作为出发点，讲述了客观唯心的道德观，但是缺乏理论支持，霍布斯的社会契约论，虽然具备一定的思想觉醒，但本身依然以教皇派的天赋人权为思想核心，就和儒家思想成汉文化的历史渊源，最终却是统治者的思想控制工具。</p><p>黑格尔的“自我意识”正好揭露了国家机器诞生的核心，讲述了国家这个机器的本质，最后作者告诉你如何正确的看待暴力本身。</p><p>以上就是这本书讲的大致内容。</p><h1 id="个人评价"><a href="#个人评价" class="headerlink" title="个人评价"></a>个人评价</h1><p>比较有意思的书，通过这本书可以了解暴力究竟是如何定义的，以及如何对待暴力这一中性的事物，我们可以了解到康德的“定言命令式”，黑格尔的“自我意识”的一些重点。</p><p>霍布斯的“社会契约论”缺陷和不足，他们的思想斗争以及观点都具备鲜明的时代色彩，作为不懂哲学的我，作者用形象的语言介绍的十分有趣，实在没有想到一本小小的青少年读物居然会上升到哲学。</p><p>个人认为这本书比较适合作为《人类简史》的补充，也适合作为看另一本书《枪炮细菌与钢铁》的引导（但不建议看中文，翻译差）。</p><p>国家成为了权力机关，在不自觉的剥夺了人类暴力行为本身，这究竟是如何做到的？归根结底是工业革命带来枪支火药的热兵器，也促成了长久稳定国家的形成，从另一个角度看，国家是科技发展的必然产物，也是进化的必然 ，国家会以各种形式存在，并不会消亡。</p><p>很多时候，事物发展的规律是多方面的，作者在阐述中用辩证角度开放的回答了一些哲人的观点，这又让我想到了《非暴力沟通》的区分情感与评论，这本书出色之处就在于情感的剥离和评论的客观性，而客观性的论述让人更让人具有反思性。</p><h1 id="个人语录"><a href="#个人语录" class="headerlink" title="个人语录"></a>个人语录</h1><p>个人认为这本书一些值得思考和推敲的话题：</p><ul><li>如果违法不被以同样的对待和同情，正义也会变为伪装暴力的工具。</li><li>如果行为被绝对的道德标准论断，那么事实往往会被掩盖和隐藏。</li><li>如果暴力以道德标准作为行使与衡量，那么法律和秩序稳定将同时失去。</li><li>国家实质是暴力的集合体，但是用暴力手段推翻国家往往滋生暴力（恐怖分子推翻政府）。所谓物极必反，当暴力甚至会影响自身的存在，换来的却更有可能是去安全和稳定的生活（核武器）。</li><li>康德的定言命令式，试图给道德和暴力明确的定义，但是其本身没法自洽，康德本人也无法回答道德本身违背定言命令式这一命题。</li><li>霍布斯的社会契约论，把国家的发展看作是“自然现象”和“获得契约”，“获得契约”具备一定局限性，但是有一定现实意义。</li><li>黑格尔揭露国家诞生的另一种观点：寻求“认可”的阶级斗争，直到一方倒下认可，斗争不会结束。</li><li>实质现代观念上的国家，是以工业革命为开端，我们现代人的国家理念实质只有4、500年的历史，也就是枪炮细菌和钢铁罪恶的开始。</li><li>正是因为我们生活在不是非黑即白的世界，所以我们必然生活在政治世界的斗争当中。</li></ul><h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p>访问链接：<span class="exturl" data-url="aHR0cHM6Ly93d3cubXVidWNtLmNvbS9kb2MvNVVXS29wRE5tOFI=" title="https://www.mubucm.com/doc/5UWKopDNm8R">https://www.mubucm.com/doc/5UWKopDNm8R<i class="fa fa-external-link"></i></span></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/%E3%80%8A%E8%99%BD%E7%84%B6%E4%BA%BA%E4%BA%BA%E9%83%BD%E8%AF%B4%E6%9A%B4%E5%8A%9B%E4%B8%8D%E5%A5%BD%E3%80%8B.png" alt="《虽然人人都说暴力不好》思维导图"></p><h1 id="暴力的好坏评判"><a href="#暴力的好坏评判" class="headerlink" title="暴力的好坏评判"></a>暴力的好坏评判</h1><p>第一章节我们可以获得下面的一些观点：</p><p>第一个观点，作者开头引入了为什么人人都反对暴力，学校却很严厉的体罚惩罚不听话的学生？正所谓欲加之罪，何患无辞，惩罚的理由有千万个，作者在小时候受到了无声的暴力对待，这是这本书作者思考暴力为何物以及后续延伸的索引。</p><p>第二个观点，为了保护重要的人，有时候不得不动用暴力。为了抵挡暴力，我们有时候也必须动用暴力，暴力是一个不好也不坏的东西，极端的反对暴力，人们甚至会选择遏制自己的欲望，比如有的地方不吃猪肉，有的地方只吃素食，当然另一端也有极端的赞同暴力，演变成遭人利用的战争机器，比如法西斯。</p><blockquote><p>法西斯是人文主义走向极端的一种体现。</p></blockquote><p>第三个观点，虽然大部分人看上去都讨厌暴力，内心却又十分接受它的存在，这是隐藏在内心的阴暗面。暴力本身和金钱一样，是让人又爱又恨的东西，人作为生物不可避免的渴望杀戮和血腥，但是人活在国家的框架之下，发挥的永远是被授予的正当的执行暴力的权利，暴力实际上是被“赋予”的而不是“与生俱来”的，这一点会在本书的后文讨论。</p><p>第四个观点，道德和法律以及人类社会环境的约束，造成人类和谐社会的根本。实际上人作为生物，人类本身活着其实就是暴力，吃肉就是对于动物的暴力，吃蔬菜是对植物的暴力。暴力本身一直无处不在。</p><p>所以暴力的好坏是无法评判的，为了生存，人类和所有生物一样，从来不会觉得这是“不好的事情”，也不会认为这是“好事情”。暴力只因主观因素决定，跟随主观内心。</p><p>既然暴力不可取但是又没有明确的道德约束，那么为什么不能杀人呢？作为人的争斗，为什么仅仅限于求出结果而不是殊死搏斗？</p><h1 id="为什么不能杀人？"><a href="#为什么不能杀人？" class="headerlink" title="为什么不能杀人？"></a>为什么不能杀人？</h1><p>暴力本身没有理论支持，那么为什么不能杀人？</p><p>人言可畏，言语有时候会成为强大的力量，人们恐惧言语的力量胜过行使暴力。但是单凭言语是力量过于弱小，因为人可以安慰自己行使暴力加害他人，国家依靠法律约束暴力的泛滥，给为“不能杀人”这一点给了绝对的限制理由。</p><p>但法律实际上也会允许杀人，法律通过正当的理由和正当的程序形式，杀人便成了“好”的了，对于受害者来说，这是一件“好事”，但是对于公众来说，这样的法律本身十分危险，法律应该有尺度和约束的牢笼，但是国家权力才是被作为丈量万物的“尺度”，这样本身是否矛盾的，这也是为什么法治体现了国家的治国之本。</p><p>所以说杀人不对？还是说暴力也不对？如果严格按照道德标准评判杀人的好坏，那么道德标准无法自洽，人人虽然都反对杀人，但是人人却又喜欢“杀人”，不能杀人看似是根深蒂固都道德标准，实际上更大程度是因为暴力行为本身受到控制和受到裁定。</p><p>此外，言语并非完全无用，否则教育会失去其本身意义，教育需要引导孩子做出正确的行为，符合安稳和平社会的意愿生存。但是又因为此种原因从小到大灌输不反抗的观念，而看不见暴力，逐渐变得顺从，顺从则会滋生暴力。</p><p>不能因为看不见的暴力，而成为“绵羊”，完全拒绝暴力本身就是不可取的，这是底线，这并不是不可动用的武器，在任何情况下，都要有明辨是非的心。</p><p>所以为什么不能杀人？说白了实质上还是取决于国家所制定的法律约束框架，和个人情感无关，有的国家甚至为了金钱可以舍弃一切。个人的意志约束虽然能起到一定的作用，但是究其原因，取决于国家的“操盘者”如何设计。</p><p>这里举个例子，在中国个人持枪是不被允许存在的“极端恐怖分子”，而在美国一个家庭持有几把手枪却是再正常不过的行为，从我们的国家角度看，持枪是“暴力”行为，以此推断”为什么不能杀人？“这一理由，其实并不是我们自己说了算。</p><p>道德本身是由社会环境诞生的产物，是一种<strong>客观唯心主义</strong>的存在。有了国家的掌控，道德还有什么用？道德又该如何定义？康德的“定言命令式”给出了他的答案。</p><h1 id="康德的“定言命令式”"><a href="#康德的“定言命令式”" class="headerlink" title="康德的“定言命令式”"></a>康德的“定言命令式”</h1><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><p>定言命令式，是德意志哲学家康德在1785年出版的《道德形而上学的基础》一书中所提出的哲学概念。</p><p>下面的内容引自维基：</p><blockquote><p>康德认为，道德完全先天地存在于人的理性之中。只有因基于道德的义务感而做出的行为，方存在道德价值。因心地善良而做出的义举，或是因义务而做出的德行（譬如军人因救灾而牺牲），都不能算作真正有德的行为。</p><p>道德应当，而且只应当从规律概念中引申演绎而来。尽管自然界中的一切事物都遵循某种规律，但只有理性生物（人）才具有按照规律的理念而行动的能力（自由意志）。就客观原则对意志的约束规范而言，其命令尽管是强制的，但同时也是理性的。这种理性命令的程式，就叫作“令式”。</p><p>令式有两种。如果某种行为无关于任何目的，而出<strong>自纯粹客观的必然性</strong>，那么这种令式才是“定言令式”。如果<strong>行为是实现目的的手段</strong>，则被康德称为“假言令式”。</p></blockquote><p>在这本书中，作者对于“定言命令式”的理解是：定言命令式是道德基础，所谓的定言命令式，就是 <strong>不以人的意志转移，无论何时何地，都只基于道德的义务感</strong> ，强行做某事或者不做某事的<strong>道德律</strong>。</p><p>比如：“不行就是不行”就是简单的道德定言命令式，但是“不想被抓就不要偷东西”这不是定言命令式，因为“不想被抓就不要偷东西”，可以有很多的反对说法，”只要不被抓到就可以偷东西”这就是彻头彻尾的主观唯心主义。</p><p>定言命令式实质是“不行就是不行”，指的是康德认为的定言命令式是不需要理由的，比如“不能杀人”是道德律，“为什么杀人是不对的”这不需要理由，“不行就是不行”，从这一点可以看出，<strong>道德是建立一种无法为行为寻找理由的基础上建立的</strong>，道德并不是对于行为的约束，更像是对于行为本身的直接否定。</p><h2 id="“定言命令式”-站不住脚"><a href="#“定言命令式”-站不住脚" class="headerlink" title="“定言命令式” 站不住脚"></a>“定言命令式” 站不住脚</h2><p>但是事情并没有结束，康德在后续的著作中又赞成死刑，他认为如果不通过刑法将人处死，将无法实现正义。</p><p>为什么这么说？这不是自相矛盾么？个人理解是康德自身认为杀人偿命本身也是定言命令式，贯彻死刑并不是为了通过死刑维护道德律，而是通过死刑实现正义，所谓正义是维持道德律的基本条件。</p><p>这就又回到了“不行就是不行”这一定言命令式，因为不能用死刑来满足受害者的“私欲”，也不能用死刑来作为制约犯罪的条件，所以法律需要给受害人和加害人同样的尊重，用死刑制裁杀人犯和道德律以及任何理由无关。</p><p>但是显然这一套说法本身没法自圆其说，既说“不行就是不行”，又说“杀人应当偿命”，显然康德的这一套说法属于“客观唯心主义”，禁不住理论的推敲和考验，康德本身也陷入到了关于这个定言命令式的争论当中。</p><p>康德在不同的时间点产生了不同的说法，归根结底是 <strong>道德没有任何理论支撑</strong>，之所以失去理论支撑，是因为道德只在某种特定环境下产生，比如国家管辖之下的法律，才能真正的控制住暴力滋生。</p><p>比如，如果一个人为了生存而必须自相残杀，基于生存条件他必须做出违背“定言命令式”的行为，所以这也就违背了道德，康德这时候的”赞成死刑“，也同样是违背了道德剥脱了别人的生存权，所以道德本身就是在违背定言命令式进行工作的。 </p><p>所以”定言命令式“是站不住脚的，因为要”定言命令式“要让人相信，就必须要“无条件”，但是无条件显然是不可能的，因为无法为道德赋予任何理论，也无法用言语解释道德究竟是什么。无法讨论道德的存在，是因为道德是给予人这种客观存在而诞生的“社会意识”，就好比理性并不是先天诞生于内心，而是以社会生活存在的基础上而出现的“约束”。</p><p>光凭道德是站不住脚的，所以才需要法律去约束道德，道德本身只能看作是”调味品”，取决于环境对于人格的约束，而法律诞生自国家这一个机器，国家是“巨大的谎言”，他比道德更具备“欺骗性”。</p><p>道德本身没有理论支持，康德的发言显然是存在矛盾的，需要具体情况具体分析。所以为什么要讲这么多关于哲学的东西？因为这和后面讨论的国家有关。</p><p>接下来我们再看看霍布斯的社会契约论。</p><h1 id="霍布斯的“社会契约论”"><a href="#霍布斯的“社会契约论”" class="headerlink" title="霍布斯的“社会契约论”"></a>霍布斯的“社会契约论”</h1><p>在引出霍布斯的社会契约论之前，先来看看作者在书中讲述的丰城秀吉刀狩令”。</p><h2 id="引子：刀狩令"><a href="#引子：刀狩令" class="headerlink" title="引子：刀狩令"></a>引子：刀狩令</h2><p>刀狩令指的是日本历史上没收武士以外的僧侣和平民所拥有武器的政策。该政策最早是在镰仓时代实施，而最为有名的刀狩令则是丰臣政权于1588年（天正16年）所实施的刀狩令。</p><p>秀吉的刀狩令是以解除百姓的武装为目的，以农村存在的武器为前提，从百姓手中夺取带刀的权利。但是实质上刀狩令更多是在表面上推行，因为它针对的只是冷兵器，并没有禁止平民拥有热兵器，比如持有其他枪，弓箭和以驱除害兽为目的的铁炮，以及祭祀用的武器是被允许的。</p><p>这里肯定会有疑问，百姓都能私藏火药了，刀狩令的意义是什么？刀狩令更多的意义是赋予了“<strong>绝对的阶级</strong>”观念，武士拥有持刀权利，平民便会把持刀看作身份象征，进而产生了身份制度，由身份制度而逐渐演化为阶级，而阶级的目标则是建立和平昌盛的，任自己掌控的“太平天国”，国家也由此诞生而巩固。</p><p><strong>刀狩令本质是将人划分为“可以行使暴力的人”和“不可以行使暴力权利的人”</strong>，然而这种推进实质上更像是社会契约，但是这种契约在当时还比较弱</p><h2 id="社会契约论"><a href="#社会契约论" class="headerlink" title="社会契约论"></a>社会契约论</h2><p>霍布斯的国家理论是从一种假想的“自然状态”入手的，在国家产生之前的这种自然状态中，人们都依据自然法而享有各种天赋的自然权利。他在《利维坦》中系统论述的社会契约论思想、君权民授理论和天赋权利学说，奠定了西方近代政治学的基础。</p><p>霍布斯的社会契约中把国家的形成，看作是“自然的联邦”和“获得的联邦”。</p><p>“<strong>自然的联邦</strong>”：可以看作是一位强者把所有人的暴力收归于一体，强者和所有人建立一种安稳秩序的契约关系，所有人的暴力由一个人掌控，实质是“天赋人权”，天赋君权的思想。</p><p>“<strong>获得的联邦</strong>”：说明了权力是由于弱者一方“赠予”强者一方，难听点就是强者一方强制剥夺弱者的暴力权利，让弱者依附于强者本身存在。 </p><p>显然“获得的联邦”才是现实，也道出了国家起源的本质，而“自然联邦”则成为了胜利者的宣传工具。社会契约论是暴力终结和权力归一的开始，由“获得的联邦”逐渐演化出阶级，社会契约论简单来说是指暴力权力能够在自然契约的状态下，由部分群体拥有制裁的权力。</p><p>所以霍布斯的理论并不是毫无意义的，但是西方政治学把 <strong>自然的联邦</strong> 这一套作为“粉饰”工具，掩盖国家机器的“罪恶”一生。以此作为政治思想传输和思想控制的一种手段和工具，霍布斯的部分理论实质已经十分接近真相本身。</p><h1 id="黑格尔的“自我意识”"><a href="#黑格尔的“自我意识”" class="headerlink" title="黑格尔的“自我意识”"></a>黑格尔的“自我意识”</h1><p>和霍布斯的“顺其自然”不同，黑格尔揭露了国家起源的丑恶本质：<strong>国家的起源来源于不间断的斗争，直到一方承认和服从</strong>。</p><p>所谓自我意识，指的是为了要得到某样东西，必须要与另一方进行斗争，为了斗争则需要强迫对方屈服战斗到最后一刻，为了战斗到最后一刻。</p><p>这一观点由黑格尔提出，他最初的论断是两个人对于同一事物的争斗，其中一方最终总会屈服于另一方，只有最为勇敢和战斗到底的一方可以获得胜利，也就是所谓的“<strong>精神胜利法</strong>”，黑格尔以此推导出国家起源的过程。</p><p>黑格尔的“自我意识”有什么意义呢？关键是阐述了<strong>暴力和权力的认可与连接</strong>，无论是权力和权利，本身都不是因为设立而存在的，而是因为<strong>认同</strong>而存在，斗争胜利的一方获得权力，而斗争失败的一方选择服从并且获得被授予和被控制的权利。作为生物的暴力的实践活动，本身就是为了获得“认可”这一目的本身。</p><p>所以黑格尔的思想，既包含了社会契约本身，又包含了对于暴力哲学的解释。因为自我意识的存在，不同的组织之间必然会斗争，而产生斗争则必然引出政治世界。</p><p>何谓政治世界？政治世界就是<strong>树立谁可以对其使用暴力和谁不能对其使用暴力</strong>，是否意味着政治世界就是所谓的非黑即白，彼此充满斗争呢？这么说肯定是不对的，正是因为我们生活在不是非黑即白的世界，所以我们必然生活在政治世界的斗争当中，这句话值得推敲。</p><h1 id="国家的本质"><a href="#国家的本质" class="headerlink" title="国家的本质"></a>国家的本质</h1><p>国家的本质实质是暴力的权力中枢，从这一点看国家本身就不是干净的产物，但是否定和肯定暴力或者批判暴力也好，暴力本身并不会因为国家灭亡消失而消失，我们身处国家管辖之下，就无时无刻身处暴力之中，只不过暴力被约束和限制。</p><p>所以国家的本质需要面对暴力观念的本身，我们分为“国家和暴力”、“国家的形成”、“税收的本质”三个方面讨论。</p><h2 id="国家和暴力"><a href="#国家和暴力" class="headerlink" title="国家和暴力"></a>国家和暴力</h2><p>广义上说暴力是基于财富的争端开始，也是国家形成的开始，而枪支弹药是决定暴力合而为一归于国家管控的的关键，古代皇帝之所以无法完整统一，是因为暴力有可能滋生在小团体，并且逐渐被无限放大，或者通过分封权力被逐渐瓦解，最终自然溃散。只有权力完全不会溢出，才有可能导致暴力的正常控制，国家才能够真正的正常运转。</p><p>运用暴力取代一个国家，为了压制国家本身的暴力，是在用道德标准呼吁更大的暴力，那么只会滋生更加暴力和专制的国家，这种假的“定言命令式”造成更黑暗的暴力滋生，所以不要因为国家这一“黑暗”的存在，而出现了推翻国家的想法，因为 <strong>“恶”一旦滋生，只会被越放越大</strong>。</p><p>但是话说回来，国家统治的基础是推翻是建立另一个国家或者组织，如果一方可以以暴力完全侵占另一方，那么暴力演变为武器是自然而然的，枪炮和钢铁带来的长久稳定的国家，行使暴力的代价加大，越是小心谨慎。</p><p>我们不能因为暴力受到国家统治。而以此作为反对国家暴力的道德论断，如果行为被绝对的道德标准论断，那么事实往往会被掩盖和隐藏。</p><p>综上所述，国家的合并是由于暴力权力掌握在少部分人手中得以实现，也就是说真理必然掌握在少数人手中。</p><h2 id="国家的形成"><a href="#国家的形成" class="headerlink" title="国家的形成"></a>国家的形成</h2><p>我们结合前面的内容，从康德、霍布斯和黑格尔的观点看国家的形成。</p><p>国家暴力通常都是由分散到统一，在国家没有形成之前，暴力分散在小部分集体手中，可能是村落，也能是地区。在古代，因为暴力实际上是很难完全控制的，因为冷兵器可以被轻易造出来，而到了热兵器时代，枪支制造本身就需要一定的技术，同时只要控制材料的获取，制造枪支也是无米之炊。</p><p>所以热兵器就像是武士刀一样，掌握在一部分人手中，于是身份和阶级诞生产生了所谓的精神胜利力量，进而集团和势力的诞生，再之后则是国家的诞生。</p><p>康德用定言命令式论断暴力本身，但是他的理论始终无法将道德本身和定言命令式自洽， 更多的是自相矛盾。</p><p>虽然国家的诞生包含复杂的历史原因和人文社会原因，但是归根结底，就是暴力由分散到统一的过程。</p><h2 id="税收的本质"><a href="#税收的本质" class="headerlink" title="税收的本质"></a>税收的本质</h2><p>那么国家是如何收税的呢？国家将暴力按照合法和不合法的分开，才能合理的征税，如果没有任何法律约束进行合法的暴力征收，那么国家和黑社会的对等性将会消失，国家和黑社会也会变得没有什么不同，这时候将会有反对的声音存在。</p><p>税收的本质是，国家掌握暴力权力保护底层人民的合法安全的维持秩序的手段，和黑社会的本质区别是，<strong>税收不需要声明或者证明自己的存在</strong>，而是属于一种<strong>自愿被剥夺行为</strong>，当然国家更多时候会动用一系列措施，让公民找不到借口避税，但是避税和收税始终是无法完全避免。</p><h1 id="如何看待暴力"><a href="#如何看待暴力" class="headerlink" title="如何看待暴力"></a>如何看待暴力</h1><p>评判暴力不应该以道德作为天平，而应该衡量如何利用国家机器更好的管理暴力，如何制衡社会中的暴力行为。</p><p>取代国家是不可取的，因为”黑恶势力“总会乘虚而入，就好像古代皇帝的椅子永远都是有人坐的，既然国家作为暴力的中枢本身无法替代，那么就应当积极应对国家做出的调整和改变，不管如何看待，作为普通人最终永远只能选择接受。</p><p>抛开国家这个机器失控不谈，我们生活实际上本身无法脱离暴力，因为有些事情只能通过暴力的手段去解决，我们需要的是不评价不站队的去看待暴力本身，也就是现在常说的”理中客“。</p><p>恶意是可怕的，这时常让我想起泰戈尔诗中那个存在阴暗面的罪恶的自己，同时也让我直接想到了《恶意》这本书。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这篇读书笔记内容很多，写的比较啰嗦，很多哲学的内容需要不断形象概括和理解，当然这也是这本书的有趣之处，作者中性的论述和严谨求证值得学习，总结就是学到了不少”奇怪“的知识，认识了三个奇怪的哲人，哈哈。</p><p>两月没写非技术的读书笔记了，希望这篇没有辜负读者期望。</p><p>最后，这篇文章收录到：<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vbGF6eVRpbWVzL2Fkb25nLXN0dWR5Tm90ZXM=" title="https://gitee.com/lazyTimes/adong-studyNotes">阿东的书屋: 个人的读书笔记归档，欢迎同样爱看书的小伙伴一起共读。 欢迎关注公众号：懒时小窝 (gitee.com)<i class="fa fa-external-link"></i></span> 这个项目中，所属目录是“2022-09”，也可以在PC端直接搜标题名称找到对应的位置。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      虽然人人都说暴力不好
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://whitestore.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="书籍" scheme="https://whitestore.top/tags/%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>【科普】蓝思值是什么？</title>
    <link href="https://whitestore.top/2022/09/07/lansizhi/"/>
    <id>https://whitestore.top/2022/09/07/lansizhi/</id>
    <published>2022-09-07T13:26:56.000Z</published>
    <updated>2022-09-08T02:18:34.397Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【科普】蓝思值是什么？"><a href="#【科普】蓝思值是什么？" class="headerlink" title="【科普】蓝思值是什么？"></a>【科普】蓝思值是什么？</h1><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>如果你喜欢并且想要看一些英文书或者原著，或者想要提升英语水平，那么阅读这些内容都会有帮助。</p><p>原文：<span class="exturl" data-url="aHR0cHM6Ly93d3cuc3R1ZHl0b3VyYS5jb20vbGV4aWxlLw==" title="https://www.studytoura.com/lexile/">https://www.studytoura.com/lexile/<i class="fa fa-external-link"></i></span>，本文为阅读完这篇文章之后的一些个人笔记。</p><a id="more"></a><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>蓝思阅读体系最初由A. Jackson Stenner和Malbert Smith博士创立于1989年，旨在为<strong>阅读</strong>和<strong>写作</strong>提供更加精准的<strong>测评</strong>系统。</p><p>也就是说可以认为是测试系统，所有的内容都只是依据，不能过度依赖。</p><p>所谓的蓝思值可以简单认为是综合多项指标构建的一套<strong>英文材料阅读能力的分级制度</strong>。划分依据主要是对比一个文章或者一本书当中<strong>重复单词的数量</strong>出现的频率，可以简单理解为一句英文当中，如果出现的重复单词很多，蓝思值会普遍比较低，反之则很高。</p><p>这里我们常常会陷入一个误区，认为书越厚的书蓝思值越高。实际上这种观念是错的，比如《哈利波特》虽然字很多，但是实际上句子不是特别难理解，而个人之前所看的名著《老人与海》，虽然看着100多页，但是蓝思值高达940！因为海明威这老头写书喜欢整很多生僻词。</p><p>所以实际上任何国家的语言都一样，虽然创造发明的文字很多，但是实际上生活中用来用去的也就那些单词，难懂的书不仅仅是语法上的复杂，生僻词和不重复单词的使用也是非常关键的。</p><p>此外从这些依据我们可以直接了解到，如果我们能通读蓝思值高的书，那么毫无疑问单词量和语法掌握程度肯定很高，反之，还需要回去练练，这很直观的体现了蓝思值的作用和意义。</p><p>光文字不够直观，这里直接给一张图，这个图实际上<strong>心理安慰成分比较大</strong>，实际上以中国应试教育，绝大多数人哪怕大学过了英语四级，只要生活不使用英语，要不了多少时间就会直线退化到美国小学一年级水平：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220907122440.png" alt=""></p><p>当然也不需要过分的纠结蓝思值以及去对号入座，这只是一个参考值帮助你更好的寻找自己适合的读物而已。</p><h1 id="有什么用？"><a href="#有什么用？" class="headerlink" title="有什么用？"></a>有什么用？</h1><p>蓝思值的根本作用是 <strong>找到你的学习区，拒绝舒适区，避开困难区</strong>。但是这些标准都是以美国人的标准进行衡量的，作为非母语语言英语学习和阅读者，蓝思值的下限通常会更低。</p><p>蓝思值在美国还是受到认可的，各个大洲基本都有流行和普及，也推广到了国外，如果没有阅读英文书或者英文材料的习惯，大概率是不知道有这个东西的（比如我也是阅读相关文章之后才了解到有这东西）。</p><p>此外个人实际使用之后发现阅读英语材料提升有帮助的，至少可以给自己一个坚持的理由，根据自己的水平调高或者调低目标要求，我们可以把自己想要看的书用蓝思值进行标记，然后再进行分类，按照书的难易程度进行划分阅读，这样可以保持坚持读英语的习惯。</p><h1 id="怎么用？"><a href="#怎么用？" class="headerlink" title="怎么用？"></a>怎么用？</h1><p>查找方式如下：</p><p>登录到网站：<span class="exturl" data-url="aHR0cHM6Ly9odWIubGV4aWxlLmNvbS9maW5kLWEtYm9vay9zZWFyY2g=" title="https://hub.lexile.com/find-a-book/search">https://hub.lexile.com/find-a-book/search<i class="fa fa-external-link"></i></span></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220907161705.png" alt=""></p><p>比如我用《Tuesdays With Morrie》这本书去搜索这本书的蓝思值。</p><p>网站标注的蓝思值还是挺高的，但是实际上这本书当中有很多对话，个人认为并不认为十分难懂，算是好读的书。个人认为难的部分是在老师讲的很多机翻也，以及比较难理解的深刻道理上，这本书和ALS牵扯有很多医学方面的单词出现，所以很可能会划定比较难的一类。</p><p>如果有Ipad，我们使用Ipad上的<strong>蒙哥阅读器</strong>查一下这本书就会发现，有将近一半的单词在英语4级的水平以下，20%的内容属于4级水平，所以也不需要过多信任或者纠结蓝思值的高低，更建议 <strong>眼见为实</strong>。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220907121644.png" alt=""></p><p>还有一种方法是直接根据搜索条件进行搜索。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220907161947.png" alt=""></p><p>比如我找到 100 - 200蓝思值的动物分类的书籍。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220907162053.png" alt=""></p><p>就会出现一些幼儿园的小朋友都可以看懂的书，还挺有意思的。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220907162040.png" alt=""></p><blockquote><p>搜索条件中有一个条件下拉框，内容是K1,123456，这些内容不是国内四六级的标准，是人家美国人的标准，切记不要将国人思维带进去。</p></blockquote><h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><h2 id="如何评估或提高自身水平？"><a href="#如何评估或提高自身水平？" class="headerlink" title="如何评估或提高自身水平？"></a>如何评估或提高自身水平？</h2><p>对于美国人来说，这些网站用起来如鱼得水，但是对于我们来说却是不一样的。一般来讲，一篇文章如果看下来<strong>生词在0-25%区间</strong>，内容也大概理解，基本上就是落在学习区的书籍。</p><p>据调查，一个普通美国人接受良好教育的情况下，词汇量通常是再 2万到3万的区间，也就是说我们要达到美国成年人，起步的词汇量就需要追上2万这个大卡。</p><p><strong>这是很难得</strong>！因为我说的是美国成人的水平，人家从出生到成年用了20年，可以用生活和环境自动学习很多东西，这些在国内几乎是没法实现的，你也没有那么多20年。</p><p>所以实际上你只需要追求到<strong>美国高中生的水平</strong>，你也可以看懂大部分的读物，无论是工作还是生活都够用，因为仅仅是追上美国高中生这一点就很难。</p><p>此外时蓝思值要活学活用，比如网站中的搜索条件中的K1,12345并不是指的英语级别，而是美国本土学院的年龄段和蓝思值对应表，用数字划分区间更简洁一些。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220907163721.png" alt=""></p><h2 id="吐槽：谨慎选择"><a href="#吐槽：谨慎选择" class="headerlink" title="吐槽：谨慎选择"></a>吐槽：谨慎选择</h2><p>TNND，《老人与海》作为世界名著不是盖的，煎熬着看了两个月啃完不容易，所以大家不要学我，一定要找适合自己的书看，个人喜欢死钻牛角尖，哪怕一大堆生词的书也会又倔又犟的努力看懂，英文书一旦开始看很难停下来。</p><p>但是现在想想自己真是<code>fool</code>，白白浪费了很多时间。但是偶尔在困难区锻炼会很有干劲，经验之谈。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220907162350.png" alt=""></p><h2 id="蓝思值标识"><a href="#蓝思值标识" class="headerlink" title="蓝思值标识"></a>蓝思值标识</h2><p>因为蓝思值是作为美国教育儿童的一项指标参考之一，所以再蓝思值上面还会有一些标记，个人感觉对于没受到过美国学习教育的“外国人”启发意义不是很大，说白了就是看不懂，所以放到最后了。</p><p><strong>AD: Adult Directed</strong> <strong>成人指导</strong>： 标注有AD的文本（多为图画书）里面的图片虽然可以辅助孩子理解，但其生词数以及文本编排等可能会影响孩子阅读。所以官方建议成人朗读给孩子听，边朗读边解释，而不是让孩子自主阅读。</p><p><strong>NC: Non-Conforming</strong> <strong>非标准</strong>：标注有NC的文本更适合阅读能力较强，蓝思值超越所在年龄段普遍水平的学员。这类文本蓝思值较高，但文本内容适合所在年龄段。</p><p><strong>HL: High-Low</strong> <strong>高兴趣低可读性</strong>：标注有HL的文本更适合阅读能力较弱，蓝思值低于所在年龄段普遍水平的学员。这类文本蓝思值较低，但文本内容适合所在年龄段。</p><h2 id="为什么要学英语？"><a href="#为什么要学英语？" class="headerlink" title="为什么要学英语？"></a>为什么要学英语？</h2><p>过去的一些记录，看看就好，个人始终认为只要互联网存在一天，学英语就是有价值的事情。</p><ul><li><strong>互联网是美国人发明的！互联网是美国人发明的！互联网是美国人发明的！</strong> 这个理由够不够。</li><li>Stack flow 是技术圈最顶尖的技术论坛，编程上99%的问题你都可以上面找到思路或者答案。 </li><li>知识不是凭空来的，只是你用中文搜不到而已。</li><li>尽信书不如无书，任何的二手资料，永远不如官方文档。就好比HTTP，RFC里面做了很多规定，主流浏览器大部分时候都是遵照协议实现的，互联网发展到今天，靠的是标准的“强制执行”。</li><li>翻译软件是工具，不是看不懂英文搬出来解决问题的再生父母。 </li><li>《JAVA编程思想》，被翻译搞臭的一本的好书，被翻译烂的书就是在害人，误人子弟，就应该口诛笔伐。 - 我所见的高手，没有英语差的。 </li><li>我们现在所学的东西，人家老外可能十几年就学的很深并且写出博客了=-=</li></ul><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>蓝思值还是比较有用的指标，喜欢阅读英文书的同学可以试试用网站测试一下。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      蓝思值和相关科普
    
    </summary>
    
    
      <category term="其他" scheme="https://whitestore.top/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="其他" scheme="https://whitestore.top/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】拿到一台虚拟机Linux该干什么？</title>
    <link href="https://whitestore.top/2022/09/07/linuxshould/"/>
    <id>https://whitestore.top/2022/09/07/linuxshould/</id>
    <published>2022-09-07T13:23:04.000Z</published>
    <updated>2022-09-08T02:18:34.397Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【Linux】拿到一台虚拟机Linux该干什么？"><a href="#【Linux】拿到一台虚拟机Linux该干什么？" class="headerlink" title="【Linux】拿到一台虚拟机Linux该干什么？"></a>【Linux】拿到一台虚拟机Linux该干什么？</h1><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>很多时候我们喜欢在自己电脑上装一台Linux虚拟机玩，但是每次装好之后基本都是两眼无神，不知道下一步干啥，所以这篇文章主要就是解决安装好Linux之后，建议做的一些操作，帮助快速构建本地可用环境。</p><p>本文演示的Linux版本为CenterOs7.9，使用的镜像是官方7.9的Miniual版本（也就是最小体积版本），VM Tool 的版本为16.2.3 build-19376536。整个过程步骤十分简单，比较适合新手使用。</p><a id="more"></a><h2 id="一、步骤"><a href="#一、步骤" class="headerlink" title="一、步骤"></a>一、步骤</h2><h2 id="1-1-虚拟机连接"><a href="#1-1-虚拟机连接" class="headerlink" title="1.1 虚拟机连接"></a>1.1 虚拟机连接</h2><p>通过虚拟机登录到LInux，切换Root角色，使用<code>sudo vi /etc/ssh/sshd_config</code>修改文件，注意不要改错文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/ssh/sshd_config</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改端口</span></span><br><span class="line">Port 10022</span><br><span class="line"><span class="meta">#</span><span class="bash"> 由于是新的Linux虚拟机，建议还是先保留22端口，等能正常用10022登陆再去掉，万一10022登不上就嗝屁了（并不会）</span></span><br><span class="line">Port 22</span><br><span class="line"><span class="meta">#</span><span class="bash"> 不允许 ROOT 登陆，不成文规定</span></span><br><span class="line">PermitRootLogin: no</span><br></pre></td></tr></table></figure><h2 id="1-2-禁止root登陆"><a href="#1-2-禁止root登陆" class="headerlink" title="1.2 禁止root登陆"></a>1.2 禁止root登陆</h2><p>执行命令<code>vi /etc/ssh/sshd_config</code>，找到<code>PermitRootLogin</code>，将后面的yes改为no。</p><p>记得把前面的注释 <code>#</code> 取消，这样root就不能远程登录了！通常用普通账号登录进去，要用到root的时候进入系统再使用命令<code>su root</code>。</p><p>也可以构建 <strong>给予sudo权限的用户</strong> 操作自己的虚拟机（下文介绍），总之就是不要Root直接登录。</p><p><code>vi</code> 命令是没有颜色提示的，所以如果想要更好的配置阅读体验，通常需要安装<code>vim</code>，命令<code>yum install vim -y</code>。</p><p>再次强调拿到虚拟机之后第一手操作是<strong>关闭Root登录</strong>，不管是否为本地LInux服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 不允许 ROOT 登陆</span><br><span class="line">PermitRootLogin: no</span><br></pre></td></tr></table></figure><p>修改完成之后的效果图：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220906164214.png" alt="改端口禁ROOT"></p><blockquote><p>如果找不到配置，检查是否修改的是<strong>ssh_config</strong>，而不是<strong>sshd_config</strong>文件！</p></blockquote><h2 id="1-3-改登录端口（ssh）"><a href="#1-3-改登录端口（ssh）" class="headerlink" title="1.3 改登录端口（ssh）"></a>1.3 改登录端口（ssh）</h2><p>临时新增端口方法不建议使用，这里记录改文件永久生效的办法。</p><p>因为是自己本地的虚拟机，所以直接图省事，把防火墙关闭，这样也不要老是去配端口。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>根据要求加上自己需要的端口，将<code>#Port 22</code>的注释去掉并且换行加入<code>Port 10022</code>，如果是不是增加而是想直接修改端口的话，这里<strong>建议先保留22端口，等新端口可以登录再去掉</strong>。</p><p>另外再介绍一下，443是https使用的端口，3128是squid使用的端口，一万以内的端口使用频率很高。</p><p>如果是自己使用建议使用大端口，比如10000~65535以上，基本不会有中间件和其他的冲突问题。</p><p>对于一些自己程序使用的端口，也是数建议千位数字前面加一个1,，基本可以保证不冲突。</p><p>修改完成之后一定要记得 <strong>重启ssh服务</strong>：<code>systemctl restart sshd.service</code>，或者直接重启虚拟机Linux系统。</p><h2 id="1-4-关闭linux内部防火墙"><a href="#1-4-关闭linux内部防火墙" class="headerlink" title="1.4 关闭linux内部防火墙"></a>1.4 关闭linux内部防火墙</h2><p><strong>检测自己添加了多少开放的端口</strong>  ：<code>firewall-cmd --zone=public --list-ports</code>。当然我这里演示是直接关掉防火墙，对外是畅通无阻的。</p><p>临时新增方法（不建议使用）：<code>firewall-cmd --zone=public --add-port=12280/tcp --permanent</code> ，<code>--permanent</code>就是让端口永久生效</p><p>不建议使用原因，第一个是不知道端口加来干嘛用的，后面容易忘，第二个是这个操作只能<strong>临时生效</strong>，重新启动又会还原。</p><blockquote><p>不建议使用的其他原因是执行此命令<strong>会把文件的所有注释清空</strong>！！</p></blockquote><p>注意改端口之后尝试外部连接是失效的，因为还有selinux和防火墙需要处理，这里依然图省事一并给他关了。</p><p>所以这里firewalld 的基本使用如下：</p><pre><code>启动：`systemctl start firewalld`关闭： `systemctl stop firewalld`查看状态：`systemctl status firewalld` 开机禁用  ： `systemctl disable firewalld`开机启用  ： `systemctl enable firewalld`</code></pre><p>我们需要关闭防火墙，当然这里只能在自己的虚拟机这么用，主要是减少自己捣鼓学习的时候避免各种不必要的麻烦，在真实的生产环境实际上更多情况是开启的。</p><p>此外如果是云服务器提供商，这个配置通常也是关闭的，取而代之的是在外部做了一个安全网。</p><p><strong>步骤</strong></p><p>使用<code>systemctl status firewalld</code>检查状态。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220523114235.png" alt=""></p><p>关闭<code>systemctl status firewalld.serivce</code>。</p><blockquote><p>这里有个挺蛋疼的踩坑点，感觉这块像是两个人写的（怪怪的），使用<code>systemctl stop firewalld</code>是临时关闭，重启之后防火墙又会自动打开，<code>systemctl status firewalld.serivce</code>是<strong>永久关闭防火墙服务</strong>。</p></blockquote><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220906162311.png" alt=""></p><h2 id="1-5-关闭-SeLinux"><a href="#1-5-关闭-SeLinux" class="headerlink" title="1.5 关闭 SeLinux"></a>1.5 关闭 SeLinux</h2><p><strong>简易解释</strong></p><p>关闭防火墙之后，接着是关闭 <strong>SeLinux</strong> 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 注意需要ROOT 权限</span></span><br><span class="line"> vi /etc/selinux/config</span><br><span class="line"><span class="meta">#</span><span class="bash">　将 SELINUX=disabled 表示关闭</span></span><br><span class="line">SELINUX=disabled</span><br></pre></td></tr></table></figure><p>操作完成之后使用 <code>:</code> 加上<code>-x</code> 保存，之后建议<code>reboot</code>一下。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220523112457.png" alt=""></p><blockquote><p> <strong>x 和 wq 的区别？</strong><br>       x 执行操作完毕，如果修改了文件，文件的最后修改时间会产生变化，没有，则不变化<br>       wq 执行操作完毕，不管文件有没有改动，最后修改时间都会产生变化</p></blockquote><p><strong>保姆解释</strong></p><p><strong>永久生效</strong>的方法，执行命令 <code>vi /etc/selinux/config</code> 【需要<strong>ROOT</strong>权限】，出现如下文本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> This file controls the state of SELinux on the system.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> SELINUX= can take one of these three values:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     enforcing - SELinux security policy is enforced.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     permissive - SELinux prints warnings instead of enforcing.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     disabled - No SELinux policy is loaded.</span></span><br><span class="line">SELINUX=enforcing</span><br><span class="line"><span class="meta">#</span><span class="bash"> SELINUXTYPE= can take one of three two values:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     targeted - Targeted processes are protected,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     minimum - Modification of targeted policy. Only selected processes are protected. </span></span><br><span class="line"><span class="meta">#</span><span class="bash">     mls - Multi Level Security protection.</span></span><br><span class="line">SELINUXTYPE=targeted</span><br></pre></td></tr></table></figure><p>默认情况下SELINUX是<code>enforcing</code>的，我们只需要修改这一部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELINUX&#x3D;disabled</span><br></pre></td></tr></table></figure><p>最后<code>reboot</code>一下。</p><h2 id="1-6-Sudo权限用户构建"><a href="#1-6-Sudo权限用户构建" class="headerlink" title="1.6 Sudo权限用户构建"></a>1.6 Sudo权限用户构建</h2><p>使用Root添加新用户，配置密码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加新用户</span></span><br><span class="line">useradd 想要添加的用户名（英文）</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改密码</span></span><br><span class="line">passwd 想要添加的用户名（英文）</span><br><span class="line"><span class="meta">#</span><span class="bash"> 之后提示输入密码</span></span><br></pre></td></tr></table></figure><p>让新用户具备SUDO的权限，<code>vi /etc/sudoers</code>，或者给这个文件赋予写入的权限<code>chmod u+w /etc/sudoers</code>（直接Root操作更方便）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Next comes the main part: which users can run what software on </span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># which machines (the sudoers file can be shared between multiple</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># systems).</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Syntax:</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#      user    MACHINE=COMMANDS</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># The COMMANDS section may have other options added to it.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Allow root to run any commands anywhere </span></span></span><br><span class="line">root    ALL=(ALL)       ALL</span><br><span class="line">zxd     ALL=(ALL)       ALL</span><br></pre></td></tr></table></figure><p>后续使用者加上sudo 命令， 就可以具有root权限了，但是会提示输入密码。</p><p>这样的用户既可以外部登录，操作的时候也相对安全一些，虽然有Sudo权限，但是实际上要比Root管的范围要小一点，Root依然是Linux的最高权限管理员。</p><p><strong>另一种方法：错误示范</strong></p><p>下面的方式通用是给普通用户穿一件Root的衣服，但是这样的话登录会被识别为Root登录，<strong>和禁用Root发生冲突</strong>，直白的说就是登不进系统（尴尬）。</p><blockquote><p>不建议从用户管理的角度做这种操作，因为本质上相当于复制了一个Root。</p></blockquote><p>创建一个新用户，但是给予root同等的权限，我们称之为伪Root的普通用户，换句话说叫做系统管理员。</p><p>我们需要执行下面的步骤：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加新用户</span></span><br><span class="line">useradd 想要添加的用户名（英文）</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改密码</span></span><br><span class="line">passwd 想要添加的用户名（英文）</span><br><span class="line"><span class="meta">#</span><span class="bash"> 之后提示输入密码</span></span><br></pre></td></tr></table></figure><p>接下来是配置用户的Root权限，这里要使用Root身份进行操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/passwd</span><br></pre></td></tr></table></figure><p>第一行是root身份，所以我们直接把相关配置赋给新用户。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#第一行内容</span><br><span class="line">root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</span><br><span class="line"># 新增用户（通常新增用户的最底部）</span><br><span class="line">zxd:x:1000:1000:zxd:&#x2F;home&#x2F;zxd:&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line"># 进行修改操作</span><br><span class="line"># 修改之前（通常新增用户的最底部）</span><br><span class="line">zxd:x:1000:1000:zxd:&#x2F;home&#x2F;zxd:&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line"># 修改之后</span><br><span class="line"># 删除掉</span><br><span class="line"># zxd:x:1000:1000:zxd:&#x2F;home&#x2F;zxd:&#x2F;bin&#x2F;bash</span><br><span class="line"># 新增下面这一行</span><br><span class="line">新增用户名:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p>最后验证一下，如果<code>su 新建用户名</code>之后前面显示的内容为Root则说明伪装成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost zxd]# su zxd</span><br></pre></td></tr></table></figure><h2 id="1-7-验证"><a href="#1-7-验证" class="headerlink" title="1.7 验证"></a>1.7 验证</h2><p>这里直接使用<strong>Xshell</strong>进行测试，使用10022登录，22端口无法登录，无法用root登录等均验证通过。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220907101420.png" alt=""></p><h1 id="二、扩展思考"><a href="#二、扩展思考" class="headerlink" title="二、扩展思考"></a>二、扩展思考</h1><p>弄完基础配置的Linux系统之后，我们可以从下面的方面入手，当然后半部分基本为扩展学习建议：</p><ul><li>关闭 selinux 。</li><li>SSH 改端口（ssh），1024以内的端口需要root启动的。比较常见的端口一般禁止占用：<ul><li>0 - 65535 ；</li><li>ssl 443 ；</li><li>22 ；</li><li>8080 ；</li><li>80 ；</li><li>1433 ；</li><li>3306； </li><li>10022（改完之后的登录端口） ；</li><li>5022；</li><li>禁止root登陆； </li></ul></li><li>新建用户和组，给予目录的权限。</li><li>开放linux内部防火墙（iptables 6（不维护）、firewalld 7） 。</li><li>挂载硬盘 。</li><li>NFS文件共享 。</li><li>局域网拷贝 。</li><li>文件自动同步 。</li><li>检测服务器磁盘空间 。</li><li>shell 自动清理磁盘 。</li><li>构建软链接，硬链接 （windows,linux）。</li><li>yum本地源。</li><li>挂载光驱 （【无法联网的情况，学会可以使用本地源】）</li><li>时间设置，时间同步，修改时区。 </li><li>常用的命令熟悉。</li><li>常用软件安装。</li><li>根据所学解决甲方安全测评等单位，给出的服务器安全整改报告，或者自己设置一些难度比较高的挑战目标（如果有可能的话）。</li></ul><h1 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h1><p>轻松简单的文章，希望这篇文章对于读者有帮助。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      拿到一台虚拟机Linux该干什么？
    
    </summary>
    
    
      <category term="服务端-linux" scheme="https://whitestore.top/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF-linux/"/>
    
    
      <category term="服务端-linux" scheme="https://whitestore.top/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF-linux/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 缓存技术</title>
    <link href="https://whitestore.top/2022/08/24/httphuancun/"/>
    <id>https://whitestore.top/2022/08/24/httphuancun/</id>
    <published>2022-08-24T13:01:55.000Z</published>
    <updated>2022-09-08T02:18:34.394Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP-缓存技术"><a href="#HTTP-缓存技术" class="headerlink" title="HTTP 缓存技术"></a>HTTP 缓存技术</h1><p>缓存技术出现在HTTP1.1当中，目的是尽可能的减少对于服务器进行请求。为了实现缓存技术，HTTP设计者在头部字段增加针对缓存的头部字段。HTTP 缓存有两种方式，<strong>强制缓存</strong>和<strong>协商缓存</strong>。</p><h2 id="认识缓存"><a href="#认识缓存" class="headerlink" title="认识缓存"></a>认识缓存</h2><p>介绍具体的缓存技术之前，我们先来认识一下HTTP中的缓存特点。</p><p>注意<strong>缓存只对获取文件有效</strong>，从服务器上拿到文件然后放入本地缓存，下次再获取则从本地缓存区获取文件，这样可以减轻服务器压力。</p><p>缓存技术在HTTP中的体现是通过几个请求字段的配合，按照一定的判断流程控制。HTTP1.1主要通过下面三个请求头部信息判定缓存有效性：</p><ul><li><code>Cache-Control</code>：服务器可以返回此字段指定浏览器和中间缓存应该存活多久。</li><li><code>ETag</code>：浏览器缓存过期的时候，通过Etag令牌检查文件是否出现改变。Etag 是特殊算法计算的唯一哈希值。</li><li><code>Last-Modified</code>：和Etag用途相同，但是它是基于时间的策略检查是否更改。</li></ul><p>这三个字段基本囊括大部分HTTP缓存技术的应用场景。</p><a id="more"></a><h3 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h3><p>缓存位置通常存在下面几种：</p><ul><li>Service Work</li><li>Memory Cache</li><li>Disk Cache（常用）</li><li>Push Cache</li></ul><h4 id="Service-Work"><a href="#Service-Work" class="headerlink" title="Service Work"></a>Service Work</h4><p>通常运行在浏览器的后台，主要功能是实现缓存，使用此组件需要请求协议为HTTPS，因为Service Work 本身会拦截请求，需要 HTTPS保证安全才能使用。</p><h4 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a>Memory Cache</h4><p>内存中的缓存，主要是当前页面已经捕获的资源。比如图片，脚本等，这种方式要比Disk Cache 要快上非常多，但是注意这个缓存寿命非常短，一旦关闭Tab，内存缓存会随着页面的关闭立马释放。</p><p>内存缓存中有一块重要的缓存资源是 <strong>preloader 相关指令</strong>，也是页面优化的手段之一，可以做到解析脚本和CSS文件的同时请求下一个资源。</p><h4 id="Disk-Cache"><a href="#Disk-Cache" class="headerlink" title="Disk Cache"></a>Disk Cache</h4><p>Disk Cache 存在于磁盘的缓存，读取虽然慢一点，但是可以实现持久化存储，并且容量比内存缓存要宽泛很多。</p><p>Disk Cache的覆盖面在浏览器中占用比重很大，通常结合HTTP头部字段进行判断，如果跨站点下载文件，已经下载过的文件不会再次请求，而是直接从<code>Disk Cache</code> 获取。</p><blockquote><p>如何判断缓存进内存还是进磁盘？<br>通常有两个依据：</p><ol><li>如果是大文件，通常会进入磁盘当中进行缓存。</li><li>如果是频繁访问的文件，也会放入磁盘。</li></ol></blockquote><h4 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h4><p>推送缓存是HTTP/2 新加入的内容，上面三种情况都没有命中的时候才会尝试使用。它是会话级别缓存，一旦会话结束，也会立即释放缓存，生命周期只比内存缓存长一点点。</p><h4 id="缓存过程"><a href="#缓存过程" class="headerlink" title="缓存过程"></a>缓存过程</h4><p>缓存的大致流程如下：</p><ol><li>客户端发起HTTP请求访问浏览器缓存，浏览器不存在缓存，告知客户端让它重新发请求。</li><li>客户端再次发起HTTP请求到原始服务器，原始服务器返回结果和缓存规则。</li><li>客户端再次发起请求，从浏览器的缓存中获取请求结果。</li></ol><p>注意第一步是隐式处理的，所以缓存过程主要有两个要点：</p><ul><li>每次请求都会检查浏览器是否存在缓存标识，以及请求的缓存结果。</li><li>如果没有特殊字段禁用缓存，缓存将会把请求结果缓存存在浏览器缓存当中。</li></ul><p>缓存判定主要依赖两项技术：<strong>强制缓存</strong>和<strong>协商缓</strong>存，也是HTTP缓存技术的要点。将在下文进行进行介绍。</p><h3 id="Pragma-头部"><a href="#Pragma-头部" class="headerlink" title="Pragma 头部"></a>Pragma 头部</h3><p>Pragma 于 HTTP1.0 中定义，单词含义叫做“编译指令”，几乎可以包含任何内容，目的是给浏览器发送请求中进行一些指令操作，但是主要的应用场景是缓存操控。</p><p>Pragma主要作用是保持 HTTP1.0 向后兼容，因为<strong>缓存技术是在HTTP1.1中才出现</strong>的。</p><p>比如让一些HTTP1.0的源服务识别客户端理解”无缓存“的请求头部，这时候Prama就可以派上用场。</p><p>Pragma 如果被发送，将会应用于所有的应用程序和客户端。如果存在HTTP1.1缓存技术的相关请求头部字段，在<strong>服务器可以识别的前提下</strong>，会优先解析HTTP1.1的请求头部，从而忽略Pragma头部。</p><p>但是这里介绍的所有内容都是 HTTP1.0 约定俗成的东西。HTTP1.0 本身不能算作标准，只能算作“草稿”，所以 <strong>Pragma 既没有明确规范，也没有可靠性</strong>，现在的网络环境这个字段基本不再使用。仅仅是有可能的向后兼容场景中用到。</p><blockquote><p>介绍这些内容，只是让大家知道点历史。</p></blockquote><p><strong>Pargma 头部使用方式</strong></p><p>基本语法 <code>Pragma: 1# pragma-directive</code><br>举例  <code>Pragma: no-cache</code>（实际上也是唯一取值）</p><h2 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h2><p>强制缓存指的是只要浏览器没有过期，就使用缓存进行返回，主动性在浏览器方。</p><p>比如下面的请求当中，使用了缓存进行返回，强缓存利用两个响应头部实现， <strong>相对时间“Cache-Control”</strong> 以及 <strong>“Expire”绝对时间</strong> 两个字段。</p><p>在讲述<code>Cache-Control</code>之前我们先停一下，先来了解后面这个过时的东西<strong>Expires</strong>。</p><p><strong>Expires 有什么用？</strong> 这个字段的作用是设置一个特殊的时间，一旦超过这个时间，就会过期。简而言之就是所谓的<strong>绝对时间</strong>，比如我们设置时间为 <code>Expires：Sat，13 May 2022 07:00:00  GMT</code>，意味着一旦超过这个时间就会失效。</p><p>但是这个时间是存在问题的，虽然原始服务器的时间无法更改，但是 <strong>客户端时间是可以自由改动的</strong>，这样就会导致客户端时间和服务器时间不一致，出现缓存一致性问题，你也可以把这种乱改时间的方式叫做<code>the world</code>（砸瓦鲁多）。</p><p>此外<strong>Expires</strong>日期时间必须是格林威治时间（GMT），而不能是本地时间，也不能随意指定日期格式，局限性比较大。</p><p>如果设置的Expires过期时间是固定时间，但是返回之前没有没有更新下一次过期时间，那么每一次客户端的请求都会进入到服务端，会加大服务端压力，缓存的意义也就失效了。</p><p>于是Cache-Control针对Expires的局限性进行改进而在HTTP1.1中登场。</p><p>如果同时有 <code>Cache-Control</code> 和 <code>Expires</code> 字段，<strong>Cache-Control的优先级高于 Expires</strong> 。所以通常情况下不建议使用 Expires，如果非要使用，建议用在静态资源上给资源设置绝对过期时间，或者作为双保险兼容所有HTTP代理服务使用。</p><p>此外<code>Cache-Control</code>和<code>Expires</code>这两个字段的区别是 <code>Cache-Control</code> 字段的选项要多一些，<code>Cache-Control</code>是HTTP1.1标准协议中出现并推荐使用的，<code>Expires</code> 是HTTP1.0的规定，但是HTTP1.0并不是明确标准，不具备任何约束力。</p><blockquote><p>HTTP 1.0 虽然明面上属于草稿纸协议，Expires看似也不推荐使用，但是后续的协议并没有废弃它，所以还是有一定的存在意义的（前后兼容问题）。</p></blockquote><p>首部字段 <code>Expires</code> 会将资源失效的日期告知客户端。如果不希望资源被缓存，则建议把首部字段 <code>Expires</code> 和首部字段<code>Date</code>设置相同的时间。</p><p><strong>强制缓存的使用策略</strong></p><ul><li><strong>第一次访问服务器资源</strong>，服务器会在返回资源的同时返回这两个字段，同时为这两个字段设置过期时间。</li><li>浏览器第二次乃至更多次访问，首先比对 <strong>Cache-Control</strong>的时间是否过期，如果有就使用缓存，没有就<strong>重新请求</strong>。</li><li>再次请求会更新 <code>Cache-Control</code>，之后以此反复。</li></ul><h3 id="Cache-Control例子"><a href="#Cache-Control例子" class="headerlink" title="Cache-Control例子"></a><code>Cache-Control</code>例子</h3><p>例子网址：<span class="exturl" data-url="aHR0cHM6Ly93ZWIuZGV2L2kxOG4vZW4vaHR0cC1jYWNoZS8jZXhhbXBsZXM=" title="https://web.dev/i18n/en/http-cache/#examples">https://web.dev/i18n/en/http-cache/#examples<i class="fa fa-external-link"></i></span></p><table><thead><tr><th align="left"><code>Cache-Control</code>价值</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left"><code>max-age=86400</code></td><td align="left">响应可以由浏览器和中间缓存缓存长达 1 天（60 秒 x 60 分钟 x 24 小时）。</td></tr><tr><td align="left"><code>private, max-age=600</code></td><td align="left">响应可以由浏览器（但不是中间缓存）缓存长达 10 分钟（60 秒 x 10 分钟）。</td></tr><tr><td align="left"><code>public, max-age=31536000</code></td><td align="left">响应可以由任何缓存存储 1 年。</td></tr><tr><td align="left"><code>no-store</code></td><td align="left">不允许缓存响应，并且必须在每次请求时全部获取。</td></tr></tbody></table><h3 id="Cache-Control-字段选项"><a href="#Cache-Control-字段选项" class="headerlink" title="Cache-Control 字段选项"></a>Cache-Control 字段选项</h3><ul><li><code>max-age</code>：此参数为高优先级，代表缓存的最大存活时间，单位为秒，其实时间为客户端接受响应的那一刻计算。</li><li><code>no-cache</code>：浏览器在每次使用缓存之前都必须使用服务器重新验证。注意这个字段并不是禁用缓存的真正含义，这里暂时卖个关子，下文继续解释。</li><li><code>no-store</code>：缓存不应该缓存任何客户端和服务端的内容，实际上的<strong>不使用缓存</strong>。和no-cache的区别是这个设置完全才是真实的不使用缓存。</li><li><code>public</code>：表示资源可以由任何代理进行缓存。</li><li><code>private</code>：表示指定资源专属于特定用户，虽然依然可以缓存，但<strong>只能在客户端缓存</strong>，比如私有的网页响应由桌面浏览器缓存，不能给CDN进行加速。</li></ul><blockquote><p>注意在<code>Cache-Control</code>指定<code>max-age</code>的属性时候，比起首部字段Expires，会优先处理max-age。</p></blockquote><p>在 <strong>《HTTP权威指南》</strong> 可以看到更多字段解释，上面仅仅列举一些常用字段。</p><blockquote><p>重点关注 no-cache，很容易误解含义的一个属性。</p></blockquote><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220815060304.png" alt="Cache-Control 常用字段 - 1"></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220815060414.png" alt="Cache-Control 常用字段 - 2"></p><p><strong>s-maxage</strong></p><p>有时候我们会看到下面的请求属性：<code>s-maxage</code></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220814190150.png" alt="s-maxage"></p><p>它所表示的含义是覆盖<code>max-age</code>或者<code>Expires</code>头，但是仅适用于共享缓存 (比如各个代理)，私有缓存会忽略它（private）。</p><p><strong>Cache-Control案例</strong></p><p>通过下面的案例可以看到，内容是从<code>disk cache</code>本地返回的，没有请求服务器。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220814182034.png" alt=""></p><p>强制缓存除了 <code>from disk cache</code> 之外，还有可能遇到使用<code>from memory cache</code>进行返回，表示同样不会访问服务器，但是返回的内容是从内存中来的，并且因为是内存所以如果关闭当前页面会被立马释放。</p><p>更多有关Cache-Control的内容可以看看下面的资料网站。</p><p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0NhY2hlLUNvbnRyb2w=" title="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control">Cache-Control - HTTP | MDN (mozilla.org)<i class="fa fa-external-link"></i></span></p><h3 id="Expires-和-Cache-Control-两者对比"><a href="#Expires-和-Cache-Control-两者对比" class="headerlink" title="Expires 和 Cache-Control 两者对比"></a>Expires 和 Cache-Control 两者对比</h3><p>这个比较容易被问到，所以这里再啰嗦一遍。其实本质上区别并不是很大，只不过Expires 是  HTTP1.0 出现的，要比Cache-Control （HTTP1.1）出得早而已，并且Cache-Control本身就是为了替换Expires 而存在的。</p><p>虽然目前大部分网站都是支持HTTP1.1 的，但是如果真的碰到只能识别HTTP1.0 的服务器，此字段依然有存在价值，所以这种做法只是一种保证前后兼容的稳定而已。</p><h3 id="Cache-Control-流程图"><a href="#Cache-Control-流程图" class="headerlink" title="Cache-Control  流程图"></a><code>Cache-Control</code>  流程图</h3><p>图来自老外的博客：<span class="exturl" data-url="aHR0cHM6Ly93ZWIuZGV2L2kxOG4vZW4vaHR0cC1jYWNoZS8=" title="https://web.dev/i18n/en/http-cache/"># Prevent unnecessary network requests with the HTTP Cache<i class="fa fa-external-link"></i></span></p><p>需要注意最后一步的Etag，是协商缓存中的重要判断依据，这部分内容会在下文解释。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202208160701622.png" alt="Cache-Control 流程图"></p><h3 id="no-cache-VS-no-store"><a href="#no-cache-VS-no-store" class="headerlink" title="no-cache VS no-store"></a>no-cache VS no-store</h3><p>“no store”请求指令指示缓存不能存储此请求或对其的任何响应的任何部分。</p><blockquote><p>The “no-store” request directive indicates that a cache MUST NOT store any part of either this request or any response to it. This directive applies to both private and shared caches.</p></blockquote><p>no-store 比较好理解，它是真正意义上的不使用缓存，含义是禁用中间代理（浏览器，CDN，缓存服务器、代理）缓存响应内容，行为类似非代理缓存服务，一旦碰到缓存就会删除。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220814211613.png" alt=""></p><p>“no cache”请求指令表示，如果未在源服务器上成功验证，缓存不得使用存储的响应来满足请求。</p><blockquote><p>The “no-cache” response directive indicates that the response MUST NOT be used to satisfy a subsequent request without successful validation on the origin server.</p></blockquote><p>上面是RFC协议的原话，这个定义非常容易误解，隐藏的含义是：<strong>实际上<code>no cache</code> 是会进行缓存的</strong>。</p><p>什么时候缓存呢？在与原始服务器进行新鲜度再验证之前，缓存不能将其提供给客户端使用。而如果再度验证服务器没有对于内容进行更改，那么还是使用缓存数据进行处理。</p><p>简而言之就是一句话：<strong>如果服务器没有更新内容，那么就会缓存数据，否则需要重新请求和服务器进行验证比对</strong>。</p><p>大多数人会理解错这一层含义，会误认为是“不接受服务器的缓存响应”，实际上它是会接受的。《HTTP权威指南》解释说这个首部更适合用 <strong>do-not-serve-from-cache-without-revalidation（不需要请求服务，直接用缓存，除非服务器重新验证）</strong> 这个名字会更恰当一些，我们同样可以按照作者的建议进行理解。</p><p>但是这里肯定又会问，你都<code>no-cache</code>了我怎么知道什么时候响应新内容呢？</p><p>先别急，这里有一套稍微复杂的判断机制：<strong>协商缓存</strong>，学东西一点一点来，我们接着看其他几个强制缓存的问题。</p><h3 id="max-age-0-和-no-cache-等价吗？"><a href="#max-age-0-和-no-cache-等价吗？" class="headerlink" title="max-age=0 和 no-cache 等价吗？"></a>max-age=0 和 no-cache 等价吗？</h3><p>这个问题比较偏门，但是作为面试题角度比较刁钻。</p><p>两者的区别是<code>max-age=0</code>通常是告诉浏览器<strong>建议</strong>刷新缓存，<code>max-age=0</code>是<strong>非强制性（Should）</strong> 的，<code>no-cache</code>要求强制和服务器进行验证才允许使用缓存，所以<code>no-cache</code> 具有强制（MUST）性。</p><p>但是怎么处理还得看浏览器的设计，所以不考虑浏览器设计的因素下，可以认为行为比较一致，或者直接自信点：它们差不多。</p><h3 id="什么样的请求方法会被缓存？"><a href="#什么样的请求方法会被缓存？" class="headerlink" title="什么样的请求方法会被缓存？"></a>什么样的请求方法会被缓存？</h3><ul><li>GET 请求通常具备缓存失效。</li><li>HEAD方法跟GET方法相同，只不过服务器响应时不会返回消息体，所以HEAD请求会被缓存。（比较容易被忽略）</li><li>PUT 无法被缓存。</li><li>POST 缓存在指定明确的过期请柬请求字段的时候可以使用，但是基本没有被实施。</li></ul><blockquote><p>HEAD 很容易被忽略，实际上它具备一定的作用：</p><ul><li>检查连接是否活跃（active）。</li><li>检查网页是否存在改动。</li><li>多用于获取RSS，网站标志等信息的场景使用。</li></ul></blockquote><h3 id="缓存优先级判断"><a href="#缓存优先级判断" class="headerlink" title="缓存优先级判断"></a>缓存优先级判断</h3><p>采用下面的顺序：</p><ol><li>如果是共享缓存并且存在<code>s-maxage</code>，则为最高优先级。</li><li>检查是否存在max-age。</li><li>检查是否存在Expires，需要使用此时间减去响应字段的Date字段值，算出来的数值就是有效期。</li></ol><p>需要提醒这些时间是不会和时区产生影响的，因为返回的都是<strong>原始服务器的时间</strong>。</p><p>但是在这里我们发现一个问题，如果上面条件都不满足，如果<strong>不存在到期时间</strong>咋办？</p><p>因为原始服务器的时间并不是总是可靠的，如果请求当中没有任何“新鲜度“（max-age、Expires等过期时间）设置，请求头部也没指定任何禁用缓存和任何限制，那么这时候需要用<code>heuristic expiration time</code>这个值。</p><p><code>heuristic expiration time</code>（中文说法：<strong>启发式缓存时间</strong>），在《HTTP权威指南》叫做试探性过期时间，其实是利用其他字段的算出一个“合理”的估计值（也就是 <code>Last-Modified</code>）。</p><p>关于计算的方法，在RFC规范柄中没有强制如何设计，而是在协议中给出下面这句话：</p><blockquote><p>If the response has a Last-Modified header field (Section 2.2 of [RFC7232]), caches are encouraged to use a heuristic expiration value that is no more than some fraction of the interval since that time. A typical setting of this fraction might be 10%.</p></blockquote><p>如果响应具有<code>Last-Modified header</code>的标头字段（RFC7232的第2.2节），<strong>则鼓励缓存使用启发式缓存时间值</strong>，该值会计算一个不超过自该时间起间隔 * 某个比例（的时间）。<strong>比例的经典设置可能为10%</strong>。</p><p>这是嘛意思？没看懂呀，其实这里要联系RFC原文的前后文了，这里就不贴英文了。大致意思是在优先级判断中的第三点判断，有效期计算被定义为<strong>Expires-Date字段</strong>。</p><p>如果服务端返回<code>Last-Modified header</code> ，则计算方式为 <strong>Date字段 - Last-Modified字段值</strong>。</p><p>但是如果直接这样计算有可能会太长了，RFC给出 10 % 的建议值。这个建议值有这两点考虑：</p><ul><li>很久之前存放的文档一般不会更改，所以留在缓存很安全，10%估计值的比率尚且可以接受（？）。</li><li>频繁更新的内容通常缓存收益很小，使用估计值10%可以尽可能减少缓存时间，尽可能的返回最新内容。</li></ul><blockquote><p>更新频率不同长短的资源都能收益，这样看起来这处理方式是不是很不错呀？但是<br>想法是好的，现实是这样做会带来更多麻烦，这点放到下面讨论。</p></blockquote><p>总而言之，不满足缓存优先级判断，浏览器通常会用  <strong>Last-Modified字段值</strong> 计算一个合适的参考值作为缓存过期时间存在，最终的计算公式为：</p><p><strong><code>Last-Modified Time - Date</code> * 0.1 (10%)`</strong></p><blockquote><p>当存储的响应中存在显式过期时间时，缓存不得使用启发式缓存时间来确定新鲜度。不能使用此算法。官方这话是在暗示你要尽量给资源设置缓存过期时间，因为我建议的这东西不是特别靠谱。</p></blockquote><p>目前多数浏览器使用 <code>LM-factor</code> 算法（也就是上面的公式），使用的也是RFC协议建议的比例 10 %，20% 这个说法现在来看已经过时。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220815063339.png" alt=""></p><blockquote><p>10%以及悲观估计依据：<br>This specification does not provide specific algorithms, but does impose worst-case constraints on their results.<br>  本规范未提供具体算法，但对其结果施加了最坏情况约束，所谓的最坏情况约束就是 10%。</p></blockquote><p><strong>113 响应状态码</strong></p><p>这里有个偏门的 113 响应状态码，表示如果缓存使用了超过24小时的有效时间并且响应时间大于24小时，不应该采取任何操作。1XX状态码需要后续的确认操作。</p><p>但是实际上很多浏览器压根没有搭理过这个建议，也没有做响应措施，这一点需要注意。</p><p><strong>如果Last-Modified都没有怎么办？</strong></p><p>乖乖，如果这都没有的话，缓存通常会为没有任何新鲜周期线索的文档，分配一个默认的新鲜周期（通常是一个小时或一天）。</p><p>有时比较保守的缓存会将这种试探性新鲜生存期设置为 0，强制缓存在每次将其提供给客户端之前验证一下这些数据是否仍然是新鲜的。</p><p><strong>启发式缓存时间坏处</strong></p><p>凡事都有例外，启发式缓存时间本意是好的，但是存在明显的弊端。</p><p>假如一个文件超过一个月没设置过期时间，并且已经经过一个月的时间，这时候发现文件存在严重问题，需要立刻修复。</p><p>这时候一旦修改，会导致上个版本3天之后才过期（1个月的10%=3天左右），意味着更新一个文件需要至少3天（20%就是将近一周），请求才会传新文件。如果使用CDN，这个时间还会更长。</p><p>当然这种问题解决方案也很多，比如在设置文件的时候带上<strong>版本号或者编号</strong>，比如对外进行 302 临时重定向到另一个位置并且设置过期时间，或者先删文件再后重新添加，并且手动强制同步。</p><p><strong>综上所述，尽量不要使用启发式缓存，尽量给每个请求设置过期时间，但是也不要设置过长时间，长时间的强缓存会因为CDN等缓存服务器的关系导致一个资源迟迟难以更新（哪怕没有启发式缓存时间）</strong>。</p><p><strong>新协议对RFC2616的改动</strong></p><p>注：[RFC2616] 第13.9节禁止缓存计算带有查询组件的URI的启发式新鲜度（即包含“？”的URI）。此项在实践中，这并没有得到广泛推广。</p><p>综上所述，如果源服务器希望排除缓存，则鼓励它们发送显式指令（例如，缓存控制：无缓存）。</p><h3 id="新响应的计算方式"><a href="#新响应的计算方式" class="headerlink" title="新响应的计算方式"></a>新响应的计算方式</h3><p>下面这个公式是判断依据：</p><p><strong>response_is_fresh = (freshness_lifetime &gt; current_age)</strong></p><p>判断依据十分简单，新鲜度的时间是否超过寿命，超过寿命就需要丢弃缓存重新请求。也正是因为这种简单粗暴的手法，使得缓存既能够提供便利的同时，不至于对于用户访问造成过多影响。</p><h3 id="响应表头设置建议"><a href="#响应表头设置建议" class="headerlink" title="响应表头设置建议"></a>响应表头设置建议</h3><p>因为启发式缓存时间的存在，强烈建议重要的文件资源都加上缓存有效期。针对缓存有效期的响应头设计，通常有下面的几点建议：</p><p><strong>版本化URL</strong></p><p>比如针对CSS文件设置了长达一年的缓存过期时间，如果出现临时更改，有的用户如果刚好清除缓存可以看到最新的内容，而没有清除缓存的可能拿到本地旧版本文件。这样可以有更好的用户体验，旧缓存数据的用户在刷新缓存之后就可以看到新内容。</p><p>通常情况下，在文件名中嵌入文件的版本号来执行此操作，例如<code>style.x234dff.css</code>。</p><p><strong>无版本化URL</strong></p><p>如果是没有版本化的URL很久突然要进行更新，则需要尽量添加头部。</p><p><code>Cache-Control</code>值可以帮助我们微调未版本化 URL 的缓存位置和方式：</p><ul><li>no-cache：缓存请求当前URL的版本数据之前需要和服务器进行验证。</li><li>no-store：屏蔽中间代理服务器的缓存行为，不存储缓存文件。</li><li>private：浏览器可以缓存文件，但是中间代理缓存服务器不能缓存。</li><li>public：响应可以被任何缓存进行存储。</li></ul><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>缓存生效的情况下，浏览器会返回304状态码。协商缓存是在强制缓存失效之后，需要重新对比缓存，由服务器决定是否失效的一种机制。</p><blockquote><p>304：请求的资源没有改变，但是被重定向到已缓冲的文件，所以也叫做缓存重定向，这个子弹主要是用于缓存处理。</p></blockquote><p>协商缓存的请求步骤通常分为两步。</p><p>初次访问：<br>    客户端请求依然需要发送到服务端，但是服务端会通知浏览器缓存请求响应信息，浏览器这时候会偷偷缓存请求。</p><p>第二至更多次访问：<br>    1. 假设客户端请求资源已经过期，则在请求中携带Etag 访问服务器。<br>    2. 服务器比对Etag进行校验，比较是否和本地一致。<br>    3. 如果一致返回304，浏览器可以继续使用资源。<br>    4. 如果不一致就需要重新返回请求结果，再次进行缓存。</p><p><strong>协商缓存实际上就是浏览器和服务器进行协商通过协商的结果判断是否使用本地缓存。</strong></p><p><strong>主要涉及的请求头部</strong></p><p>注意这里一共有<strong>两组四个字段</strong>进行判断，<code>ETag</code>和<code>If-None-Match</code>（一组）， <code>If-Modified-Since</code> 字段与 <code>Last-Modified</code> 字段（一组），<strong>前者优先级比后者高</strong>，同时出现会出现“短路效应”。</p><h4 id="ETag和If-None-Match"><a href="#ETag和If-None-Match" class="headerlink" title="ETag和If-None-Match"></a><code>ETag</code>和<code>If-None-Match</code></h4><p>两者的值都是资源的唯一标识符（实际为文件资源的哈希散列值）。</p><p>判断过程如下：</p><ul><li>浏览器请求资源，原始服务器返回报文中加入<code>Etag</code>值，资源更新则Etag值也会更新。</li><li>浏览器再次请求资源，此时请求报文会加入<code>If-None-Match</code>，值为上一次响应报文的Etag值。</li><li>服务器比对报文的<code>If-None-Match</code>和当前的<code>Etag</code>是否一致，不一致则更新Etag并且返回，下一次浏览器请求Etag将传输新的值。如果一致表示资源没有更新，状态码返回304，浏览器从本地缓存获取，<strong>此时响应头会同时返回Etag值</strong>。（虽然没有变化）</li></ul><h4 id="If-Modified-Since-字段与-Last-Modified-字段"><a href="#If-Modified-Since-字段与-Last-Modified-字段" class="headerlink" title="If-Modified-Since 字段与 Last-Modified 字段"></a><code>If-Modified-Since</code> 字段与 <code>Last-Modified</code> 字段</h4><p>位于请求头部的<code>If-Modified-Since</code> 字段以及位于响应头部中的 <code>Last-Modified</code> 字段。</p><ul><li>响应头部中的 <code>Last-Modified</code> 字段：表示资源的<code>Last-Modified</code>（ 最后修改时间）。</li><li>请求头部的<code>If-Modified-Since</code> 字段：资源过期并且接收响应头部出现 <code>Last-Modified</code> （最后修改时间）声明，会发送此字段，并且此字段值等于<code>Last-Modified</code>（ 最后修改时间）。</li></ul><p>判断流程如下：</p><ul><li>浏览器第一次向服务端请求之后，服务端响应中加入 <code>Last-Modified</code> 字段，表示资源最后一次修改时间。</li><li>浏览器再次请求，在请求报文中会加入<code>If-Modified-Since</code> 字段，字段值等于上一次浏览器返回的<code>Last-Modified</code> （最后一次修改时间）。</li><li>服务器比对<code>Last-Modified</code> 和<code>If-Modified-Since</code> 字段，如果不一致则接受请求并且返回更新之后的资源，如果一致表示资源没有更新，返回304状态码，此时浏览器会从本地缓存获取资源文件。值得注意的是，<strong>本地请求如果是304，此时响应头中不会再添加<code>Last-Modified</code>字段</strong>。</li></ul><h3 id="协商缓存和强制缓存流程图"><a href="#协商缓存和强制缓存流程图" class="headerlink" title="协商缓存和强制缓存流程图"></a>协商缓存和强制缓存流程图</h3><p>这个图来自参考文章的第一篇，画的很棒，为作者点个赞：</p><blockquote><p>注意：If-None-Match 和 If-Modified-Since 的关系是：<code>If-None-Match &amp;&amp; If-Modified-Since</code>。</p></blockquote><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202208170727835.png" alt=""></p><p>下面的图和上面类似，不过把<code>If-None-Match</code>和 <code>If-Modified-Since</code>丰富了一下：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202208170731807.png" alt=""></p><h3 id="如果同时发送If-None-Match-、If-Modified-Since字段怎么处理"><a href="#如果同时发送If-None-Match-、If-Modified-Since字段怎么处理" class="headerlink" title="如果同时发送If-None-Match 、If-Modified-Since字段怎么处理"></a>如果同时发送<code>If-None-Match</code> 、<code>If-Modified-Since</code>字段怎么处理</h3><p>此时服务器只要比较<code>If-None-Match</code>和<code>ETag</code>的内容是否一致即可，内容一致则返回304并且依然使用，不一致则返回新的请求结果，并且重新缓存。</p><p><code>If-None-Match</code>判断优先级总是要高一些，IETF同样如此建议。</p><h3 id="Etag-和-Last-Modifed-对比"><a href="#Etag-和-Last-Modifed-对比" class="headerlink" title="Etag 和 Last-Modifed 对比"></a>Etag 和 Last-Modifed 对比</h3><p><code>Etag</code>和<code>Last-Modifed</code>效果是相同的，为什么相同的功能需要两个字段控制？</p><p>首先说一下结论，<code>Etag</code> 实际上更为推荐并且更常使用，因为它的细粒度更小，下面我们举个例子，再进行总结。</p><p>我们先来举个栗子，假设一个资源从资源请求开始到当前请求过去了120秒接近过期节点，并且浏览器启用了同一个资源的新请求，此时HTTP刚好卡在过期节点之前找到缓存。虽然查到的缓存在获取那一刻是没有过期的，但是他不能这么干，因为此时在浏览器看来<strong>响应已经过期了</strong>，浏览器需要重新发一个新请求获得完整响应。</p><p>上面的例子本意是好的，但是如果资源没有出现改变，就没有必要下载已经在缓存本地的信息，这么做明显是浪费服务器资源。如果很多个请求都在这个临界点访问，这样会加大服务器资源的浪费。</p><p>所以基于时间的判断是不可靠的，Etag标头负责检查文件内容的哈希码，浏览器不需要知道哈希算法，只需要拿客户端请求的Etag值和当前本地缓存比对即可，如果Etag值一致，哪怕此时请求资源响应已经过期了，依然可以用本地缓存文件返回，跳过下载步骤。</p><p>有了上面的案例，下面我们知道了为什么要引入Etag，下面是相关<strong>结论</strong>。</p><p><strong>结论</strong></p><ul><li>有时候文件仅仅是改了日期（比如重新传了一份一模一样的覆盖），我们可以认为文件内容是没有改变的，依然可以用本地缓存而不是GET请求。</li><li>文件如果改动非常频繁但是内容没有改变，<code>Last-Modifed</code>是S（秒）级，控制粒度大，很容易出现请求响应过期，并且频繁的重新下载。</li><li>某些服务器不能精确表示最后修改时间，只能给出笼统的日期。</li></ul><p>总的来说就是基于时间的判断是不可靠的，使用Etag值可以更加精确控制缓存，所以引入服务器自动生成Etag校验码作为唯一标识符，如果资源频繁改动会重新生成Etag值，但是如果资源只是频繁的刷新修改日期，则Etag不变。</p><p>在默认的情况下这两个值可以一起使用，但是牢记<strong>优先校验ETag</strong>（原因请看上面的栗子）。</p><h2 id="用户行为对缓存影响"><a href="#用户行为对缓存影响" class="headerlink" title="用户行为对缓存影响"></a>用户行为对缓存影响</h2><p>这里直接用了网上的一张图，主要记住几个无效的项即可。</p><p>下面是日常用户操作</p><ol><li>大部分网站打开网页通常优先检查disk cache，有就使用，没有就发送请求。</li><li>F5刷新，因为此时TAB没有关闭，使用memory cache 是可用的，会被优先使用，而disk cache 会被滞后使用。</li><li>强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 <code>Cache-control: no-cache</code>(为了兼容，还带了<code>Pragma: no-cache</code>)，此时返回200状态码和最新内容。</li></ol><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202208170708552.png" alt=""></p><h2 id="缓存策略建议"><a href="#缓存策略建议" class="headerlink" title="缓存策略建议"></a>缓存策略建议</h2><p>因为缓存是作用于文件的，而文件资源基本情况有两种：<strong>频繁改动的资源</strong>和<strong>长久不变化的资源</strong>。</p><p>频繁变动的资源：</p><ul><li>首先需要使用 <code>Cache-Control: no-cache</code> 使浏览器每次都请求服务。</li><li>配合 <code>ETag</code> 或者 <code>Last-Modified</code> 来验证资源是否有效。</li></ul><p>这样的处理方法可以显著的减少响应内容的大小。</p><p>长久不变的资源：</p><p>直接给一个<code>Max-age=31536000</code> 一年的时间让浏览器强制使用缓存，所以通常建议在文件名中加入哈希码和版本号等信息，防止长久缓存文件突然需要更新的时候能及时反馈给客户端。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxNTgxNjMzMQ==" title="https://segmentfault.com/a/1190000015816331">一张图理解Http缓存 - SegmentFault 思否<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9yZmMyY24uY29tL3JmYzcyMzQuaHRtbA==" title="https://rfc2cn.com/rfc7234.html">RFC7234 中文翻译 中文RFC RFC文档 RFC翻译 RFC中文版 (rfc2cn.com)<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvY1Vxa0czTkVUbUpiZ2xEWGZTZjB0Zw==" title="https://mp.weixin.qq.com/s/cUqkG3NETmJbglDXfSf0tg">【第1398期】一文读懂前端缓存 (qq.com)<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93ZWIuZGV2L2kxOG4vZW4vaHR0cC1jYWNoZS8=" title="https://web.dev/i18n/en/http-cache/">Prevent unnecessary network requests with the HTTP Cache (web.dev)<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC85OTM0MDExMA==" title="https://zhuanlan.zhihu.com/p/99340110"># 深入理解浏览器的缓存机制<i class="fa fa-external-link"></i></span></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      HTTP缓存技术
    
    </summary>
    
    
      <category term="网络/网络基础" scheme="https://whitestore.top/categories/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="网络/网络基础" scheme="https://whitestore.top/tags/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>《网络是怎么样连接的》读书笔记 - 认识网络基础概念（一）</title>
    <link href="https://whitestore.top/2022/08/11/rswljcgn/"/>
    <id>https://whitestore.top/2022/08/11/rswljcgn/</id>
    <published>2022-08-10T21:30:06.000Z</published>
    <updated>2022-09-08T02:18:34.397Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《网络是怎么样连接的》读书笔记-认识网络基础概念（一）"><a href="#《网络是怎么样连接的》读书笔记-认识网络基础概念（一）" class="headerlink" title="《网络是怎么样连接的》读书笔记 - 认识网络基础概念（一）"></a>《网络是怎么样连接的》读书笔记 - 认识网络基础概念（一）</h1><h2 id="本章重点"><a href="#本章重点" class="headerlink" title="本章重点"></a>本章重点</h2><ol><li>关于互联网的一些历史补充</li><li>解析URL的过程简述</li><li>HTPP请求的基本结构和组成</li><li>IP 地址、子网掩码以及DNS的基本了解，掌握概念和相关知识点。</li></ol><h2 id="讲讲历史"><a href="#讲讲历史" class="headerlink" title="讲讲历史"></a>讲讲历史</h2><p>1991年8月6日，在瑞士日内瓦的核子研究中心（CERN）工作的英国物理学家蒂姆·伯纳斯·李（Tim Berners-Lee），正式提出了World Wide Web，也就是如今我们非常熟悉的www。</p><p>www是什么？万维网WWW是World Wide Web的简称，也称为Web、3W等。WWW是基于<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/lrqLmiLfmnLovNTE2ODE1Mw==" title="https://baike.baidu.com/item/客户机/5168153">客户机<i class="fa fa-external-link"></i></span>/<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/mnI3liqHlmagvMTAwNTcx" title="https://baike.baidu.com/item/服务器/100571">服务器<i class="fa fa-external-link"></i></span>方式的信息发现技术和<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/otoXmlofmnKwvMjgzMjQyMg==" title="https://baike.baidu.com/item/超文本/2832422">超文本<i class="fa fa-external-link"></i></span>的<strong>综合技术</strong>。</p><p>这里个人比较好奇我们天天都在说3w，3w，但是<strong>互联网是怎么出现的的书中并没有解释？</strong></p><p>这里查了下网上资料根据个人理解解释一波：</p><p>实际上网络最开始苗头出现在美苏冷战的时期美国建立的<strong>APRA</strong>科研部门，被突然扯出来的科研部门一盘散沙不知道干嘛，对付苏联的科研工作也没什么进展，直到一个叫做罗伯特·泰勒的哥们出现，他的突破口是发现小型的通信网络不能兼容不同型号的计算机，我们都知道技术的顶峰就是定规则，毫无疑问他选择构建一套协议让所有的计算机都能遵守这一套规则干活。</p><p>于是他找来了几个牛逼的大佬开始捣鼓，中间巴拉巴拉做了很多事绕了很多弯，目的其实就是为了实现上面说的东西，最终在一次失败的“LOGIN”验证中虽然仅仅传输了“LO”两个字母就断开了，但是这次失败是历史性的进步，因为两个不同的设备实实在在的通信了，最终修复之后完成了这五个字母的正常传输。</p><p>随后捯饬出的<strong>ARPANET（阿帕网）</strong> 这个项目，也就是正式的互联网雏形。</p><p>课外知识到此结束，现在我们看看第一章主要看点：</p><ol><li>如何解析网址？</li><li>DNS 服务器如何查询域名对应的 IP 地址？</li><li>DNS服务器如何接力？</li><li>浏览器如何将消息委托给操作系统发送给 Web 服务器？</li></ol><p>核心是理解DNS的角色地位和作用，以及浏览器如何跟DNS交互完成网址（域名）解析为IP这一个操作的，本章最后的委托流程是整个第二章的重点内容，笔记顺其自然的放到了第二章笔记当中，为了方便理解把笔记归纳到第二部分。</p><a id="more"></a><h2 id="如何解析网址"><a href="#如何解析网址" class="headerlink" title="如何解析网址"></a><strong>如何解析网址</strong></h2><p>我们从URL开始，什么是URL，URL是Uniform Resource Locator的简称，专业解释叫做统一资源定位符，除开我们常见的http、https协议之外，浏览器还可以进行ftp文件上传，下载文件，发送电子邮件，浏览新文化等操作。</p><p>我们把这些行为看作是资源交互，虽然不同的资源交互会存在不同的URL组合，但是不管URL的组合形式如何变化，最终是<strong>开头决定一切</strong>，开头部分决定对待资源方式。</p><p>解析网址我们可以看下面的例子：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205232140810.png" alt="img"></p><p>碰到省略文件名的情况，通常下面几种：</p><ul><li><code>http://xxxx/dir/</code>表示 <code>/dir/</code> 之后的内容被省略，这时候通常情况下会设置对应这个目录的真实访问路径进行<strong>补全</strong>。</li><li>对于web中最为经典的<code>http://localhost:8080/</code>访问路径，通常情况下Web服务器会访问到<code>/index.html</code>这个文件，如果没有就会返回404的页面。</li><li>如果只有域名，比如<code>www.baidu.com</code>，那就会直接访问web服务器设置的根路径对应的资源和相关文件。</li><li>含混不清的路径比如<code>http://localhost:8080/wishlist</code>，则会根据先判断是否为文件名，然后判断是否为目录的情况处理，或者看作一个请求映射到另一处资源，或者做一次重定向。</li></ul><p>上面的内容不必深究，只需要明白<strong>浏览器的第一步工作就是对 URL 进行解析</strong>。</p><h2 id="Http请求"><a href="#Http请求" class="headerlink" title="Http请求"></a><strong>Http请求</strong></h2><p>http请求简单来说可以简单概括为一句话：<strong>对什么做了什么样的操作</strong>，所谓对什么指的是URL，表示标识了的目标对象，做什么样的操作就是所谓的方法，方法主要是分为两个<code>POST</code>和<code>GET</code>方法，其他方法基本没啥用处，个人只在偶尔几个对接文档中遇到过<code>PUT</code>和<code>HEAD</code>方法。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205232259633.png" alt="img"></p><p><code>GET</code>方法：通常用于一些可见资源的访问，或者开放资源的访问，通常情况下不需要过多的限制就可以直接向具体的目录寻找需要的资源。</p><p><code>POST</code>方法：比较常见的是使用表单或者 AJAX的方式访问，并且通常会指向一个WEB的应用程序，获取应用程序的数据需要传递服务器需要的一些有效参数，否则服务端会根据具体情况通知客户端无权访问。</p><blockquote><p><strong>AJAX</strong>即“<strong>Asynchronous JavaScript and XML</strong>”（非同步的<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS9KYXZhU2NyaXB0" title="https://zh.m.wikipedia.org/wiki/JavaScript">JavaScript<i class="fa fa-external-link"></i></span>与<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS9YTUw=" title="https://zh.m.wikipedia.org/wiki/XML">XML<i class="fa fa-external-link"></i></span>技术），指的是一套综合了多项技术的<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS/ngI/opr3lmag=" title="https://zh.m.wikipedia.org/wiki/瀏覽器">浏览器<i class="fa fa-external-link"></i></span>端<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS/ntrLpoIE=" title="https://zh.m.wikipedia.org/wiki/網頁">网页<i class="fa fa-external-link"></i></span>开发技术。Ajax的概念由<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS/lgpHopb/Ct+ipueWnhuWjq8K36LOI55Ge54m5" title="https://zh.m.wikipedia.org/wiki/傑西·詹姆士·賈瑞特">杰西·詹姆士·贾瑞特<i class="fa fa-external-link"></i></span>所提出<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvemgtaGFucy9BSkFYI2NpdGVfbm90ZS0x" title="https://zh.m.wikipedia.org/zh-hans/AJAX#cite_note-1">[1]<i class="fa fa-external-link"></i></span>。</p></blockquote><p><strong>Http请求消息</strong></p><p>知道了 <strong>对什么做了什么样的操作</strong>，现在来看看Http 具体是怎么做这件事情的。</p><p>Http请求消息主要分为下面组织结构：</p><ul><li>第一行最开头的部分提取URL的内容，原封不动解析，末尾为HTTP版本号主要标记当前HTTP请求版本。</li></ul><blockquote><p>例如：<code>GET /cgi/sample.cgi?Field1=ABCDEFG&amp;SendButton=SEND HTTP/1.1</code></p></blockquote><ul><li><p>第二行为消息头，这里列举一些简单的内容：</p><ul><li><strong>Data</strong>：请求响应生成日期。</li><li><strong>Pragma</strong>：数据是否允许缓存。</li><li><strong>Transfer-Encoding</strong>：消息主体<strong>编码格式</strong>（重要）。</li><li><strong>Via</strong>：经过的代理和网关。</li></ul></li><li><p>消息头后面存在一行 <strong>完美没有内容的空行</strong>。</p></li><li><p>第四行为消息体，但是实验用的是GET方法所以通常内容为空。</p></li></ul><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205240734243.png" alt="img"></p><p>我们以访问谷歌为例，下面的内容访问谷歌搜索页面的一次请求参考，这里的内容直接通过谷歌浏览器的F12拷贝，可以看到基本包含了请求行，消息头和消息行（GET通常没有所以下面没有体现）三种。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">常规</span><br><span class="line"></span><br><span class="line">1.  请求网址:https://www.google.com/</span><br><span class="line">2.  请求方法:GET</span><br><span class="line">3.  状态代码:200</span><br><span class="line">4.  远程地址:127.0.0.1:7890</span><br><span class="line">5.  引荐来源网址政策:origin</span><br><span class="line"></span><br><span class="line">请求标头</span><br><span class="line"></span><br><span class="line">1.  :authority:www.google.com</span><br><span class="line">2.  :method:GET</span><br><span class="line">3.  :path:/</span><br><span class="line">4.  :scheme:https</span><br><span class="line">5.  accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">6.  accept-encoding:gzip, deflate, br</span><br><span class="line">7.  accept-language:zh,zh-TW;q=0.9,en-US;q=0.8,en;q=0.7,zh-CN;q=0.6</span><br><span class="line">8.  cache-control:no-cache</span><br><span class="line">9.  cookie:SID=KQi0QVpC_wxTynb6H6HjGmVq-9mYvCuIDOMx9EmEUJ8ii7dJzN_1F-ho69FdK6AN9ekOkA.; __Secure-1PSID=KQi0QVpC_wxTynb6H6HjGmVq-9mYvCuIDOMx9EmEUJ8ii7dJaTdIpqSfRfNb-BvF0haitA.; __Secure-3PSID=KQi0QVpC_wxTynb6H6HjGmVq-9mYvCuIDOMx9EmEUJ8ii7dJ6_WQQeEF09oAZ9MQfe21sA.; HSID=AOdmIhuBCutDeMwVS; APISID=ckyVXTB27QMaC2gQ/AVulr1cMnMbpD0e1x; SSID=AL0-0R0Ofsj3zaqrr; SAPISID=dqpTwJeh7bnii2Ki/AfsaDUfE8uMVR1aqv; __Secure-1PAPISID=dqpTwJeh7bnii2Ki/AfsaDUfE8uMVR1aqv; __Secure-3PAPISID=dqpTwJeh7bnii2Ki/AfsaDUfE8uMVR1aqv; SEARCH_SAMESITE=CgQIvJUB; 1P_JAR=2022-05-24-23; AEC=AakniGOKhznRpAD797X4u508i2XHJjEVYQQHANlqaJC2JSZ1F7mAe-vX_rg; NID=511=K-qt_LW-4ad1IYdJgfPLZjJw772wez2L3_FK9hwrrHAaksdhT8bTqz4icJEnJviOb92zcnyfS4h7P8HB_Is0f_FebYTe_5DR3qFEclHS1R9N1P7r9pv7Z4p12341S72RZRfzIlQ3-CVZUqQKBm1Xy1i9fKwejMGHTPMY2hk02sA--ey8nAEyt1_A7SVMe0RvrEkPnVm88fBnyyyFMMSCeSG1oqYKeC2x7iHJ0GwdbEpeGojpMQyQxAn1jAdxyXbC0oko0rCFjYn7eUREz2A9KA; SIDCC=AJi4QfGQeW0y_3pnzuBs7KI-WabF5XR_-dQchpcoNUN_bRVICBknb39qNQhP4IklnPn6kW4M3d8; __Secure-3PSIDCC=AJi4QfFOaoqiWv0mqmOskkIKVYy_-QNOATkPOyhNt9B8BBTMnRqnv-0zdgVgBNmIJRwlzBS4x6U</span><br><span class="line">10.  pragma:no-cache</span><br><span class="line">11.  sec-ch-dpr:2</span><br><span class="line">12.  sec-ch-ua:" Not A;Brand";v="99", "Chromium";v="101", "Google Chrome";v="101"</span><br><span class="line">13.  sec-ch-ua-arch:"arm"</span><br><span class="line">14.  sec-ch-ua-bitness:"64"</span><br><span class="line">15.  sec-ch-ua-full-version:"101.0.4951.64"</span><br><span class="line">16.  sec-ch-ua-full-version-list:" Not A;Brand";v="99.0.0.0", "Chromium";v="101.0.4951.64", "Google Chrome";v="101.0.4951.64"</span><br><span class="line">17.  sec-ch-ua-mobile:?0</span><br><span class="line">18.  sec-ch-ua-model:""</span><br><span class="line">19.  sec-ch-ua-platform:"macOS"</span><br><span class="line">20.  sec-ch-ua-platform-version:"12.3.1"</span><br><span class="line">21.  sec-ch-ua-wow64:?0</span><br><span class="line">22.  sec-ch-viewport-width:1440</span><br><span class="line">23.  sec-fetch-dest:document</span><br><span class="line">24.  sec-fetch-mode:navigate</span><br><span class="line">25.  sec-fetch-site:same-origin</span><br><span class="line">26.  sec-fetch-user:?1</span><br><span class="line">27.  upgrade-insecure-requests:1</span><br><span class="line">28.  user-agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.64 Safari/537.36</span><br><span class="line">29.  x-client-data:CLG1yQEIkrbJAQijtskBCMS2yQEIqZ3KAQjYjMsBCJShywEI2+/LAQjmhMwBCNupzAEI/qrMAQjDrMwBCKSvzAEYqKnKARirqcoB</span><br><span class="line">30. 已解码：message ClientVariations &#123; // Active client experiment variation IDs. repeated int32 variation_id = [3300017, 3300114, 3300131, 3300164, 3313321, 3327576, 3330196, 3340251, 3342950, 3347675, 3347838, 3348035, 3348388]; // Active client experiment variation IDs that trigger server-side behavior. repeated int32 trigger_variation_id = [3314856, 3314859]; &#125;</span><br></pre></td></tr></table></figure><p><strong>响应内容</strong></p><p>响应页面也是类似的需要回应请求行需要的内容信息，同时告知自己允许接受什么样的请求，如果目标IP找不到通常会变为404结果。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">响应标头</span><br><span class="line"></span><br><span class="line">1.  accept-ch: Sec-CH-Viewport-Width  </span><br><span class="line">2.  accept-ch: Sec-CH-Viewport-Height</span><br><span class="line">3.  accept-ch: Sec-CH-DPR</span><br><span class="line">4.  accept-ch: Sec-CH-UA-Platform</span><br><span class="line">5.  accept-ch: Sec-CH-UA-Platform-Version</span><br><span class="line">6.  accept-ch: Sec-CH-UA-Full-Version</span><br><span class="line">7.  accept-ch: Sec-CH-UA-Arch</span><br><span class="line">8.  accept-ch: Sec-CH-UA-Model</span><br><span class="line">9.  accept-ch: Sec-CH-UA-Bitness</span><br><span class="line">10.  accept-ch: Sec-CH-UA-Full-Version-List</span><br><span class="line">11.  accept-ch: Sec-CH-UA-WoW64</span><br><span class="line">12.  alt-svc: h3=":443"; ma=2592000,h3-29=":443"; ma=2592000,h3-Q050=":443"; ma=2592000,h3-Q046=":443"; ma=2592000,h3-Q043=":443"; ma=2592000,quic=":443"; ma=2592000; v="46,43"</span><br><span class="line">13.  bfcache-opt-in: unload</span><br><span class="line">14.  cache-control: private, max-age=0</span><br><span class="line">15.  content-encoding: br</span><br><span class="line">16.  content-length: 43734</span><br><span class="line">17.  content-type: text/html; charset=UTF-8</span><br><span class="line">18.  date: Tue, 24 May 2022 23:24:59 GMT</span><br><span class="line">19.  expires: -1</span><br><span class="line">20.  server: gws</span><br><span class="line">21.  set-cookie: 1P_JAR=2022-05-24-23; expires=Thu, 23-Jun-2022 23:24:59 GMT; path=/; domain=.google.com; Secure; SameSite=none</span><br><span class="line">22.  set-cookie: AEC=; expires=Mon, 01-Jan-1990 00:00:00 GMT; path=/; domain=www.google.com</span><br><span class="line">23.  set-cookie: AEC=; expires=Mon, 01-Jan-1990 00:00:00 GMT; path=/; domain=.www.google.com</span><br><span class="line">24.  set-cookie: AEC=; expires=Mon, 01-Jan-1990 00:00:00 GMT; path=/; domain=google.com</span><br><span class="line">25.  set-cookie: AEC=; expires=Mon, 01-Jan-1990 00:00:00 GMT; path=/; domain=.google.com</span><br><span class="line">26.  set-cookie: SIDCC=AJi4QfEXTiPm1BcAx1gfQzXOs-hmdcHylOVoSbbpy8cUIlP7hNwwfnfo_E8ZdTY1JZli8AqYYWk; expires=Wed, 24-May-2023 23:24:59 GMT; path=/; domain=.google.com; priority=high</span><br><span class="line">27.  set-cookie: __Secure-3PSIDCC=AJi4QfFdxOIbJrwDKltt2sBRVFIcLOCyqQmgTSfYjXTYwqbhh0GPLcR9cxsgyaIh1j_GITbGeHc; expires=Wed, 24-May-2023 23:24:59 GMT; path=/; domain=.google.com; Secure; HttpOnly; priority=high; SameSite=none</span><br><span class="line">28.  strict-transport-security: max-age=31536000</span><br><span class="line">29.  x-frame-options: SAMEORIGIN</span><br><span class="line">30.  x-xss-protection: 0</span><br></pre></td></tr></table></figure><p>响应内容相对比较简单，主要关注重点为第一行内容中的状态码和响应短语，请求执行结果是成功还是失败。上面的交互内容需要注意Http请求严格遵循一个请求对应一个响应内容。</p><blockquote><p>注意：1 条请求消息中只能写 1 个 URI。如果需要获取多个文件，必须对每个文件单独发送 1 条请求。</p></blockquote><p>“如何解析网址？”这个问题从头到尾的介绍到这里就完成的，接下来来看看下一个问题”DNS 服务器如何查询域名对应的 IP 地址？”。</p><h2 id="IP-和-DNS"><a href="#IP-和-DNS" class="headerlink" title="IP 和 DNS"></a><strong>IP 和 DNS</strong></h2><p>首先我们看看IP和DNS是啥，解析网址（域名）和发送请求和响应内容看似是浏览器完成的，实际上它并不具备这些功能， <strong>浏览器收发网络请求实际上需要依托操作系统完成</strong> ，而现代网络基本是<code>TCP/IP</code> 的天下，所以<code>IP</code>发挥关键作用，而<code>DNS</code>存储<code>IP</code>和域名映射的仓库。</p><ul><li>IP：可以类比做我们现实的具体位置，比如XX路XX号，XX路（网络号）对应的的是分配给<strong>整个子网</strong>的号码，而XX号（IP地址）的号码则分配给子网中的计算机，获得到IP地址之后就相当于锁定了当前计算机所在的具体位置，自然也可以可以找到了。</li><li>DNS：直白来讲就是存储了域名和IP映射的记录的站点，浏览器要获取真实地址需要找DNS才能知道，因为域名放任用户自由定义将会出现同一个域名映射多个IP。</li></ul><p>下面我们先观察XX路XX号的号也就是IP地址是如何被找到的。</p><p>发送网络的一方通过子网首先需要经过集线器，把内容转发到最近的路由器上，然后路由器会不断跨越找到离接受者更近的下一个路由器，最后再找到集线器然后在转发到接收者的路由器上，路由器在这里是方向盘的角色，而DNS寻址就像是导航。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205250802048.png" alt="img"></p><blockquote><p>集线器和路由器是什么？ A　路由器：一种对包进行转发的设备。 B　集线器：一种对包进行转发的设备， 分为中继式集线器和交换式集线器两种.</p></blockquote><h2 id="IP地址的组成"><a href="#IP地址的组成" class="headerlink" title="IP地址的组成"></a>IP地址的组成</h2><p>IP地址是一个32位的Bit数，通过8个bit为一组分为4组，每一组用十进制表示并且使用小圆点断开。</p><p>但是仅凭这32个bit是无法定位IP地址和网络号的，所以需要给IP地址附加信息。</p><p>通常IP地址的组合有下面的方法：</p><p>a）IP地址主体：<code>11.22.33.44</code></p><p>b）IP和子网掩码：<code>11.22.33.44/255.255.255.0</code></p><p>c）网络号的比特数作为子网掩码表示：<code>11.22.33.44/24</code></p><p>d）子网地址：<code>11.22.33.0/24</code>，此时代表了整个子网</p><p>e）子网广播地址：<code>11.22.33.255/24</code></p><p>首先整个IP分为32位固定长度，每四个为一组用圆点分隔，通过 0 - 255的十进制表示，比如0就是8个0，255就是8个1，但是仅仅凭借32个位数是<strong>没法辨别</strong>这32位那一部分是网络号，那一部分是主机号的，所以下面是IP的基本组成：</p><ul><li><code>11.22.33.44</code>：表示基本的IP。</li><li><code>11.22.33.44/255.255.255.0</code>：前面部分是基本IP，后面的部分表示子网掩码，表示方式和IP地址一致，注意最后的8位全部为0表示整个子网。</li><li><code>11.22.33.44/24</code>： 这个24也是子网掩码，但是表示子网的方式是使用比特数。</li><li><code>11.22.33.0/24</code>： 子网掩码没有变，IP地址变了，最后的8位0也是表示整个子网。</li><li><code>11.22.33.255/24</code>： 子网掩码没有变，IP地址变了，最后的8位全部位1表示<strong>广播</strong> 整个子网。</li></ul><h3 id="什么是子网掩码？"><a href="#什么是子网掩码？" class="headerlink" title="什么是子网掩码？"></a>什么是子网掩码？</h3><p>初学者可能比较难以理解的概念，这里如果看不懂建议多找找资料挑一个看得懂的解释（关键是自己理解并且能自己复述）。</p><p>下面是从书中原图，个人看完感觉并不是特别直观也不知道干嘛，所以做了一个补充说明。</p><p>实际上下面图中网络号用了AND（位操作 <code>&amp;</code>）计算出网络号码，计算之后确认出网络号是10.1.2，而后面省略的部分其实是8个0的掩码掩盖主机，这里的子网就是 10.1.2.0，对应的主机IP是10.1.2.3。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202206182257006.png" alt=""></p><p>如果看不懂上面说的是啥，这里补充解释一下：</p><p>首先我们需要清楚子网掩码这东西是干嘛的，说白了就是划分网络号和主机号的，网络号可以看作一栋楼，主机是里面的小房间，但是房间编号可能是<code>101</code>，也可能是<code>0101</code>，更有可能是<code>00101</code>，具体得看掩盖的房间号从0000到1111有多少个，决定能分配给多少主机，而计算机0又很特殊，所以网络号的部分+ 子网掩码掩盖的位数部分（表现全为0）组成一个子网，<strong>只有在同一个子网的主机才能互相通信</strong>。</p><p>所以<strong>子网掩码不能单独存在，它必须结合IP地址一起使用</strong>，子网掩码主要分为两个部分：全为1表示网络号，全为0表示的是主机号。</p><p>那么我们随便设置一个子网掩码比如<code>255.255.255.111</code>行不行？</p><p>答案是<strong>不行</strong>，<strong>不行</strong>，<strong>不行</strong>。因为<strong>子网掩码 必须是 连续的 1和0 组成</strong>，上面的掩码<code>255.255.255.0</code> 才是正确的用法，再举例比如<code>255.255.255.244</code>也是合格的子网掩码。</p><p>我们举例说明一下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1100 0000.1010 1000.0000 0001.1000 0001 <span class="comment">-- 192.168.1.129</span></span><br><span class="line">1111 1111.1111 1111.1111 1111.0000 0000 <span class="comment">-- 255.255.255.0</span></span><br><span class="line">———————————————————— </span><br><span class="line">1100 0000.1010 1000.0000 0001.0000 0000 <span class="comment">-- 划分出最终子网网段：192.168.1.0</span></span><br><span class="line">注：确认最终的网络号和主机网段使用了位操作 &amp; （1 &amp; 1 = 1，1 &amp; 0 = 0）</span><br></pre></td></tr></table></figure><p>从最终的结果来看<code>192.168.1.0</code> 的前面24位都为1是暴露的，而后面8位被子网掩码给遮掩住，所以他的另一种写法是<code>192.168.1.0/24</code>，表示24位是1代表网络号，剩余的8位用于表示主机号但是因为被掩盖了所以全部为0。</p><p>虽然被掩盖了，但是主机号位置是0是1不需要关心的，主机号如果落在<code>192.168.1.0</code>到<code>192.168.1.255</code>表示同在一个网段内子网一视同仁，比如<code>192.168.1.129</code>表示其中的129位，包含在这个网段之内。</p><p><strong>小结</strong></p><ol><li><strong>子网掩码 必须是 连续的 1和0 组成</strong>，简单记忆为1的部分来分割网络号，为0的部分用于掩盖主机号，同一个子网内的主机可以互相通信。</li><li>子网掩码有两种写入方式一种是使用和I P 地址一样的32位完全表示方式，另一种是使用数字计算1比特数进行替换，比如24就是下面图中的24个1。</li><li>IP 地址的主机号，全 0表示整个子网，全 1表示向子网上所有设备发送包。这里补充一下全为1的情况 - “广播”。</li></ol><blockquote><p>广播是什么意思？广播地址是专门用于同时向该网络中所有主机进行广播的一个地址，只要是在同一个网段的主机都可以收听到广播。（例如<code>192.168.211.32/24</code>的广播地址为：<code>192.168.211.255</code>）</p></blockquote><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>DNS： <code>Domain Name System</code> <strong>域名服务系统</strong>，最常见的用法是将服务器名称和 IP 地址进行关联，当然只是它的主业，他有一些副业也挺重要但是不是关键感兴趣了解即可。</p><p>IP是难以记忆的，而简短域名更容易被人记住。你可能会觉得域名长了也难记忆啊，虽然解析IP的速度要比解析域名来的快的很多，但是显然网民为了访问一个网站要记住一串数字显然是不可能的，同时域名实际上对于当时的互联网发展来说也是有意义的。</p><p>所以谁来告诉主机域名的真实IP是多少？这时候DNS就上场了，DNS的作用是说白了就是用来映射IP和域名的一个东西。</p><p>DNS是如何完成映射的？对于用户主机来说一定存在一个用于解析DNS的客户端，这个客户端通常被称为解析器，通过域名解析出IP地址的过程也被称为<strong>域名解析</strong>。</p><p><strong>调用解析器</strong></p><p>那么如何调用解析器？解析器实际上就是一段程序代码，这一段程序代码包含在底层操作系统的<code>Socket</code>库当中，通过<code>Socket</code>库调用解析器，然后解析器会向 DNS 服务器发送查询消息， DNS 服 务器根据请求查询IP然后返回响应消息。</p><p>Socket 解析域名的过程非常简单，只需要一行代码就可以完成：<code>gethostbyname(&quot;</code><a href="http://www.lab.glasscom.com" target="_blank" rel="noopener"><code>www.lab.glasscom.com</code></a><code>&quot;);</code>。</p><blockquote><p>库：指的是通用程序组件的集合，用于规范程序代码的规范组建。以解析器为例，Socket 库是用于调用网络功能的程序组件集合。</p></blockquote><p><strong>解析器内部又是如何工作的？</strong></p><p>在应用程序调用解析器的时候，此时控制权会转移到解析器，当控制权转为解析器之后解析器会生成要发送给 DNS 服务器的查询消息，生成过程类似构建一条“请告诉XXX的IP地址”的消息，并且发给DNS服务器完成解析。</p><p>特别注意注意<strong>发送请求不是由解析器完成</strong>，而是需要再次委托给操作系统的<strong>协议栈</strong>完成，所以此时权限会再次转移到协议栈，协议栈最终通过网卡把消息发给DNS，然后DNS查到IP返回消息，至此一次DNS解析请求就完成了。</p><p>值得注意的是 解析器会将取出的 IP 地址写入应用程序<strong>指定的内存地址</strong>中，此外还需要注意请求DNS服务器本身IP也是需要配置的，只不过这个 IP 地址是作为 TCP/IP 的项目事先设置好的，不需要再去查询直接就可以获取。</p><p>最后在不同的操作系统中获取DNS服务器的地址方式会有差别。</p><p>根据上面的描述，总结DNS解析流程：</p><ol><li>WEB浏览器发送域名解析请求，通过Socket向解析器进行请求解析，此时应用程序将会挂起。</li><li>解析器负责“翻译”应用程序的DNS解析请求，但是把具体的请求操作委托给系统栈。</li><li>系统栈负责将请求通过网卡发送给DNS服务器，等待DNS反馈结果。</li><li>DNS获取真实IP之后将结果通过链路反向回送到应用程序。</li></ol><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202206182256279.png" alt=""></p><p><strong>DNS工作</strong></p><p>接下来我们看看dns要如何工作，dns需要查询用户消息包含下面几个部分：</p><ul><li>域名：用来替代IP方便记忆。</li><li>class：考虑到互联网之外的情况，当然外部网络现在只有标识为in的互联网。</li><li>type：表示记录类型用于区分dns的解析方式，不同类型结果不同。</li></ul><p>需要注意的是所有a类型的记录在DNS上注册了，再比如所有邮件类型都是MX的类型，整个DNS工作其实就简单的根据类型和域名进行查表，找到匹配的就回传，否则就会找不到。</p><p>域名层次：所谓域名层次就是DNS不可能是一台服务器，而是需要多台服务器配合，各自管理自己范围的内容，而对于域名来说越靠右边的部分在域名的层次里面越高。</p><p>这样看来是不是有点意思，以日常生活举例并不是我们认为的<code>www</code>是最高，其实他是最低的等级，<code>.com</code>才是最高的。</p><p><strong>DNS查找步骤</strong></p><p>首先将负责管理下级域的 DNS 服务器的 IP 地址注册到它们的上级 DNS 服务器中，然后上级 DNS 服务器的 IP 地址再注册到更上一级的 DNS 服务器中，以此类推。</p><p>举个例子，需要解析等域名为<code>www.baidu.com</code>，DNS需要事先把整个<code>www.baidu.com</code>整个域名注册到<code>baidu.com</code>，再把<code>baidu.com</code>注册到<code>com</code>域名，再把<code>com</code>注册到根域，这样就可以通过上级找下级。</p><p>这里提到DNS有一个根域，根域名指的是就是一个句点 <code>.</code> ，和Linux的根路径意义表现形式上类似。</p><p>根据根域可以解释为什么任何奇怪等域名都可以被访问到，原因是所有的下级都会注册到上级中，最后都有一个共同的 ，如果所有下级要找到根域，自然需要注册根域这个句点。</p><p>DNS查找的过程是自下而上找最近的DNS然后自上而下找根域向下查找的的，也就是先找<strong>最近的dns</strong>找，没有找到就需要直接从根域进行查找，一路通过层级下探找到最终的ip，这也是为什么访问国外ip慢的原因，因为路由链路实在是很长，可能需要几十次dns搜索查找。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202206182255672.png" alt=""></p><p><strong>DNS缓存</strong></p><p>如果每个主机每次请求总是要通过DNS获取域名对应的IP信息，是不可能每次都DNS让找一遍的，实际上解析到的真实IP会预先缓存起来下次访问重复的数据直接返回即可。</p><p>另外虽然前面介绍的是查找自上而下从根域向下查找，实际上DNS还可以利用缓存特性通过多个层级的共享域名加快访问速度跨级查找，比如<code>www.baidu.com</code>和<code>www.baidu</code> 可以共享缓存直接跳两个层级快速找到（当然这里其实找最近的一个DNS就能找到，这里仅仅是举例）。</p><p>但是缓存有个副作用，就是不存在的ip地址消息也会缓存，不过为了防止这种情况一般会有过期时间，过期之后依然需要再次走一遍DNS查找流程。</p><blockquote><p>问题引导：问题</p><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5uaWtrZWlicC5jby5qcC8=" title="http://www.nikkeibp.co.jp/">http://www.nikkeibp.co.jp/<i class="fa fa-external-link"></i></span> 中的 http 代表什么意思？</li></ul><p>表示的是HTTP 协议</p><ul><li>下面两个网址有什么不同？</li></ul><p>a. <span class="exturl" data-url="aHR0cDovL3d3dy5uaWtrZWlicC5jby5qcC9zYW1wbGU=" title="http://www.nikkeibp.co.jp/sample">http://www.nikkeibp.co.jp/sample<i class="fa fa-external-link"></i></span></p><p>b. <span class="exturl" data-url="aHR0cDovL3d3dy5uaWtrZWlicC5jby5qcC9zYW1wbGUv" title="http://www.nikkeibp.co.jp/sample/">http://www.nikkeibp.co.jp/sample/<i class="fa fa-external-link"></i></span></p><p>区别点在于sample 可能被解析出和预期不符合的结果。</p><p>用来识别连接在互联网上的计算机和服务器的地址叫什么？</p><p>IP地址</p><p>根据 Web 服务器的域名来查询 IP 地址时所使用的服务器叫什么？</p><p>DNHS服务器</p><p>向 DNS 服务器发送请求消息的程序叫什么？</p><p>解析器。</p></blockquote><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      网络基础
    
    </summary>
    
    
      <category term="网络/网络基础" scheme="https://whitestore.top/categories/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="网络/网络基础" scheme="https://whitestore.top/tags/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>《how to die alone》读书笔记</title>
    <link href="https://whitestore.top/2022/08/11/howtodie/"/>
    <id>https://whitestore.top/2022/08/11/howtodie/</id>
    <published>2022-08-10T21:28:25.000Z</published>
    <updated>2022-09-08T02:18:34.396Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《how-to-die-alone》读书笔记"><a href="#《how-to-die-alone》读书笔记" class="headerlink" title="《how to die alone》读书笔记"></a>《how to die alone》读书笔记</h1><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220604191654.png" alt=""></p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>算是个人真正意义上靠着翻译软件和自己掌握的拉胯的单词水平啃完的第一本全英文书，从封面到内容半个中文都没有，前前后后靠着自己的记录啃了2个月左右的时间，最终看完发现对于自己的单词积累量提升还是挺大的。</p><p>这本书是图文结合的一本娱乐向小说？作者用摆烂的布莱尔发泄自己被甩的怨恨和愤怒，比较有意思的书籍，整体看来来也并不会因为作者是一个外国人get不到点。</p><p>看这本书一方面是对于书名比较感兴趣，另一方面是顺带锻炼自己的英语能力。</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>这本书网上找不到电子版，可能是太小众了吧，不过实体书确实很贵，原因是100多页但是因为是彩页+漫画。</p><p>对比个人买的其他全英文书这本书的装订还是比较好的，国外的书籍喜欢用回收纸，并且看上去像是国内十几年前的盗版书纸质，没办法老外就是如此粗暴简单。</p><p>最终这本书是轻松娱乐向的，简单看看即可。</p><h1 id="个人评价"><a href="#个人评价" class="headerlink" title="个人评价"></a>个人评价</h1><p>这本书并不打算做个人笔记了，所有的笔记都是自己的翻译内容，个人在翻译过程中顺带记录了一些查询的单词，这本书个人查询的单词还是非常多的，所以基本会看到满屏的标签内容。</p><h1 id="笔记记录"><a href="#笔记记录" class="headerlink" title="笔记记录"></a>笔记记录</h1><p>相当于直接翻译了这本书了，当然质量堪忧，很多地方没有润色。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li>自我介绍：<strong>MEET BLAIR</strong>（密特，布莱尔）</li><li>布莱尔五条孤独终老的建议<ol><li>成为反社会隐士 #antisocial_hermit  </li><li>获得最糟糕朋友奖 #earn_worst_award </li><li>在工作中获得“F”</li><li>破坏你的健康 #wreck </li><li>避免就像是瘟疫的浪漫</li></ol></li><li>如何坟墓中获得笑声。</li><li>致谢</li></ol><h2 id="内容介绍（书的背面）"><a href="#内容介绍（书的背面）" class="headerlink" title="内容介绍（书的背面）"></a>内容介绍（书的背面）</h2><p>作者：莫，韦尔奇萨。单口喜剧演员，作家，漫画家，被前任甩了然后创造了布莱尔。</p><p>不接受任何形式的约会，布莱尔来了，生活的主人，穿着运动裤，只和猫说话，从阴暗但是诚实的角度来看，布莱尔会教你如何成为一个反社会隐士，在你无聊的工作中摆烂，破坏你的人际关系，总是，总是允许自己选择沙发而不是健身房。</p><h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>hi，我是布莱尔，我们从来没有朋友，大概是因为你的父母叫我“有点压抑 #depress  ”和“太愤世嫉俗”和“她的爸爸在哪”？在生活中我看你会有黑暗的看法，但是我总是积极 #postive 的并且活在一个充斥着极度积极的 youtube 人物的世界里，诚实 #honest 将会有所回报，难道不是么？</p><p>这个世界有太多自我拯救的书籍，他们提供克服 #overcome 社交焦虑 #social_anxiety  的步骤并开出不吃肉 #meat 的处方，在生活中通过无趣的饮食 #diets  减轻你的体重，这些书为一部分人服务，我不想浪费我的生命阅读如何改善 #conversation 自己生活的书籍，我更愿意浪费我的生命和我的猫单独对话。</p><p>所以这本自救指导书并不会帮助你如何自救，这本指导书适用于想要穿着运动裤，每顿饭只吃吃披萨并且在家过日子的勇敢灵魂。</p><p>在这本书中，我会教你如何成为反社会斗士，如何破坏你的友谊，我甚至会提供墓碑 #tombsone 建议 #suggest  来帮助你庆祝成功独自死去，当我们都去世的时候你可以感谢我。</p><h2 id="成为反社会隐士"><a href="#成为反社会隐士" class="headerlink" title="成为反社会隐士"></a>成为反社会隐士</h2><p>在某一点 #certain_point 上，参加聚会成为更多成为苦差事而不是奖励 #reward ，可能是因为没有令人惊喜 #surprise 的对象 #element ，每一次聚会都与之前相同 #identical ，当你挑选一套衣服 #outfit 时，你会感到羞耻 #fat-shame ，你太早的参加聚会，与你聊天的人你将再也不会见面，你花费 #spend. #whole  整晚都在想象自己在家里穿着运动裤看谋杀纪录片。</p><p>为什么要参加麻烦的聚会？为了某人？为了某事？如果你真的想孤独致死，从现在开始保持单独行动，再也不要离开你的房子去看望任何朋友或者家人，你的猫除外。</p><ul><li><p>一个女人的肖像，她所有的计划都在剥落</p></li><li><p>隐士秘诀 1：如果你不确定是否要出门，立刻说不</p><ul><li><p>在公共场所遇到熟人如何隐身？</p><ul><li><p>跳到那个衣架 #rack 的中间 #middle</p></li><li><p>躺在那灌木丛 #bush 中</p></li><li><p>躲在树后面 #behind</p></li><li><p>跟在后面（保持相同的步伐）</p></li><li><p>拉住一个小宝贝，说看我现在必须找到他的妈妈</p></li><li><p>把那个宝贝还给你，你还没准备好承担那种责任 #responsibility </p></li><li><p>跳进下水道，十几岁的突变忍者龟在他们看到杰拉德之前是普通的乌龟，他们不想和他们的朋友说话</p></li></ul></li></ul></li></ul><pre><code>-我们小时候玩捉迷藏 #hide_and_seck ， 是为了让我们准备好在成年后在公共场合见到我们认识的人呆在家里并且静止不动今日预测 #forecast ：外面人太多，适合呆在家里。</code></pre><ul><li><p>隐士秘诀2: 如果您在网上关注曾经生活过的人，您就不需要生活</p><ul><li><p>我想我会去里面滚动 #scroll #inside</p></li><li><p>在脱离你无聊的朋友时候经由我的猫太孤单了并且需要我，你一定可以理解。</p></li><li><p>锻炼？是的，锻炼，我必须去健身房 #gym 了</p></li><li><p>必须在日落前整理我的麦片盒 #sunset</p></li><li><p>我上班要迟到了！(你不用说你正在做的是在社交媒体上跟踪前朋友，你的办公室是一张床，你的同事是一只猫)</p></li><li><p>我在艰难的观察每一个谋杀 #murder  纪录片的可能性</p></li><li><p>我需要礼拜（祈祷 #pary ）（相信我，没有人在这一点上可以战胜你）</p></li></ul></li></ul><ul><li><p>和猫单独对话</p><ul><li><p>你整天都在干啥？</p></li><li><p>我们死了之后都会去哪？</p></li><li><p>你相信 #believe 奇迹？会发生在游戏里面么</p></li><li><p>你认为和 tim 和斯黛希会干什么？</p></li><li><p>诚实 #honest 回答，我死了时候；你会吃了我么？</p></li></ul></li><li><p>宠物因为没法学会喝酒的原因  #reason （所以）很孤独</p></li><li><p>差点离开基本上就是离开，指站在门口。</p></li><li><p>我想我在被关爱中（吹头发）</p></li><li><p>6种方法在五分钟内美化你的运动裤</p><ul><li><p>系上腰带 #belt</p></li><li><p>亮片 #sequin</p></li><li><p>戴上围巾</p></li><li><p>把口袋 #pocket 翻到外面，等到朋友来问 这是新趋势嘛？你的五分钟外出将会提升.</p></li><li><p>不穿 开玩笑 #kidding 的，不要这样</p></li><li><p>把它们挂在你的屁股上，你有燕尾服</p></li></ul></li><li><p>一个运动裤派对</p></li><li><p>一个人吃饭是和他人的新式吃法</p></li><li><p>完成家务本身就是家务，也就是不做家务</p></li><li><p>隐士秘诀3: 面无表情的盯着窗外，直到邻居最终标记你为“奇怪的猫女士”. 这是应得的</p></li><li><p>我付了很多房租 #rent 让里面 #inside 这么惨 #miserable<br> kmk </p></li><li><p>如果你独自生活，洗澡永远是你的todo 项目</p></li><li><p>Oh，这个地方你不能去</p></li><li><p>隐士秘诀4:随意计划活动，只是不要邀请任何人参加（ #events , #plan ， #invite ， #just ）</p><ul><li>看，一个反社会的冰淇淋</li></ul></li></ul><p>你真的是一个合格的反社会 #hermit 隐士？</p><ul><li><input disabled="" type="checkbox"> 夜间活动你的首选 #preferred 是疯狂TV SHOW（猜测是美国的很火的综艺节目）</li><li><input disabled="" type="checkbox"> 你的沙发上的毯子的数量 #The_number_of   超过了 #surpasses  装饰枕头的数量</li><li><input disabled="" type="checkbox"> 当你下班 #after_work 回到家时，你有很大的可能 #fat_chance 会离开</li><li><input disabled="" type="checkbox"> 当朋友问你要不要出去喝酒的时候你很恐慌 #panic</li><li><input disabled="" type="checkbox"> 你只有规定 #regurlar 的访客那就是送餐人 #delivery  。</li><li><input disabled="" type="checkbox"> 对了，送餐员在你的快速拨号里面</li><li><input disabled="" type="checkbox"> 雨过天晴 #rain 的时候，你会觉得很兴奋</li><li><input disabled="" type="checkbox"> 你用完整的句子和你的猫说话 #complete_sentences</li><li><input disabled="" type="checkbox"> 在一本叫做《如何孤独地死去》的书中，你住在这里并填写了检查表 #check_list #fill_out </li></ul><p>你是否勾选了超过7个选项？恭喜 #congrats ，你是合格隐士，但是你不是唯一的一个，在这个世界上还有我也填写了这份报告 #fill_out </p><h2 id="糟糕朋友奖"><a href="#糟糕朋友奖" class="headerlink" title="糟糕朋友奖"></a>糟糕朋友奖</h2><p>朋友是被高估 #overrited 的，你只有在学校的自助餐厅感到孤独的时候才真的需要他们，就像贫穷的史蒂夫一样，怀疑鬼鬼祟祟的在毕业之后和你的朋友失去联系？相信他</p><p>朋友永远不会告诉你真相，他们想让你像他们一样，所以他们只是会说一些你想听到的话，比如 “你需要完整的刘海”，“急需要尽快完成你的作业”，”你的牙齿上没有蔬菜叶，布莱尔，说茄子”。</p><p>如果你想要认真的单身生活，你应该让你朋友待会儿或者立刻滚蛋，不确定要这么做？跟随我的tip ，你也能获得著名 #prestigious 的糟糕朋友奖</p><p>当你因为无聊 #bored 和童年朋友聊天的时候，一定要带到 # bring up 一个旧的学校餐厅，你要战斗好几个小时。</p><p>10年了你还欠我3美元和两份双层芝士汉堡</p><p>在和你谈到机场层面之前，我可以接受任何层次的友谊。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I&#39;m confortable with any level of friendship before the talking you to the airport level</span><br></pre></td></tr></table></figure><p>你的纹身 #tatoo 完整含义是什么？</p><p>他的意思是：我讨厌小声说话的陌生人有趣，</p><p>所以，你是从哪里来的?</p><p>糟糕朋友标签2</p><p>如果你在外面没有 #out 食物和金钱，偷袭 #raid 你富有朋友的冰箱 #fridge ，如果他们抓到你，说你想念和他们在一起。</p><p>我对待 #treat  我的朋友的房子就像24小时便利店。</p><p>你的朋友不想听但你还是会说的真相:</p><ul><li>或许你的妈妈是对的（在任何事情上都适用）</li><li>嘿，你肯定 #definitely 选 #picked 错了职业 #career。</li><li>如果我被逮捕 #arrested  ，你是我最后一个会打电话的人。</li><li>当你告诉关于你生活中的故事时我会小睡 #naps 一下。</li><li>是的，实际 #actually 上你已经告诉我“快乐”的故事17次了。</li><li>你不能因为化妆品扼杀 #kill 你约会  #date  的时间（但是我能）。</li><li>你和你宠物的相性太糟糕了</li><li>是的，<strong>你的发型就像是用促销优惠券剪的</strong></li><li>你的新男朋友精确的像你旧男朋友</li><li>你有口臭（绝杀）</li></ul><p>当你要吃早午餐的时候，千万不要坐中间位置，人们通常会从你旁边经过并且会很吵，（建议是）抢夺最后一个位置坐下，无论何时只要你想你可以跑去卫生间。</p><p>我宁愿吃自己的手臂，也不愿意和你和你大学朋友去吃早午餐。</p><blockquote><p>I’d rather eat my own arm than go to brunch with you and your college friends</p></blockquote><p>我没有嘲笑你非常难过，我在笑是因为情绪让我感到不舒服。</p><p>当你假扮 #pretend 成你的成熟朋友我的宝贝改变了我，我爱你，我最乖的宝贝。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205181333674.png" alt=""></p><p>给你的猫一个人名，当你说你不能出去，因为你已经有计划，John，你的朋友认为你遇到了一个更 cool 的人。</p><p><strong>我不想去参加你的婚礼的原因</strong></p><ul><li>我不能给任何礼物在你的注册证上</li><li>我知道你会惩罚单身人士在儿童座位旁边</li><li>之后我不会尊重和你的关系见到你在单身派对</li><li>我讨厌在派对上和其他单身人士一起被迫捧着鲜花</li></ul><p>你是一个最糟糕的朋友么？如果你想要获得最糟糕朋友奖，下面这些检查清单可以帮助你：</p><ul><li><input disabled="" type="checkbox"> 你总是迟到。</li><li><input disabled="" type="checkbox"> 你不带任何吃的却到处蹭吃蹭喝。</li><li><input disabled="" type="checkbox"> 你从来不回群组消息。</li><li><input disabled="" type="checkbox"> 当朋友不在身边的时候说他们的坏话。</li><li><input disabled="" type="checkbox"> 你曾经告诉你最好多朋友她的宝贝看起来 很怪异。</li><li><input disabled="" type="checkbox"> 你 对待你朋友的厨房就像是在开酒吧。</li><li><input disabled="" type="checkbox"> 任何地方你从来不当司机。</li><li><input disabled="" type="checkbox"> 你借走你的朋友的外套，同时归还的时候带着猫身上的毛。</li><li><input disabled="" type="checkbox"> 你从不关注关于你朋友的生活，然而，非常关注他们宠物的生活。</li></ul><p>你选择超过7项么？恭喜，你获得最坏朋友奖项，你同你的猫保持居家，因为你的朋友不能接受你在任何地方。</p><p><strong>在你的工作上获得F</strong></p><p>如果你像我一样工作是为了生活，而不是因为其他任何事情，你 靠着薪水活下来，你每天都在幻想告诉你的老板，我要辞职，当然当咖啡越来越少的时候我从来没有填满咖啡壶，并且我经常从供应柜偷很多纸。</p><p>关于最糟糕的同事，我的意思是，我有点喜欢那个总是把妻子给他做的午饭里面薯片分给我的人，但是其他每个人都很糟糕，实际上一些人总是想要努力工作，我猜有一句老话说的对：“不要结交朋友也不要树立敌人，你的同事理你真的，真的很远”。</p><p>我们不应该工作，人生太短，但是如果你必须跋涉到办公室，这一节将会教你怎么样投入最少量的努力。</p><p>饼图看起来不是很美味，但是他们是给你无聊的同事表达你的对于工作不满最好的方式。</p><p>在工作中表现自己不舒服</p><ul><li>我不舒服 #sick（因为露面）。</li><li>我出了好多汗 #sweating ， 真的很多。</li><li>发型糟糕的一天，这是合理的，不是么。</li><li>从珍妮特那里抓住了一些东西（def 不知道怎么翻译）。</li><li>免费的午餐让我食物中毒 #poisoning ，都是你的错。</li><li>睫毛永久地卡在我的眼睛里 #eyelash 。</li><li>脱水了 #dehydarated</li><li>我的猫跑了，他去了另一间屋子，她喜欢那个地方。</li><li>我看了一部有关外星人的纪录片，那有什么意义。</li><li>晕车。</li><li>晕船。</li><li>晕火车。</li><li>赛格威病 #Segway</li><li>我扭伤我的脚腕，这次是真的</li><li>我没衣服穿了，很严重，我几个月没洗衣服了</li><li>我很难准备这一周的工作</li><li>我得了百日咳</li></ul><p>听起来像是 ？？？ 的笑声</p><p>你迟到了！</p><p>我总是迟到，只不过今天被抓 #caught 了而已</p><p>噢。。。。</p><p>在卫生间只花费20分钟看 Instagram。</p><blockquote><p>介绍：（Instagram（照片墙）是一款运行在移动端上的社交应用，以一种快速、美妙和有趣的方式将你随时抓拍下的<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlOUIlQkUlRTclODklODcvMzcyNDE2" title="https://baike.baidu.com/item/%E5%9B%BE%E7%89%87/372416">图片<i class="fa fa-external-link"></i></span>彼此分享。）</p></blockquote><p>糟糕雇员Tips3：<br>在你正在工作的时候查看另一个工作， 就像是你获得报酬并计划逃跑。</p><p>你是最差的员工吗？</p><p>下面这些简单清单你应该看看</p><p><strong>你是糟糕的雇员么？</strong></p><ul><li>在最后的一个星期你上班迟到了4天</li><li>你经常 #regular 停留 #park 在你老板的位置 #spot</li><li>你养成了经常提醒每个人的习惯，这份工作太适合你了</li><li>你剽窃 #steal 公司的补给品 #supply 并且放到黑市上去卖</li><li>你只会在有可能会有免费蛋糕的时候才说生日快乐</li><li>你带着你的猫去上班虽然你的同事对猫过敏</li><li>不管何时何地你会撕掉冰箱里的食物标签并且撕掉他</li><li>你从来没有填满咖啡机</li><li>我每天大约花四分之三的时间评判同事</li><li>每天保持四分之一的时间在社交媒体上</li></ul><p>最后一条感觉中招了，额</p><h2 id="报复健康"><a href="#报复健康" class="headerlink" title="报复健康"></a>报复健康</h2><p>我刚刚编造的一条新研究，我们思考锻炼 #work_out 和正确饮食百分之800比我们实际上要做的更多，我确定有一些励志名言列表，由一堆支持我的足球教练 #coache 来鼓励 #encourage 你锻炼和喝蔬菜汤，但是我想提供另一个选择 #alternative  ，丢掉汗湿的毛巾 #toweal ，我的意思是，就像我说的，他是汗湿 #sweat 的，不需要随身携带，这太恶心  #gross 了。</p><p>此外，你可以在你的生活中每天喝你的绿色饮料然后每天去参加黑暗的EDM碰撞旋转 #spin 课程，但是我们所有的书都以同样的方式结尾，开个玩笑，很明显 #obviosly ，保持单身，独自死去。</p><p>所以坐下来，绝对不要起床，打开一袋薯片，并且阅读本章如何做，你几乎什么都学不到  #exactly ，这真是棒极 #brilliant 了。</p><p>差不多 #almost 吃到肚子里有宝宝的重量 #weight 了</p><blockquote><p><strong>BYOSnacks</strong>: bring your onw Snacks 自带酒水或者食物。</p></blockquote><p>当你去你的乳糖 #lactose 不耐症 #intolerant 素食 #vegan 主义者朋友生日派对时</p><p>不喜欢热瑜伽 #yoga 。更多进入热口袋?（不太知道怎么翻译。）</p><p>我今天做的唯一锻炼是当我大喊“下班了“，并且离开办公室的时候。</p><p>我要放弃海滩身材换桃子 #peach 身材，圆滚滚 #fuzzy</p><p>放置一个开始标记在你的睡椅上，然后放一个结束的标记在你的冰箱 #fridge  上，看你只是想快点赢比赛 #race 而已。</p><p>我有糟糕 #terrible 的饮食结构，我总是欺骗 #cheat 他们。</p><p>我喜欢我的锻炼就像是鸡蛋这个单词的最前面的e一样easy</p><p>联系到能到达床边的快递</p><p>在周末对待你自己就像是对待垃圾流水线</p><p><strong>能给任何人留下深刻印象的单身晚餐</strong></p><ul><li>可以放进微波炉的 #Microwaveble 意大利面 #spaghetti</li><li>剩下一半 #half 的过期三明治</li><li>搅碎的沙拉和奶酪块 #cube</li><li>弹出蛋挞 #pop-Tarts 自助餐 #buffet ，又名 #aka 绝望 #despair 自助餐 </li><li>盒装葡萄酒 #wine</li><li>谷物面包 #cereal 和带有沉淀物 #dregs 的牛奶</li><li>偷来的面包和三滴带有钠的泪水</li></ul><p>这是协定。你每个月给我钱并且再也不要见到我</p><p>你滚蛋</p><p> 像烟雾一般消散</p><ul><li>不要调料</li><li>不要腌菜</li><li>不要西红柿</li><li>不要面包<br>我要她所有不要的东西</li></ul><p>连续第十年把跑一次马拉松放进新年绝对要完成的任务里面</p><p>备注：自从第七年开始没有动过一英里</p><p>#row ：有连续不断的意思</p><p>如果你躺着在一条羽毛编织的毛毯上你不需要出去锻炼身体</p><p><strong>你在沙发难题上已经完成你的转变了吗？</strong></p><ul><li>你在你的健身房穿着运动裤步行，并且强烈的要求 #demanded 注销 #cancel 你的健身卡会员 #membership</li><li>你还在回家的路上叫披萨的外卖，这是唯一的毒药和肾上激素你在公共场合烧掉你 ·的游泳衣</li><li>当你应该跑步的时候你可以散步</li><li>当你应该散步的时候可以坐下</li><li>当你应该坐下的时候你应该躺平</li><li>你购买了时候一直想要的谷物食物，种类差不多是那种小饼干</li><li>你渴望设置一项世界纪录，不要锻炼</li><li>你参加5k比赛只是想要一件免费T恤</li></ul><p><strong>什么是应该买的而不是不怎么使用的健身房会员</strong></p><ul><li>48条运动裤</li><li>一个给我猫的无技术 #technology 修养所 #retreat</li><li>装在车里面的按摩椅 #massage</li><li>更多的TV流媒体订阅 #subscriptions</li><li>1995年别克车 #Buick</li><li>电子游戏 所有的按钮都在一个控制器里面，包含所有的锻炼内容</li><li>伊利诺斯州一栋普通房子</li><li>一台跑步机 #treadmill ，用来挂我的48条运动裤</li><li>一个奶酪汉堡 #cheeseburger</li><li>很多比特币 #bitcoin</li></ul><h2 id="避免瘟疫浪漫"><a href="#避免瘟疫浪漫" class="headerlink" title="避免瘟疫浪漫"></a>避免瘟疫浪漫</h2><p>在线约会应该会让事情变简单，但是不知道怎么浪漫比任何事情都难，</p><p>另一方面，人们在坠入爱河时候会感到无聊，他们变得非常乐观并且脸上总是洋溢着笑容，你想要过上这样的生活吗？不！有更多有趣的事情等待着永远单身的朋友们享受生活时间，不需要分享披萨和和大量的床上空间。</p><p>如果你已经有女朋友，或者甚至想要成为其中一员，立马停下，抛弃，卷走他，在这个单元我会告诉你如何让你的浪漫点燃你的生活，以及让他看起来像是荣耀探险。</p><p>家庭假日全套装备</p><p>是的，还是单身</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220526132526.png" alt=""></p><p><strong>愤世嫉俗方法</strong></p><p>在你约会的时候展示你的宠物照片，如果他们露出奇怪的样子，拿起你的饮料泼到他们脸上。</p><p>我只会回应一种也就是猫的呼叫</p><p>如果你快乐并且你知道它。把那狗屎留给自己：if you are happy and you konw it. keepthat shit to yourself</p><p>我在修剪指甲的时候才会感觉我住我的手</p><p>如果你想要避免第二次约会，你需要在第一次约会的时候明确的内容</p><p>如果你快乐并且你知道它。把那狗屎留给自己</p><blockquote><p>if you are happy and you konw it. keepthat shit to yourself</p></blockquote><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220604190605.png" alt=""></p><p>你喜欢什么类型的音乐，经典传统摇滚</p><p>我喜欢旧货币</p><p>每周五的晚上我都会得大量皮疹，你呢？</p><p>当你的紧急联系人是你的妈妈的时候你知道你单身知道你单身</p><p>正好约会后告诉我他们不喜欢猫。</p><p>讽刺的看家庭剧，大声喊出像是“哈，没有任何人是真实的”，和“给我三年时间，他毫无疑问爱上他最好的朋友”。</p><p>第一次恋爱，结婚，然后生孩子，我太孤独了</p><p><strong>如何分手?</strong></p><ol><li>是时候决定反弹 #bounce 了。</li><li>看部电影破坏自己的预先准备富兰克林，亲爱的，不会是我的错。</li><li>通知杂货店，你待会儿需要他们的帮助。</li><li>传递你的嘘声（抱怨） #boo ，告诉他们你离家出走了。</li><li>等待直到他们去上班，然后悄悄溜到他们房子附近对他们的宠物说goodbye</li><li>烧掉你的手机</li><li>吃掉杂货店买的零食 #groceries</li></ol><p>不要线上或者线下约会</p><p>多米诺披萨APP &gt; Tinder（一款APP），因为我可以看到进度条。</p><p>手牵手散步应该是违法 #illegal</p><p>刚发了我的第一个sext（祷告），那是一张丹麦奶酪的照片。</p><p>补充：这里不太懂sext如何翻译，于是查了一下，个人猜想是宗教的一种俚语，简单理解为<strong>中午</strong>这个时间点即可。</p><blockquote><p><strong>六时经</strong>为<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTk3JUE1JUU4JUFGJUJFJUU3JUJCJThG" title="https://zh.wikipedia.org/wiki/%E6%97%A5%E8%AF%BE%E7%BB%8F">日课经<i class="fa fa-external-link"></i></span>的一部分，是<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JThGJUE0JUU3JUJEJTk3JUU5JUE5JUFD" title="https://zh.wikipedia.org/wiki/%E5%8F%A4%E7%BD%97%E9%A9%AC">古罗马<i class="fa fa-external-link"></i></span>的六点 ，等于现在的中午。是正午时的一次<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUE1JTg4JUU3JUE1JUI3" title="https://zh.wikipedia.org/wiki/%E7%A5%88%E7%A5%B7">祈祷<i class="fa fa-external-link"></i></span>。这一时间的祈祷主要是为了纪念<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JTgwJUI2JUU3JUE4JUEz" title="https://zh.wikipedia.org/wiki/%E8%80%B6%E7%A8%A3">耶稣<i class="fa fa-external-link"></i></span>被钉在十字架上的那一刻：“第六日的第六时被钉在十字架上的耶稣撕毁了<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU0JUJBJTlBJUU1JUJEJTkz" title="https://zh.wikipedia.org/wiki/%E4%BA%9A%E5%BD%93">亚当<i class="fa fa-external-link"></i></span>的赎罪行径”（<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JThCJTlDJUU1JThEJUEwJUU1JUJBJUFEJUU3JUE0JUJD" title="https://zh.wikipedia.org/wiki/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E7%A4%BC">拜占庭礼<i class="fa fa-external-link"></i></span>）。</p></blockquote><blockquote><p>按照<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUJFJTg1JUU5JUE2JUFDJUU3JUE2JUFF" title="https://zh.wikipedia.org/wiki/%E7%BE%85%E9%A6%AC%E7%A6%AE">罗马礼<i class="fa fa-external-link"></i></span>习俗，六时经应由一首<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUI1JTlFJUU2JUFEJThD" title="https://zh.wikipedia.org/wiki/%E8%B5%9E%E6%AD%8C">赞歌<i class="fa fa-external-link"></i></span>、三首<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JTgxJTk2JUU4JUE5JUE5" title="https://zh.wikipedia.org/wiki/%E8%81%96%E8%A9%A9">圣诗<i class="fa fa-external-link"></i></span>（或几节圣诗）、一段简短的<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JTgxJTk2JUU2JTlCJUI4" title="https://zh.wikipedia.org/wiki/%E8%81%96%E6%9B%B8">圣书<i class="fa fa-external-link"></i></span>阅读、一段<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3cvaW5kZXgucGhwP3RpdGxlPSVFNyVCQiU4RiVFNiU5NiU4NyZhY3Rpb249ZWRpdCZyZWRsaW5rPTE=" title="https://zh.wikipedia.org/w/index.php?title=%E7%BB%8F%E6%96%87&action=edit&redlink=1">经文<i class="fa fa-external-link"></i></span>和一段<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUE1JUI3JUU1JTkxJThB" title="https://zh.wikipedia.org/wiki/%E7%A5%B7%E5%91%8A">祷告<i class="fa fa-external-link"></i></span>组成。某些<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU0JUJGJUFFJUU5JTgxJTkzJUU5JTk5JUEy" title="https://zh.wikipedia.org/wiki/%E4%BF%AE%E9%81%93%E9%99%A2">修道院<i class="fa fa-external-link"></i></span>还会在降福前或降福后（根据具体地点而定），增加一首献给<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JTgxJTk2JUU2JUFGJThEJUU5JUE2JUFDJUU1JTg4JUE5JUU0JUJBJTlF" title="https://zh.wikipedia.org/wiki/%E8%81%96%E6%AF%8D%E9%A6%AC%E5%88%A9%E4%BA%9E">圣母马利亚<i class="fa fa-external-link"></i></span>的<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3cvaW5kZXgucGhwP3RpdGxlPSVFNSU5QyVBMyVFNiVBRiU4RCVFOCVCNSU5RSZhY3Rpb249ZWRpdCZyZWRsaW5rPTE=" title="https://zh.wikipedia.org/w/index.php?title=%E5%9C%A3%E6%AF%8D%E8%B5%9E&action=edit&redlink=1">圣母赞<i class="fa fa-external-link"></i></span>。</p></blockquote><p><strong>你是否成功避免了浪漫瘟疫？</strong><br>这个清单将帮助您确定您是否已经掌握 #mastered 了单身的艺术 </p><ul><li><input disabled="" type="checkbox"> 醒来的时候学猫叫 #meows 而不是你好</li><li><input disabled="" type="checkbox"> 没有人可以花你的钱来购买你</li><li><input disabled="" type="checkbox"> 你的感情对象应该是一袋薯条</li><li><input disabled="" type="checkbox"> 醉酒不是给你的前任发短信，而是给你的税务会计师 #accountant 发电子邮件</li><li><input disabled="" type="checkbox"> 你不必与任何人一起检查 #check ，做出一个可怕的决定</li><li><input disabled="" type="checkbox"> 当你的朋友邀请您参加 #invite 他们的婚礼 #wedding 时，你的朋友已经停止给你+1 #plusone （点赞）了<ul><li><input disabled="" type="checkbox"> 你有几个室内植物 #houseplant</li></ul></li><li><input disabled="" type="checkbox"> 你的洗发水 #shampoo 可以永久 #forever 使用</li><li><input disabled="" type="checkbox"> 您更喜欢 #prefer #onion 洋葱戒指 #ring 而不是结婚戒指</li></ul><p>你勾选了7个或者更多么，恭喜你已经正式避免了困扰，你的奖品？在Netflix上观看您想要的任何内容，不受阻挡。 #uninterrupted </p><p><strong>如何从严肃中找到笑点</strong></p><p>好吧，总有一天我们都会死这太糟糕了，但是死亡是不值得恐惧的 #scary ，就像生活它可以变得温和而愉快  #amusing 。所以为什么不放声大笑？有了正确的墓碑 #grave 你可以使墓地变成喜剧舞台</p><p>这里有一些墓碑会招待游客，路过的陌生人和墓地 #graveyard 的鬼魂 #ghost</p><p>他死后在做自己想做的事情，睡觉</p><p>那个果汁清理的不干净</p><p>我想要意大利香肠 #pepperoni 在我的墓碑上</p><p>一些感同身受的悲伤音乐</p><p>访问你最喜欢的幽灵请选择最喜欢的节目</p><p>贩卖机 #vending #machine 墓碑，吃掉你的感觉。</p><p>篮球场墓碑</p><p>反弹一些悲伤 #sorrow 的好方法</p><p>你更像一个骨灰 #urn 盒人？不用担心 #worry ，我会帮你盖住他。如果你有无法逃脱 #shake 的亲人，用这个可爱的饼干骨灰盒对他们恶作剧</p><p>来吧，瓮已经  #urned 笑了</p><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>感谢布莱尔的（原始 #original ）粉丝，你的美丽评论和鼓励的话语改变了当然是我的职业生涯 #career ，填补我心中的空洞 #gaping #hole 。</p><p>致所有甩了我的前任 – 那场龙卷风 #tornado  般失恋心碎导致我画了布莱尔。</p><p>致Workman Publishing – 埃文，格里菲斯是完美的猫 – 有爱的编辑，感谢您修正我的语法错误因为我真得不喜欢逗号而且我无论如何也喜欢连续不断向公立学校大喊太谢谢你了诶文你太伟大 #magniffisent 了（惊喜？）</p><p>感谢安东尼 * 马特罗 让一切顺利并相信他，你的积极性 #positivity 真的会让布莱尔失望。</p><p>致贾斯汀的信，他非常努力的说服让我的工作充满信息，大机会 #fat_chance </p><p>致我聪明又了不起的祖父母 Ed 和 Mary.</p><p>最后，致我的妈妈玛丽，作为5个孩子的单身母亲，，但你总是设法 #managed 找到并且拿起我的小漫画，并且丢掉他们，所有的垃圾导致了这本书。</p><p>啊，本节结束了么，我饿了并且所有的爱让我食欲不振 #appetite 。（By 布莱尔）</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>总的来说挺有意思的书，对于我来说能坚持看下去就已经是一种突破了。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      how-to-die-alone
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://whitestore.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="书籍" scheme="https://whitestore.top/tags/%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>《银河铁道之夜》读书笔记-为了谁而活？</title>
    <link href="https://whitestore.top/2022/06/02/bywholive/"/>
    <id>https://whitestore.top/2022/06/02/bywholive/</id>
    <published>2022-06-02T10:16:09.000Z</published>
    <updated>2022-06-02T10:17:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220601171128.png" alt=""></p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>非常“美丽”的书名，实际上却是一个十分悲伤的故事，大概悲剧更能引起读者的共鸣，本文标题起了一个叫做“为了谁”和这本书的作者身世有关，作者是为妹妹而坚持活着的人，像我这样的绝大多数普通人都难以做到吧。</p><p>这本书总是和《小王子》放到一起比较，因为两者都是源自于一场旅行的成长，我很少去了解作者过去，看书也很少去关注书名，但是因为不是很懂作品说了啥和故事背景，之后开始了解宫泽贤治的身世，不免对他抱持信念以及执着十分钦佩，能为了谁而活的人本身就是伟大的。</p><p>当我看完这本书再看看书中夹着的能通往任何地方的“车票”时候，这场旅行的回忆深深刻在脑海。</p><p><strong>下面的内容涉及剧透，如果对这本书感兴趣建议查看下面的资源了解了解。</strong></p><h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><p>链接：<span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMUVqRHhpMjJvQVpSUkQzX1psZHFkZmc/cHdkPTJramE=" title="https://pan.baidu.com/s/1EjDxi22oAZRRD3_Zldqdfg?pwd=2kja">https://pan.baidu.com/s/1EjDxi22oAZRRD3_Zldqdfg?pwd=2kja<i class="fa fa-external-link"></i></span> 提取码：2kja</p><a id="more"></a><h1 id="书籍简介"><a href="#书籍简介" class="headerlink" title="书籍简介"></a>书籍简介</h1><p>宫泽贤治的代表作《银河铁道之夜》，本作大约写于1927年，1934年被列入<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvdy9pbmRleC5waHA/dGl0bGU9JUU2JTk2JTg3JUU1JTlDJTgzJUU1JUEwJTgyJmFjdGlvbj1lZGl0JnJlZGxpbms9MQ==" title="https://zh.m.wikipedia.org/w/index.php?title=%E6%96%87%E5%9C%83%E5%A0%82&action=edit&redlink=1">文圃堂<i class="fa fa-external-link"></i></span>出版的《宫泽贤治作品集》中第三卷正式发表。其实全书仍在草稿阶段，现存4个版本，以最后一个最为人所熟知，不同版本间差异较大，学者对此众说纷纭。不过作品充满唯美幻想色彩的独特描写，因此仍受到许多人喜爱。</p><p>这本书被定义为儿童作品，却有着很多对成年人有非常多有感触的内容。</p><p>银河列车的轨迹：整个银河列车从北十字到南十字，经过的站点按照顺序排序为：<strong>银河火车站北十字星车站天鹅站普利奥辛海岸阿尔卑列监测站天鹰座停车场高原半人马星村南十字车站煤袋星云</strong>。</p><p>关联作品：</p><ul><li>银河铁道999</li><li>《银河铁道之夜》同名动画电影（B站有）</li><li>《银河铁道之夜》CG动画电影（B站有），虽然2006年但是个人感觉制作的十分精美。</li><li>《永诀の朝》（宫泽贤治所做的诗）</li></ul><p><strong>主角介绍</strong></p><p>一共两位 <strong>乔凡尼</strong> 和 <strong>坎帕内拉</strong>，当然那位落水被救的还会高级黑的小朋友忘记名字了，姑且算上。可以看到主角的人名都比较潮，男主叫乔丹尼，男主最好的朋友以及同学叫做坎培内拉，名字比较拗口但是意外的让人印象深刻。</p><p>这种新潮的起名方式和作者所处的家乡岩手县有关系。作者把岩手县叫 INATOBU，这是自创的词语，个人猜想应该是结合宗教和英语有关，然后我用上神奇的谷歌翻译查了一下，没想到还有意外的惊喜。</p><p><code>岩手 =&gt; no fly</code>，宫泽贤治奇特的想象力确实很有意思。顺带自夸一下我的联想能力。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220601164421.png" alt=""></p><p>书籍年代：太正时代的书籍。也就是从1912年7月30日至1926年12月25日止。</p><blockquote><p><strong>大正</strong>（日语：大正／たいしょう <em>Taishō</em> <span class="exturl" data-url="aHR0cHM6Ly9qYS53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUE0JUE3JUU2JUFEJUEz" title="https://ja.wikipedia.org/wiki/%E5%A4%A7%E6%AD%A3">*<i class="fa fa-external-link"></i></span>/<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS9IZWxwOiVFNiU5NyVBNSVFOCVBQSU5RQ==" title="https://zh.m.wikipedia.org/wiki/Help:%E6%97%A5%E8%AA%9E">?<i class="fa fa-external-link"></i></span>）是<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTYlOTclQTUlRTYlOUMlQUM=" title="https://zh.m.wikipedia.org/wiki/%E6%97%A5%E6%9C%AC">日本<i class="fa fa-external-link"></i></span><span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTUlQTQlQTclRTYlQUQlQTMlRTUlQTQlQTklRTclOUElODc=" title="https://zh.m.wikipedia.org/wiki/%E5%A4%A7%E6%AD%A3%E5%A4%A9%E7%9A%87">大正天皇<i class="fa fa-external-link"></i></span>在位期间使用的<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTYlOTclQTUlRTYlOUMlQUMlRTUlQjklQjQlRTglOTklOUY=" title="https://zh.m.wikipedia.org/wiki/%E6%97%A5%E6%9C%AC%E5%B9%B4%E8%99%9F">年号<i class="fa fa-external-link"></i></span>，使用时间从1912年7月30日至1926年12月25日止。承续年号为<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTYlOTglOEUlRTYlQjIlQkI=" title="https://zh.m.wikipedia.org/wiki/%E6%98%8E%E6%B2%BB">明治<i class="fa fa-external-link"></i></span>，接续年号为<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTYlOTglQUQlRTUlOTIlOEM=" title="https://zh.m.wikipedia.org/wiki/%E6%98%AD%E5%92%8C">昭和<i class="fa fa-external-link"></i></span><span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvemgtaGFucy8lRTUlQTQlQTclRTYlQUQlQTMjY2l0ZV9ub3RlLTowLTE=" title="https://zh.m.wikipedia.org/zh-hans/%E5%A4%A7%E6%AD%A3#cite_note-:0-1">[1]<i class="fa fa-external-link"></i></span>。 大正天皇体弱多病，加上第一次民主化在欧洲的遍地开花，这也促使东亚日本的政治权力从旧的<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTUlQUYlQTElRTUlQTQlQjQ=" title="https://zh.m.wikipedia.org/wiki/%E5%AF%A1%E5%A4%B4">寡头<i class="fa fa-external-link"></i></span>政治集团<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTklOTclQTglRTklOTglODA=" title="https://zh.m.wikipedia.org/wiki/%E9%97%A8%E9%98%80">门阀<i class="fa fa-external-link"></i></span>或<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTUlODYlOUIlRTQlQkElQkE=" title="https://zh.m.wikipedia.org/wiki/%E5%86%9B%E4%BA%BA">军人<i class="fa fa-external-link"></i></span>转移到<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTUlQjglOUQlRTUlOUMlOEIlRTglQUQlQjAlRTYlOUMlODNfKCVFNiU5NyVBNSVFNiU5QyVBQyk=" title="https://zh.m.wikipedia.org/wiki/%E5%B8%9D%E5%9C%8B%E8%AD%B0%E6%9C%83_(%E6%97%A5%E6%9C%AC)">帝国议会<i class="fa fa-external-link"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTYlQjAlOTElRTQlQjglQkIlRTUlODUlOUElRTYlQjQlQkU=" title="https://zh.m.wikipedia.org/wiki/%E6%B0%91%E4%B8%BB%E5%85%9A%E6%B4%BE">民主党派<i class="fa fa-external-link"></i></span>。 因此，这个时代被认为是日本被称为“<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTUlQTQlQTclRTYlQUQlQTMlRTYlQjAlOTElRTQlQjglQkI=" title="https://zh.m.wikipedia.org/wiki/%E5%A4%A7%E6%AD%A3%E6%B0%91%E4%B8%BB">大正民主<i class="fa fa-external-link"></i></span>”的<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTglODclQUElRTclOTQlQjElRTQlQjglQkIlRTQlQjklODk=" title="https://zh.m.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E4%B8%BB%E4%B9%89">自由主义<i class="fa fa-external-link"></i></span>运动的时代，它通常区别于<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTYlOTglOEUlRTYlQjIlQkI=" title="https://zh.m.wikipedia.org/wiki/%E6%98%8E%E6%B2%BB">明治时代<i class="fa fa-external-link"></i></span>的混乱和随后由<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTUlODYlOUIlRTUlOUIlQkQlRTQlQjglQkIlRTQlQjklODk=" title="https://zh.m.wikipedia.org/wiki/%E5%86%9B%E5%9B%BD%E4%B8%BB%E4%B9%89">军国主义<i class="fa fa-external-link"></i></span>驱动的<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTYlOTglQUQlRTUlOTIlOEM=" title="https://zh.m.wikipedia.org/wiki/%E6%98%AD%E5%92%8C">昭和时代<i class="fa fa-external-link"></i></span>初期<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvemgtaGFucy8lRTUlQTQlQTclRTYlQUQlQTMjY2l0ZV9ub3RlLTowLTE=" title="https://zh.m.wikipedia.org/zh-hans/%E5%A4%A7%E6%AD%A3#cite_note-:0-1">[1]<i class="fa fa-external-link"></i></span>。大正纪元与<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTYlQjAlOTElRTUlOUMlOEIlRTclQjQlODAlRTUlODUlODM=" title="https://zh.m.wikipedia.org/wiki/%E6%B0%91%E5%9C%8B%E7%B4%80%E5%85%83">民国纪元<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTQlQjglQkIlRTQlQkQlOTMlRTclQkElQUElRTUlODUlODM=" title="https://zh.m.wikipedia.org/wiki/%E4%B8%BB%E4%BD%93%E7%BA%AA%E5%85%83">主体纪元<i class="fa fa-external-link"></i></span>共享相同的元年。</p></blockquote><p>可能让人看不下去的原因有：</p><ul><li>开头比较黑暗，因为美丽的书名，会让人以为一开始就觉得</li><li>新潮的名字，特别是人名会让人退却。</li></ul><p>这两点可能会觉得莫名其妙，但是换位并且结合日本人排外的思想想象一下相信不是很难理解。</p><p><strong>几点重要的暗示：</strong></p><ol><li>叙事基调：在黑暗之后，是无比美丽和光明的生活。</li><li>无论何时都要对未来抱有期望。</li><li>乔丹尼的母亲叮嘱乔丹可以去看灯会，但是不要到水里去成为贯穿整个故事的伏笔。</li><li>乔丹尼所在的城镇每一年又一次叫做“银河祭”的盛会，成为引出整个故事的基础。</li><li><strong>今晚是银河祭，请大家外出观看银河</strong>，盛大的节日和悲剧形成强烈对比。</li></ol><h1 id="为什么要写这样的故事？"><a href="#为什么要写这样的故事？" class="headerlink" title="为什么要写这样的故事？"></a>为什么要写这样的故事？</h1><p>作者写这本书的目的似乎可以从他过去写的一首诗中可以体现，这首诗叫做永诀の朝。为什么要聊到这首诗呢？因为这和宫泽贤治的妹妹有关系，这是他为了缅怀早早逝去的妹妹写的一首诗。</p><p>下面找来了两个版本的翻译：</p><p>第一个版本</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">就在今天  </span><br><span class="line"></span><br><span class="line">我的妹妹啊要去远方  </span><br><span class="line"></span><br><span class="line">雨雪交加，前门异常明亮  </span><br><span class="line"></span><br><span class="line">　　（请给我些雨雪）  </span><br><span class="line">　　</span><br><span class="line">从暗红的阴惨的云中  </span><br><span class="line"></span><br><span class="line">雨雪凄凄地落下来  </span><br><span class="line"></span><br><span class="line">　　（请给我些雨雪）  </span><br><span class="line">　　</span><br><span class="line">拿着有两棵蓝色菜图案的陶碗 </span><br><span class="line"></span><br><span class="line">给你去盛雨雪  </span><br><span class="line"></span><br><span class="line">我像出了膛的子弹  </span><br><span class="line"></span><br><span class="line">冲向那暗淡的雨雪之中  </span><br><span class="line"></span><br><span class="line">　　（请给我些雨雪）  </span><br><span class="line">　　</span><br><span class="line">从铅灰色的暗淡云中  </span><br><span class="line"></span><br><span class="line">雨雪凄凄地沉落下来  </span><br><span class="line"></span><br><span class="line">啊，敏子  </span><br><span class="line"></span><br><span class="line">在这死亡的时刻  </span><br><span class="line"></span><br><span class="line">为了使我一生光明  </span><br><span class="line"></span><br><span class="line">你让我拿给你  </span><br><span class="line"></span><br><span class="line">一碗清凉的雪  </span><br><span class="line"></span><br><span class="line">谢谢你，我的勇敢的妹妹  </span><br><span class="line"></span><br><span class="line">我一定勇往直前  </span><br><span class="line"></span><br><span class="line">　　（请给我些雨雪） </span><br><span class="line">　　 </span><br><span class="line">你是在高烧和喘息之中  </span><br><span class="line"></span><br><span class="line">让我</span><br><span class="line"></span><br><span class="line">从那称为银河，太阳，大气层的  </span><br><span class="line"></span><br><span class="line">大宇宙落下来的雪中取来最后一碗  </span><br><span class="line"></span><br><span class="line">在两块花岗岩石上  </span><br><span class="line"></span><br><span class="line">雨雪寂寞地存留着  </span><br><span class="line"></span><br><span class="line">我小心地站在上面  </span><br><span class="line"></span><br><span class="line">雪和水，纯白的雪和水  </span><br><span class="line"></span><br><span class="line">从挂满透明冰冷水珠的  </span><br><span class="line"></span><br><span class="line">光润美丽的松树枝上  </span><br><span class="line"></span><br><span class="line">给心爱的妹妹取来最后的一餐  </span><br><span class="line"></span><br><span class="line">在我们一块长大的日子里  </span><br><span class="line"></span><br><span class="line">看惯了的茶碗的蓝色图案  </span><br><span class="line"></span><br><span class="line">今天你也要与它告别  </span><br><span class="line"></span><br><span class="line">　　（我一个人死去）  </span><br><span class="line">　　</span><br><span class="line">你今天真的要告别  </span><br><span class="line"></span><br><span class="line">啊，那封锁了的病室里  </span><br><span class="line"></span><br><span class="line">在那黑暗的屏风和帐子里  </span><br><span class="line"></span><br><span class="line">我的勇敢的妹妹啊  </span><br><span class="line"></span><br><span class="line">优美地苍白地燃尽她最后的生命  </span><br><span class="line"></span><br><span class="line">不管从哪里挑选这雪  </span><br><span class="line"></span><br><span class="line">都是那么洁白  </span><br><span class="line"></span><br><span class="line">从那可怕的混乱的天空  </span><br><span class="line"></span><br><span class="line">落下这美丽的雪  </span><br><span class="line"></span><br><span class="line">　　（假如再次托生  </span><br><span class="line">　　</span><br><span class="line">　　不单为自己  </span><br><span class="line">　　</span><br><span class="line">　　也要为别人把苦来尝）</span><br><span class="line">　　  </span><br><span class="line">我对着你吃的两碗雪  </span><br><span class="line"></span><br><span class="line">内心祈祷  </span><br><span class="line"></span><br><span class="line">愿它变为上天的赐予  </span><br><span class="line"></span><br><span class="line">为你和大家  </span><br><span class="line"></span><br><span class="line">得到圣粮  </span><br><span class="line"></span><br><span class="line">我宁愿舍弃一切的幸福</span><br></pre></td></tr></table></figure><p>第二个版本（个人认为第二版翻译略好一些，更有诗词的律动感）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">《永诀之朝》</span><br><span class="line"></span><br><span class="line">今昔你就要远去了，</span><br><span class="line"></span><br><span class="line">我的妹妹。</span><br><span class="line"></span><br><span class="line">门外的世界风雨交叠，</span><br><span class="line"></span><br><span class="line">却异常的明媚。</span><br><span class="line"></span><br><span class="line">从隐隐泛红却又愈发阴沉的天空，</span><br><span class="line"></span><br><span class="line">迅疾地飘飞着雨雪。</span><br><span class="line"></span><br><span class="line">那两个缺口的陶瓷碗。</span><br><span class="line"></span><br><span class="line">绘着那熟悉的蓝色莼菜花纹。</span><br><span class="line"></span><br><span class="line">为了让碗里盛满你所渴求着的雪，</span><br><span class="line"></span><br><span class="line">我像破了膛的弧线的子弹一般，</span><br><span class="line"></span><br><span class="line">冲向外面黯淡交加的雨雪。</span><br><span class="line"></span><br><span class="line">那铅灰色沉寂的天空中，</span><br><span class="line"></span><br><span class="line">雨雪一阵又一阵的紧紧催促着。</span><br><span class="line"></span><br><span class="line">啊，妹妹。</span><br><span class="line"></span><br><span class="line">你为了让我释怀乐观起来，</span><br><span class="line"></span><br><span class="line">求我接一碗那圣洁冰凉的雪。</span><br><span class="line"></span><br><span class="line">尽管你已生命垂危。</span><br><span class="line"></span><br><span class="line">谢谢你啊，</span><br><span class="line"></span><br><span class="line">我勇敢可敬的妹妹。</span><br><span class="line"></span><br><span class="line">我也一定会勇敢向前，无畏风雪。</span><br><span class="line"></span><br><span class="line">随着激烈又炽热的喘息，</span><br><span class="line"></span><br><span class="line">你拜托我。</span><br><span class="line"></span><br><span class="line">为你捧来从被称为银河、太阳、大气层的世界的天空中，</span><br><span class="line"></span><br><span class="line">飘落下的最后一轮雪。</span><br><span class="line"></span><br><span class="line">在两块光滑的花岗岩上，</span><br><span class="line"></span><br><span class="line">雨雪静静地沉寂着。</span><br><span class="line"></span><br><span class="line">我小心翼翼地站在那上面，</span><br><span class="line"></span><br><span class="line">保持着雪与水那纯洁的联系，</span><br><span class="line"></span><br><span class="line">满载着透明的冰冷安静的雪水，</span><br><span class="line"></span><br><span class="line">从这闪烁着残微光亮的脆嫩松枝上，</span><br><span class="line"></span><br><span class="line">为我那心爱的善良美好的妹妹取下那最后的渴求。</span><br><span class="line"></span><br><span class="line">在伴随着我们一起长大的岁月里，</span><br><span class="line"></span><br><span class="line">早已熟悉了这陶瓷碗上的蓝色花纹。</span><br><span class="line"></span><br><span class="line">如是今朝却也要与你永诀，</span><br><span class="line"></span><br><span class="line">（我将独自前行）</span><br><span class="line"></span><br><span class="line">在那封闭了的病房里，</span><br><span class="line"></span><br><span class="line">在那昏暗的屏风和帐子里，</span><br><span class="line"></span><br><span class="line">你正面色苍白温情脉脉地燃尽着生命啊</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">我亲爱的妹妹，</span><br><span class="line"></span><br><span class="line">无论是抉择着哪里的雪，</span><br><span class="line"></span><br><span class="line">它都是那么的洁白。</span><br><span class="line"></span><br><span class="line">从那昏暗的雨雪交加的可怕天空中，</span><br><span class="line"></span><br><span class="line">竟落下如此美丽动人的雪。</span><br><span class="line"></span><br><span class="line">（假如获得重生，这次要活的轻松，不再遭受苦难）</span><br><span class="line"></span><br><span class="line">面对你所渴求的那两碗雪，</span><br><span class="line"></span><br><span class="line">我衷心的祈祷着。</span><br><span class="line"></span><br><span class="line">愿它变成上天的赐予，</span><br><span class="line"></span><br><span class="line">为你和大家，</span><br><span class="line"></span><br><span class="line">得到神圣的粮食</span><br><span class="line"></span><br><span class="line">我宁愿舍弃这一切的幸福</span><br><span class="line"></span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>十分优美并且让人看完有种想哭的冲动的诗，因为包含了作者真挚的情感。</p><p>上面的故事是宫泽贤治和他妹妹的真实的故事，宫泽贤治的妹妹在生命的最后一刻让哥哥给他带点雪尝尝，宫泽贤治焦急的跑到屋外找雪的身影，最后却回家却发现妹妹已经永远闭上双眼。</p><p>令我最感动的是”你拜托我。为你捧来从被称为银河、太阳、大气层的世界的天空中，飘落下的最后一轮雪。”这句话。</p><p>妹妹的死直接影响了宫泽贤治对人生和世界的看法，也让他写出印象深刻的作品。也引导出《银河铁道之夜》中十分启发人的一句话：</p><p><strong>如果能为了某人而活着，我想大概是一件幸福的事情吧。</strong></p><p>宫泽贤治确实是十分温柔并且也确实是诚恳真实的人，最好的体现是他在生前所有畅销世界的巨作其实都是<strong>写给自己</strong>的，很多十分优秀的作品并没有发表（包括这本影响力最大的书），所以从这一些细节可以看到宫泽贤治确实一直贯彻自己的理念，为自己的妹妹而活并且很少考虑自己，是十分值得欣赏的人。</p><p>那么为什么要写出《银河铁道之夜》呢？这里就必须要探究作者妹妹死后的故事，当然个人也是从日本人的书评讲解里面才明白的。在宫泽贤治的妹妹死后宫泽贤治和家人闹掰了，因为家人要用传统的方式让妹妹下葬，而宫泽贤治则更希望用自己的方式向妹妹告别，最终结果就是导致妹妹一直无法安然入土魂归天灵。</p><p>经过很长时间的争吵，宫泽贤治最终选择离开家庭独自营生，这也导致宫泽贤治没有和自己的妹妹好好告别，所以<strong>《银河铁道之夜》实际上是宫泽贤治为了给自己妹妹告别所写的一本书</strong>，正如书中的角色一般，他用银河列车和绝美的风景送走了妹妹化身的坎培内拉，最后再将一切回忆随着牛奶瓶一般带在他的身上。</p><h1 id="个人评价"><a href="#个人评价" class="headerlink" title="个人评价"></a>个人评价</h1><p>蕴含了宗教，科学，信仰，以及自己的真挚祝愿，融合在一个小孩子也看得懂的书中，宫泽贤治确实是一个厉害的人，看这本书甚至让我有些理解宗教的魅力是什么，而信仰究竟有什么样的力量。</p><p>实际上个人在读完第一遍之后其实并不是很了解上面这些内容的，故事很吸引人但是很多地方十分奇怪作者为什么要写这样的故事，虽然故事看到一半在各种暗示中透露了各种信息可以明显看出是一个悲伤的故事，但是依然摸不着头脑写本书的用意是什么，所以我果断找了个日本的书评靠着字幕翻译大概看懂了这本书讲了什么，另外看了下油管500多万粉丝，确实是一个大佬。</p><p>整本书开头两章从主角乔丹尼悲惨的命运，到视角一转却有些莫名其妙的坐上了开往银河的列车，当下的痛苦与黑暗和壮阔的银河列车鲜明对比，乔丹尼是作者的化身，在艰苦过后是幸福的邂逅，先抑后扬也让后面列车上的故事回忆更为深刻。</p><p>然而这一段奇幻的旅行却终究是悲伤的故事，故事最后突然急转直下，这是作者对于现实和理想的刻意安排，个人认为这也是暗指得与失的哲学。</p><p>其中让我印象最为深刻的是关于蝎子的故事，蝎子本身是有毒的，它一辈子都在伤害别人，但是到了死前的那一刻却决定要献出自己的生命，“反正我都要死了，不如就为你而死吧”，所以蝎子的本性似乎并不坏？我们是否愿意为了谁做出牺牲？</p><p>大概伟大的作家都会伴随着悲惨的命运，有时候只能感叹上天的不公，宫泽贤治只活了37年也因病匆匆离开了人世。</p><h1 id="佳句摘录"><a href="#佳句摘录" class="headerlink" title="佳句摘录"></a>佳句摘录</h1><ul><li>我不知道什么是真正的幸福，但我知道即使遭遇再大的痛苦，只要我们走在正确的道路上，那么无论顺境或逆境，都会距离真正的幸福越来越近。</li><li>如果能为了某人而活着，我想大概是一件幸福的事情吧。</li><li>人生的幸福在于每一个小小瞬间。</li></ul><h1 id="内容分析"><a href="#内容分析" class="headerlink" title="内容分析"></a>内容分析</h1><p>下面是个人看书过程中的一些疑问和看法，有些内容是个人看完之后查资料明白是什么意思的，属于意外之喜，顺便涨了一些知识。</p><h2 id="捡铅字"><a href="#捡铅字" class="headerlink" title="捡铅字"></a>捡铅字</h2><p>捡铅字是第二章乔丹尼给印刷厂打工的工作内容，这一段个人第一次看的时候完全不知道主角在干什么，所以这里有必要补充解释一下，在作者的那个年代，印刷是需要在铅块和板上面放上假名和汉字的，使用的是活版印刷术，印刷一本书需要把“字”捡到一个个的板上面才能印刷，然后下一页再用同样的方式捡到一起印刷下一章，是非常辛苦单调但是需要很强注意力的工作。所以不难理解为什么拿到报酬的乔丹尼会如此开心了。</p><p>另外这里再次回忆这一章的内容，又要被人嘲笑“小放大镜”，又要急急忙忙的捡铅字，实在是有够憋屈，难怪前面两章比较劝退人。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220601153653.png" alt=""></p><h2 id="海獭皮"><a href="#海獭皮" class="headerlink" title="海獭皮"></a>海獭皮</h2><p>乔丹尼的父亲是渔民，需要外出捕鱼，在出海之前答应给乔丹尼一件海獭皮的衣服，然而迟迟未归的父亲却也这件事成为了同学嘲笑乔丹尼的笑点。</p><p>拿不到海獭皮的外套而被同学嘲笑是为什么呢？其实是由于当时海獭都是当地人偷猎，后面因为大肆杀害野生动物而被政府禁止，嘲笑乔丹尼拿不到海獭皮是暗指的他爸被抓去坐牢了，属于不骂人的“高级黑”，看书过程不免想要吐槽小学生都已经这么强了么。</p><p>当然只有坎佩内拉不会嘲笑他，并且主角的父亲和坎佩内拉的父亲在读书的时候是朋友，所以他们之间也是能互相理解的朋友。</p><h2 id="四维空间"><a href="#四维空间" class="headerlink" title="四维空间"></a>四维空间</h2><p>在天鹅站，主人公一行人遇到了考古的学者，随后的火车行驶过程中遇到了红胡子老头，红胡子老头是一个捕鸟人，之后是乔丹尼和坎佩内拉与捕鸟人的一些互动。</p><p>捕鸟人的剧情不长，但是看到捕鸟人能闪现到白鹭的旁边，并且在主角询问之后回答这是轻而易举的事情，不知道为什么让我想起来《三体》中那个“徒手”摘心脏的故事，很明显作者在这里提出了自己对于四维空间的一种遐想，实在是难以想象100年前就有这生动的想象力，并且在书中用简单明了的方式体现，虽然没有过多深入但是可以看出作者的知识渊博。</p><h2 id="得与失"><a href="#得与失" class="headerlink" title="得与失"></a>得与失</h2><p>在故事的最后是乔丹尼在现实世界得知了坎佩内拉为了救同学自己淹死的消息，乔丹尼带着装满了回忆的牛奶瓶赶回家中却意外得知父亲归来的消息，大概作者在暗示<strong>当你失去某样东西的时候，有新的事物在向你走来</strong>，所以作者的温柔总是藏在这种看不见的地方。</p><p>转念一想，牛奶瓶和雪一样都是白色的，为了让母亲喝上牛奶而捧着牛奶瓶的乔丹尼映射了为了妹妹捧着雪的宫泽贤治，这大概也是宫泽贤治激励自己哪怕过去无法挽回，却依然可以为了某种事物而活的心态吧。</p><p>这大概也是作者自己不愿意把《银河铁道之夜》公开于世，只愿让他督促和勉励自己的一份记录。</p><h1 id="写到最后"><a href="#写到最后" class="headerlink" title="写到最后"></a>写到最后</h1><p>书里书外都有着看似悲伤的故事，作者是为了为了妹妹坚持活下去，我们又是为了谁而活呢？</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      非常“美丽”的书名，实际上却是一个十分悲伤的故事
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://whitestore.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="书籍" scheme="https://whitestore.top/tags/%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>谷歌三件套 - Bigtable</title>
    <link href="https://whitestore.top/2022/05/21/google-bigtable/"/>
    <id>https://whitestore.top/2022/05/21/google-bigtable/</id>
    <published>2022-05-21T11:16:54.000Z</published>
    <updated>2022-06-02T10:09:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="谷歌三件套-Bigtable"><a href="#谷歌三件套-Bigtable" class="headerlink" title="谷歌三件套 - Bigtable"></a>谷歌三件套 - Bigtable</h1><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>如标题所言，这一篇文章简单介绍BigTable，其实个人更建议看LevelDB这款开源数据库，因为这数据库也是Bigtable的作者 <strong>JeffreyDean</strong> 设计的，很多内容不能说像简直就是一模一样。</p><p>值得注意的是，看Bigtable的内容<strong>千万不要带着关系型数据库的思维</strong>，建议看之前看看《数据密集型应用系统设计》的第三章，里面提到了LSM-Tree以及大数据系统设计思想，或者看看个人之前写的文章 [[《数据密集型型系统设计》LSM-Tree VS BTree]]</p><h1 id="三件套论文资料"><a href="#三件套论文资料" class="headerlink" title="三件套论文资料"></a>三件套论文资料</h1><p>Bigtable 原始在线论文： <strong><span class="exturl" data-url="aHR0cHM6Ly9zdGF0aWMuZ29vZ2xldXNlcmNvbnRlbnQuY29tL21lZGlhL3Jlc2VhcmNoLmdvb2dsZS5jb20vemgtQ04vL2FyY2hpdmUvYmlndGFibGUtb3NkaTA2LnBkZg==" title="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/bigtable-osdi06.pdf">Bigtable: A Distributed Storage System for Structured Data<i class="fa fa-external-link"></i></span></strong></p><p>MapReduct 原始在线论文：<span class="exturl" data-url="aHR0cHM6Ly9zdGF0aWMuZ29vZ2xldXNlcmNvbnRlbnQuY29tL21lZGlhL3Jlc2VhcmNoLmdvb2dsZS5jb20vemgtQ04vL2FyY2hpdmUvbWFwcmVkdWNlLW9zZGkwNC5wZGY=" title="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf">MapReduce: Simplified Data Processing on Large Clusters<i class="fa fa-external-link"></i></span></p><p>GFS 原始在线论文：<span class="exturl" data-url="aHR0cHM6Ly9zdGF0aWMuZ29vZ2xldXNlcmNvbnRlbnQuY29tL21lZGlhL3Jlc2VhcmNoLmdvb2dsZS5jb20vemgtQ04vL2FyY2hpdmUvZ2ZzLXNvc3AyMDAzLnBkZg==" title="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/gfs-sosp2003.pdf">The Google File System<i class="fa fa-external-link"></i></span></p><p>如果看不懂英文或者想要线下阅读，个人从某全是广告的技术网站买了一份中文翻译以及原始英文论文PDF，合并到一起免费分享给大家（虽然掏钱买也没几个钱）：</p><p>链接: <span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMTVaMjRhcTYydTI1WV9MckhTYU5DQ3c=" title="https://pan.baidu.com/s/15Z24aq62u25Y_LrHSaNCCw">Google-GFS,Bigtable,Mapreduce三大论文英文原版+中文翻译<i class="fa fa-external-link"></i></span> 提取码: 82ok </p><blockquote><p>（如果链接失效可以关注公众号“懒时小窝” 回复“谷歌三件套”或者“谷歌”获取这些内容）</p></blockquote><a id="more"></a><h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>下面Bigtable介绍内容可以跳过，论文巴拉巴拉吹了一大堆，其实关键也就是关注这几个点：</p><ul><li>大数据、分布式存储、异地多活容灾（侧面反应）。</li><li>GFS和BigTable的关系。</li><li>Chubby。</li><li>LSM-Tree 数据结构。</li><li>SSTable（LSM-Tree）。</li></ul><p>Bigtable 是一个<strong>分布式存储系统</strong>，用于管理旨在扩展到非常大的结构化数据<br>大小：数千种商品的 PB 级数据服务器。 Google 的许多项目都将数据存储在 Bigtable 中，包括网络索引、谷歌地球和谷歌财经。 这些应用提出了非常不同的要求</p><p>在 Bigtable 上，无论是在数据大小方面（从 URL 到网页到卫星图像）和延迟要求<br>（从后端批量处理到实时数据服务）。尽管有这些不同的需求，Bigtable 还是成功地为所有用户提供了灵活、高性能的解决方案这些 Google 产品。 在本文中，我们描述了 Bigtable 提供的简单数据模型，它为客户提供对数据布局和格式的动态控制，我们描述了 Bigtable 的设计和实现。</p><p>Bigtable看起来像一个数据库，采用了很多数据库的实现策略。但是Bigtable并不支持完整的关系型数据模型；而是为客户端提供了一种简单的数据模型，客户端可以动态地控制数据的布局和格式，并且利用底层数据存储的局部性特征。Bigtable将数据统统看成无意义的字节串，客户端需要将结构化和非结构化数据串行化再存入Bigtable。</p><p>前面提到相当多的google应用使用了BigTable，比如Google Earth和Google Analytics，这里建议有条件高级上网的同学推荐看一下<strong>Google Earth</strong> 找找你家位置，你会发现在这个世界上你没有啥秘密可言（地理位置上），也能最直观的明白现代导弹为什么可以精准无误的打击，挺恐怖的事情。</p><p>题外话就扯到这，由于网上有很多介绍的文章，这里也同样结合原始论文和理解摘录自己感兴趣的部分，因为个人是看完一整个LevelDB的源代码之后再回来看的，很多东西都省略了，没看过的更多内容可以参考下面这篇文章：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L09wZW5OYWl2ZS9hcnRpY2xlL2RldGFpbHMvNzUzMjU4OQ==" title="https://blog.csdn.net/OpenNaive/article/details/7532589">BigTable解读<i class="fa fa-external-link"></i></span></p><p>我们不需要关注谷歌吹逼自己的高性能，高负载介绍，毕竟都会这么对外宣传，我们只要了解Bigtable干了啥和怎么实现即可。</p><h1 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h1><p>首先介绍最为重要的数据组织结构也就是数据模型，论文第二节开头对于SSTable做了定义：</p><p> A Bigtable is a sparse（稀疏）, distributed（分布式）, persistent（持久化） multidimensional（多维度） sorted map（排序哈希表）。</p><p>简单的数据模型意味着灵活和很强的扩展性，SSTable 使用 <code>row</code>、<code>column</code> 和 <code>timestamp</code> 三个字段作为这个哈希的键，值是字节数组，其实也就是字符串。</p><p>一条数据最小单位可以抽象理解为这样的存储形式：</p><p><code>(row:string, column:string, time:int64) → string</code></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205201448701.png" alt=""></p><p>再次强调这里的数据格式<strong>不能按照关系型数据库理解</strong>，原因是他本质上是<strong>Key/Value</strong>的存储格式，这三个值不能按照单纯行或者列存储格式理解，而是使用<strong>混合存储</strong>+多维数据的存储方式，所以这三个值抽象理解为<strong>行键（row）、列键（column）、时间戳（timestamp）</strong>，最终由这三个参数构成三维参数。</p><p><strong>行键（row）</strong></p><p>行键是原子操作，行数据可以是任意的字符串，最大可以扩展到64个KB，当然多数情况为10 - 100个字节，每一个读和写操作都是一个独立原子性的。</p><p>行的范围是可以动态划分的，行的数据切分称为切片，通过切片用户只需要和更加少量的数据通信，通过分片也可以更好的获取更加准确和可控的数据范围。</p><p>切片在行键中被称为 tablet，切片支持负载均衡，随着表的扩展片也会自动进行分裂，最终一个分片控制在100 MB - 200MB 当中。</p><p><strong>列键（column）</strong></p><p>列的存储格式涉及到一个被称之为 <strong>列族</strong> 的概念，通过列族的方式把相似的值组合到一起，一个列族里的列一般存储相同类型的数据，所以通常情况下列族的数据变动比较小，但是列族是可以随意添加和删除的，并且通过谷歌特定的格式进行命名，列族</p><p>这里补充列族的概念，指的是<strong>把一行中的所有列和行主键保存到一起</strong>，并且不使用列压缩的形式存储。其实这种用行转列基本就可以实现，所以列族严格意义上依然是行存储的变体，和真正的列存储还是存在差异的。</p><p>由于列族的存在，使得SSTable实现一个key的多维度映射，所以多维的概念就是在列族上出现的，同时可以把列族看做是二级索引。</p><p><strong>时间戳</strong></p><p>时间戳负责标记每一个行列索引的版本号，每个单元格可以包含多个版本，版本通过时间戳管理，BigTable的时间戳是64位整数，通常情况为微秒级别的单位，可以使用客户端进行指定单位。</p><p>时间戳显然就是三级别索引了，读取的时候通过最新的时间戳可以认为是数据的最新版本。另外在查询时如果 只给出行列，那么返回的是<strong>最新版本的数据</strong>；如果给出了行列时间戳，那么返回的是时间<strong>小于或等于时间戳的数据</strong>。</p><blockquote><p>这也是现在大数据框架的存储格式特点，比如目前前景不错的<strong>Tidb</strong>，支持OLTP也支持OLAP。</p></blockquote><h1 id="支撑组件"><a href="#支撑组件" class="headerlink" title="支撑组件"></a>支撑组件</h1><p>BigTable除开SSTable之外，还存在其他的支持组件：</p><ul><li>用GFS来存储日志和数据文件.</li><li>按SSTable文件格式存储数据.</li><li>用Chubby管理元数据.</li></ul><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205201416964.png" alt=""></p><p><strong>GFS（Google File System）</strong></p><p>从上面的内容可以看到，GFS先于memtable操作，显然充当了整个系统的日志部分，这一部分牵扯到谷歌三件套的另一个系统设计GFS，不是本文讨论的重点，这里只需要知道它干了所有和Log和数据存储位置有关的事情即可。</p><p>既然是日志和数据的存储，那么GFS自然也知道数据的具体位置，因为属于SSTable的前置组件，所以 SSTable 的具体位置需要GFS提前记录。</p><p>另外memtable相当于SSTable的缓存，当memtable成长到一定规模会被冻结，Bigtable随之创建一个新的memtable，并且将冻结的memtable转换为SSTable格式写入GFS，这个操作称为<code>minor compaction</code>。</p><blockquote><p>在 LevelDB中体现的是Level0的SSTable 压缩合并。</p></blockquote><p><strong>Chubby</strong></p><p>Bigtable 依赖于一个高可用和持久的分布式锁服务称为 <strong>Chubby</strong>，它由五个活动副本组成，其中一个是选举为主节点的Master，节点正常的时候可以进行互相通信，Chubby 使用Paxos算法保持一致。</p><p>Chubby提供了命名空间，内部通过小文件和目录组成，目录或者文件可以配置单独的锁，使得读和写操作都是原子性的，Chubby 客户端提供一致性的文件缓存，每一个Chubby 都必须和另一个 Chubby 保持会话，如果客户端会话过期会丢失全部的锁。</p><p><strong>SSTable</strong></p><p>终于要进入重点部分了，可惜的是原始论文并没有详细的介绍SSTable的内部数据结构，仅仅在论文第六个小节中介绍了SSTable的作用。</p><p>首先看看BigTable和GFS 是什么关系呢？在论文中我们可以看到一个类似树的结构，其中根节点为主服务器，主服务器负责接受请求，通过管理分片服务器将请求分片到不同的片服务器中，所以从外层看最终干活的是<strong>片服务器</strong>。</p><p>然而片服务器实际上本身也只是负责管理自己分片的SSTable，它也通过特殊索引知道数据在那个SSTable分片中，然后从GFS中读取SSTable文件的数据，而GFS则可能要从多个Chuncker server里面搜索数据。</p><p>而图中的metatable原数据表可以看作是和SSTable绑定的类似<strong>索引</strong>的关系，元数据表的数据是<strong>不能被外界访问</strong>的，外界访问的是元数据对应的SSTable分片。</p><h1 id="Bigtable集群"><a href="#Bigtable集群" class="headerlink" title="Bigtable集群"></a>Bigtable集群</h1><p>BigTable集群通过三个层级配套组件完成工作。</p><p>第一层是<strong>主服务器（master server</strong>）也就是我们上面提到的Chubby，本身也通过集群的方式保证root tablet正常访问，也可以直接看作我们广为使用的中间件节点集群。</p><p>第二层是<strong>分片服务器</strong>，也称 tablet，其中root tablet是元数据表（METADATA table）的第一个分片，</p><p>第三层是<strong>元数据</strong>的部分，和 root tablet 组成元数据映射表，元数据包含很多的用户数据分片。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205211600915.png" alt=""></p><p>关于三个层级内部的组成这里不用过多猜测到底长啥样，还是那句话去看LevelDB吧。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章简单介绍了一下BigTable 中一些核心部分，有很大部分内容都被忽略了，对于大数据方向的同学来说这三篇论文基本是必看的资料，因为说白了这三驾马车放到现在基本也可以通用，提到的很多理念对现在的中间件有很深的影响。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>关于<strong>Bigtable</strong>部分就介绍到这里了，虽然论文还要很多理论的部分，但是个人看下来之后基本在LevelDB都有体现，所以想要了解使用的直接看LevelDB源代码理解起来更快。</p><h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDA0MTY1MjAwMw==" title="https://segmentfault.com/a/1190000041652003">[《数据密集型型系统设计》LSM-Tree VS BTree]<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDA0MTcyMDIwNQ==" title="https://segmentfault.com/a/1190000041720205">[LSM-Tree - LevelDb了解和实现]<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDA0MTg2NDU3OQ==" title="https://segmentfault.com/a/1190000041864579">[LSM-Tree - LevelDb 源码解析]<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDA0MTg2OTU4Ng==" title="https://segmentfault.com/a/1190000041869586">[LSM-Tree - LevelDb Skiplist跳表]<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDA0MTg3MzQwMA==" title="https://segmentfault.com/a/1190000041873400">[LSM-Tree - LevelDb 布隆过滤器]<i class="fa fa-external-link"></i></span></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      bigtable数据结构解析
    
    </summary>
    
    
      <category term="谷歌三件套" scheme="https://whitestore.top/categories/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97/"/>
    
    
      <category term="LevelDB" scheme="https://whitestore.top/tags/LevelDB/"/>
    
      <category term="谷歌" scheme="https://whitestore.top/tags/%E8%B0%B7%E6%AD%8C/"/>
    
  </entry>
  
  <entry>
    <title>《生之欲》观影感悟</title>
    <link href="https://whitestore.top/2022/05/21/szygw/"/>
    <id>https://whitestore.top/2022/05/21/szygw/</id>
    <published>2022-05-21T11:15:11.000Z</published>
    <updated>2022-06-02T10:09:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>乘着假期的尾巴看了这一部电影，不得不说虽然豆瓣的高分不一定是好电影，但是这一部上世纪五十年代的电影还是值得观看。</p><p>本文内容<strong>包含剧透</strong>。</p><blockquote><p>兑现前两天立得看电影的Flag，个人认为不管是好的电影还是书籍都是值得记录和回忆的， 为了让自己不忘记电影留下点东西也为不白白浪费两个小时的 宝贵人生。</p></blockquote><h1 id="故事内容"><a href="#故事内容" class="headerlink" title="故事内容"></a><strong>故事内容</strong></h1><p>一句话概括：《生之欲》讲述了一位官僚在发现自己患了晚期癌症后，试图在他的生活中找到意义。</p><blockquote><p>A bureaucrat tries to find a meaning in his life after he discovers he has terminal cancer.</p></blockquote><p>《<strong>生之欲</strong>》（日语：生きる）在<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JUE2JTk5JUU2JUI4JUFG" title="https://zh.wikipedia.org/wiki/%E9%A6%99%E6%B8%AF">香港<i class="fa fa-external-link"></i></span>译作《<strong>流芳颂</strong>》，乃是1952年由<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTk3JUE1JUU2JTlDJUFD" title="https://zh.wikipedia.org/wiki/%E6%97%A5%E6%9C%AC">日本<i class="fa fa-external-link"></i></span>知名<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUIwJThFJUU2JUJDJTk0" title="https://zh.wikipedia.org/wiki/%E5%B0%8E%E6%BC%94">导演<i class="fa fa-external-link"></i></span><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JUJCJTkxJUU2JUJFJUE0JUU2JTk4JThF" title="https://zh.wikipedia.org/wiki/%E9%BB%91%E6%BE%A4%E6%98%8E">黑泽明<i class="fa fa-external-link"></i></span>执导的<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTlCJUJCJUU1JUJEJUIx" title="https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%BD%B1">电影<i class="fa fa-external-link"></i></span>，曾获得日本<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JUFGJThGJUU2JTk3JUE1JUU5JTlCJUJCJUU1JUJEJUIxJUU3JThEJThF" title="https://zh.wikipedia.org/wiki/%E6%AF%8F%E6%97%A5%E9%9B%BB%E5%BD%B1%E7%8D%8E">每日电影最佳影片奖<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTlCJUJCJUU1JUJEJUIxJUU2JTk3JUFDJUU1JUEwJUIx" title="https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%BD%B1%E6%97%AC%E5%A0%B1">电影旬报<i class="fa fa-external-link"></i></span>年度最佳影片奖、<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTlGJThGJUU2JTlFJTk3JUU1JUJEJUIxJUU1JUIxJTk1" title="https://zh.wikipedia.org/wiki/%E6%9F%8F%E6%9E%97%E5%BD%B1%E5%B1%95">柏林影展<i class="fa fa-external-link"></i></span>特别奖等奖项。</p><p>在市公所工作30年的市民课课长渡边勘治每天过着盖章、签公文的乏味生活，某日因身体不适前往<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTg2JUFCJUU5JTk5JUEy" title="https://zh.wikipedia.org/wiki/%E9%86%AB%E9%99%A2">医院<i class="fa fa-external-link"></i></span>检查，结果竟被告知罹患<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JTgzJTgzJUU3JTk5JThD" title="https://zh.wikipedia.org/wiki/%E8%83%83%E7%99%8C">胃癌<i class="fa fa-external-link"></i></span>末期，只剩下约半年的生命。回到家中，<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTg1JTkyJUU1JUFEJTkw" title="https://zh.wikipedia.org/wiki/%E5%85%92%E5%AD%90">儿子<i class="fa fa-external-link"></i></span>与<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUFBJUIzJUU1JUE5JUE2" title="https://zh.wikipedia.org/wiki/%E5%AA%B3%E5%A9%A6">媳妇<i class="fa fa-external-link"></i></span>对他并不友善，甚至可谓不孝。感到悲伤的渡边，带了毕生积蓄离家出走，也不去上班了。他在外头遇见一位<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUIwJThGJUU4JUFBJUFB" title="https://zh.wikipedia.org/wiki/%E5%B0%8F%E8%AA%AA">小说<i class="fa fa-external-link"></i></span><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU0JUJEJTlDJUU1JUFFJUI2" title="https://zh.wikipedia.org/wiki/%E4%BD%9C%E5%AE%B6">作家<i class="fa fa-external-link"></i></span>，告之自己将不久于人世，他认为从未替自己好好活过。小说家同情其遭遇，带他去打<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUJEJTg4JUU3JThGJUEwJUU2JUE5JTlG" title="https://zh.wikipedia.org/wiki/%E5%BD%88%E7%8F%A0%E6%A9%9F">小钢珠<i class="fa fa-external-link"></i></span>，甚至去<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUE2JTkzJUU5JTk5JUEy" title="https://zh.wikipedia.org/wiki/%E5%A6%93%E9%99%A2">声色场所<i class="fa fa-external-link"></i></span>。对渡边来说，虽然这些事很新鲜，但到头来却觉得空虚落寞。第二天他就告别了小说家，一个人孤独的走在街上。</p><p>他遇见了市公所的一位年轻女职员小田切丰，后者表示她厌倦公务员无聊的工作，已觅得新职，却因课长没来上班，没人批准<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUJFJUFEJUU4JTgxJUI3" title="https://zh.wikipedia.org/wiki/%E8%BE%AD%E8%81%B7">辞呈<i class="fa fa-external-link"></i></span>。渡边便将小田切带回家中，为她盖离职同意书；见她丝袜破掉，想为她买双新的。这天他要求小田切带他去玩，两人也度过快乐的一天。但回家后却遭到儿子辱骂，认为他之前带走的存款算是家用的一部分；儿子同时误会小田切是他的年轻<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTg0JTlCJUU0JUJBJUJB" title="https://zh.wikipedia.org/wiki/%E6%84%9B%E4%BA%BA">情人<i class="fa fa-external-link"></i></span>，要求父亲自重。</p><p>过了几天后，渡边前往小田切新任职的<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JThFJUE5JUU1JTg1JUI3" title="https://zh.wikipedia.org/wiki/%E7%8E%A9%E5%85%B7">玩具<i class="fa fa-external-link"></i></span>工厂，希望她再陪着出去玩。小田切原本不想答应，但渡边苦苦哀求，她只好同意。晚上来到一家<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUE1JUJGJUU5JUE0JTkwJUU1JUJCJUIz" title="https://zh.wikipedia.org/wiki/%E8%A5%BF%E9%A4%90%E5%BB%B3">西餐厅<i class="fa fa-external-link"></i></span>，渡边的举动让小田切以为他要对她不轨，十分害怕。没想到渡边告诉她自己得了不治之症，来日无多，但是见到小田切如此年轻有活力，希望小田切告诉他究竟活着是为了什么。小田切只好战战兢兢的拿出一只玩具<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTg1JTk0" title="https://zh.wikipedia.org/wiki/%E5%85%94">兔<i class="fa fa-external-link"></i></span>子告诉他，她平常在工厂工作就是做这种东西；只要想到自己做出的东西是为别人带来欢乐，自己也就很开心。渡边突然想到自己想要什么了，向小田切道谢后便离开餐厅。此时碰巧有群年轻人替一位少女庆生，众人唱起<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUE1JTlEJUU0JUJEJUEwJUU3JTk0JTlGJUU2JTk3JUE1JUU1JUJGJUFCJUU0JUI5JTkw" title="https://zh.wikipedia.org/wiki/%E7%A5%9D%E4%BD%A0%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90">生日快乐歌<i class="fa fa-external-link"></i></span>，仿佛在庆祝渡边的重生。</p><p>翌日渡边再度回到市公所上班，将他请假这些日子的公文全数拿出来，发觉有件案子是许多妇女前来陈情，希望将某条臭水沟改建为<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTg1JUFDJUU1JTlDJTky" title="https://zh.wikipedia.org/wiki/%E5%85%AC%E5%9C%92">公园<i class="fa fa-external-link"></i></span>，却屡屡遭到各单位互踢皮球不愿处理。他决定要处理这件事，带着下属开始各处奔走。5个月后，渡边过世，在灵堂上大家开始回忆他生命最后5个月的过程，发觉他非常努力奔走以建立公园，最后甚至选择在大<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTlCJUFB" title="https://zh.wikipedia.org/wiki/%E9%9B%AA">雪<i class="fa fa-external-link"></i></span>的夜里独自快乐的唱着歌，死于自己亲手建立的公园里。虽然在守灵的酒会上，大家如此怀念渡边所做的一切，但等到第二天上班时市公所 依就弥漫着官僚之气。尽管有职员看不过去，心中认为应该要继承渡边的精神，但也仅止于缅怀而已。</p><a id="more"></a><h1 id="个人评价"><a href="#个人评价" class="headerlink" title="个人评价"></a>个人评价</h1><p>十分推荐所有人去看的一部电影，虽然剧情大致的走向都能猜到，但是在看完之后绝对不会后悔的电影，顺带一提如果难以忍受电影时长可以多倍速观看，不过看着看着就会自然减速。</p><p>志村乔的演技也确实入木三分，不仅演绎出不知人生目的的活着，在醒悟之后眼神的那种光，以及和儿子的关系疏远，所谓好的演员是电影成功的另一半。</p><p>另外感叹上世纪50年代的电影质量和现在真的没法比，虽然是一部黑白电影，但是这部电影在个人心目中地位不亚于《肖申克的救赎》。</p><h1 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h1><p>黑白片加上2小时的电影时长估计没有多少读者可以坚持下来。</p><p>虽然人物的表情略显夸张，表情也有点用力过度的样子，但是看到主角眼睛都要瞪出来的那种孤独依然为之动容。</p><p>令人讽刺是最后葬礼上小职员虽然高歌要做出改变，然而最后却都按部就班的在体制内做着无用的零件，这样的事情像极了每天都在打鸡血的普通人。</p><p>然而更令人讽刺的是在葬礼上最关系最为紧密的儿子以及陪伴一旁的儿媳却一直沉默，最为亲近的人却成为了距离最遥远的陌生人，只在最后寥寥数语中知道父亲死前竟然为自己处理后事并且把身价财产传给儿子，直到这时才后悔一切无法挽回，然而现今这样的人似乎越来越多，这样的场面也越来越多……</p><p><strong>真切的活着最好的办法是培养利他之心，为他人和社会做出贡献</strong>，这也是为什么主角在听到小田切的感受之后能涅槃重生的根本原因。</p><h1 id="影评摘录"><a href="#影评摘录" class="headerlink" title="影评摘录"></a>影评摘录</h1><p>下面是摘自豆瓣的影评，在个人看来是对这部电影比较中肯的评价了。</p><p>个人心目中黑泽明最杰出的电影，同行朋友评价说“后劲太大”。这种电影，看一部少一部，看到就是赚到。世界没有进步，电影也没有进步，我无法相信一部讲故事的电影，能做的比《生之欲》更好。 说理蕴含在叙事中，因此显得格外通透。每个人都能从电影里看到自己，思考如何抵抗庸俗的生活。</p><p>当你的生命只剩半年，你会怎么做？——这是每个人都听过但无法给出确凿回答的问题。黑泽明不仅提出问题，他还给出了答案，这答案不仅领先于观众（叙事技巧），而且每一层次的回答都是对之前的超越（主题）。 </p><p>从后悔到享乐再到认真生活，最后落在对政府及个人辛辣无情的批判。</p><p>每个人酒后都振臂高呼继承遗志却无一改变，而真正觉醒的人无非也是独木难支、黯然神伤。不是理想主义，而是现实主义。人生的真相就这样向我摊开，印证了心中所想后也难免要陷入深深的失落。</p><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><p>电影原片：<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL2Jhbmd1bWkvcGxheS9lcDMxMTYxNT90aGVtZT1tb3ZpZSZzcG1faWRfZnJvbT0zMzMuNzg4LnJlY29tbWVuZF9tb3JlX3ZpZGVvLjE=" title="https://www.bilibili.com/bangumi/play/ep311615?theme=movie&spm_id_from=333.788.recommend_more_video.1">生之欲正片-电影-高清在线观看<i class="fa fa-external-link"></i></span></p><p>最为感动的部分是 ゴンドラの唄 这首歌。</p><p>个人认为最好的一个剪辑：<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVFzNDExVjdIbi8/c3BtX2lkX2Zyb209MzMzLjc4OC5yZWNvbW1lbmRfbW9yZV92aWRlby4y" title="https://www.bilibili.com/video/BV1Qs411V7Hn/?spm_id_from=333.788.recommend_more_video.2">ゴンドラの唄 - 船歌 - The Gondola Song -志村乔（《生之欲》黑泽明1952）_哔哩哔哩_bilibili<i class="fa fa-external-link"></i></span></p><p>光是曲子都非常好听：<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMUR0NDExRzdtTS8/c3BtX2lkX2Zyb209MzMzLjc4OC5yZWNvbW1lbmRfbW9yZV92aWRlby4x" title="https://www.bilibili.com/video/BV1Dt411G7mM/?spm_id_from=333.788.recommend_more_video.1">【手风琴】《凤尾船之歌》2011 ゴンドラの唄_哔哩哔哩_bilibili<i class="fa fa-external-link"></i></span></p><p>下面是对应的歌词：</p><blockquote><p>生命苦短 恋爱吧！少女！<br>    在朱唇褪色之前，<br>    在热血冷却之前，<br>    明天就没有这样的好时光了。<br>    生命苦短 恋爱吧！少女！<br>    来吧！彼此手牵手 登上他的船，<br>    让他滚烫的面颊贴在你的面庞上，<br>    在这里有谁也追求不到的东西。<br>    生命苦短 恋爱吧！少女！<br>    在你黑发染上白霜之前，<br>    在你心灵的火焰还未熄灭之前，<br>    因为今日是不会再来临的。</p></blockquote><h1 id="剧情摘录"><a href="#剧情摘录" class="headerlink" title="剧情摘录"></a>剧情摘录</h1><p>下面是边看电影边做的一些细节笔记，简单看看即可。</p><ol><li>市民科长不知道为什么而活。</li><li>政府踢皮球，造公园的事情跑了不下十几个部门，市民科长如同木乃伊一般的处理公务。</li><li>被下级戏谑30年不请假记录打破。</li><li>医院的旁人讲述胃癌反应，科长胃癌的反应被旁人看出来惊慌躲避，</li><li>医生说只是轻型胃溃疡，实际上只有不到半年的命。</li><li>儿子想要动用父亲的养老金，父亲听到之后却只是想着活着的意义。</li><li>看着死去妻子的照片，回忆妻子过去。儿子的过去回忆：棒球，割盲肠，儿子被征兵，然而长久的分割父子之间关系疏远。（镜头语言和场景切换都是神来之笔）</li><li>遇到小说家，诉说自己的苦衷。</li><li>小说家带领主角享受人生。</li><li>被人拿了戴了几十年的帽子而换新帽子。（意味着抛弃过去）。</li><li>后悔人生，歌唱：ゴンドラの唄。</li><li>儿子不理解父亲认为父亲的不配合令人失望，父亲也因儿子之间天堑般的隔阂痛苦。</li><li>遇到离职的下属小田切，追随并追问存在的意义。</li><li>陌生人的生日歌为庆祝主角的涅槃重生。</li><li>主角想要解决公园问题，生命却戛然而止。</li><li>利用各种职员的对话，阐述主角光辉事迹。</li><li>振臂高呼改变现状，第二天却又沦入体制，真正觉醒之人看清世界的面貌，然而想要反抗却是独木难支。</li><li>最后公园的一幕，是主角曾经存在最好的证明。</li><li>批判一个人要在一个人死去之后。<br>电影结束。</li></ol><h2 id="时间轴"><a href="#时间轴" class="headerlink" title="时间轴"></a>时间轴</h2><p>26:32 镜头切换，主角后悔这几张画面很有镜头语言的感觉，父亲和儿子之间某种看不见的隔阂。</p><p>38:30 无可奈何的接受现实<br><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205042157854.png" alt=""></p><p>41:56秒 和小说家倾诉自己想要知道如何体验人生，甚至连自己存了大半辈子的钱也不知道怎么花，于是小说家带他尽情享受人生。</p><p>49:24 第一次唱<strong>ゴンドラの唄</strong>，后悔自己如同行尸走肉的活了30年。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041928283.png" alt=""></p><p>忍受胃癌的痛苦却没有目的空洞活着的表情。另外这个动作莫名像是拿破仑。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041948309.png" alt=""></p><p>1小时24分<br>请求小田切告诉主角为什么会如此年轻活力，请教人生的存在意义。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041954734.png" alt=""></p><p>1小时28分<br>饭店陌生人庆祝友人的生日歌代表了主角的涅槃重生。</p><p>1小时32分<br>然而主角涅槃重生的之时，主角生命戛然而止。个人最为惊讶的地方。</p><p>02:05:48 几句名台词：</p><ul><li>我不能憎恨别人，我没有这种时间。</li><li>30年以来我从没见过黄昏，它太美丽了，但是我已经没有这种时间。</li></ul><p>02:16:30 荡秋千，第二次唱<strong>ゴンドラの唄</strong>，和第一次唱不同，这一次主角是认真而活的尽情歌唱，以至于巡逻警官也为止动容。</p><p>最后一幕：<br>真正觉醒的人看着主角建成的公园而感叹，然而现实却依旧如此的残酷。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>人一旦有了目的，大抵只会感叹人生的短暂，就如电影的主角一般，拼尽全力，人的伟大也只活在别人眼中，珍惜现在的每一刻，就是为自己而活。</p><p>19年电影院刷了2，30部电影，然后几乎没怎么看过电影了，感叹曾经美好年代，也感叹时间易逝。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      乘着假期的尾巴看了这一部电影
    
    </summary>
    
    
      <category term="其他" scheme="https://whitestore.top/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="其他" scheme="https://whitestore.top/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>LSM-Tree - LevelDb 源码解析</title>
    <link href="https://whitestore.top/2022/05/21/leveldb-source/"/>
    <id>https://whitestore.top/2022/05/21/leveldb-source/</id>
    <published>2022-05-21T11:13:33.000Z</published>
    <updated>2022-06-02T10:09:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LSM-Tree-LevelDb-源码解析"><a href="#LSM-Tree-LevelDb-源码解析" class="headerlink" title="LSM-Tree - LevelDb 源码解析"></a>LSM-Tree - LevelDb 源码解析</h1><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在上一篇文章[[LSM-Tree - LevelDb了解和实现]]中介绍了LevelDb相关的数据结构和核心组件，LevelDB的核心读写部分，以及为什么在这个数据库中写入的速度要比读取的速度快上好几倍。 </p><p>LevelDB的源代码还是比较好懂的，好懂到我只学过学JAVA只有定点基础C语言入门知识的人也能看懂，另一方面作者在关键的地方都给了注释，甚至告诉你为什么要这么设计<s>（写的很好很棒让人落泪为什么自己没这样的同事）</s>。</p><p>如果还是看不懂，作者也写了很多数据结构介绍的md文档（在doc目录中）告诉你核心组件的作用。</p><p>总之，不要惧怕这个数据库，无论是作为优秀代码和设计模式还是各种主流数据结构算法应用都非常值得学习和参考。</p><blockquote><p>Tip：这一节代码内容非常多，所以不建议在手机或者移动设备阅读，更适合在PC上观看。</p></blockquote><a id="more"></a><h2 id="源码运行"><a href="#源码运行" class="headerlink" title="源码运行"></a>源码运行</h2><p>LevelDB的编译是比较简单的，可以从官网直接克隆代码。</p><p>地址：<span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzJTNBLy9naXRodWIuY29tL2dvb2dsZS9sZXZlbGRi" title="https://link.zhihu.com/?target=https%3A//github.com/google/leveldb">https://github.com/google/leveldb<i class="fa fa-external-link"></i></span></p><p>具体操作步骤如下(也可以参考仓库中的<code>README</code>)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone --recurse-submodules https://github.com/google/leveldb.git</span><br><span class="line">mkdir -p build &amp;&amp; cd build</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Release .. &amp;&amp; cmake --build .</span><br></pre></td></tr></table></figure><p>完成整个编译动作之后，我们可以新增一个动态库，一个静态库和test目录，接着就可以编写单元测试了，同时官方的源代码中有很多的单元测试可以提供自己编写的测试程序进行调试使用，当然这里跳过这些内容，直接从源码开始。</p><h2 id="底层存储存储结构"><a href="#底层存储存储结构" class="headerlink" title="底层存储存储结构"></a>底层存储存储结构</h2><p>关联：[[SSTable]]</p><p>在LevelDB中<strong>SSTable</strong>是整个数据库最重要的结构，所有的SSTable文件本身的内容是<strong>不可修改</strong>的，虽然通常数据在内存中操作，但是数据不可能无限存储，当数据到达一定量之后就需要持久化到磁盘中，而压缩合并的处理就十分考验系统性能了，为此LevelDb使用分层的结构进行存储，下面我们从外部的使用结构开始来了解内部的设计。</p><p>整个外部的黑盒就是数据库本身了，以事务性数据库为例，通常的操作无非就是ACID四种，但是放到LSM-Tree的数据结构有点不一样，因为更新和删除其实都会通过“新增”与“合并”的方式完成新数据对旧数据的覆盖。</p><p>扯远了，我们从简单的概念开始，首先是整个DB的源代码，DB源代码可以通过以下路径访问：</p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9sZXZlbGRiL2Jsb2IvbWFpbi9pbmNsdWRlL2xldmVsZGIvZGIuaA==" title="https://github.com/google/leveldb/blob/main/include/leveldb/db.h">https://github.com/google/leveldb/blob/main/include/leveldb/db.h<i class="fa fa-external-link"></i></span></p><p>首先我们需要了解DB存储结构，可以看到存储引擎的对外提供的接口十分简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LEVELDB_EXPORT</span> <span class="title">DB</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置数据库的key-value结构，如果没有返回OK则视为操作失败，</span></span><br><span class="line"><span class="comment">// 备注：考虑默认打开sync=true操作，`Put` 方法在内部最终会调用 `Write` 方法，只是在上层为调用者提供了两个不同的选择。</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Status <span class="title">Put</span><span class="params">(<span class="keyword">const</span> WriteOptions&amp; options, <span class="keyword">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> Slice&amp; value)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功返回OK，如果异常则不返回OK，如果什么都返回，说明被删除的Key不存在，</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Status <span class="title">Delete</span><span class="params">(<span class="keyword">const</span> WriteOptions&amp; options, <span class="keyword">const</span> Slice&amp; key)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入操作</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Status <span class="title">Write</span><span class="params">(<span class="keyword">const</span> WriteOptions&amp; options, WriteBatch* updates)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据key获取数据</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Status <span class="title">Get</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options, <span class="keyword">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="built_in">std</span>::<span class="built_in">string</span>* value)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Get</code> 和 <code>Put</code> 是 LevelDB 为上层提供的用于读写的接口，注意这个接口的<code>Update</code>和<code>Delele</code>操作 实际上是通过<code>Put</code>完成的，实现方式是内部做了类型判断，十分有意思，这里可以先留意一下。</p><h2 id="write部分"><a href="#write部分" class="headerlink" title="write部分"></a>write部分</h2><p>下面先从写入操作开始，看看数据是如何进入到LevelDb，以及内部是如何管理的。</p><p>Write的内部逻辑算是比较复杂的，所以这里画了下基本流程图：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204171601989.png" alt=""></p><p>我们从DB的<code>Write()</code>接口方法切入，简化代码之后大致的流程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  为写入构建足够的空间，此时可以不需要加锁。</span></span><br><span class="line">Status status = MakeRoomForWrite(updates == <span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">//  通过 `AddRecord` 方法向日志中追加一条写操作的记录；</span></span><br><span class="line">status = log_-&gt;AddRecord(WriteBatchInternal::Contents(write_batch));</span><br><span class="line"><span class="comment">//  如果日志记录成功，则将数据进行写入</span></span><br><span class="line"><span class="keyword">if</span> (status.ok()) &#123;</span><br><span class="line">status = WriteBatchInternal::InsertInto(write_batch, mem_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个执行流程如下：</p><ul><li>首先调用 <code>MakeRoomForWrite</code> 方法为即将进行的写入提供足够的空间。<ul><li>如果当前空间不足需要冻结当前的<code>memtable</code>，此时发生<code>Minor Compaction</code>并创建一个新的 <code>MemTable</code> 对象。</li><li>如果满足触发<code>Major Compaction</code>需要对数据进行压缩并且对于SSTable进行合并。</li></ul></li><li>通过<code>AddRecord</code>方法向日志中追加一条写操作记录。</li><li>最终调用<strong>memtable</strong>往内存结构中添加<strong>key/value</strong>，完成最终写入操作。</li></ul><p>将写入操作的源代码逻辑简化之后最终如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DBImpl::Write</span><span class="params">(<span class="keyword">const</span> WriteOptions&amp; options, WriteBatch* my_batch)</span> </span>&#123;</span><br><span class="line">  <span class="function">Writer <span class="title">w</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  w.batch = my_batch;</span><br><span class="line"></span><br><span class="line">  MakeRoomForWrite(my_batch == <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">uint64_t</span> last_sequence = versions_-&gt;LastSequence();</span><br><span class="line">  Writer* last_writer = &amp;w;</span><br><span class="line">  WriteBatch* updates = BuildBatchGroup(&amp;last_writer);</span><br><span class="line">  WriteBatchInternal::SetSequence(updates, last_sequence + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 记录最终的操作记录点</span></span><br><span class="line">  last_sequence += WriteBatchInternal::Count(updates);</span><br><span class="line"><span class="comment">// 日志编写</span></span><br><span class="line">  log_-&gt;AddRecord(WriteBatchInternal::Contents(updates));</span><br><span class="line"><span class="comment">// 将数据写入memtable</span></span><br><span class="line">  WriteBatchInternal::InsertInto(updates, mem_);</span><br><span class="line"></span><br><span class="line">  versions_-&gt;SetLastSequence(last_sequence);</span><br><span class="line">  <span class="keyword">return</span> Status::OK();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码有较多的方法封装，这里我们一个个来看。</p><p><code>MaybeScheduleCompaction()</code>压缩合并（如果觉得这里突兀可以请参阅上文的流程图）在源码中系统会定时检查是否可以进行压缩合并，if/else用于多线程并发写入的时候进行合并写入的操作，当发现有不同线程在操作就会等待结果或者等到拿到锁之后接管合并写入的操作。</p><blockquote><p>如果对于下面的代码有疑问可以阅读[[LSM-Tree - LevelDb了解和实现]]中关于“合并写入”的部分，为了节省时间，可以在网页中直接输入关键字“<strong>合并写入</strong>”快速定位，这里假设读者已经了解基本的工作流程，就不再赘述了。</p></blockquote><p>#LevelDb合并写入操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::MaybeScheduleCompaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">mutex_.AssertHeld();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (background_compaction_scheduled_) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Already scheduled</span></span><br><span class="line"><span class="comment">// 正在压缩</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DB is being deleted; no more background compactions</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DB正在被删除；不再有后台压缩</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!bg_error_.ok()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Already got an error; no more changes</span></span><br><span class="line"><span class="comment">// 已经发生异常，不能做更多改动。</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm_ == <span class="literal">nullptr</span> &amp;&amp; manual_compaction_ == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line"></span><br><span class="line">!versions_-&gt;NeedsCompaction()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不需要合并则不工作</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 设置当前正常进行压缩合并</span></span><br><span class="line"></span><br><span class="line">background_compaction_scheduled_ = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 开始压缩合并</span></span><br><span class="line"></span><br><span class="line">env_-&gt;Schedule(&amp;DBImpl::BGWork, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>不可变memtable</strong>：</p><p>在write的函数内部有这样一串代码，此时会暂停解锁等待写入，这个写入又是干嘛的？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Status status = MakeRoomForWrite(updates == <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><p>进入方法内部会发现通过一个<code>while</code>循环判断当前的 <code>memtable</code>状态，一旦发现memtable写入已经写满整个<code>mem</code>，则需要停止写入并且将当前的<code>memtable</code>转为<strong>imutiablememtable</strong>，并且创建新的<code>mem</code>切换写入，此时还会同时根据一些条件判断是否可以进行压缩 <code>mem</code>。</p><p>这里额外解释源码中<strong>GUARDED_BY</strong>含义：</p><p>GUARDED_BY是数据成员的属性，该属性声明数据成员受给定功能保护。对数据的读操作需要<strong>共享</strong>访问，而写操作则需要<strong>互斥</strong>访问。</p><p>该 GUARDED_BY属性声明线程必须先锁定<strong>listener_list_mutex</strong>才能对其进行读写listener_list，从而确保增量和减量操作是原子的。</p><p><strong>总结：其实就是一个典型的互斥共享锁，至于实现不是本文的重点。</strong></p><p>mem可以看作是当前的系统备忘录或者说临时的记账板，和大多数的日志或者关系型数据库类似，都是先写入日志在进行后续的所有“事务”操作，也就是<strong>日志优先于记录操作</strong> 原则，根据日志写入操作加锁来完成并发操作的正常运行。</p><p><code>MakeRoomForWrite</code> 方法中比较关键的部分都加了注释，很多操作作者都有介绍意图，代码逻辑都比较简单，多看几遍基本了解大致思路即可。（C++语法看不懂不必过多纠结，明白他要做什么就行，主要是我也看不懂，哈哈）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!bg_error_.ok()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Yield previous error</span></span><br><span class="line"></span><br><span class="line">s = bg_error_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (allow_delay &amp;&amp; versions_-&gt;NumLevelFiles(<span class="number">0</span>) &gt;=</span><br><span class="line"></span><br><span class="line">config::kL0_SlowdownWritesTrigger) &#123;</span><br><span class="line"><span class="comment">// 我们正接近于达到对L0文件数量的硬性限制。L0文件的数量。当我们遇到硬性限制时，与其将单个写操作延迟数而是在我们达到硬限制时，开始将每个mem单独写1ms以减少延迟变化。另外。这个延迟将一些CPU移交给压缩线程，因为 如果它与写入者共享同一个核心的话。</span></span><br><span class="line"></span><br><span class="line">mutex_.Unlock();</span><br><span class="line"></span><br><span class="line">env_-&gt;SleepForMicroseconds(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 不要将一个单一的写入延迟超过一次</span></span><br><span class="line">allow_delay = <span class="literal">false</span>; </span><br><span class="line">mutex_.Lock();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!force &amp;&amp;</span><br><span class="line"></span><br><span class="line">(mem_-&gt;ApproximateMemoryUsage() &lt;= options_.write_buffer_size)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在当前的mem中还有空间</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们已经填满了当前的memtable，但之前的的mem还在写入，所以需要等待</span></span><br><span class="line"></span><br><span class="line">background_work_finished_signal_.Wait();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (versions_-&gt;NumLevelFiles(<span class="number">0</span>) &gt;= </span><br><span class="line">config::kL0_StopWritesTrigger) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">background_work_finished_signal_.Wait();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A试图切换到一个新的memtable并触发对旧memtable的压缩</span></span><br><span class="line">assert(versions_-&gt;PrevLogNumber() == <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 新建文件号</span></span><br><span class="line"><span class="keyword">uint64_t</span> new_log_number = versions_-&gt;NewFileNumber(); <span class="comment">//return next_file_number_++;</span></span><br><span class="line"></span><br><span class="line">WritableFile* lfile = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">// 新建可写入文件, 内部通过一个map构建一个文件：文件状态的简易文件系统</span></span><br><span class="line"><span class="comment">// typedef std::map&lt;std::string, FileState*&gt; FileSystem;</span></span><br><span class="line">s = env_-&gt;NewWritableFile(LogFileName(dbname_, new_log_number), &amp;lfile);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line"><span class="comment">// 避免死循环重复新增文件号</span></span><br><span class="line">versions_-&gt;ReuseFileNumber(new_log_number);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> log_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> logfile_;</span><br><span class="line"></span><br><span class="line">logfile_ = lfile;</span><br><span class="line"></span><br><span class="line">logfile_number_ = new_log_number;</span><br><span class="line"><span class="comment">// 写入日志</span></span><br><span class="line">log_ = <span class="keyword">new</span> <span class="built_in">log</span>::Writer(lfile);</span><br><span class="line"><span class="comment">// **重点：imm_ 就是immutable 他将引用指向当前已经写满的mem，其实和mem对象没什么区别，就是加了一个互斥共享锁而已（写互斥，读共享）**</span></span><br><span class="line">imm_ = mem_;</span><br><span class="line"></span><br><span class="line">has_imm_.store(<span class="literal">true</span>, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line"><span class="comment">// 新建新的memtable</span></span><br><span class="line">mem_ = <span class="keyword">new</span> MemTable(internal_comparator_);</span><br><span class="line"><span class="comment">// 引用至新块</span></span><br><span class="line">mem_-&gt;Ref();</span><br><span class="line"></span><br><span class="line">force = <span class="literal">false</span>; <span class="comment">// Do not force another compaction if have room</span></span><br><span class="line"><span class="comment">// 尝试对于已满mem压缩合并 ，此处承接上文</span></span><br><span class="line">MaybeScheduleCompaction();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面用一个简单的示意图了解上面的大致流程：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204181000328.png" alt=""></p><p>注意这对于[[SSTable]]的原始理论的实现结构显然是有一定出入，当然这是很正常的理论和实践的差别。</p><p>在通常情况下<code>memtable</code>可以通过短暂的延迟读写请求等待压缩完成，但是一旦发现mem占用的内存过大，此时就需要给<strong>当前的mem加锁变为_imu状态</strong>，然后创建一个新的 MemTable 实例并且把<strong>新进来的请求转到新的mem中</strong>，这样就可以继续接受外界的写操作，不再需要等待 <code>Minor Compaction</code> 的结束了。</p><blockquote><p>再次注意此处会通过函数 <strong>MaybeScheduleCompaction</strong> 是否进行压缩合并的操作判断。</p></blockquote><p>这种无等待的设计思路来自于：[[Dynamic-sized NonBlocking Hash table]]，可以自己下下论文来看看，当然也可以等我后面的文章。</p><h2 id="log部分"><a href="#log部分" class="headerlink" title="log部分"></a>log部分</h2><p>写入的大致操作流程了解之后，下面来看看LevelDb的日志管理也就是<code>AddRecord()</code>函数的操作：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204172014056.png" alt=""></p><p>注意日志的核心部分并不在<code>AddRecord()</code>内部，因为内部只有一些简单的字符串拼接操作，这里将核心放到了<code>RecordType</code>的部分，可以看到这里通过当前日志字符长度判断不同的类型，<code>RecordType</code>标识当前记录在块里面的位置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//....</span></span><br><span class="line"><span class="keyword">enum</span> RecordType &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Zero is reserved for preallocated files</span></span><br><span class="line"></span><br><span class="line">kZeroType = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">kFullType = <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// For fragments</span></span><br><span class="line"></span><br><span class="line">kFirstType = <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">kMiddleType = <span class="number">3</span>,</span><br><span class="line"></span><br><span class="line">kLastType = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//....</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RecordType type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">bool</span> <span class="built_in">end</span> = (left == fragment_length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">begin</span> &amp;&amp; <span class="built_in">end</span>) &#123;</span><br><span class="line"></span><br><span class="line">type = kFullType;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">begin</span>) &#123;</span><br><span class="line"></span><br><span class="line">type = kFirstType;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">end</span>) &#123;</span><br><span class="line"></span><br><span class="line">type = kLastType;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">type = kMiddleType;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>First：是用户记录第一个片段的类型，<br>Last：是用户记录的最后一个片段的类型。<br>   Middle：是一个用户记录的所有内部片段的类型。</p></blockquote><p>如果看不懂源代码，可以根据作者的md文档介绍也可以大致了解日志文件结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">record :=</span><br><span class="line">     checksum: uint32     <span class="comment">// crc32c of type and data[] ; little-endian</span></span><br><span class="line">     length: uint16       <span class="comment">// little-endian</span></span><br><span class="line">     type: uint8          <span class="comment">// One of FULL, FIRST, MIDDLE, LAST</span></span><br><span class="line">     data: uint8[length]</span><br></pre></td></tr></table></figure><p>我们可以根据描述简单画一个图：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204171749969.png" alt=""></p><p>从<code>RecordType</code>内部的定义可以看到日志固定为<strong>32KB</strong>大小，在日志文件中将分为多部分，但是一个日志只包含在一个单一的文件块。</p><p>RecordType 存储的内容如下：</p><ul><li>前面4个字节用于CRC校验</li><li>接着两个字节是块数据长度</li><li>接着是一个字节的类型标识（标识当前日志记录在块中位置）</li><li>最后是数据payload部分</li></ul><p><strong>32kb</strong>大小选择是考虑到日志记录行的磁盘对齐和日志读写，针对日志写的速度也非常快，写入的日志先写入内存的文件表，然后通过<code>fdatasync(...)</code>方法将缓冲区<code>fflush</code>到磁盘中并且持久化，最后通过日志完成故障恢复的操作。</p><p>需要注意如果日志记录较大可能存在于多个block块中。</p><p>一个记录永远不会在一个块的最后六个字节内开始，理由是一个记录前面需要一些其他部分占用空间（也就是记录行的校验和数据长度标识信息等）。</p><p>为了防止单个日志块被拆分到多个文件以及压缩考虑，这种“浪费”是可以被接受。</p><p>如果读者非要清楚最后几个字节存储的是什么，想满足自己的好奇心，可以看下面的代码：</p><p><code>dest_-&gt;Append(Slice(&quot;\x00\x00\x00\x00\x00\x00&quot;, leftover));</code></p><p><strong>日志写流程图</strong>：</p><p>日志写的流程比较简单，主要分歧点是当前块剩余空间是否够写入一个header，并且最后6个字节将会填充空格进行补齐。</p><p>在日志写入的过程中通过一个<code>while(ture)</code>不断判断<code>buffer</code>大小，如果大小超过<strong>32KB</strong>-最后6个字节，则需要停止写入并且把开始写入到现在位置为一个数据块。</p><p>下面是日志写流程图：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204171802290.png" alt="日志写流程图"></p><p>下面是日志读流程图：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204171802000.png" alt="日志读流程图"></p><p>既然日志大小为32kb，那么日志的读写单位也应该是32kb，接着便是扫描数据块，在扫描chunk的时候如果发现CRC校验不通过则返回错误信息，如果数据破损则丢弃当前chunk。</p><p>翻了一下代码，简单来说就是读取通过<code>while(true)</code>循环<code>read</code>，直到读取到类型为<code>Last</code>的<code>chunk</code>，日志记录读取完成。</p><p><code>memtable</code>比较有意思的特点是无论插入还是删除都是通过“新增”的方式实现的（你没有看错），内部通过<code>Mainfest</code>维护状态，同时根据版本号和序列号维护一条记录是新增还是删除并且保证读取到的内容是最新值，具体介绍同样在上一节[[LSM-Tree - LevelDb了解和实现]]中。</p><p>注意<strong>写入日志之后记录是不能查询</strong>的（因为中间有可能存在断电故障导致真实记录没有写入），日志仅作为故障恢复，只有<strong>数据写入到mem之后才被访问到</strong>。</p><p>关于mem新增和删除的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemTableInserter</span> :</span> <span class="keyword">public</span> WriteBatch::Handler &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">SequenceNumber sequence_;</span><br><span class="line"></span><br><span class="line">MemTable* mem_;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Put</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">mem_-&gt;Add(sequence_, kTypeValue, key, value);</span><br><span class="line"></span><br><span class="line">sequence_++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">mem_-&gt;Add(sequence_, kTypeDeletion, key, Slice());</span><br><span class="line"></span><br><span class="line">sequence_++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace</span></span><br></pre></td></tr></table></figure><p>在<code>Add()</code>函数的内部通过一个[[LSM-Tree - LevelDb Skiplist跳表]]完成数据的插入，在数据的node中包含了记录键值，为了保证读取的数据永远是最新的，记录需要在<code>skiplist</code>内部进行排序，节点排序使用的是比较常见的比较器<code>Compare</code>，如果用户想要自定义排序（例如处理不同的字符编码等）可以编写自己的比较器实现。</p><p>对于一条记录的结构我们也可以从 <code>Add()</code> 函数中看到作者的注释：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Format of an entry is concatenation of:</span></span><br><span class="line">  <span class="comment">//  key_size     : varint32 of internal_key.size()</span></span><br><span class="line">  <span class="comment">//  key bytes    : char[internal_key.size()]</span></span><br><span class="line">  <span class="comment">//  tag          : uint64((sequence &lt;&lt; 8) | type)</span></span><br><span class="line">  <span class="comment">//  value_size   : varint32 of value.size()</span></span><br><span class="line">  <span class="comment">//  value bytes  : char[value.size()]</span></span><br></pre></td></tr></table></figure><blockquote><p>[[VarInt32编码]]：在这里虽然是变长整型类型但是实际使用4个字节表示。<br><code>uint64((sequence &lt;&lt; 8) | type</code>：位运算之后实际为7个字节的sequence长度<br>注意在tag和value_size中间有一个ValueType标记来标记记录是新增还是删除。</p></blockquote><p>VarInt32 (vary int 32)，即：长度可变的 32 为整型类型。一般来说，int 类型的长度固定为 32 字节。但 VarInt32 类型的数据长度是不固定的，VarInt32 中每个字节的最高位有特殊的含义。如果最高位为 1 代表下一个字节也是该数字的一部分。</p><p>因此，表示一个整型数字最少用 1 个字节，最多用 5 个字节表示。如果某个系统中大部分数字需要 &gt;= 4 字节才能表示，那其实并不适合用 VarInt32 来编码。</p><p>根据<code>get()</code>代码内部通过<code>valueType</code>进行区分，<code>valueType</code>占用一个字节的空间进行判断新增还是删除记录，默认比较器判断新增或者删除记录逻辑如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (comparator_.comparator.user_comparator()-&gt;Compare(</span><br><span class="line"></span><br><span class="line">Slice(key_ptr, key_length - <span class="number">8</span>), key.user_key()) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Correct user key</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint64_t</span> tag = DecodeFixed64(key_ptr + key_length - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (<span class="keyword">static_cast</span>&lt;ValueType&gt;(tag &amp; <span class="number">0xff</span>)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> kTypeValue: &#123;</span><br><span class="line"></span><br><span class="line">Slice v = GetLengthPrefixedSlice(key_ptr + key_length);</span><br><span class="line"></span><br><span class="line">value-&gt;assign(v.data(), v.size());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> kTypeDeletion:</span><br><span class="line"></span><br><span class="line">*s = Status::NotFound(Slice());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据代码定义和上面的描述画出下面的结构图：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204171916505.png" alt=""></p><p><strong>Compare键排序</strong></p><p>LevelDb的memtable通过跳表维护了键，内部默认情况下通过<code>InternalKeyComparator</code>对于键进行比较，下面是比较内部逻辑：</p><p>比较器通过 <code>user_key</code> 和 <code>sequence_number</code> 进行排序，同时按照user_key进行升序排序，<strong>序列号通过插入的时间递增</strong>，以此来保证无论是增加还是删除都是获取到最新的信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 一个用于内部键的比较器，它使用一个指定的比较器用于用户键部分比较，并通过递减序列号来打破平衡。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InternalKeyComparator::Compare</span><span class="params">(<span class="keyword">const</span> Slice&amp; akey, <span class="keyword">const</span> Slice&amp; bkey)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Order by:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加用户密钥（根据用户提供的比较器）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递减序列号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递减类型（尽管序列号应该足以消除歧义）。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> r = user_comparator_-&gt;Compare(ExtractUserKey(akey), ExtractUserKey(bkey));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint64_t</span> anum = DecodeFixed64(akey.data() + akey.size() - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint64_t</span> bnum = DecodeFixed64(bkey.data() + bkey.size() - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (anum &gt; bnum) &#123;</span><br><span class="line"></span><br><span class="line">r = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (anum &lt; bnum) &#123;</span><br><span class="line"></span><br><span class="line">r = +<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意被比较key<strong>可能包含完全不同的内容</strong>，这里读者肯定会有疑问对于key获取值进行提取信息是否会有影响，然而从get的逻辑来看它可以通过键长度，和序列号等信息进行获取Key，并且获取是<strong>header的头部信息</strong>，所以key是任何类型都是没有影响的。</p><p><strong>记录查询</strong></p><p>现在我们再回过头来看一下<code>memtable</code>是如何读取的，从<code>memtable</code>和<code>imumemble</code>的关系可以看出有点类似<strong>缓存</strong>，当<code>memtable</code>写满之后转为<code>imumem</code>并且等待同步至磁盘。</p><p>key读取和查找的顺序如下：</p><ul><li>在memtable中获取指定Key，如果数据符合条件则结束查找。</li><li>在Imumemtable中查找指定Key，如果数据符合条件则结束查找。</li><li>按低层至高层的顺序在level i层的sstable文件中查找指定的key，若搜索到符合条件的数据项就会结束查找，否则返回Not Found错误，表示数据库中不存在指定的数据。</li></ul><p>记录按照层级关系进行搜索，首先是从当前内存中正在写入<code>memtable</code>搜索，接着是<code>imumemtable</code>，再接着是存在于磁盘不同层级的<code>SSTable</code>，SSTable通过<code>*.ldb</code>的形式进行标记，可以快速找到。</p><p>最终我们可以把LevelDb的查询看作下面的形式：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204172111973.png" alt=""></p><p><strong>小结</strong>：</p><p>这一部分我们了解了LevelDB源代码部分等基础结构DB，介绍了LevelDB的基础对外接口，LevelDB和map的接口看起来十分类似，这一部分重点讲述了读写操作等源代码，以及内部合并压缩的一些细节。</p><p>另外记录查询等动作和之前介绍LevelDB等读写流程大致类似，当然代码简化了很多的内容，读者可以根据自己感兴趣的内容研究。</p><h2 id="SSTable操作"><a href="#SSTable操作" class="headerlink" title="SSTable操作"></a>SSTable操作</h2><p>前面我们提到了记录的增删改查底层查询，和日志的读写细节，下面则针对谷歌发明的特殊数据结构<code>SSTable</code>进行介绍。</p><p><strong>SSTable如何工作？</strong></p><p><code>SSTable</code>在初始的论文中可以总结出下面的特点：</p><ul><li>写入的时候不写入磁盘而是先写入内存表的数据结构。</li><li>当数据结构内存占用超过一定的阈值就可以直接写入到磁盘文件由于已经是排好序的状态，所以可以直接对旧结构覆盖，写入效率比较高。并且写入和数据结构改动可以同时进行。</li><li>读写顺序按照 内存 - 磁盘 - 上一次写入文件 - 未找到。</li><li>后台定时线程定时合并和压缩排序分段，将废弃值给覆盖或者丢弃。</li></ul><p>[[SSTable]] 最早出现在谷歌2006年的论文当中，LevelDB的SSTable设计也有部分特性体现这个数据结构，当然并不是完全一致的，LevelDB利用SSTable在磁盘中维护多层级的数据节点。</p><p>可以认为了解SSTable结构就相当于了解了LevelDb的核心数据结构设计。</p><p><strong>多层级SSTable</strong></p><p>我们重点看看多层级的SSTable部分，levelDB在磁盘中扫描SSTable的时候LevelDB并不会跳过层级，这里肯定会有疑问每个层级都扫一遍的效率问题，针对这个问题作者在db中设计了下面的数据结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FileMetaData</span> &#123;</span></span><br><span class="line"></span><br><span class="line">FileMetaData() : refs(<span class="number">0</span>), allowed_seeks(<span class="number">1</span> &lt;&lt; <span class="number">30</span>), file_size(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">int</span> refs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> allowed_seeks; <span class="comment">// 允许压缩搜索</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> number;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> file_size; <span class="comment">// 文件大小</span></span><br><span class="line"></span><br><span class="line">InternalKey smallest; <span class="comment">// 表提供的最小内部密钥</span></span><br><span class="line"></span><br><span class="line">InternalKey largest; <span class="comment">// 表提供最大内部密钥</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上面的结构体声明中定义了压缩SSTable文件的全部信息，包括最大值和最小值，运行查找次数，文件引用次数和文件号，SSTable会按照固定的形式存储到同一个目录下面，所以可以通过文件号进行快速搜索。</p><p>查找和记录key顺序类似，都是按照<strong>从小到大</strong>的顺序进行读取的，以Level0为例，里面通常包含<strong>4个固定的SSTable</strong>，并且内部通常存在key交叉，所以会按照从SSTable1-4的顺序进行读取，而更高层次的层级则通过查找上面结构体的最大值和最小值的信息（smallest和largest）。</p><p>具体的文件搜索细节可以通过<code>TableCache::FindTable</code>查找 ，由于篇幅有限这里就不贴代码了，简要逻辑是配合缓存和<code>RandomAccessFile</code>对于文件进行读写，然后把读到的文件信息写入到内存中方便下次获取。</p><blockquote><p>如果了解Mysql Btree设计会发现文件搜索有些类似页目录的查找。不同的是Btree页目录通过页目录等稀疏搜索。</p></blockquote><p><strong>SSTable合并</strong></p><p>我们再来看看SSTable是如何合并的，之前提到过SSTable通过<strong>MaybeScheduleCompaction</strong>尝试合并，需要注意这个合并压缩和Bigtable的形式类似，都是根据不同的条件判断是否进行合并，一旦可以合并便执行<code>BackgroundCompaction</code>操作。</p><p>合并分为两种情况，一种是<strong>Minor Compaction</strong>，另一种是将<strong>Memtable</strong>数据写满转为不可变对象（实际就是加锁），执行<code>CompactMemtable</code>进行压缩。</p><p>合并操作简化版源代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::CompactMemTable</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">VersionEdit edit;</span><br><span class="line">Version* base = versions_-&gt;current();</span><br><span class="line">WriteLevel0Table(imm_, &amp;edit, base);</span><br><span class="line">versions_-&gt;LogAndApply(&amp;edit, &amp;mutex_);</span><br><span class="line">RemoveObsoleteFiles();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CompactMemTable方法会先构建当前的修改版本号，然后调用<code>WriteLevel0Table()</code>方法尝试把当前的Imumtable写入到Level0的层级。<br>如果发现Level0的层级SSTable过多，则进一步进行<strong>Major Compaction</strong>，同时根据<code>BackgroudCompcation()</code>选择合适的压缩层级和压缩方式。</p><p>下面是<code>writeLevel0</code>的简化代码：</p><p>简化代码的最后几行代码会获取文件信息的最大值和最小值以此判断是否在当前SSTable搜索还是跳转到下一个。</p><p>数据如果是写入Level0我们可以看作是<strong>Major Compaction</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::WriteLevel0Table</span><span class="params">(MemTable* mem, VersionEdit* edit,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">Version* base)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SSTable文件信息</span></span><br><span class="line">FileMetaData meta;</span><br><span class="line"></span><br><span class="line">meta.number = versions_-&gt;NewFileNumber();</span><br><span class="line"></span><br><span class="line">pending_outputs_.insert(meta.number);</span><br><span class="line"></span><br><span class="line">Iterator* iter = mem-&gt;NewIterator();</span><br><span class="line"><span class="comment">// 构建SSTable文件</span></span><br><span class="line">BuildTable(dbname_, env_, options_, table_cache_, iter, &amp;meta);</span><br><span class="line"></span><br><span class="line">pending_outputs_.erase(meta.number);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，如果 file_size 为零，则该文件已被删除，并且不应被添加到清单中。</span></span><br><span class="line"><span class="comment">// 获取文件信息的最大值和最小值</span></span><br><span class="line"><span class="keyword">const</span> Slice min_user_key = meta.smallest.user_key();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Slice max_user_key = meta.largest.user_key();</span><br><span class="line"><span class="comment">// level层级扫描</span></span><br><span class="line">base-&gt;PickLevelForMemTableOutput(min_user_key, max_user_key);</span><br><span class="line"><span class="comment">// 写入文件</span></span><br><span class="line">edit-&gt;AddFile(level, meta.number, meta.file_size, meta.smallest,</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Status::ok();</span><br></pre></td></tr></table></figure><p>结合上下两段源码可以发现文件管理最终是通过<code>VersionEdit</code>来完成的，如果写入成功了则返回当前的SSTable的<code>FileMetaData</code>，在<code>VersionEdit</code>内部通过<code>logAndApply</code>的方式记录文件内部的变化，也就是前文介绍的日志管理功能了，完成之后通过<code>RemoveObsoleteFiles()</code>方法进行数据的清理操作。</p><p>如果<code>Level0</code>写满了此时就需要进行<strong>Major Compaction</strong>，这个压缩会比前面的要复杂一些因为涉及低层级到高层级的压缩。</p><p>这里需要再回看<code>BackgroundCompaction</code>的代码，具体代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::BackgroundCompaction</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"><span class="comment">// 如果存在不可变imumem,进行压缩合并</span></span><br><span class="line">CompactMemTable();</span><br><span class="line">  </span><br><span class="line">versions_-&gt;PickCompaction();</span><br><span class="line"></span><br><span class="line">VersionSet::LevelSummaryStorage tmp;</span><br><span class="line"></span><br><span class="line">CompactionState* compact = <span class="keyword">new</span> CompactionState(c);</span><br><span class="line"></span><br><span class="line">DoCompactionWork(compact);</span><br><span class="line"></span><br><span class="line">CleanupCompaction(compact);</span><br><span class="line"></span><br><span class="line">c-&gt;ReleaseInputs();</span><br><span class="line"></span><br><span class="line">RemoveObsoleteFiles();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先根据<code>VersionSet</code> 查找需要压缩的信息，并且打包加入到 <strong>Compaction</strong> 对象，这个对象根据查询次数和大小限制来选择需要压缩的<strong>两个层级</strong>，因为level0中包含很多重叠键，则会在更高层级找到有重叠的键的SSTable，再通过<code>FileMetaData</code>找到需要压缩的文件，另外查询频繁的SSTable将会“升级”到更高层级进行压缩存储，并且更新文件信息方便下一次查找。</p><p><strong>合并的触发条件</strong></p><p>每个 SSTable 在创建之后的 <code>allowed_seeks</code> 都为 100 次，当 <code>allowed_seeks &lt; 0</code> 时就会触发该文件的与更高层级和合并，因为频繁查询的数据通常会降低系统性能。</p><p>这样的设计理由是<strong>在高层级搜索键说明在上一层肯定是相同的键查找</strong>，同时也是为了减少每次都覆盖扫描多层级扫描寻找数据。最终这种设计方式核心是以更新<strong>FileMetaData</strong> 来减少下一次查询的性能开销。</p><p>另外这种处理可以简单理解为我们在操作系统中进行深层次文件夹搜索的时候，如果频繁查询某个深层次的数据很麻烦，解决此问题的第一种方式是建立一个“快捷方式”的文件夹，另一种是直接做标签直接指向这个目录，其实两者都是差不多的，所以压缩设计也是同理。</p><p>LevelDB 中的 <code>DoCompactionWork</code> 方法会对所有传入的 SSTable 中的键值使用<strong>归并排序</strong>进行合并，最后会在更高层级中生成一个新的 SSTable。</p><blockquote><p>归并排序主要是对于key进行归并，使得迭代的时候key就是有序的可以直接合并到指定的高高层级。关键代码存在于下面的代码<br><code>Iterator* input = versions_-&gt;MakeInputIterator(compact-&gt;compaction);</code></p></blockquote><p><strong>归并排序</strong></p><p><strong>DoCompactionWork</strong> 归并排序 的源代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::DoCompactionWork</span><span class="params">(CompactionState* compact)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int64_t</span> imm_micros = <span class="number">0</span>; <span class="comment">// Micros spent doing imm_ compactions</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (snapshots_.empty()) &#123;</span><br><span class="line"><span class="comment">// 快照为空，找到直接采用记录信息的最后序列号</span></span><br><span class="line"></span><br><span class="line">compact-&gt;smallest_snapshot = versions_-&gt;LastSequence();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 快照存在，则抛弃之前所有的序列</span></span><br><span class="line">compact-&gt;smallest_snapshot = snapshots_.oldest()-&gt;sequence_number();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 对于待压缩数据进行，内部生成一个MergingIterator，当构建迭代器之后键内部就是有序的状态了，也就是前面说的归并排序的部分</span></span><br><span class="line">Iterator* input = versions_-&gt;MakeInputIterator(compact-&gt;compaction);</span><br><span class="line"></span><br><span class="line">input-&gt;SeekToFirst();</span><br><span class="line"></span><br><span class="line">Status status;</span><br><span class="line"></span><br><span class="line">ParsedInternalKey ikey;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> current_user_key;</span><br><span class="line"><span class="comment">//当前记录user key</span></span><br><span class="line"><span class="keyword">bool</span> has_current_user_key = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">SequenceNumber last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (input-&gt;Valid() &amp;&amp; !shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优先考虑imumemtable的压缩工作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (has_imm_.load(<span class="built_in">std</span>::memory_order_relaxed)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint64_t</span> imm_start = env_-&gt;NowMicros();</span><br><span class="line"></span><br><span class="line">imm_micros += (env_-&gt;NowMicros() - imm_start);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Slice key = input-&gt;key();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (compact-&gt;compaction-&gt;ShouldStopBefore(key) &amp;&amp;</span><br><span class="line"></span><br><span class="line">compact-&gt;builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line"></span><br><span class="line">status = FinishCompactionOutputFile(compact, input);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理键/值，添加到状态等。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> drop = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ParseInternalKey(key, &amp;ikey)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除和隐藏呗删除key</span></span><br><span class="line"></span><br><span class="line">current_user_key.clear();</span><br><span class="line"></span><br><span class="line">has_current_user_key = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 更新序列号</span></span><br><span class="line">last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!has_current_user_key ||</span><br><span class="line"></span><br><span class="line">user_comparator()-&gt;Compare(ikey.user_key, Slice(current_user_key)) !=</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户key第一次出现</span></span><br><span class="line"></span><br><span class="line">current_user_key.assign(ikey.user_key.data(), ikey.user_key.size());</span><br><span class="line"></span><br><span class="line">has_current_user_key = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (last_sequence_for_key &lt;= compact-&gt;smallest_snapshot) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩以后旧key边界的被新的覆盖</span></span><br><span class="line"></span><br><span class="line">drop = <span class="literal">true</span>; <span class="comment">// (A)</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ikey.type == kTypeDeletion &amp;&amp;</span><br><span class="line"></span><br><span class="line">ikey.sequence &lt;= compact-&gt;smallest_snapshot &amp;&amp;</span><br><span class="line"></span><br><span class="line">compact-&gt;compaction-&gt;IsBaseLevelForKey(ikey.user_key)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于这个用户密钥：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (1) 高层没有数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (2) 较低层的数据会有较大的序列号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (3) 层中的数据在此处被压缩并具有</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 较小的序列号将在下一个被丢弃</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个循环的几次迭代（根据上面的规则（A））。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因此，此删除标记已过时，可以删除。</span></span><br><span class="line"></span><br><span class="line">drop = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">last_sequence_for_key = ikey.sequence;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>归并排序并且处理完键值信息完成跨层级压缩，之后便是是一些收尾工作，收尾工作需要对于压缩之后的信息统计。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">CompactionStats stats;</span><br><span class="line"></span><br><span class="line">stats.micros = env_-&gt;NowMicros() - start_micros - imm_micros;</span><br><span class="line"><span class="comment">//选择两个层级的SSTable</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> which = <span class="number">0</span>; which &lt; <span class="number">2</span>; which++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; compact-&gt;compaction-&gt;num_input_files(which); i++) &#123;</span><br><span class="line"></span><br><span class="line">stats.bytes_read += compact-&gt;compaction-&gt;input(which, i)-&gt;file_size;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; compact-&gt;outputs.size(); i++) &#123;</span><br><span class="line"></span><br><span class="line">stats.bytes_written += compact-&gt;outputs[i].file_size;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 压缩到更高的层级</span></span><br><span class="line">stats_[compact-&gt;compaction-&gt;level() + <span class="number">1</span>].Add(stats);</span><br><span class="line"><span class="comment">// 注册压缩结果</span></span><br><span class="line">InstallCompactionResults(compact);</span><br><span class="line"><span class="comment">// 压缩信息存储</span></span><br><span class="line">VersionSet::LevelSummaryStorage tmp;</span><br><span class="line">Log(options_.info_log, <span class="string">"compacted to: %s"</span>, versions_-&gt;LevelSummary(&amp;tmp));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> status;</span><br></pre></td></tr></table></figure><p>最后层级压缩的默认层级为<strong>7个层级</strong>，在源代码中有如下定义：</p><p><code>static const int kNumLevels = 7;</code></p><p><strong>小结</strong></p><p>这里我们小结一下合并压缩的两个操作：<code>Minor Compaction</code>和<code>Major Compaction</code>：</p><p><code>Minor Compaction</code>：这个GC主要是Level0层级的一些压缩操作，由于Level0层级被较为频繁使用，类似一级缓存，键值不会强制要求进行排序，所以重叠的键会比较多，整个压缩的过程比较好理解，关键部分是skiplist（跳表）中构建一个新的SSTable并且插入到指定层级。</p><p>注：<code>Minor Compaction</code>进行的时候会暂停<code>Major Compaction</code>操作。</p><p><strong>Minor Compaction</strong>：这个比Minor Compaction复杂不少，不仅包含跨层级压缩，还包括键范围确定和迭代器归并排序和最终的统计信息操作，其中最最关键的部分是归并排序压缩列表，之后将旧文件和新文件合并生产新的<code>VersionSet</code>信息，另外这里除开全局的压缩进度和管理操作之外。</p><p>另外Minor Compaction完成之后还会再尝试一次Minor Compaction，因为Minor Compaction可能带来更多的重复键，所以再进行一次压缩可以进一步提高查找效率。</p><p><strong>Major Compaction</strong>：这个操作需要暂停整个LevelDB的读写，因为此时需要对于整个LevelDb的多层级进行跨层级合并，跨层级压缩要复杂很多，具体的细节会在后面介绍。</p><blockquote><p>这里可以认为是作者在测试的过程发现一种情况并且做的优化。</p></blockquote><p><strong>存储状态 - VersionSet</strong></p><p>从这个对象名称来看直接理解为“版本集合”，在内部通过一个Version的结构体对于键值信息进行“版本控制”，毫无疑问这是由于多线程压缩所带来的特性，所以最终是一个双向链表+历史版本的形式串联，但是永远只有一个版本是当前版本。<br>VersionSet最为频繁也是比较关键的一个操作函数<code>LogAndApply</code>，下面是简化之后的<code>VersionSet::LogAndApply</code>代码：</p><blockquote><p>这里可以对照关系型数据库Mysql的Mvcc中的undo log类比进行理解</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">VersionSet::LogAndApply</span><span class="params">(VersionEdit* edit, port::Mutex* mu)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 更新版本链表信息</span></span><br><span class="line"><span class="keyword">if</span> (!edit-&gt;has_prev_log_number_) &#123;</span><br><span class="line"></span><br><span class="line">edit-&gt;SetPrevLogNumber(prev_log_number_);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">edit-&gt;SetNextFile(next_file_number_);</span><br><span class="line"></span><br><span class="line">edit-&gt;SetLastSequence(last_sequence_);</span><br><span class="line"></span><br><span class="line">Version* v = <span class="keyword">new</span> Version(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">// 构建当前的版本version，委托给建造器进行构建</span></span><br><span class="line"><span class="function">Builder <span class="title">builder</span><span class="params">(<span class="keyword">this</span>, current_)</span></span>;</span><br><span class="line"></span><br><span class="line">builder.Apply(edit);</span><br><span class="line"></span><br><span class="line">builder.SaveTo(v);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键方法：内部通过打分机制确定文件所在的层级，值得注意的是level0的层级确定在源代码中有较多描述</span></span><br><span class="line">Finalize(v);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如有必要，通过创建包含当前版本快照的临时文件来初始化新的描述符日志文件。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> new_manifest_file;</span><br><span class="line"><span class="comment">//  没有理由在这里解锁*mu，因为我们只在第一次调用LogAndApply时（打开数据库时）碰到这个路径。</span></span><br><span class="line">new_manifest_file = DescriptorFileName(dbname_, manifest_file_number_);</span><br><span class="line"><span class="comment">// 写入mainfest文件</span></span><br><span class="line">env_-&gt;NewWritableFile(new_manifest_file, &amp;descriptor_file_);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入版本信息快照</span></span><br><span class="line">WriteSnapshot(descriptor_log_);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把记录写到 MANIFEST中</span></span><br><span class="line"></span><br><span class="line">descriptor_log_-&gt;AddRecord(record);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果创建了新的文件，则将当前版本指向这个文件</span></span><br><span class="line"></span><br><span class="line">SetCurrentFile(env_, dbname_, manifest_file_number_);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册新版本</span></span><br><span class="line"></span><br><span class="line">AppendVersion(v);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Status::OK();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键部分注释已给出，这里的<strong>Mainfest</strong>细节在之前没有提到过，在作者提供的<code>impl.md</code>是这样介绍mainfest的：</p><blockquote><p>MANIFEST 文件列出了组成每个级别的排序表集、相应的键范围和其他重要的元数据。 每当重新打开数据库时，都会创建一个新的 MANIFEST 文件（文件名中嵌入了一个新编号）。 MANIFEST 文件被格式化为日志，并且对服务状态所做的更改（随着文件的添加或删除）被附加到此日志中。</p></blockquote><p>从个人的角度来看，这个文件有点类似BigTable中的元数据<code>Meta</code>。</p><p><strong>SSTable文件格式</strong></p><p>理解这部分不需要急着看源代码，在仓库中的<code>table_format.md</code>的文件中同样有相关描述，这里就直接照搬官方文档翻译了：</p><blockquote><p>leveldb 文件格式<br><beginning_of_file><br>[数据块 1]<br>[数据块 2]<br>…<br>[数据块N]<br>[元块 1]<br>…<br>[元块K]<br>[元索引块]<br>[索引块]<br>[页脚]（固定大小；从 file_size - sizeof(Footer) 开始）<br><end_of_file></p></blockquote><p>我们可以根据描述画一个对应的结构图：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204172242656.png" alt=""></p><p>上面的结构图从上至下的介绍如下：</p><ul><li>数据块：按照LSM-Tree的数据存储规范，按照key/value的顺序形式进行排序，数据块根据<code>block.builder.cc</code>的内部逻辑进行格式化，并且可以选择是否压缩存储。</li><li>元数据块：元数据块和数据块类似也使用<code>block.builder.cc</code>进行格式化，同时可选是否压缩，元数据块后续扩展更多的类型（主要用作数据类型记录）</li><li>“元索引”块：为每个其他元数据块索引，键为元块的名称，值为指向该元块的 BlockHandle。</li><li>“索引块”：包含数据块的索引，键是对应<strong>字符串&gt;=数据块的最后一个键</strong>，并且在连续的数据块的第一个键之前，值是 数据块的 BlockHandle。</li><li>文件的最后是一个固定长度的页脚，其中包含元索引和索引块的 BlockHandle 以及一个<strong>幻数</strong>。</li></ul><blockquote><p>幻数又被称为魔数，比如JAVA的字节码第一个字节8位是<code>CAFEBABE</code>，数值和字节大小没什么意义，更多是作者的兴趣。</p></blockquote><p>注意Footer页脚固定48个字节的大小，我们能在其中拿到 <strong>元索引块</strong> 和 <strong>索引块</strong>的位置，然后通过这两个索引寻找其他值对应的位置。</p><p>更详细的内容可以继续参考<code>table_format.md</code>介绍，这里就不再赘述了。</p><p><strong>TableBuilder</strong>：</p><p>SSTable接口定义于一个<code>TableBuilder</code>构建器当中，<strong>TableBuilder</strong> 提供了用于构建 Table 的接口，关于此接口的定义如下：</p><p>TableBuilder提供了用于建立表的接口  (一个从键到值的不可变和排序的映射)。</p><p>多个线程可以在一个TableBuilder上调用const方法而不需要外部同步。但如果任何一个线程可能调用一个非常量方法，所有访问同一个TableBuilder的线程必须使用外部同步。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TableBuilder 提供了用于构建 Table 的接口</span></span><br><span class="line"><span class="comment">//（从键到值的不可变且排序的映射）。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 多个线程可以在 TableBuilder 上调用 const 方法，而无需</span></span><br><span class="line"><span class="comment">// 外部同步，但如果任何线程可能调用</span></span><br><span class="line"><span class="comment">// 非常量方法，所有访问同一个 TableBuilder 的线程都必须使用</span></span><br><span class="line"><span class="comment">// 外部同步。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LEVELDB_EXPORT</span> <span class="title">TableBuilder</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">TableBuilder(<span class="keyword">const</span> Options&amp; options, WritableFile* file);</span><br><span class="line"></span><br><span class="line">TableBuilder(<span class="keyword">const</span> TableBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">TableBuilder&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> TableBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">改变该构建器所使用的选项。注意：只有部分的</span></span><br><span class="line"><span class="comment">选项字段可以在构建后改变。如果一个字段是</span></span><br><span class="line"><span class="comment">不允许动态变化，并且其在结构中的值</span></span><br><span class="line"><span class="comment">中的值与传递给本方法的结构中的值不同。</span></span><br><span class="line"><span class="comment">结构中的值不同，该方法将返回一个错误</span></span><br><span class="line"><span class="comment">而不改变任何字段。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Status <span class="title">ChangeOptions</span><span class="params">(<span class="keyword">const</span> Options&amp; options)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Flush</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">status</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Finish</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">表示应该放弃这个建设者的内容。停止</span></span><br><span class="line"><span class="comment">在此函数返回后停止使用传递给构造函数的文件。</span></span><br><span class="line"><span class="comment">如果调用者不打算调用Finish()，它必须在销毁此构建器之前调用Abandon()</span></span><br><span class="line"><span class="comment">之前调用Abandon()。</span></span><br><span class="line"><span class="comment">需要。Finish()、Abandon()未被调用。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Abandon</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">NumEntries</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">FileSize</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ok</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> status().ok(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WriteBlock</span><span class="params">(BlockBuilder* block, BlockHandle* handle)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WriteRawBlock</span><span class="params">(<span class="keyword">const</span> Slice&amp; data, CompressionType, BlockHandle* handle)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rep</span>;</span></span><br><span class="line"></span><br><span class="line">Rep* rep_;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>小结</strong>：</p><p>SSTable 相关的设计在整个LevelDB中有着重要的地位和作用，我们介绍了SSTable的多层级合并和压缩的细节，以及两种不同的压缩形式，第一种是针对Level0的简单压缩，简单压缩只需要把存在于内存中的SSTable也就是将Imumemtable压缩到磁盘中存储，特别注意的是这个动作在第一次完成之后通常还会再执行一次，目的是为了防止合并之后产生的。</p><p>另一种是针对频繁Key查询进行的多层级压缩，多层级压缩要比简单压缩复杂许多，但是多层级压缩是提高整个LevelDB写入性能和查询性能到关键。</p><p>最后，从LevelDB中也可以看到很多经典数据结构和算法的实现，比键管理利用了跳表+归并排序的方式提高管理效率，排序的内容不仅利于查询，在存储的时候也有利于数据的顺序扫描。</p><h2 id="Skiplist跳表"><a href="#Skiplist跳表" class="headerlink" title="Skiplist跳表"></a>Skiplist跳表</h2><p>跳表不仅在LevelDb中使用，还在许多其他的中间件中存在实现，这一部分内容将会放到下一篇文章单独介绍。</p><p>压缩文件使用了归并排序的方式进行键合并，而内部的数据库除了归并排序之外还使用了比较关键的[[LSM-Tree - LevelDb Skiplist跳表]]来进行有序键值管理，在了解LevelDB跳表的细节之前，需要先了解跳表这个数据结构的基本概念。</p><p>[[LevelDb跳表实现]]</p><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>Bloom Filter是一种空间效率很高的随机数据结构，它利用位数组很简洁地表示一个集合，并能判断一个元素是否属于这个集合。Bloom Filter的这种高效是有一定代价的：在判断一个元素是否属于某个集合时，有可能会把不属于这个集合的元素误认为属于这个集合（false positive）。因此，Bloom Filter不适合那些“零错误”的应用场合。而在能容忍低错误率的应用场合下，Bloom Filter通过极少的错误换取了存储空间的极大节省。</p><p>leveldb中利用布隆过滤器判断指定的key值是否存在于sstable中，若过滤器表示不存在，则该key一定不存在，由此加快了查找的效率。</p><p>布隆过滤器在不同的开源组件中用的也比较多，所以这里同样放到了一篇单独文章讲解。</p><p>[[LSM-Tree - LevelDb布隆过滤器]]</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>LevelDB的设计还是很有意思的，关键是大部分的代码都有解释和介绍。</p><p>源代码内容很多，但是仔细分析的话不难分析，感谢看到最后。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sZXZlbGRiLWhhbmRib29rLnJlYWR0aGVkb2NzLmlvL3poL2xhdGVzdC9pbmRleC5odG1s" title="https://leveldb-handbook.readthedocs.io/zh/latest/index.html">leveldb-handbook<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kcmF2ZW5lc3MubWUvYmlndGFibGUtbGV2ZWxkYi8=" title="https://draveness.me/bigtable-leveldb/">bigtable-leveldb<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC85ZDgyOTY1NjI4MDY=" title="https://www.jianshu.com/p/9d8296562806">Skip List–跳表（全网最详细的跳表文章没有之一） - 简书 (jianshu.com)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppYW9tZW5nL2FydGljbGUvZGV0YWlscy8xNDk1NTAw" title="https://blog.csdn.net/jiaomeng/article/details/1495500"># Bloom Filter概念和原理<i class="fa fa-external-link"></i></span></li></ul><h1 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h1><ul><li><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDA0MTcyMDIwNQ==" title="https://segmentfault.com/a/1190000041720205">LSM-Tree - LevelDb了解和实现<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDA0MTY1MjAwMw==" title="https://segmentfault.com/a/1190000041652003">《数据密集型型系统设计》LSM-Tree VS BTree<i class="fa fa-external-link"></i></span></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      源码解析
    
    </summary>
    
    
      <category term="数据库-LevelDB" scheme="https://whitestore.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-LevelDB/"/>
    
    
      <category term="数据库" scheme="https://whitestore.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>LSM-Tree - LevelDb Skiplist跳表</title>
    <link href="https://whitestore.top/2022/05/21/level-skiplist/"/>
    <id>https://whitestore.top/2022/05/21/level-skiplist/</id>
    <published>2022-05-21T11:10:02.000Z</published>
    <updated>2022-09-08T02:18:34.395Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LSM-Tree-LevelDb-Skiplist跳表"><a href="#LSM-Tree-LevelDb-Skiplist跳表" class="headerlink" title="LSM-Tree - LevelDb Skiplist跳表"></a>LSM-Tree - LevelDb Skiplist跳表</h1><h1 id="跳表介绍"><a href="#跳表介绍" class="headerlink" title="跳表介绍"></a>跳表介绍</h1><p>跳表（SkipList）是由William Pugh提出的。他在论文<Skip lists: a probabilistic alternative to balanced trees>中详细地介绍了有关跳表结构、插入删除操作的细节。</p><blockquote><p>文档：Skiplist跳表原始论文 - pugh-skiplists-cacm1990.pdf<br>链接：<span class="exturl" data-url="aHR0cDovL25vdGUueW91ZGFvLmNvbS9ub3Rlc2hhcmU/aWQ9NjY3YWVkOTZmMDEyZWRjYWRhMDQ3YmFmNzVhYTE3NjkmYW1wO3N1Yj1CNDI3RTAwQzgxOEI0MjhBQkQzOEE4MTMxODBBRjlBOA==" title="http://note.youdao.com/noteshare?id=667aed96f012edcada047baf75aa1769&amp;sub=B427E00C818B428ABD38A813180AF9A8">http://note.youdao.com/noteshare?id=667aed96f012edcada047baf75aa1769&amp;sub=B427E00C818B428ABD38A813180AF9A8<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在线性的数据数据结构中我们经常可以想到数组和链表，数组是插入慢查询快，而链表是插入快，查询要稍微慢一些，而跳表主要是针对链表<strong>查询速度</strong>进行优化的一种数据结构，多层级的跳表实际上是对底层链表的索引，非常典型的空间换时间，把链表的查询时间尽量控制在O(logN)。</p><a id="more"></a><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>由于使用了类似索引点数据维护方式，所以新增和删除需要同时维护跳表结构，跳表利用概率平衡的方式简化新增和删除操作，和树操作利用左旋和右旋等操作维持数据平衡不同，跳表利用了类似猜硬币的方式抉择出在哪一层插入或者删除节点和更新索引。</p><p>从下面的abcde图中，我们可以看一下跳表的演进：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220519072104.png" alt=""></p><p>首先a是一个典型的链表结构，对于查询来说需要<code>O(n)</code>的时间，链表长度越长查询越慢。</p><p>b在a的基础上，每次隔2个节点加一个额外的指针，通过这样的操作，每次查询时间就减少了【n/2】+次数。</p><p>c、d、e继续按照这样的思路继续加额外指针，最终只留下从头到尾的一层指针结束。</p><p>但是可以看到如果按照统一的思路每一层这样加节点对于维护整个节点的效率十分低，我们将拥有额外指针的节点看作一个K层节点，按照图中整理可以看到对于1层的节点占了50%，2层为25%，3层为12.5%……如果插入新节点能按照这样的规律进行插入删除，那么效率提升就不会出现很大的性能影响。</p><p>维护辅助指针会带来更大的复杂度，索引在每一层的节点中都会指向当前层所在的下一个节点，也就是说每一层都是一个链表。</p><p><strong>时间复杂度如何计算的？</strong></p><p>推导公式如下：</p><p><code>n/2^k =&gt; n / 2^k = 2 =&gt; h = log2n -1 =&gt; O(logn)</code></p><p>k代表节点层数，h表示最高级</p><p>原始的链表有n个元素，则一级索引有n/2 个元素、二级索引有 n/4 个元素、k级索引就有 n/(2^k)个元素。最高级索引一般有2个元素（头指向尾），最高级索引指向2 = n/(2^h)，即 h =(log2)n-1，最高级的索引h为索引层高度+原数据高度，最终跳表高度为 h = (log2) n。</p><p>经过索引的优化之后，整个查询的时间复杂度可以近似看作<strong>O(logn)</strong> ，和 二分查找的效率类似。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220519075430.png" alt=""></p><p><strong>空间复杂度如何计算？</strong></p><p>随着层数的增加，建立索引的空间开销是越来越小的，一层索引为 n/2，二层索引为 n/4，三层为 n/8 …..最后 n/2 + n/4 + n/8 +…. + 2（最高层一般为2个节点）最后因为分母相加可以认为是近似 <strong>O(n)</strong> 的空间复杂度。</p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>下面是跳表的增删改查的处理流程，由于删除和插入都依赖查询，我们先从查询开始介绍：</p><p>查询的操作方式可以看下面的绘图，比如如果需要查找存在于中间的节点17，则会根据线条顺序查找，这里简述查询顺序：</p><ol><li>从索引的最高层进行查找，直接找到下一个节点。</li><li>如果当前内容大于节点内容，则直接找下一个节点比较。</li><li>如果当前节点等于查找节点则直接返回。</li><li>如果当前节点大于节点，并且下一个节点大于当前节点，并且层高不为0，则继续往层高更低的一个层级节点查找同时<strong>回到更低层级前一个节点</strong>，如果层高为0，则返回当前节点，当前节点的key要大于查找的key。</li></ol><p>查找比较好理解，就是用索引快速跨越多个链表节点减少搜索次数，然后层数下探找到相关的节点，注意拥有索引的节点，通常在上层节点会有指向下层的指针。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220519073220.png" alt=""></p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>插入操作比较关键，因为这里涉及到非常影响跳表性能的索引节点选举动作。按照之前的查找操作步骤，插入操作需要<strong>每次记录每一层的前任节点</strong>。</p><p><strong>关键点</strong>：插入的关键点在于选举那个节点增加层高来维持二分查找的效率，在找到位置之后，通常使用随机抛硬币的方式随机为节点增加层高，层级越高被选中的概率通常会指数倍的降低，之后根据三个参数：种子（用于实现概率随机）以及当前节点的层数和概率值P或者其他的随机值算法进行计算，但是为了防止单节点层高过高，通常会限制最终层高防止单一节点的层高超过上限。</p><blockquote><p>根据墨菲定律，无论单一节点层高过高可能性再低，都需要做限制。</p></blockquote><p>这里挑了LevelDB跳表数据结构的一段代码进行介绍：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func (p *DB) randHeight() (h <span class="keyword">int</span>) &#123;</span><br><span class="line"><span class="comment">// 限制跳表扩展的最高层级</span></span><br><span class="line">    <span class="keyword">const</span> branching = <span class="number">4</span></span><br><span class="line">    h = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> h &lt; tMaxHeight &amp;&amp; p.rnd.Int()%branching == <span class="number">0</span> &#123;</span><br><span class="line">        h++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入节点之后，会根据记录的前任节点在每一层的位置按照跳表规则建立新节点的索引。</p><p>跳表插入新节点本身的更新十分非常简单，只需要把<strong>当前节点下一个节点指向插入节点的下一个节点的下一个节点，插入节点的下一个节点指向当前节点</strong> 即可。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220519075520.png" alt=""></p><p><strong>插入操作时间复杂度</strong></p><p>如果是单链表，那么一次遍历就可以完成，结果永远都是<strong>O(1)</strong>，对于跳表的插入，最坏的情况也就是需要在所有层都更新索引，这种情况是<strong>O(logN)</strong>。</p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除也是依赖查询完成的，根据查询找到待删除节点之后在每一层按照查询的规则把当前节点删除即可。</p><p>删除的时间复杂度快慢取决于于查询的层数，假设需要删除N个元素，而每一层其实都是一个单向的链表，单链表的查询是O(1)，同时是因为跳表最优是近似二分查找的效率，索引层数为logn，删除的层数也是logN，N取决于层级。</p><p>最终删除元素的总时间包含：</p><p>查找元素的时间 + _删除 logn个元素的时间 = <code>O(logn) + O(logn) = 2O(logn)</code>，忽略常数部分最终结果为 O(logn)。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>其实多数和Key-Value有关的LST-Tree 数据结构都有类似的跳表实现，因为链表在业务方面使用可能比较少，但是在数据结构和数据库设计上面却是至关重要的地位：</p><ul><li>HBase</li><li>Redis</li><li>LevelDB</li></ul><p><strong>小结</strong></p><ul><li>跳表让链表也能够完成二分查找的操作</li><li>元素的插入会根据抛硬币和权重分配随机选举Level</li><li>最底层永远是原始链表，而上层则是索引数据</li><li>索引节点通常会多一个指针指向下层节点，但是不是所有的程序设计都是按照这种方式，有其他的处理方式间接实现此功能（具体可以看redis 的 zset源代码）</li><li>跳表查询、插入、删除的时间复杂度为O(log n)，与平衡二叉树接近</li></ul><h1 id="LevelDb跳表实现"><a href="#LevelDb跳表实现" class="headerlink" title="LevelDb跳表实现"></a>LevelDb跳表实现</h1><p>在之前讨论合并压缩文件使用了归并排序的方式进行键合并，而内部的数据库除了归并排序之外还使用了比较关键的[[LSM-Tree - LevelDb Skiplist跳表]]来进行有序键值管理。</p><p>跳表在Redis和Kafka中都有实现，这里的Skiplist其实也是类似的，可以看作C++版本的跳表案例。</p><p>这部分就不看作者的文档了，我们直接源码开干。</p><h2 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h2><p>首先我们需要清楚LevelDB的跳表包含了什么东西？在代码的一开始定义了 <strong>Node</strong>节点用来表示链表节点，以及 <strong>Iterator</strong>迭代器的内容进行迭代，内部定义了<code>std::atomic&lt;Node*&gt; next_[1]</code> 长度等于节点高度的数组。 </p><p>next_[0]是最底层的节点（用于跳表跨层获取数据），核心是作者自认为写的一般的Random 随机器（通过位操作生成随机的一个位号码）。</p><p>LevelDB的整个实现比较简洁规范，在设计上定义了很多函数来简化复杂代码的增加，建议看不懂就多看几遍跳表的理论。</p><h2 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h2><p>#levelDB插入操作 #levelDB查询操作</p><p>在了解过[[LSM-Tree - LevelDb Skiplist跳表]]之后，我们发现对于跳表这种数据结构来说，核心部分在于查询和插入两个部分，当然查询是理解插入点前提，但是对于插入抛硬币选举的实现有必要深究一下。</p><h2 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h2><p>查询操作比较好理解，和跳表的数据结构规定差不多，和[[LSM-Tree - LevelDb Skiplist跳表]]的实现类似：</p><p>可以发现和跳表原始的实现方式如出一辙，这里相当于复读理论的内容：</p><ol><li>从索引的最高层进行查找，直接找到下一个节点。</li><li>如果当前内容大于节点内容，则直接找下一个节点比较。</li><li>如果当前节点等于查找节点则直接返回。</li><li>如果当前节点大于节点，并且下一个节点大于当前节点，并且层高不为0，则继续往层高更低的一个层级节点查找同时<strong>回到更低层级前一个节点</strong>，如果层高为0，则返回当前节点，当前节点的key要大于查找的key。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回层级最前的节点，该节点位于键的位置或之后。如果没有这样的节点，返回nullptr。如果prev不是空的，则在[0...max_height_1]中的每一级，将prev[level]的指针填充到前一个 节点的指针来填充[0...max_height_1]中的每一级的 "level"。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">SkipList</span>&lt;Key, Comparator&gt;:</span>:Node*</span><br><span class="line"></span><br><span class="line">SkipList&lt;Key, Comparator&gt;::FindGreaterOrEqual(<span class="keyword">const</span> Key&amp; key,</span><br><span class="line"></span><br><span class="line">Node** prev) <span class="keyword">const</span> &#123;</span><br><span class="line"></span><br><span class="line">Node* x = head_;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 防止无限for循环</span></span><br><span class="line"><span class="keyword">int</span> level = GetMaxHeight() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">Node* next = x-&gt;Next(level);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (KeyIsAfterNode(key, next)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果当前节点在层级之后，则查找下一个链表节点</span></span><br><span class="line"></span><br><span class="line">x = next;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (prev != <span class="literal">nullptr</span>) prev[level] = x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> next;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 层级下沉</span></span><br><span class="line"></span><br><span class="line">level--;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><p>插入操作的代码如下，注意跳表需要在插入之前对于节点进行加锁的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">SkipList</span>&lt;Key, Comparator&gt;:</span>:Insert(<span class="keyword">const</span> Key&amp; key) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为前置节点最多有kMaxHeight层，所以直接使用kMaxHeight 简单粗暴</span></span><br><span class="line">Node* prev[kMaxHeight];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回层级最前的节点，该节点位于键的位置或之后。如果没有这样的节点，返回nullptr。如果prev不是空的，则在[0...max_height_1]中的每一级，将prev[level]的指针填充到前一个 节点的指针来填充[0...max_height_1]中的每一级的 "level"。</span></span><br><span class="line">Node* x = FindGreaterOrEqual(key, prev);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不允许进行重复插入操作（同步加锁）</span></span><br><span class="line">assert(x == <span class="literal">nullptr</span> || !Equal(key, x-&gt;key));</span><br><span class="line"></span><br><span class="line"><span class="comment">// **新增层级选举**，使用随机函数和最高层级限制，按照类似抛硬币的规则选择是否新增层级。</span></span><br><span class="line"><span class="comment">// 随机获取一个 level 值</span></span><br><span class="line"><span class="keyword">int</span> height = RandomHeight();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前随机level是否大于 当前点跳表层数</span></span><br><span class="line"><span class="keyword">if</span> (height &gt; GetMaxHeight()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头指针下探到最低层</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = GetMaxHeight(); i &lt; height; i++) &#123;</span><br><span class="line">prev[i] = head_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这部分建议多读读原注释。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">机器翻译：在没有任何同步的情况下突变max_height_是可以的。与并发读取器之间没有任何同步。一个并发的读者在观察到的新值的并发读者将看到max_height_的旧值。的新水平指针（nullptr），或者在下面的循环中设置一个新的值。下面的循环中设置的新值。在前一种情况下，读者将立即下降到下一个级别，因为nullptr会在所有的键之后。在后一种情况下，读取器将使用新的节点</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">理解：意思是说这一步不需要并发加锁，这是因为并发读读取到更新的跳表层数，哪怕现在这个节点没有插入，也会返回nullptr，在leveldb的比较器当中的nullpt会在最前面，默认看作比所有的key都要大，所以会往下继续找，这样就可以保证写入和读取都是符合预期的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">max_height_.store(height, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增跳表节点</span></span><br><span class="line">x = NewNode(key, height);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123;</span><br><span class="line"><span class="comment">// NoBarrier_SetNext()就够了，因为当我们在prev[i]中发布一个指针 "x "时，我们会添加一个障碍。我们在prev[i]中发布一个指向 "x "的指针。</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 更新指针引用</span></span><br><span class="line"><span class="comment">// 为了保证并发读的准确性，需要先设置节点指针然后再设置原始表的prev 指针</span></span><br><span class="line">x-&gt;NoBarrier_SetNext(i, prev[i]-&gt;NoBarrier_Next(i));</span><br><span class="line"><span class="comment">// 内部会强制进行同步</span></span><br><span class="line">prev[i]-&gt;SetNext(i, x);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跳表实现的难点在于层数的确定，而LevelDB的难点在于<strong>插入节点如何保证并发写入的时候能够正确的并发读</strong>。</p><p><strong>RandomHeight() 新增层级选举</strong>：</p><p>在LevelDb中层级选举的核心的代码是：<code>height &lt; kMaxHeight &amp;&amp; rnd_.OneIn(kBranching)</code>，内部在控制跳表层数最多不超过<code>kMaxHeight</code>层的情况下，对于4取余的操作实现<strong>构造 P = 3/4 的几何分布</strong>，最终判断是否新增层数。</p><blockquote><p>原始情况下跳表增加1层为 1/2，2层为1/4，3层为1/8，4层为1/16。LevelDB的11层最高层限制key的数量，但是11层的节点概率通常会非常非常小。<br>最终LevelDB选择的结果是3/4 的节点为 1 层节点，3/16 的节点为 2 层节点，3/64 的节点为 3 层节点，依此类推。</p></blockquote><p>层级选举的特点：</p><ol><li>插入新节点的指针数通过独立计算一个概率值决定，使全局节点的指针数满足几何分布即可。</li><li>插入时不需要做额外的节点调整，只需要先找到其需要放的位置，然后修改他和前驱的指向即可。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">SkipList</span>&lt;Key, Comparator&gt;:</span>:RandomHeight() &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在kBranching中以1的概率增加高度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> kBranching = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> height = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// rnd_.OneIn(kBranching):"1/n "的时间会返回真没其他情况会返回假</span></span><br><span class="line"><span class="comment">// 相当于层数会按照4 的倍数减小， 4层是3层的4分之一，简单理解为 每次加一层概率就要乘一个 1/4。</span></span><br><span class="line"><span class="keyword">while</span> (height &lt; kMaxHeight &amp;&amp; rnd_.OneIn(kBranching)) &#123;</span><br><span class="line"></span><br><span class="line">height++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">assert(height &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">assert(height &lt;= kMaxHeight);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> height;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看到概率P使用了1/4计算方式，使用1/4的好处是让层数更为分散，典型的时间换空间的操作，虽然会牺牲一部分空间，但是获得更高的性能，<strong>在此情况下，可以最多支持 n = (1/p)^kMaxHeight 个节点的情况</strong>。</p><blockquote><p>对于LevelDB这种写快过读的业务，效率是最优考虑。</p></blockquote><p>12层高的节点最多可以存储多少数据？那么可以直接使用4^12 计算约等于 <strong>16M</strong>。当然12层的概率微乎其微。</p><h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><p>LevelDB跳表是没有删除这个概念的，相对应的更新也是针对next指针的变动。</p><ol><li>除非跳表被销毁，跳表节点<strong>只会增加而不会被删除</strong>，因为跳表<strong>根本不对外提供删除接口</strong>。</li><li>被插入到跳表中的节点，除了 next 指针其他域都是不可变的，并且只有插入操作会改变跳表。（以此来替代更新）</li></ol><h2 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h2><p>之前的[[LSM-Tree - LevelDb 源码解析]] 分析解释过整个跳表的遍历通过<code>Iterator</code>完成，内部使用了归并排序对于key进行排序，同时<code>null ptr</code>作为特殊值永远排在最前面。</p><p>LevelDB自带的迭代器实现较为丰富，除开迭代器经典的<code>remove()</code>，<code>next()</code>、<code>haseNext()</code>之外，还有<code>Seek</code>，<code>SeekToFirst</code>，<code>SeekToLast</code>、以及<code>Prev</code>向前遍历的操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Advances to the next position.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// REQUIRES: Valid()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Advances to the previous position.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// REQUIRES: Valid()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prev</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Advance to the first entry with a key &gt;= target</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">const</span> Key&amp; target)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Position at the first entry in list.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Final state of iterator is Valid() iff list is not empty.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeekToFirst</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Position at the last entry in list.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Final state of iterator is Valid() iff list is not empty.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeekToLast</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>这里需要特意强调的是向前遍历这个操作<strong>并不是通过增加prev指针反向迭代</strong>的，而是<strong>从head开始查找</strong>，也是时间换空间。</p><p>最后有两个比较频繁的使用操作<code>FindLast</code>和<code>FindLessThan</code>，注释写的简单明了，就不多介绍了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return the latest node with a key &lt; key.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Return head_ if there is no such node.</span></span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">FindLessThan</span><span class="params">(<span class="keyword">const</span> Key&amp; key)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">// Return the last node in the list.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Return head_ if list is empty.</span></span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">FindLast</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>LevelDB的跳表设计难点主要体现在并发读写的维持以及节点的层级选举上面，这一部分是和原始的跳表差别比较大的地方，而其他地方基本可以看作原始跳表的理论设计的，所以把 LevelDB 作为跳表的模板代码学习也是十分推荐的。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC85ZDgyOTY1NjI4MDY=" title="https://www.jianshu.com/p/9d8296562806">Skip List–跳表（全网最详细的跳表文章没有之一） - 简书 (jianshu.com)<i class="fa fa-external-link"></i></span></p><p>跳表数据结构的实现，JAVA版本的链表可以看下面的代码：<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dhbmd6aGVuZzA4MjIvYWxnby9ibG9iL21hc3Rlci9qYXZhLzE3X3NraXBsaXN0L1NraXBMaXN0LmphdmE=" title="https://github.com/wangzheng0822/algo/blob/master/java/17_skiplist/SkipList.java">algo/SkipList.java at master · wangzheng0822/algo · GitHub<i class="fa fa-external-link"></i></span></p><h1 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h1><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDA0MTY1MjAwMw==" title="https://segmentfault.com/a/1190000041652003">[《数据密集型型系统设计》LSM-Tree VS BTree]<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDA0MTcyMDIwNQ==" title="https://segmentfault.com/a/1190000041720205">[LSM-Tree - LevelDb了解和实现]<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDA0MTg2NDU3OQ==" title="https://segmentfault.com/a/1190000041864579">[LSM-Tree - LevelDb 源码解析]<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDA0MTg2OTU4Ng==" title="https://segmentfault.com/a/1190000041869586">[LSM-Tree - LevelDb Skiplist跳表]<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDA0MTg3MzQwMA==" title="https://segmentfault.com/a/1190000041873400">[LSM-Tree - LevelDb 布隆过滤器]<i class="fa fa-external-link"></i></span></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      Skiplist跳表
    
    </summary>
    
    
      <category term="数据库-LevelDB" scheme="https://whitestore.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-LevelDB/"/>
    
    
      <category term="数据库" scheme="https://whitestore.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>LSM-Tree - LevelDb 布隆过滤器</title>
    <link href="https://whitestore.top/2022/05/21/leveled-bloom/"/>
    <id>https://whitestore.top/2022/05/21/leveled-bloom/</id>
    <published>2022-05-21T11:07:44.000Z</published>
    <updated>2022-06-02T10:09:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LSM-Tree-LevelDb布隆过滤器"><a href="#LSM-Tree-LevelDb布隆过滤器" class="headerlink" title="LSM-Tree - LevelDb布隆过滤器"></a>LSM-Tree - LevelDb布隆过滤器</h1><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>布隆过滤器有点类似哈希表，但是比哈希表的效率要更高，因为使用了位来判断Key是否存在，布隆过滤器在完成高效搜索key是否存在的同时带来一定的副作用– <strong>不保证Key一定存在</strong>，所以它只适用于允许一定容错率的系统。</p><p>一句话概括：<code>Bloom Filter</code> 是一个<strong>基于概率的数据结构</strong>，它只能告诉我们一个元素绝对不在集合内或<strong>可能</strong>在集合内。</p><p>布隆过滤器比较悬浮的东西是它不保证元素百分百在一个集合内，所以适用于具备一定容错的业务，关于它的理论和实践很多内容都是参考或者直接摘自网上的资料加上自己的理解，如有错误欢迎指正。</p><a id="more"></a><h1 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h1><p>理论基础相关文章都大同小异，这里归纳自这一篇大神写的文章：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppYW9tZW5nL2FydGljbGUvZGV0YWlscy8xNDk1NTAw" title="https://blog.csdn.net/jiaomeng/article/details/1495500">Bloom Filter概念和原理_jiaomeng的博客-CSDN博客_bloomfilter<i class="fa fa-external-link"></i></span>，简洁易懂，另外建议多参考原始论文，这里很多内容其实也是归纳自老外早已写出来的论文。</p><p>在这个网址中可以通过JS代码查看实际的运行效果：<br><span class="exturl" data-url="aHR0cHM6Ly9sbGltbGxpYi5naXRodWIuaW8vYmxvb21maWx0ZXItdHV0b3JpYWwvemhfQ04v" title="https://llimllib.github.io/bloomfilter-tutorial/zh_CN/">Bloom Filters by Example (llimllib.github.io)<i class="fa fa-external-link"></i></span></p><blockquote><p>注意在案例中使用了<code>Fnv</code>和 <code>Murmur</code> 这两个简单的哈希函数。</p></blockquote><p>对于一个布隆过滤器，通常有如下定义：</p><ol><li>n 个 key。</li><li>m bits 的空间 v，全部初始化为0。</li></ol><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205031233283.png" alt=""></p><ol start="3"><li><p>Bloom Filter 理论建议使用k个相互独立的哈希函数（Hash Function），用于表示<code>S={x1, x2,…,xn}</code>的n个元素的集合，对任意一个元素x，第 i 个哈希函数映射的位置hi(x) 就会被置为1（1≤i≤k）。</p><p> 如果有多个哈希函数位置都为1，那么只有 <strong>第一个哈希结果被使用</strong>。比如下面的图中从左往右数第二个“1”所在的位置就是最终哈希函数选中位置。</p></li></ol><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205031235855.png" alt=""></p><ol start="4"><li><p>为了判断当前的元素是否在集合当中，需要对于当前的元素y进行k次的哈希函数，如果所有的hi(y)次数是1（i &lt;= i &lt;= k中的次数都是1）就认为当前的元素y<strong>可能</strong>在集合中，否则就绝对不存在。</p><p> 以下面的内容y1因为存在hash为0的结果，所以认为不存在于集合，而y2所有的hash都落在1上，可以认为<strong>可能</strong>存在集合。</p></li></ol><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205031927973.png" alt=""></p><p>布隆过滤器的理论内容相对简单，关键部分是哈希函数的选择和错误率的平衡。</p><p><strong>错误率计算</strong></p><p>首先布隆过滤器需要注意bit位长度，也就是数组长度。通常一个大的布隆过滤器会比小的布隆过滤器有更小的错误率。</p><p>误判率的计算公式为：<code>(1-e^(-kn/m))^k</code>。</p><p>推导过程如下，过程不是特别重要，了解最终公式即可：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205032059650.png" alt=""></p><blockquote><p>n为key的个数，m为bits的位数（也就是数组大小）</p></blockquote><p>根据这个公式可以发现，需要先确定可能插入的数据集的容量大小 <em>n</em>, 然后再调整 k 和 <em>m</em> 来为你的应用配置过滤器，m 越大，k 越大， n 越小，那么误判率越小。</p><p>考虑到 p 为设置为0的概率，因此可以认为 m 有一半设置为1，一半设置为0时，误判率最低，注意这句话在最后的推导部分会详细介绍。</p><p><strong>多少个哈希函数？</strong></p><p>根据错误率计算结论，这里又有一个问题，就是究竟应该选择多少个哈希函数，哈希函数的过多容易导致计算效率降低影响性能，太少又会让误判率升高。</p><p>高兴的是，这个公式也有人推导出来了：</p><p><strong>hash 函数 k 的最优个数为 ln2 * (m/n)</strong>。</p><p>可以通过以下的步骤来确定 Bloom filter 的大小:</p><ol><li>确定 <em>n</em> 的变动范围</li><li>选定 <em>m</em> 的值</li><li>计算 <em>k</em> 的最优值</li><li>对于给定的n, <em>m</em>,  k计算错误率。如果这个错误率不能接受，那么回到第二步，否则结束</li></ol><p><strong>Bloom filter 的时间复杂度和空间复杂度?</strong></p><p>插入和测试操作的时间复杂度都是 O(k)，这是因为如果想要插入或者查询一个元素，只需要对于元素进行k次数的函数运算。</p><p>空间复杂度就比较难以估算了，因为误差率的存在，大小是难以确定的，如果难以估算一个过滤器的大小，最好选择一个哈希表或者一个可拓展的 Bloom filter。</p><blockquote><p>注意⚠️：LevelDB的过滤器大小是不能少于64位的bit数组。</p></blockquote><p><strong>m中多少位数为1合适</strong></p><p>直接记住结论：<strong>可以认为 m 有一半设置为1，一半设置为0时，误判率最低</strong>。</p><h1 id="levelDB实现"><a href="#levelDB实现" class="headerlink" title="levelDB实现"></a>levelDB实现</h1><p>LevelDB的布隆过滤器精髓在哈希函数上，它通过一个哈希达到多个哈希的性能，同时保证误判率在一定的限制。</p><p>具体的代码实现可以阅读<strong>bloom.cc</strong>：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9sZXZlbGRiL2Jsb2IvbWFpbi91dGlsL2Jsb29tX3Rlc3QuY2M=" title="https://github.com/google/leveldb/blob/main/util/bloom_test.cc">leveldb/bloom_test.cc at main · google/leveldb · GitHub<i class="fa fa-external-link"></i></span></p><h2 id="index-md介绍"><a href="#index-md介绍" class="headerlink" title="index.md介绍"></a>index.md介绍</h2><p>这里先不深入源代码，先看看作者在<code>index.md</code>是如何解释的：<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9sZXZlbGRiL2Jsb2IvbWFpbi9kb2MvaW5kZXgubWQjZmlsdGVycw==" title="https://github.com/google/leveldb/blob/main/doc/index.md#filters">leveldb/index.md at main · google/leveldb · GitHub<i class="fa fa-external-link"></i></span></p><p>由于leveldb数据在磁盘上的组织方式，一个<code>Get()</code>的调用可能涉及到从磁盘上多次读取，所以可选的<code>FilterPolicy</code>机制可以被用来可以用来大大减少磁盘读取的次数，其实这里就是指的使用布隆过滤器提高过滤效率。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">leveldb::Options options;</span><br><span class="line"></span><br><span class="line">options.filter_policy = NewBloomFilterPolicy(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">leveldb::DB* db;</span><br><span class="line"></span><br><span class="line">leveldb::DB::Open(options, <span class="string">"/tmp/testdb"</span>, &amp;db);</span><br><span class="line"></span><br><span class="line">... use the database ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> db;</span><br><span class="line"><span class="comment">// 注意，关闭leveldb的时候需要手动释放过滤器所占用内存空间</span></span><br><span class="line"><span class="keyword">delete</span> options.filter_policy;</span><br></pre></td></tr></table></figure><p>前面的代码将基于布隆过滤器的过滤策略与数据库联系起来。 </p><p>基于布隆过滤器的过滤依赖于在内存中为每个密钥保留一定数量的数据（本例中每个密钥为10bits，因为这是我们传递给<code>NewBloomFilterPolicy</code>的参数）。</p><p>这个过滤器将减少<code>Get()</code>调用所需的不必要的磁盘IO次数，提升效率大约是<strong>100倍</strong>。增加每一个key的位数将导致更大的减少，但<strong>代价占用是更多的内存</strong>。我们建议那些工作集不适合放在内存中的应用程序不适合在内存中使用，并且进行大量随机读取的应用程序设置一个过滤策略。</p><h2 id="FilterPolicy"><a href="#FilterPolicy" class="headerlink" title="FilterPolicy"></a>FilterPolicy</h2><p>整个过滤器通过对外的接口<code>FilterPolicy</code>，目的是减少<code>DB::Get()</code>函数调用时间，通常内部默认使用布隆过滤器。</p><p>下面是接口定义的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Slice</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LEVELDB_EXPORT</span> <span class="title">FilterPolicy</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> ~FilterPolicy();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return the name of this policy. Note that if the filter encoding</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// changes in an incompatible way, the name returned by this method</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// must be changed. Otherwise, old incompatible filters may be</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// passed to methods of this type.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回该策略的名称。注意如果过滤器的编码变化，此方法返回的名称必须被改变。否则不兼容旧的过滤器可能被传递给这种类型的方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">Name</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// keys[0,n-1] contains a list of keys (potentially with duplicates)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// that are ordered according to the user supplied comparator.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Append a filter that summarizes keys[0,n-1] to *dst.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Warning: do not change the initial contents of *dst. Instead,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// append the newly constructed filter to *dst.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* keys[0,n-1] 包含一个键的列表（可能有重复的）。根据用户提供的比较器进行排序。将一个总结keys[0,n-1]的过滤器追加到*dst。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 警告：不要改变*dst的初始内容。 相反将新构建的过滤器追加到*dst中。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">CreateFilter</span><span class="params">(<span class="keyword">const</span> Slice* keys, <span class="keyword">int</span> n,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="built_in">std</span>::<span class="built_in">string</span>* dst)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// "filter" contains the data appended by a preceding call to</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CreateFilter() on this class. This method must return true if</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the key was in the list of keys passed to CreateFilter().</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This method may return true or false if the key was not on the</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// list, but it should aim to return false with a high probability.</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> "filter "包含了前面对这个类的CreateFilter()的调用所附加的数据。如果键在传递给CreateFilter()的键列表中，该方法必须返回true。如果键不在列表中，该方法可能会返回true或false，但它应该以返回false的概率大为目标。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">KeyMayMatch</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; filter)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这一部分注释较多，放到后文介绍</span></span><br><span class="line"></span><br><span class="line"><span class="function">LEVELDB_EXPORT <span class="keyword">const</span> FilterPolicy* <span class="title">NewBloomFilterPolicy</span><span class="params">(<span class="keyword">int</span> bits_per_key)</span></span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace leveldb</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// STORAGE_LEVELDB_INCLUDE_FILTER_POLICY_H_</span></span></span><br></pre></td></tr></table></figure><h2 id="bloom-cc"><a href="#bloom-cc" class="headerlink" title="bloom.cc"></a>bloom.cc</h2><p>关于具体的代码解释放在了注释当中，比较值得关注的是创建过滤器的部分以及哈希函数的部分，这部分介绍的是过滤器本身的源代码，关键的哈希函数放到了下面的小节。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright (c) 2012 The LevelDB Authors. All rights reserved.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style license that can be</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// found in the LICENSE file. See the AUTHORS file for names of contributors.</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"leveldb/filter_policy.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"leveldb/Slice.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"util/hash.h"</span></span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint32_t</span> <span class="title">BloomHash</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 注意 0xbc9f1d34</span></span><br><span class="line"><span class="keyword">return</span> Hash(key.data(), key.size(), <span class="number">0xbc9f1d34</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BloomFilterPolicy</span> :</span> <span class="keyword">public</span> FilterPolicy &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">BloomFilterPolicy</span><span class="params">(<span class="keyword">int</span> bits_per_key)</span> : <span class="title">bits_per_key_</span><span class="params">(bits_per_key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We intentionally round down to reduce probing cost a little bit</span></span><br><span class="line"><span class="comment">// 我们有意四舍五入，以减少一点探测成本</span></span><br><span class="line">k_ = <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(bits_per_key * <span class="number">0.69</span>); <span class="comment">// 0.69 =~ ln(2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (k_ &lt; <span class="number">1</span>) k_ = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (k_ &gt; <span class="number">30</span>) k_ = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">Name</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">"leveldb.BuiltinBloomFilter2"</span>; &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateFilter</span><span class="params">(<span class="keyword">const</span> Slice* keys, <span class="keyword">int</span> n, <span class="built_in">std</span>::<span class="built_in">string</span>* dst)</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compute bloom filter size (in both bits and bytes)</span></span><br><span class="line"><span class="comment">// 计算布过滤器的大小（包括比特和字节）。</span></span><br><span class="line"><span class="keyword">size_t</span> bits = n * bits_per_key_;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// For small n, we can see a very high false positive rate. Fix it</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// by enforcing a minimum bloom filter length.</span></span><br><span class="line"><span class="comment">// 对于小的n，我们可以看到一个非常高的误判率。通过强制执行最小Bloom filter长度来解决这个问题。</span></span><br><span class="line"><span class="comment">// tip: 这里就是之前说的如果bit位数过小会增加误判率</span></span><br><span class="line"><span class="keyword">if</span> (bits &lt; <span class="number">64</span>) bits = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> bytes = (bits + <span class="number">7</span>) / <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 至少有64个bits</span></span><br><span class="line">bits = bytes * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> init_size = dst-&gt;size();</span><br><span class="line"><span class="comment">// 调整容器的大小，使其包含_n个_元素。</span></span><br><span class="line">dst-&gt;resize(init_size + bytes, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">dst-&gt;push_back(<span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(k_)); <span class="comment">// Remember # of probes in filter</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* <span class="built_in">array</span> = &amp;(*dst)[init_size];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use double-hashing to generate a sequence of hash values.</span></span><br><span class="line"><span class="comment">// See analysis in [Kirsch,Mitzenmacher 2006].</span></span><br><span class="line"><span class="comment">// 使用双重哈希法生成一连串的哈希值。见[Kirsch,Mitzenmacher 2006]中的分析。</span></span><br><span class="line"><span class="comment">// tips: 原始论文请看参考资料 -&gt; LNCS 4168 - Less Hashing, Same Performance: Building a Better Bloom Filter (harvard.edu)</span></span><br><span class="line"><span class="keyword">uint32_t</span> h = BloomHash(keys[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> delta = (h &gt;&gt; <span class="number">17</span>) | (h &lt;&lt; <span class="number">15</span>); <span class="comment">// // 向右旋转17位</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; k_; j++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> bitpos = h % bits;</span><br><span class="line"></span><br><span class="line"><span class="built_in">array</span>[bitpos / <span class="number">8</span>] |= (<span class="number">1</span> &lt;&lt; (bitpos % <span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">h += delta;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">关键函数：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">KeyMayMatch</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; bloom_filter)</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> len = bloom_filter.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有1位的过滤器无意义</span></span><br><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="built_in">array</span> = bloom_filter.data();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> bits = (len - <span class="number">1</span>) * <span class="number">8</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// Use the encoded k so that we can read filters generated by</span></span><br><span class="line"><span class="comment">// bloom filters created using different parameters.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用编码的k，这样我们就可以读取由 使用不同参数创建的bloom过滤器。</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> k = <span class="built_in">array</span>[len - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (k &gt; <span class="number">30</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 超过我们设定 k 个数，直接返回 true，不滤掉该 SSTable.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Reserved for potentially new encodings for short bloom filters.</span></span><br><span class="line"><span class="comment">// Consider it a match.</span></span><br><span class="line"><span class="comment">// 保留给可能出现的新编码的短Bloom过滤器。认为它是一种匹配。</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键：哈希函数</span></span><br><span class="line"><span class="keyword">uint32_t</span> h = BloomHash(key);</span><br><span class="line"><span class="comment">// 右旋17位</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> delta = (h &gt;&gt; <span class="number">17</span>) | (h &lt;&lt; <span class="number">15</span>); <span class="comment">// Rotate right 17 bits</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> bitpos = h % bits;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">array</span>[bitpos / <span class="number">8</span>] &amp; (<span class="number">1</span> &lt;&lt; (bitpos % <span class="number">8</span>))) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">h += delta;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> bits_per_key_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> k_;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 新的布隆过滤器策略（请看下文注释）</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> FilterPolicy* <span class="title">NewBloomFilterPolicy</span><span class="params">(<span class="keyword">int</span> bits_per_key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> BloomFilterPolicy(bits_per_key);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace leveldb</span></span><br></pre></td></tr></table></figure><p><strong>NewBloomFilterPolicy</strong>函数</p><p>为什么叫做新的布隆过滤器策略，可以看作者所给的注释：</p><blockquote><p>返回一个新的过滤策略，该策略使用一个Bloom过滤器，每个密钥大约有指定的每个密钥的比特数。键的比特数是10。<br>最终测试最佳值是10，这将产生一个误报率为1%的过滤器。</p></blockquote><p>注意使用之后必须要<strong>手动</strong>释放掉相关对象内存：</p><blockquote><p>调用者必须在使用该结果的<strong>任何数据库关闭后删除该结果</strong>，数据库被关闭后，调用者必须删除该结果。</p></blockquote><p>如果使用的是自定义的比较器，它忽略了被比较的键的某些部分以及被比较的键的某些部分，这时候不允许使用<code>NewBloomFilterPolicy()</code>，而必须提供自定义的<code>FilterPolicy</code>实现，因为原始的过滤器它也忽略了键的相应部分。</p><p>例如，如果<strong>比较器忽略了尾部的空格</strong>，那么使用一个的<code>FilterPolicy</code>（比如<code>NewBloomFilterPolicy</code>），原始对<code>FilterPolicy（如NewBloomFilterPolicy）</code>行为就会出现失误，因为它<strong>不会忽略键的尾部空格</strong>。</p><h2 id="hash-cc"><a href="#hash-cc" class="headerlink" title="hash.cc"></a>hash.cc</h2><p>之前说过关键的代码其中之一是优质的哈希函数，下面是<code>hash.cc</code>的相关代码：</p><p>注意这里的哈希函数使用的伪随机数种子为<code>0xbc9f1d34</code>，对应的10进制为<code>9134</code>。</p><p>这里也可以看到LevelDB利用自己的优质哈希函数，使得一个函数取代N个函数的效果，这算是对理论的调整，内部也控制levelDB长度最少为64个bit位。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">data：bit 位数</span></span><br><span class="line"><span class="comment">n：n 个 key</span></span><br><span class="line"><span class="comment">seed：种子，实际固定为 0xbc9f1d34</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">Hash</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* data, <span class="keyword">size_t</span> n, <span class="keyword">uint32_t</span> seed)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Similar to murmur hash</span></span><br><span class="line"><span class="comment">// 类似杂音哈希</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> m = <span class="number">0xc6a4a793</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> r = <span class="number">24</span>;</span><br><span class="line"><span class="comment">// limit指向了char*数组的最后一个位置的下一个位置，类似于迭代器end()</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* limit = data + n;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">uint32_t</span> h = seed ^ (n * m);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pick up four bytes at a time</span></span><br><span class="line"><span class="comment">// 以4个字节作为一次解析</span></span><br><span class="line"><span class="keyword">while</span> (data + <span class="number">4</span> &lt;= limit) &#123;</span><br><span class="line"><span class="comment">//  每次解码前4个字节，直到最后剩下小于4个字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DecodeFixed32 低级别的Get...版本，直接从字符缓冲区读取 而不进行任何边界检查，最近的clang和gcc将其优化为一条 mov / ldr 指令。</span></span><br><span class="line"><span class="keyword">uint32_t</span> w = DecodeFixed32(data);</span><br><span class="line"></span><br><span class="line">data += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">h += w;</span><br><span class="line"></span><br><span class="line">h *= m;</span><br><span class="line"></span><br><span class="line">h ^= (h &gt;&gt; <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pick up remaining bytes</span></span><br><span class="line"><span class="comment">// 处理剩余的字节</span></span><br><span class="line"><span class="keyword">switch</span> (limit - data) &#123;</span><br><span class="line"><span class="comment">// 将剩下的字节转化到uint32_t里面</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="comment">// static_cast 表示的是良性转换，含义表示</span></span><br><span class="line">h += <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(data[<span class="number">2</span>]) &lt;&lt; <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FALLTHROUGH_INTENDED宏可以用来注解开关标签之间的隐性落差。真正的定义应该由外部提供。 这个是为不支持的编译器提供的后备版本。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#ifndef FALLTHROUGH_INTENDED</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#define FALLTHROUGH_INTENDED \</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">do &#123; \</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125; while (0)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">FALLTHROUGH_INTENDED;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">h += <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(data[<span class="number">1</span>]) &lt;&lt; <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">FALLTHROUGH_INTENDED;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">h += <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(data[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">h *= m;</span><br><span class="line"></span><br><span class="line">h ^= (h &gt;&gt; r);</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> h;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Slice-h"><a href="#Slice-h" class="headerlink" title="Slice.h"></a>Slice.h</h2><p>可以看作类似Redis的简单字符串sds设计，只不过语言使用的是c++。</p><p>相关解释可以阅读文档：</p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9sZXZlbGRiL2Jsb2IvbWFpbi9kb2MvaW5kZXgubWQjU2xpY2U=" title="https://github.com/google/leveldb/blob/main/doc/index.md#Slice">leveldb/index.md at main · google/leveldb · GitHub<i class="fa fa-external-link"></i></span></p><p>Slice 是一个简单的数据结构，包含一个进入一些外部存储的指针和size。 Slice的用户必须确保在相应的外部存储被取消分配后不使用该Slice（用完必须手动释放内存）。</p><p>多个线程可以在一个Slice上调用<strong>const方法</strong>而不需要外部同步（线程安全对象），但如果任何一个线程可能会调用非const方法，所有访问同一Slice的线程都必须使用外部同步。</p><p>C++ 或者类C的 字符串可以简单的转化为Slice：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">leveldb::Slice s1 = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">"world"</span>)</span></span>;</span><br><span class="line">leveldb::Slice s2 = str;</span><br></pre></td></tr></table></figure><p>反过来也是一样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str = s1.ToString();</span><br><span class="line">assert(str == <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"hello"</span>));</span><br></pre></td></tr></table></figure><p>在使用Slice时要小心因为要由调用者来确保Slice所指向的外部字节数组在Slice使用时保持有效。例如，下面的例子是错误的：</p><p>下面的例子中Slice将可能指向一个外部的引用，同时不保证外部引用存在。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">leveldb::Slice Slice;</span><br><span class="line"><span class="keyword">if</span> (...) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> str = ...;</span><br><span class="line">  Slice = str;</span><br><span class="line">&#125;</span><br><span class="line">Use(Slice);</span><br></pre></td></tr></table></figure><p>当if语句超出范围时，str将被销毁，Slice的存储内容将消失。</p><h1 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h1><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>作者编写的单元测试可以更为直观的看到具体效果，路径为：<code>/leveldb-main/util/bloom_test.cc</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright (c) 2012 The LevelDB Authors. All rights reserved.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style license that can be</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// found in the LICENSE file. See the AUTHORS file for names of contributors.</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"gtest/gtest.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"leveldb/filter_policy.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"util/coding.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"util/logging.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"util/testutil.h"</span></span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kVerbose = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Slice <span class="title">Key</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">char</span>* buffer)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">EncodeFixed32(buffer, i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Slice(buffer, <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BloomTest</span> :</span> <span class="keyword">public</span> testing::Test &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">BloomTest() : policy_(NewBloomFilterPolicy(<span class="number">10</span>)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">~BloomTest() &#123; <span class="keyword">delete</span> policy_; &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">keys_.clear();</span><br><span class="line"></span><br><span class="line">filter_.clear();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">const</span> Slice&amp; s)</span> </span>&#123; keys_.push_back(s.ToString()); &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Build</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Slice&gt; key_Slices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; keys_.size(); i++) &#123;</span><br><span class="line"></span><br><span class="line">key_Slices.push_back(Slice(keys_[i]));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter_.clear();</span><br><span class="line"></span><br><span class="line">policy_-&gt;CreateFilter(&amp;key_Slices[<span class="number">0</span>], <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(key_Slices.size()),</span><br><span class="line"></span><br><span class="line">&amp;filter_);</span><br><span class="line"></span><br><span class="line">keys_.clear();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (kVerbose &gt;= <span class="number">2</span>) DumpFilter();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">FilterSize</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> filter_.size(); &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DumpFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"F("</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; filter_.size(); i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> c = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(filter_[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%c"</span>, (c &amp; (<span class="number">1</span> &lt;&lt; j)) ? <span class="string">'1'</span> : <span class="string">'.'</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">")\n"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 匹配</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Matches</span><span class="params">(<span class="keyword">const</span> Slice&amp; s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!keys_.empty()) &#123;</span><br><span class="line"></span><br><span class="line">Build();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> policy_-&gt;KeyMayMatch(s, filter_);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">FalsePositiveRate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buffer[<span class="keyword">sizeof</span>(<span class="keyword">int</span>)];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Matches(Key(i + <span class="number">1000000000</span>, buffer))) &#123;</span><br><span class="line"></span><br><span class="line">result++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result / <span class="number">10000.0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> FilterPolicy* policy_;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> filter_;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; keys_;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">TEST_F(BloomTest, EmptyFilter) &#123;</span><br><span class="line"></span><br><span class="line">ASSERT_TRUE(!Matches(<span class="string">"hello"</span>));</span><br><span class="line"></span><br><span class="line">ASSERT_TRUE(!Matches(<span class="string">"world"</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">TEST_F(BloomTest, Small) &#123;</span><br><span class="line"></span><br><span class="line">Add(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">Add(<span class="string">"world"</span>);</span><br><span class="line"></span><br><span class="line">ASSERT_TRUE(Matches(<span class="string">"hello"</span>));</span><br><span class="line"></span><br><span class="line">ASSERT_TRUE(Matches(<span class="string">"world"</span>));</span><br><span class="line"></span><br><span class="line">ASSERT_TRUE(!Matches(<span class="string">"x"</span>));</span><br><span class="line"></span><br><span class="line">ASSERT_TRUE(!Matches(<span class="string">"foo"</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">NextLength</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (length &lt; <span class="number">10</span>) &#123;</span><br><span class="line"></span><br><span class="line">length += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (length &lt; <span class="number">100</span>) &#123;</span><br><span class="line"></span><br><span class="line">length += <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (length &lt; <span class="number">1000</span>) &#123;</span><br><span class="line"></span><br><span class="line">length += <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">length += <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> length;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">TEST_F(BloomTest, VaryingLengths) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buffer[<span class="keyword">sizeof</span>(<span class="keyword">int</span>)];</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// Count number of filters that significantly exceed the false positive rate</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mediocre_filters = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> good_filters = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> length = <span class="number">1</span>; length &lt;= <span class="number">10000</span>; length = NextLength(length)) &#123;</span><br><span class="line"></span><br><span class="line">Reset();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line"></span><br><span class="line">Add(Key(i, buffer));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Build();</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">ASSERT_LE(FilterSize(), <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;((length * <span class="number">10</span> / <span class="number">8</span>) + <span class="number">40</span>))</span><br><span class="line"></span><br><span class="line">&lt;&lt; length;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// All added keys must match</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line"></span><br><span class="line">ASSERT_TRUE(Matches(Key(i, buffer)))</span><br><span class="line"></span><br><span class="line">&lt;&lt; <span class="string">"Length "</span> &lt;&lt; length &lt;&lt; <span class="string">"; key "</span> &lt;&lt; i;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// Check false positive rate</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> rate = FalsePositiveRate();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (kVerbose &gt;= <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">"False positives: %5.2f%% @ length = %6d ; bytes = %6d\n"</span>,</span><br><span class="line"></span><br><span class="line">rate * <span class="number">100.0</span>, length, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(FilterSize()));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ASSERT_LE(rate, <span class="number">0.02</span>); <span class="comment">// Must not be over 2%</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rate &gt; <span class="number">0.0125</span>)</span><br><span class="line"></span><br><span class="line">mediocre_filters++; <span class="comment">// Allowed, but not too often</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">good_filters++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (kVerbose &gt;= <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Filters: %d good, %d mediocre\n"</span>, good_filters,</span><br><span class="line"></span><br><span class="line">mediocre_filters);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ASSERT_LE(mediocre_filters, good_filters / <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// Different bits-per-byte</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace leveldb</span></span><br></pre></td></tr></table></figure><h2 id="c-语法"><a href="#c-语法" class="headerlink" title="c++语法"></a>c++语法</h2><p>补充：<br>个人并没有学过C++，所以这部分补充一些不理解的关键字和语法含义。</p><p><strong>explicit</strong></p><p><span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzJTNBLy96aC5jcHByZWZlcmVuY2UuY29tL3cvY3BwL2xhbmd1YWdlL2V4cGxpY2l0" title="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/language/explicit">C++ 参考手册<i class="fa fa-external-link"></i></span>如下解释：</p><ul><li><code>explicit</code>修饰的构造函数不能被隐式调用。</li><li>禁止类对象之间的隐式转换。</li></ul><p>这篇文章我们关注的就是第一点：<strong>构造函数被<code>explicit</code>修饰后, 就不能再被隐式调用了</strong>。</p><p>这里用了网上相关的案例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Explicit</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Explicit(<span class="keyword">int</span> <span class="built_in">size</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" the size is "</span> &lt;&lt; <span class="built_in">size</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Explicit(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> _str = str;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" the str is "</span> &lt;&lt; _str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Explicit(<span class="keyword">const</span> Explicit&amp; ins)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" The Explicit is ins"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Explicit(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" the a is "</span> &lt;&lt; a  &lt;&lt; <span class="string">" the b is "</span> &lt;&lt; b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Explicit <span class="title">test0</span><span class="params">(<span class="number">15</span>)</span></span>;</span><br><span class="line">    Explicit test1 = <span class="number">10</span>;<span class="comment">// 隐式调用Explicit(int size)</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Explicit <span class="title">test2</span><span class="params">(<span class="string">"RIGHTRIGHT"</span>)</span></span>;</span><br><span class="line">    Explicit test3 = <span class="string">"BUGBUGBUG"</span>;<span class="comment">// 隐式调用Explicit(const char* str)</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Explicit <span class="title">test4</span><span class="params">(<span class="number">1</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    Explicit test5 = test1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然程序没有错误，但是把一个<code>int</code>类型或者<code>const char*</code>类型的变量赋值给<code>Explicit</code>类型的变量看起来总归不是很好，并且一旦使用出错很难排查，所以这时候构造函数被<code>explicit</code>修饰后, 就不能再被隐式调用了，添加关键字之后的效果不演示了，加上之后整个程序是无法通过编译的。</p><p>吐槽：很神经病的东西，在过去的版本中使用隐式调用提高编码效率，结果后面发现坑太大挖坑自己填。</p><p><strong>resize函数</strong></p><p>直接看下面的案例更容易理解：</p><ul><li>myvector.resize(5);<br>将原来有10个数的vector数组，调整为5个数的长度，多余的数删掉，释放内存。 <strong>5 &lt; 10 减小数组长度</strong></li><li>myvector.resize(8,100);<br>将5个数长度的vector数组的长度调整为8，不够的数用100来填补，即增加了3个100。 <strong>8 &gt; 5 增大数组长度，指定填充元素</strong></li><li>myvector.resize(12);<br>将8个数长度的vector数组的长度调整为12，用0默认填补，即增加了4个0。 <strong>12 &gt; 8 增大数组长度，未指定填充元素</strong></li></ul><h2 id="数学推导"><a href="#数学推导" class="headerlink" title="数学推导"></a>数学推导</h2><p>推导部分给想要更加深入了解的人，可以直接记住上面的结论，看不懂也没关系。</p><p>下面的大部分内容来自论文根据 <span class="exturl" data-url="aHR0cDovL3d3dy5lZWNzLmhhcnZhcmQuZWR1L35taWNoYWVsbS9wb3N0c2NyaXB0cy9lc2EyMDA2YS5wZGY=" title="http://www.eecs.harvard.edu/~michaelm/postscripts/esa2006a.pdf">LNCS 4168 - Less Hashing, Same Performance: Building a Better Bloom Filter (harvard.edu)<i class="fa fa-external-link"></i></span> 翻译。</p><blockquote><p> <code>false position</code>：误判率，也就是随着哈希和为1的bit位增加导致的误判率上升。</p></blockquote><p>根据 bloom filter 的组成，对一个指定的 bit，其被设置为0、1的概率分别为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P(<span class="number">1</span>) = <span class="number">1</span>/m</span><br><span class="line">P(<span class="number">0</span>) = <span class="number">1</span> - <span class="number">1</span>/m</span><br></pre></td></tr></table></figure><p>k 个 hash 函数，该 bit 设置为 0 的概率为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P<span class="number">'</span>(<span class="number">0</span>) = P(<span class="number">0</span>) ** k = (<span class="number">1</span> - <span class="number">1</span>/m) ** k</span><br></pre></td></tr></table></figure><p>再经过 n 个 key，该 bit 设置为 0 的概率为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P<span class="number">''</span>(<span class="number">0</span>) = P<span class="number">'</span>(<span class="number">0</span>) ** n = (<span class="number">1</span> - <span class="number">1</span>/m) ** kn</span><br></pre></td></tr></table></figure><p>根据自然对数e的公式：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041413726.png" alt=""></p><p>我们可以近似计算前面的<code>P&#39;&#39;(0)</code></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041414674.png" alt=""></p><p>关于自然对数 e 的值，可以看下面的内容:</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041327457.png" alt=""></p><p>当检测某个实际不存在的 key 时，满足条件：</p><p>其对应的 k 个 bit 恰好都设置为了1，此时即 false positive 的场景。</p><p>概率为：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041418134.png" alt=""></p><p>问题是，怎么最小化 false_positive 呢？</p><p>为了简化描述，先定义 p (即<code>P&#39;&#39;(0)</code>：某个 bit 设置为0的概率)：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041423865.png" alt=""></p><p>根据公式推导：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041424497.png" alt=""></p><p>底数是 e，为固定值，那么最小化 false_positive_rate 即为最小化指数</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041424841.png" alt=""></p><p>根据之前的计算结果，我们可以做下面的变形：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041431847.png" alt=""></p><p>最终得到结果 g：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041431129.png" alt=""></p><p>根据对称性，当 <code>p = 1/2</code> 时，f 取得最小值。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041435792.png" alt=""></p><p>此时k、f最小值为：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041436632.png" alt=""></p><p>最终的推导结果：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041441884.png" alt=""></p><p>考虑到 p 为设置为0的概率，因此<strong>可以认为 m 有一半设置为1，一半设置为0时，误判率最低</strong>。</p><p><code>false position</code>和m/n、k 的组合关系表例子可以下面的截图：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041219187.png" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Bloom Filter 通常用于快速判断某个元素是否在集合中。其本质上容忍一定的错误率来换取时空的高效性。</p><p>对于LevelDB的意义：在哈希表的基础上省下了冲突处理部分，LevelDB 在实现时使用了某种优化：<strong>利用一个哈希函数来达到近似 k 个哈希函数的效果</strong>。这样做实现了高效的并发写入同时不会牺牲过多的性能。</p><p>LevelDB除开哈希函数和针对并发写入的优化部分之外，其他部分都非常贴合布隆过滤器的理论基础，也是优秀的学习案例，作为C++版本的过滤器生产案例应用也是一个不错的参考范本。</p><p>最后，有问题找布隆准没错。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>下面的资料绝对能让你吃透布隆过滤器。</p><blockquote><p>公众号请“阅读原文”获取访问链接。</p></blockquote><ul><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppYW9tZW5nL2FydGljbGUvZGV0YWlscy8xNDk1NTAw" title="https://blog.csdn.net/jiaomeng/article/details/1495500">Bloom Filter概念和原理_jiaomeng的博客-CSDN博客_bloomfilter<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sbGltbGxpYi5naXRodWIuaW8vYmxvb21maWx0ZXItdHV0b3JpYWwvemhfQ04v" title="https://llimllib.github.io/bloomfilter-tutorial/zh_CN/">Bloom Filters by Example (llimllib.github.io)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2MuYmlhbmNoZW5nLm5ldC9jcHAvYmlhbmNoZW5nL3ZpZXcvMzI5Ny5odG1s" title="http://c.biancheng.net/cpp/biancheng/view/3297.html">C++四种类型转换运算符：static_cast、dynamic_cast、const_cast和reinterpret_cast_C语言中文网 (biancheng.net)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5lZWNzLmhhcnZhcmQuZWR1L35taWNoYWVsbS9wb3N0c2NyaXB0cy9lc2EyMDA2YS5wZGY=" title="http://www.eecs.harvard.edu/~michaelm/postscripts/esa2006a.pdf">LNCS 4168 - Less Hashing, Same Performance: Building a Better Bloom Filter (harvard.edu)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9sZXZlbGRiL2Jsb2IvbWFpbi9kb2MvaW5kZXgubWQjZmlsdGVycw==" title="https://github.com/google/leveldb/blob/main/doc/index.md#filters">leveldb/index.md at main · google/leveldb · GitHub<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5lZWNzLmhhcnZhcmQuZWR1L35taWNoYWVsbS9wb3N0c2NyaXB0cy9pbTIwMDViLnBkZg==" title="http://www.eecs.harvard.edu/~michaelm/postscripts/im2005b.pdf">im2005b.pdf (harvard.edu)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5lZWNzLmhhcnZhcmQuZWR1L35taWNoYWVsbS9wb3N0c2NyaXB0cy90b24yMDAyLnBkZg==" title="http://www.eecs.harvard.edu/~michaelm/postscripts/ton2002.pdf">Compressed bloom filters - Networking, IEEE/ACM Transactions on (harvard.edu)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9penVhbHpoeS5jbi9sZXZlbGRiLWJsb29tLWZpbHRlcg==" title="https://izualzhy.cn/leveldb-bloom-filter">leveldb笔记之9:bloom filter - Ying’s Blog (izualzhy.cn)<i class="fa fa-external-link"></i></span></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      有问题找布隆
    
    </summary>
    
    
      <category term="数据库-LevelDB" scheme="https://whitestore.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-LevelDB/"/>
    
    
      <category term="数据库" scheme="https://whitestore.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
</feed>
