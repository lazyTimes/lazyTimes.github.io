<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>爱看书的阿东</title>
  
  <subtitle>赐他一块白色石头，石头上写着新名</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://whitestore.top/"/>
  <updated>2022-11-16T03:06:25.187Z</updated>
  <id>https://whitestore.top/</id>
  
  <author>
    <name>阿东</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>&#39;如何实现B站网页下载视频&#39;</title>
    <link href="https://whitestore.top/2022/11/16/bdownload/"/>
    <id>https://whitestore.top/2022/11/16/bdownload/</id>
    <published>2022-11-16T03:05:20.000Z</published>
    <updated>2022-11-16T03:06:25.187Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>此方法建议不要随意在网上传播，虽然本意想让更多人知道，但是确实比较怕菊爆党。</p><a id="more"></a><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ol><li>先下载油猴插件（需要梯子插件搜 <strong>Tampermonkey</strong>）。</li></ol><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20221116110048.png" alt=""></p><p>网站地址：<span class="exturl" data-url="aHR0cHM6Ly93d3cudGFtcGVybW9ua2V5Lm5ldC9zY3JpcHRzLnBocA==" title="https://www.tampermonkey.net/scripts.php">Tampermonkey • Userscript Sources<i class="fa fa-external-link"></i></span></p><p>之后前往下面的搜索页面，搜索B站[空格]下载</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20221109143839.png" alt=""></p><ol start="2"><li>找到排序的第一个插件：</li></ol><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20221109143929.png" alt=""></p><ol start="3"><li><p>进入页面下载即可，详细介绍这里就这里不贴图了，低调低调，另外脚本的介绍页还藏了福利，不想错过请仔细阅读</p></li><li><p>进入到自己想要下载视频的页面<s>先来个一键三连</s>，然后就可以看到下载视频的按钮，点击之：</p></li></ol><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20221109144052.png" alt=""></p><ol start="5"><li>进入下面的页面需要做这几件事情：</li></ol><ul><li>安装下面提到的依赖软件</li><li>把RPC网址进行切换</li><li>设置自己的下载位置</li><li>全选批量下载，然后等待即可。</li></ul><p><strong>默认RPC默认地址</strong><br>(1)、Motrix RPC默认地址：ws://localhost:16800/jsonrpc<br>(2)、Aria2 RPC默认地址：ws://localhost:6800/jsonrpc</p><h1 id="依赖软件"><a href="#依赖软件" class="headerlink" title="依赖软件"></a>依赖软件</h1><h2 id="Motrix"><a href="#Motrix" class="headerlink" title="Motrix"></a>Motrix</h2><p>简单好用的开源软件： <span class="exturl" data-url="aHR0cHM6Ly9tb3RyaXguYXBwL3poLUNOLw==" title="https://motrix.app/zh-CN/">Motrix<i class="fa fa-external-link"></i></span>。有点像绿色版某雷。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20221109150021.png" alt=""></p><p>安装之后的下载效果如下：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20221109140515.png" alt=""></p><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>虽然B站下载器也可以做到，但是个人更喜欢网页无缝下载。另外插件介绍里面也提示了不单单是B站下载视频，个人没那么多心思去折腾其他网站，这里就留给读者自己尝试了</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      B站下载视频
    
    </summary>
    
    
      <category term="其他" scheme="https://whitestore.top/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="其他" scheme="https://whitestore.top/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>14岁懂社会 -《虽然人人都说暴力不好》读书笔记</title>
    <link href="https://whitestore.top/2022/11/09/suiranrenren/"/>
    <id>https://whitestore.top/2022/11/09/suiranrenren/</id>
    <published>2022-11-08T22:38:00.000Z</published>
    <updated>2022-11-16T03:04:34.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="14岁懂社会-14岁懂社会-《虽然人人都说暴力不好》读书笔记"><a href="#14岁懂社会-14岁懂社会-《虽然人人都说暴力不好》读书笔记" class="headerlink" title="#14岁懂社会 14岁懂社会 -《虽然人人都说暴力不好》读书笔记"></a>#14岁懂社会 14岁懂社会 -《虽然人人都说暴力不好》读书笔记</h1><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220912211411.png" alt="封面"></p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>不知道能否发出这篇文章出来，斗胆试一下。</p><p>很久没写非技术的内容了，这次写一个长文读书笔记。书名叫做《虽然人人都说暴力不好》，但是实际上人人内心并不反对暴力（我自己加的）。</p><p>这本书给14岁的学生看未免有点过早，它具备一定的深度，以这本书为媒介，可以借此拓展出很多有意思的话题，比如国家和暴力，道德和法律，暴力和自我意识，政治世界和国家的本质等。</p><p>这本书的笔记会涉及一些哲学讨论，如果觉得枯燥可以看结尾的“国家的本质”部分。</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>这本书是个人认为《14岁懂社会》整个系列里面最需要反思的一本书，作者从儿时受到体罚的暴力体验，到阐述暴力的讨论，从杀人是否合法，到引入了三位大人物：康德、霍布斯、黑格尔，讲述他们的思想和暴力的关联。</p><p>以康德的“定言命令式”作为出发点，讲述了客观唯心的道德观，但是缺乏理论支持，霍布斯的社会契约论，虽然具备一定的思想觉醒，但本身依然以教皇派的天赋人权为思想核心，就和儒家思想成汉文化的历史渊源，最终却是统治者的思想控制工具。</p><p>黑格尔的“自我意识”正好揭露了国家机器诞生的核心，讲述了国家这个机器的本质，最后作者告诉你如何正确的看待暴力本身。</p><p>以上就是这本书讲的大致内容。</p><h1 id="个人评价"><a href="#个人评价" class="headerlink" title="个人评价"></a>个人评价</h1><p>比较有意思的书，通过这本书可以了解暴力究竟是如何定义的，以及如何对待暴力这一中性的事物，我们可以了解到康德的“定言命令式”，黑格尔的“自我意识”的一些重点。</p><p>霍布斯的“社会契约论”缺陷和不足，他们的思想斗争以及观点都具备鲜明的时代色彩，作为不懂哲学的我，作者用形象的语言介绍的十分有趣，实在没有想到一本小小的青少年读物居然会上升到哲学。</p><p>个人认为这本书比较适合作为《人类简史》的补充，也适合作为看另一本书《枪炮细菌与钢铁》的引导（但不建议看中文，翻译差）。</p><p>国家成为了权力机关，在不自觉的剥夺了人类暴力行为本身，这究竟是如何做到的？归根结底是工业革命带来枪支火药的热兵器，也促成了长久稳定国家的形成，从另一个角度看，国家是科技发展的必然产物，也是进化的必然 ，国家会以各种形式存在，并不会消亡。</p><p>很多时候，事物发展的规律是多方面的，作者在阐述中用辩证角度开放的回答了一些哲人的观点，这又让我想到了《非暴力沟通》的区分情感与评论，这本书出色之处就在于情感的剥离和评论的客观性，而客观性的论述让人更让人具有反思性。</p><h1 id="个人语录"><a href="#个人语录" class="headerlink" title="个人语录"></a>个人语录</h1><p>个人认为这本书一些值得思考和推敲的话题：</p><ul><li>如果违法不被以同样的对待和同情，正义也会变为伪装暴力的工具。</li><li>如果行为被绝对的道德标准论断，那么事实往往会被掩盖和隐藏。</li><li>如果暴力以道德标准作为行使与衡量，那么法律和秩序稳定将同时失去。</li><li>国家实质是暴力的集合体，但是用暴力手段推翻国家往往滋生暴力（恐怖分子推翻政府）。所谓物极必反，当暴力甚至会影响自身的存在，换来的却更有可能是去安全和稳定的生活（核武器）。</li><li>康德的定言命令式，试图给道德和暴力明确的定义，但是其本身没法自洽，康德本人也无法回答道德本身违背定言命令式这一命题。</li><li>霍布斯的社会契约论，把国家的发展看作是“自然现象”和“获得契约”，“获得契约”具备一定局限性，但是有一定现实意义。</li><li>黑格尔揭露国家诞生的另一种观点：寻求“认可”的阶级斗争，直到一方倒下认可，斗争不会结束。</li><li>实质现代观念上的国家，是以工业革命为开端，我们现代人的国家理念实质只有4、500年的历史，也就是枪炮细菌和钢铁罪恶的开始。</li><li>正是因为我们生活在不是非黑即白的世界，所以我们必然生活在政治世界的斗争当中。</li></ul><h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p>访问链接：<span class="exturl" data-url="aHR0cHM6Ly93d3cubXVidWNtLmNvbS9kb2MvNVVXS29wRE5tOFI=" title="https://www.mubucm.com/doc/5UWKopDNm8R">https://www.mubucm.com/doc/5UWKopDNm8R<i class="fa fa-external-link"></i></span></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/%E3%80%8A%E8%99%BD%E7%84%B6%E4%BA%BA%E4%BA%BA%E9%83%BD%E8%AF%B4%E6%9A%B4%E5%8A%9B%E4%B8%8D%E5%A5%BD%E3%80%8B.png" alt="《虽然人人都说暴力不好》思维导图"></p><h1 id="暴力的好坏评判"><a href="#暴力的好坏评判" class="headerlink" title="暴力的好坏评判"></a>暴力的好坏评判</h1><p>第一章节我们可以获得下面的一些观点：</p><p>第一个观点，作者开头引入了为什么人人都反对暴力，学校却很严厉的体罚惩罚不听话的学生？正所谓欲加之罪，何患无辞，惩罚的理由有千万个，作者在小时候受到了无声的暴力对待，这是这本书作者思考暴力为何物以及后续延伸的索引。</p><p>第二个观点，为了保护重要的人，有时候不得不动用暴力。为了抵挡暴力，我们有时候也必须动用暴力，暴力是一个不好也不坏的东西，极端的反对暴力，人们甚至会选择遏制自己的欲望，比如有的地方不吃猪肉，有的地方只吃素食，当然另一端也有极端的赞同暴力，演变成遭人利用的战争机器，比如法西斯。</p><blockquote><p>法西斯是人文主义走向极端的一种体现。</p></blockquote><p>第三个观点，虽然大部分人看上去都讨厌暴力，内心却又十分接受它的存在，这是隐藏在内心的阴暗面。暴力本身和金钱一样，是让人又爱又恨的东西，人作为生物不可避免的渴望杀戮和血腥，但是人活在国家的框架之下，发挥的永远是被授予的正当的执行暴力的权利，暴力实际上是被“赋予”的而不是“与生俱来”的，这一点会在本书的后文讨论。</p><p>第四个观点，道德和法律以及人类社会环境的约束，造成人类和谐社会的根本。实际上人作为生物，人类本身活着其实就是暴力，吃肉就是对于动物的暴力，吃蔬菜是对植物的暴力。暴力本身一直无处不在。</p><p>所以暴力的好坏是无法评判的，为了生存，人类和所有生物一样，从来不会觉得这是“不好的事情”，也不会认为这是“好事情”。暴力只因主观因素决定，跟随主观内心。</p><p>既然暴力不可取但是又没有明确的道德约束，那么为什么不能杀人呢？作为人的争斗，为什么仅仅限于求出结果而不是殊死搏斗？</p><h1 id="为什么不能杀人？"><a href="#为什么不能杀人？" class="headerlink" title="为什么不能杀人？"></a>为什么不能杀人？</h1><p>暴力本身没有理论支持，那么为什么不能杀人？</p><p>人言可畏，言语有时候会成为强大的力量，人们恐惧言语的力量胜过行使暴力。但是单凭言语是力量过于弱小，因为人可以安慰自己行使暴力加害他人，国家依靠法律约束暴力的泛滥，给为“不能杀人”这一点给了绝对的限制理由。</p><p>但法律实际上也会允许杀人，法律通过正当的理由和正当的程序形式，杀人便成了“好”的了，对于受害者来说，这是一件“好事”，但是对于公众来说，这样的法律本身十分危险，法律应该有尺度和约束的牢笼，但是国家权力才是被作为丈量万物的“尺度”，这样本身是否矛盾的，这也是为什么法治体现了国家的治国之本。</p><p>所以说杀人不对？还是说暴力也不对？如果严格按照道德标准评判杀人的好坏，那么道德标准无法自洽，人人虽然都反对杀人，但是人人却又喜欢“杀人”，不能杀人看似是根深蒂固都道德标准，实际上更大程度是因为暴力行为本身受到控制和受到裁定。</p><p>此外，言语并非完全无用，否则教育会失去其本身意义，教育需要引导孩子做出正确的行为，符合安稳和平社会的意愿生存。但是又因为此种原因从小到大灌输不反抗的观念，而看不见暴力，逐渐变得顺从，顺从则会滋生暴力。</p><p>不能因为看不见的暴力，而成为“绵羊”，完全拒绝暴力本身就是不可取的，这是底线，这并不是不可动用的武器，在任何情况下，都要有明辨是非的心。</p><p>所以为什么不能杀人？说白了实质上还是取决于国家所制定的法律约束框架，和个人情感无关，有的国家甚至为了金钱可以舍弃一切。个人的意志约束虽然能起到一定的作用，但是究其原因，取决于国家的“操盘者”如何设计。</p><p>这里举个例子，在中国个人持枪是不被允许存在的“极端恐怖分子”，而在美国一个家庭持有几把手枪却是再正常不过的行为，从我们的国家角度看，持枪是“暴力”行为，以此推断”为什么不能杀人？“这一理由，其实并不是我们自己说了算。</p><p>道德本身是由社会环境诞生的产物，是一种<strong>客观唯心主义</strong>的存在。有了国家的掌控，道德还有什么用？道德又该如何定义？康德的“定言命令式”给出了他的答案。</p><h1 id="康德的“定言命令式”"><a href="#康德的“定言命令式”" class="headerlink" title="康德的“定言命令式”"></a>康德的“定言命令式”</h1><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><p>定言命令式，是德意志哲学家康德在1785年出版的《道德形而上学的基础》一书中所提出的哲学概念。</p><p>下面的内容引自维基：</p><blockquote><p>康德认为，道德完全先天地存在于人的理性之中。只有因基于道德的义务感而做出的行为，方存在道德价值。因心地善良而做出的义举，或是因义务而做出的德行（譬如军人因救灾而牺牲），都不能算作真正有德的行为。</p><p>道德应当，而且只应当从规律概念中引申演绎而来。尽管自然界中的一切事物都遵循某种规律，但只有理性生物（人）才具有按照规律的理念而行动的能力（自由意志）。就客观原则对意志的约束规范而言，其命令尽管是强制的，但同时也是理性的。这种理性命令的程式，就叫作“令式”。</p><p>令式有两种。如果某种行为无关于任何目的，而出<strong>自纯粹客观的必然性</strong>，那么这种令式才是“定言令式”。如果<strong>行为是实现目的的手段</strong>，则被康德称为“假言令式”。</p></blockquote><p>在这本书中，作者对于“定言命令式”的理解是：定言命令式是道德基础，所谓的定言命令式，就是 <strong>不以人的意志转移，无论何时何地，都只基于道德的义务感</strong> ，强行做某事或者不做某事的<strong>道德律</strong>。</p><p>比如：“不行就是不行”就是简单的道德定言命令式，但是“不想被抓就不要偷东西”这不是定言命令式，因为“不想被抓就不要偷东西”，可以有很多的反对说法，”只要不被抓到就可以偷东西”这就是彻头彻尾的主观唯心主义。</p><p>定言命令式实质是“不行就是不行”，指的是康德认为的定言命令式是不需要理由的，比如“不能杀人”是道德律，“为什么杀人是不对的”这不需要理由，“不行就是不行”，从这一点可以看出，<strong>道德是建立一种无法为行为寻找理由的基础上建立的</strong>，道德并不是对于行为的约束，更像是对于行为本身的直接否定。</p><h2 id="“定言命令式”-站不住脚"><a href="#“定言命令式”-站不住脚" class="headerlink" title="“定言命令式” 站不住脚"></a>“定言命令式” 站不住脚</h2><p>但是事情并没有结束，康德在后续的著作中又赞成死刑，他认为如果不通过刑法将人处死，将无法实现正义。</p><p>为什么这么说？这不是自相矛盾么？个人理解是康德自身认为杀人偿命本身也是定言命令式，贯彻死刑并不是为了通过死刑维护道德律，而是通过死刑实现正义，所谓正义是维持道德律的基本条件。</p><p>这就又回到了“不行就是不行”这一定言命令式，因为不能用死刑来满足受害者的“私欲”，也不能用死刑来作为制约犯罪的条件，所以法律需要给受害人和加害人同样的尊重，用死刑制裁杀人犯和道德律以及任何理由无关。</p><p>但是显然这一套说法本身没法自圆其说，既说“不行就是不行”，又说“杀人应当偿命”，显然康德的这一套说法属于“客观唯心主义”，禁不住理论的推敲和考验，康德本身也陷入到了关于这个定言命令式的争论当中。</p><p>康德在不同的时间点产生了不同的说法，归根结底是 <strong>道德没有任何理论支撑</strong>，之所以失去理论支撑，是因为道德只在某种特定环境下产生，比如国家管辖之下的法律，才能真正的控制住暴力滋生。</p><p>比如，如果一个人为了生存而必须自相残杀，基于生存条件他必须做出违背“定言命令式”的行为，所以这也就违背了道德，康德这时候的”赞成死刑“，也同样是违背了道德剥脱了别人的生存权，所以道德本身就是在违背定言命令式进行工作的。 </p><p>所以”定言命令式“是站不住脚的，因为要”定言命令式“要让人相信，就必须要“无条件”，但是无条件显然是不可能的，因为无法为道德赋予任何理论，也无法用言语解释道德究竟是什么。无法讨论道德的存在，是因为道德是给予人这种客观存在而诞生的“社会意识”，就好比理性并不是先天诞生于内心，而是以社会生活存在的基础上而出现的“约束”。</p><p>光凭道德是站不住脚的，所以才需要法律去约束道德，道德本身只能看作是”调味品”，取决于环境对于人格的约束，而法律诞生自国家这一个机器，国家是“巨大的谎言”，他比道德更具备“欺骗性”。</p><p>道德本身没有理论支持，康德的发言显然是存在矛盾的，需要具体情况具体分析。所以为什么要讲这么多关于哲学的东西？因为这和后面讨论的国家有关。</p><p>接下来我们再看看霍布斯的社会契约论。</p><h1 id="霍布斯的“社会契约论”"><a href="#霍布斯的“社会契约论”" class="headerlink" title="霍布斯的“社会契约论”"></a>霍布斯的“社会契约论”</h1><p>在引出霍布斯的社会契约论之前，先来看看作者在书中讲述的丰城秀吉刀狩令”。</p><h2 id="引子：刀狩令"><a href="#引子：刀狩令" class="headerlink" title="引子：刀狩令"></a>引子：刀狩令</h2><p>刀狩令指的是日本历史上没收武士以外的僧侣和平民所拥有武器的政策。该政策最早是在镰仓时代实施，而最为有名的刀狩令则是丰臣政权于1588年（天正16年）所实施的刀狩令。</p><p>秀吉的刀狩令是以解除百姓的武装为目的，以农村存在的武器为前提，从百姓手中夺取带刀的权利。但是实质上刀狩令更多是在表面上推行，因为它针对的只是冷兵器，并没有禁止平民拥有热兵器，比如持有其他枪，弓箭和以驱除害兽为目的的铁炮，以及祭祀用的武器是被允许的。</p><p>这里肯定会有疑问，百姓都能私藏火药了，刀狩令的意义是什么？刀狩令更多的意义是赋予了“<strong>绝对的阶级</strong>”观念，武士拥有持刀权利，平民便会把持刀看作身份象征，进而产生了身份制度，由身份制度而逐渐演化为阶级，而阶级的目标则是建立和平昌盛的，任自己掌控的“太平天国”，国家也由此诞生而巩固。</p><p><strong>刀狩令本质是将人划分为“可以行使暴力的人”和“不可以行使暴力权利的人”</strong>，然而这种推进实质上更像是社会契约，但是这种契约在当时还比较弱</p><h2 id="社会契约论"><a href="#社会契约论" class="headerlink" title="社会契约论"></a>社会契约论</h2><p>霍布斯的国家理论是从一种假想的“自然状态”入手的，在国家产生之前的这种自然状态中，人们都依据自然法而享有各种天赋的自然权利。他在《利维坦》中系统论述的社会契约论思想、君权民授理论和天赋权利学说，奠定了西方近代政治学的基础。</p><p>霍布斯的社会契约中把国家的形成，看作是“自然的联邦”和“获得的联邦”。</p><p>“<strong>自然的联邦</strong>”：可以看作是一位强者把所有人的暴力收归于一体，强者和所有人建立一种安稳秩序的契约关系，所有人的暴力由一个人掌控，实质是“天赋人权”，天赋君权的思想。</p><p>“<strong>获得的联邦</strong>”：说明了权力是由于弱者一方“赠予”强者一方，难听点就是强者一方强制剥夺弱者的暴力权利，让弱者依附于强者本身存在。 </p><p>显然“获得的联邦”才是现实，也道出了国家起源的本质，而“自然联邦”则成为了胜利者的宣传工具。社会契约论是暴力终结和权力归一的开始，由“获得的联邦”逐渐演化出阶级，社会契约论简单来说是指暴力权力能够在自然契约的状态下，由部分群体拥有制裁的权力。</p><p>所以霍布斯的理论并不是毫无意义的，但是西方政治学把 <strong>自然的联邦</strong> 这一套作为“粉饰”工具，掩盖国家机器的“罪恶”一生。以此作为政治思想传输和思想控制的一种手段和工具，霍布斯的部分理论实质已经十分接近真相本身。</p><h1 id="黑格尔的“自我意识”"><a href="#黑格尔的“自我意识”" class="headerlink" title="黑格尔的“自我意识”"></a>黑格尔的“自我意识”</h1><p>和霍布斯的“顺其自然”不同，黑格尔揭露了国家起源的丑恶本质：<strong>国家的起源来源于不间断的斗争，直到一方承认和服从</strong>。</p><p>所谓自我意识，指的是为了要得到某样东西，必须要与另一方进行斗争，为了斗争则需要强迫对方屈服战斗到最后一刻，为了战斗到最后一刻。</p><p>这一观点由黑格尔提出，他最初的论断是两个人对于同一事物的争斗，其中一方最终总会屈服于另一方，只有最为勇敢和战斗到底的一方可以获得胜利，也就是所谓的“<strong>精神胜利法</strong>”，黑格尔以此推导出国家起源的过程。</p><p>黑格尔的“自我意识”有什么意义呢？关键是阐述了<strong>暴力和权力的认可与连接</strong>，无论是权力和权利，本身都不是因为设立而存在的，而是因为<strong>认同</strong>而存在，斗争胜利的一方获得权力，而斗争失败的一方选择服从并且获得被授予和被控制的权利。作为生物的暴力的实践活动，本身就是为了获得“认可”这一目的本身。</p><p>所以黑格尔的思想，既包含了社会契约本身，又包含了对于暴力哲学的解释。因为自我意识的存在，不同的组织之间必然会斗争，而产生斗争则必然引出政治世界。</p><p>何谓政治世界？政治世界就是<strong>树立谁可以对其使用暴力和谁不能对其使用暴力</strong>，是否意味着政治世界就是所谓的非黑即白，彼此充满斗争呢？这么说肯定是不对的，正是因为我们生活在不是非黑即白的世界，所以我们必然生活在政治世界的斗争当中，这句话值得推敲。</p><h1 id="国家的本质"><a href="#国家的本质" class="headerlink" title="国家的本质"></a>国家的本质</h1><p>国家的本质实质是暴力的权力中枢，从这一点看国家本身就不是干净的产物，但是否定和肯定暴力或者批判暴力也好，暴力本身并不会因为国家灭亡消失而消失，我们身处国家管辖之下，就无时无刻身处暴力之中，只不过暴力被约束和限制。</p><p>所以国家的本质需要面对暴力观念的本身，我们分为“国家和暴力”、“国家的形成”、“税收的本质”三个方面讨论。</p><h2 id="国家和暴力"><a href="#国家和暴力" class="headerlink" title="国家和暴力"></a>国家和暴力</h2><p>广义上说暴力是基于财富的争端开始，也是国家形成的开始，而枪支弹药是决定暴力合而为一归于国家管控的的关键，古代皇帝之所以无法完整统一，是因为暴力有可能滋生在小团体，并且逐渐被无限放大，或者通过分封权力被逐渐瓦解，最终自然溃散。只有权力完全不会溢出，才有可能导致暴力的正常控制，国家才能够真正的正常运转。</p><p>运用暴力取代一个国家，为了压制国家本身的暴力，是在用道德标准呼吁更大的暴力，那么只会滋生更加暴力和专制的国家，这种假的“定言命令式”造成更黑暗的暴力滋生，所以不要因为国家这一“黑暗”的存在，而出现了推翻国家的想法，因为 <strong>“恶”一旦滋生，只会被越放越大</strong>。</p><p>但是话说回来，国家统治的基础是推翻是建立另一个国家或者组织，如果一方可以以暴力完全侵占另一方，那么暴力演变为武器是自然而然的，枪炮和钢铁带来的长久稳定的国家，行使暴力的代价加大，越是小心谨慎。</p><p>我们不能因为暴力受到国家统治。而以此作为反对国家暴力的道德论断，如果行为被绝对的道德标准论断，那么事实往往会被掩盖和隐藏。</p><p>综上所述，国家的合并是由于暴力权力掌握在少部分人手中得以实现，也就是说真理必然掌握在少数人手中。</p><h2 id="国家的形成"><a href="#国家的形成" class="headerlink" title="国家的形成"></a>国家的形成</h2><p>我们结合前面的内容，从康德、霍布斯和黑格尔的观点看国家的形成。</p><p>国家暴力通常都是由分散到统一，在国家没有形成之前，暴力分散在小部分集体手中，可能是村落，也能是地区。在古代，因为暴力实际上是很难完全控制的，因为冷兵器可以被轻易造出来，而到了热兵器时代，枪支制造本身就需要一定的技术，同时只要控制材料的获取，制造枪支也是无米之炊。</p><p>所以热兵器就像是武士刀一样，掌握在一部分人手中，于是身份和阶级诞生产生了所谓的精神胜利力量，进而集团和势力的诞生，再之后则是国家的诞生。</p><p>康德用定言命令式论断暴力本身，但是他的理论始终无法将道德本身和定言命令式自洽， 更多的是自相矛盾。</p><p>虽然国家的诞生包含复杂的历史原因和人文社会原因，但是归根结底，就是暴力由分散到统一的过程。</p><h2 id="税收的本质"><a href="#税收的本质" class="headerlink" title="税收的本质"></a>税收的本质</h2><p>那么国家是如何收税的呢？国家将暴力按照合法和不合法的分开，才能合理的征税，如果没有任何法律约束进行合法的暴力征收，那么国家和黑社会的对等性将会消失，国家和黑社会也会变得没有什么不同，这时候将会有反对的声音存在。</p><p>税收的本质是，国家掌握暴力权力保护底层人民的合法安全的维持秩序的手段，和黑社会的本质区别是，<strong>税收不需要声明或者证明自己的存在</strong>，而是属于一种<strong>自愿被剥夺行为</strong>，当然国家更多时候会动用一系列措施，让公民找不到借口避税，但是避税和收税始终是无法完全避免。</p><h1 id="如何看待暴力"><a href="#如何看待暴力" class="headerlink" title="如何看待暴力"></a>如何看待暴力</h1><p>评判暴力不应该以道德作为天平，而应该衡量如何利用国家机器更好的管理暴力，如何制衡社会中的暴力行为。</p><p>取代国家是不可取的，因为”黑恶势力“总会乘虚而入，就好像古代皇帝的椅子永远都是有人坐的，既然国家作为暴力的中枢本身无法替代，那么就应当积极应对国家做出的调整和改变，不管如何看待，作为普通人最终永远只能选择接受。</p><p>抛开国家这个机器失控不谈，我们生活实际上本身无法脱离暴力，因为有些事情只能通过暴力的手段去解决，我们需要的是不评价不站队的去看待暴力本身，也就是现在常说的”理中客“。</p><p>恶意是可怕的，这时常让我想起泰戈尔诗中那个存在阴暗面的罪恶的自己，同时也让我直接想到了《恶意》这本书。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这篇读书笔记内容很多，写的比较啰嗦，很多哲学的内容需要不断形象概括和理解，当然这也是这本书的有趣之处，作者中性的论述和严谨求证值得学习，总结就是学到了不少”奇怪“的知识，认识了三个奇怪的哲人，哈哈。</p><p>两月没写非技术的读书笔记了，希望这篇没有辜负读者期望。</p><p>最后，这篇文章收录到：<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vbGF6eVRpbWVzL2Fkb25nLXN0dWR5Tm90ZXM=" title="https://gitee.com/lazyTimes/adong-studyNotes">阿东的书屋: 个人的读书笔记归档，欢迎同样爱看书的小伙伴一起共读。 欢迎关注公众号：懒时小窝 (gitee.com)<i class="fa fa-external-link"></i></span> 这个项目中，所属目录是“2022-09”，也可以在PC端直接搜标题名称找到对应的位置。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      虽然人人都说暴力不好
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://whitestore.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="书籍" scheme="https://whitestore.top/tags/%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>【科普】蓝思值是什么？</title>
    <link href="https://whitestore.top/2022/09/07/lansizhi/"/>
    <id>https://whitestore.top/2022/09/07/lansizhi/</id>
    <published>2022-09-07T13:26:56.000Z</published>
    <updated>2022-09-08T02:18:34.397Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【科普】蓝思值是什么？"><a href="#【科普】蓝思值是什么？" class="headerlink" title="【科普】蓝思值是什么？"></a>【科普】蓝思值是什么？</h1><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>如果你喜欢并且想要看一些英文书或者原著，或者想要提升英语水平，那么阅读这些内容都会有帮助。</p><p>原文：<span class="exturl" data-url="aHR0cHM6Ly93d3cuc3R1ZHl0b3VyYS5jb20vbGV4aWxlLw==" title="https://www.studytoura.com/lexile/">https://www.studytoura.com/lexile/<i class="fa fa-external-link"></i></span>，本文为阅读完这篇文章之后的一些个人笔记。</p><a id="more"></a><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>蓝思阅读体系最初由A. Jackson Stenner和Malbert Smith博士创立于1989年，旨在为<strong>阅读</strong>和<strong>写作</strong>提供更加精准的<strong>测评</strong>系统。</p><p>也就是说可以认为是测试系统，所有的内容都只是依据，不能过度依赖。</p><p>所谓的蓝思值可以简单认为是综合多项指标构建的一套<strong>英文材料阅读能力的分级制度</strong>。划分依据主要是对比一个文章或者一本书当中<strong>重复单词的数量</strong>出现的频率，可以简单理解为一句英文当中，如果出现的重复单词很多，蓝思值会普遍比较低，反之则很高。</p><p>这里我们常常会陷入一个误区，认为书越厚的书蓝思值越高。实际上这种观念是错的，比如《哈利波特》虽然字很多，但是实际上句子不是特别难理解，而个人之前所看的名著《老人与海》，虽然看着100多页，但是蓝思值高达940！因为海明威这老头写书喜欢整很多生僻词。</p><p>所以实际上任何国家的语言都一样，虽然创造发明的文字很多，但是实际上生活中用来用去的也就那些单词，难懂的书不仅仅是语法上的复杂，生僻词和不重复单词的使用也是非常关键的。</p><p>此外从这些依据我们可以直接了解到，如果我们能通读蓝思值高的书，那么毫无疑问单词量和语法掌握程度肯定很高，反之，还需要回去练练，这很直观的体现了蓝思值的作用和意义。</p><p>光文字不够直观，这里直接给一张图，这个图实际上<strong>心理安慰成分比较大</strong>，实际上以中国应试教育，绝大多数人哪怕大学过了英语四级，只要生活不使用英语，要不了多少时间就会直线退化到美国小学一年级水平：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220907122440.png" alt=""></p><p>当然也不需要过分的纠结蓝思值以及去对号入座，这只是一个参考值帮助你更好的寻找自己适合的读物而已。</p><h1 id="有什么用？"><a href="#有什么用？" class="headerlink" title="有什么用？"></a>有什么用？</h1><p>蓝思值的根本作用是 <strong>找到你的学习区，拒绝舒适区，避开困难区</strong>。但是这些标准都是以美国人的标准进行衡量的，作为非母语语言英语学习和阅读者，蓝思值的下限通常会更低。</p><p>蓝思值在美国还是受到认可的，各个大洲基本都有流行和普及，也推广到了国外，如果没有阅读英文书或者英文材料的习惯，大概率是不知道有这个东西的（比如我也是阅读相关文章之后才了解到有这东西）。</p><p>此外个人实际使用之后发现阅读英语材料提升有帮助的，至少可以给自己一个坚持的理由，根据自己的水平调高或者调低目标要求，我们可以把自己想要看的书用蓝思值进行标记，然后再进行分类，按照书的难易程度进行划分阅读，这样可以保持坚持读英语的习惯。</p><h1 id="怎么用？"><a href="#怎么用？" class="headerlink" title="怎么用？"></a>怎么用？</h1><p>查找方式如下：</p><p>登录到网站：<span class="exturl" data-url="aHR0cHM6Ly9odWIubGV4aWxlLmNvbS9maW5kLWEtYm9vay9zZWFyY2g=" title="https://hub.lexile.com/find-a-book/search">https://hub.lexile.com/find-a-book/search<i class="fa fa-external-link"></i></span></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220907161705.png" alt=""></p><p>比如我用《Tuesdays With Morrie》这本书去搜索这本书的蓝思值。</p><p>网站标注的蓝思值还是挺高的，但是实际上这本书当中有很多对话，个人认为并不认为十分难懂，算是好读的书。个人认为难的部分是在老师讲的很多机翻也，以及比较难理解的深刻道理上，这本书和ALS牵扯有很多医学方面的单词出现，所以很可能会划定比较难的一类。</p><p>如果有Ipad，我们使用Ipad上的<strong>蒙哥阅读器</strong>查一下这本书就会发现，有将近一半的单词在英语4级的水平以下，20%的内容属于4级水平，所以也不需要过多信任或者纠结蓝思值的高低，更建议 <strong>眼见为实</strong>。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220907121644.png" alt=""></p><p>还有一种方法是直接根据搜索条件进行搜索。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220907161947.png" alt=""></p><p>比如我找到 100 - 200蓝思值的动物分类的书籍。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220907162053.png" alt=""></p><p>就会出现一些幼儿园的小朋友都可以看懂的书，还挺有意思的。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220907162040.png" alt=""></p><blockquote><p>搜索条件中有一个条件下拉框，内容是K1,123456，这些内容不是国内四六级的标准，是人家美国人的标准，切记不要将国人思维带进去。</p></blockquote><h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><h2 id="如何评估或提高自身水平？"><a href="#如何评估或提高自身水平？" class="headerlink" title="如何评估或提高自身水平？"></a>如何评估或提高自身水平？</h2><p>对于美国人来说，这些网站用起来如鱼得水，但是对于我们来说却是不一样的。一般来讲，一篇文章如果看下来<strong>生词在0-25%区间</strong>，内容也大概理解，基本上就是落在学习区的书籍。</p><p>据调查，一个普通美国人接受良好教育的情况下，词汇量通常是再 2万到3万的区间，也就是说我们要达到美国成年人，起步的词汇量就需要追上2万这个大卡。</p><p><strong>这是很难得</strong>！因为我说的是美国成人的水平，人家从出生到成年用了20年，可以用生活和环境自动学习很多东西，这些在国内几乎是没法实现的，你也没有那么多20年。</p><p>所以实际上你只需要追求到<strong>美国高中生的水平</strong>，你也可以看懂大部分的读物，无论是工作还是生活都够用，因为仅仅是追上美国高中生这一点就很难。</p><p>此外时蓝思值要活学活用，比如网站中的搜索条件中的K1,12345并不是指的英语级别，而是美国本土学院的年龄段和蓝思值对应表，用数字划分区间更简洁一些。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220907163721.png" alt=""></p><h2 id="吐槽：谨慎选择"><a href="#吐槽：谨慎选择" class="headerlink" title="吐槽：谨慎选择"></a>吐槽：谨慎选择</h2><p>TNND，《老人与海》作为世界名著不是盖的，煎熬着看了两个月啃完不容易，所以大家不要学我，一定要找适合自己的书看，个人喜欢死钻牛角尖，哪怕一大堆生词的书也会又倔又犟的努力看懂，英文书一旦开始看很难停下来。</p><p>但是现在想想自己真是<code>fool</code>，白白浪费了很多时间。但是偶尔在困难区锻炼会很有干劲，经验之谈。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220907162350.png" alt=""></p><h2 id="蓝思值标识"><a href="#蓝思值标识" class="headerlink" title="蓝思值标识"></a>蓝思值标识</h2><p>因为蓝思值是作为美国教育儿童的一项指标参考之一，所以再蓝思值上面还会有一些标记，个人感觉对于没受到过美国学习教育的“外国人”启发意义不是很大，说白了就是看不懂，所以放到最后了。</p><p><strong>AD: Adult Directed</strong> <strong>成人指导</strong>： 标注有AD的文本（多为图画书）里面的图片虽然可以辅助孩子理解，但其生词数以及文本编排等可能会影响孩子阅读。所以官方建议成人朗读给孩子听，边朗读边解释，而不是让孩子自主阅读。</p><p><strong>NC: Non-Conforming</strong> <strong>非标准</strong>：标注有NC的文本更适合阅读能力较强，蓝思值超越所在年龄段普遍水平的学员。这类文本蓝思值较高，但文本内容适合所在年龄段。</p><p><strong>HL: High-Low</strong> <strong>高兴趣低可读性</strong>：标注有HL的文本更适合阅读能力较弱，蓝思值低于所在年龄段普遍水平的学员。这类文本蓝思值较低，但文本内容适合所在年龄段。</p><h2 id="为什么要学英语？"><a href="#为什么要学英语？" class="headerlink" title="为什么要学英语？"></a>为什么要学英语？</h2><p>过去的一些记录，看看就好，个人始终认为只要互联网存在一天，学英语就是有价值的事情。</p><ul><li><strong>互联网是美国人发明的！互联网是美国人发明的！互联网是美国人发明的！</strong> 这个理由够不够。</li><li>Stack flow 是技术圈最顶尖的技术论坛，编程上99%的问题你都可以上面找到思路或者答案。 </li><li>知识不是凭空来的，只是你用中文搜不到而已。</li><li>尽信书不如无书，任何的二手资料，永远不如官方文档。就好比HTTP，RFC里面做了很多规定，主流浏览器大部分时候都是遵照协议实现的，互联网发展到今天，靠的是标准的“强制执行”。</li><li>翻译软件是工具，不是看不懂英文搬出来解决问题的再生父母。 </li><li>《JAVA编程思想》，被翻译搞臭的一本的好书，被翻译烂的书就是在害人，误人子弟，就应该口诛笔伐。 - 我所见的高手，没有英语差的。 </li><li>我们现在所学的东西，人家老外可能十几年就学的很深并且写出博客了=-=</li></ul><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>蓝思值还是比较有用的指标，喜欢阅读英文书的同学可以试试用网站测试一下。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      蓝思值和相关科普
    
    </summary>
    
    
      <category term="其他" scheme="https://whitestore.top/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="其他" scheme="https://whitestore.top/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】拿到一台虚拟机Linux该干什么？</title>
    <link href="https://whitestore.top/2022/09/07/linuxshould/"/>
    <id>https://whitestore.top/2022/09/07/linuxshould/</id>
    <published>2022-09-07T13:23:04.000Z</published>
    <updated>2022-09-08T02:18:34.397Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【Linux】拿到一台虚拟机Linux该干什么？"><a href="#【Linux】拿到一台虚拟机Linux该干什么？" class="headerlink" title="【Linux】拿到一台虚拟机Linux该干什么？"></a>【Linux】拿到一台虚拟机Linux该干什么？</h1><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>很多时候我们喜欢在自己电脑上装一台Linux虚拟机玩，但是每次装好之后基本都是两眼无神，不知道下一步干啥，所以这篇文章主要就是解决安装好Linux之后，建议做的一些操作，帮助快速构建本地可用环境。</p><p>本文演示的Linux版本为CenterOs7.9，使用的镜像是官方7.9的Miniual版本（也就是最小体积版本），VM Tool 的版本为16.2.3 build-19376536。整个过程步骤十分简单，比较适合新手使用。</p><a id="more"></a><h2 id="一、步骤"><a href="#一、步骤" class="headerlink" title="一、步骤"></a>一、步骤</h2><h2 id="1-1-虚拟机连接"><a href="#1-1-虚拟机连接" class="headerlink" title="1.1 虚拟机连接"></a>1.1 虚拟机连接</h2><p>通过虚拟机登录到LInux，切换Root角色，使用<code>sudo vi /etc/ssh/sshd_config</code>修改文件，注意不要改错文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/ssh/sshd_config</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改端口</span></span><br><span class="line">Port 10022</span><br><span class="line"><span class="meta">#</span><span class="bash"> 由于是新的Linux虚拟机，建议还是先保留22端口，等能正常用10022登陆再去掉，万一10022登不上就嗝屁了（并不会）</span></span><br><span class="line">Port 22</span><br><span class="line"><span class="meta">#</span><span class="bash"> 不允许 ROOT 登陆，不成文规定</span></span><br><span class="line">PermitRootLogin: no</span><br></pre></td></tr></table></figure><h2 id="1-2-禁止root登陆"><a href="#1-2-禁止root登陆" class="headerlink" title="1.2 禁止root登陆"></a>1.2 禁止root登陆</h2><p>执行命令<code>vi /etc/ssh/sshd_config</code>，找到<code>PermitRootLogin</code>，将后面的yes改为no。</p><p>记得把前面的注释 <code>#</code> 取消，这样root就不能远程登录了！通常用普通账号登录进去，要用到root的时候进入系统再使用命令<code>su root</code>。</p><p>也可以构建 <strong>给予sudo权限的用户</strong> 操作自己的虚拟机（下文介绍），总之就是不要Root直接登录。</p><p><code>vi</code> 命令是没有颜色提示的，所以如果想要更好的配置阅读体验，通常需要安装<code>vim</code>，命令<code>yum install vim -y</code>。</p><p>再次强调拿到虚拟机之后第一手操作是<strong>关闭Root登录</strong>，不管是否为本地LInux服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 不允许 ROOT 登陆</span><br><span class="line">PermitRootLogin: no</span><br></pre></td></tr></table></figure><p>修改完成之后的效果图：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220906164214.png" alt="改端口禁ROOT"></p><blockquote><p>如果找不到配置，检查是否修改的是<strong>ssh_config</strong>，而不是<strong>sshd_config</strong>文件！</p></blockquote><h2 id="1-3-改登录端口（ssh）"><a href="#1-3-改登录端口（ssh）" class="headerlink" title="1.3 改登录端口（ssh）"></a>1.3 改登录端口（ssh）</h2><p>临时新增端口方法不建议使用，这里记录改文件永久生效的办法。</p><p>因为是自己本地的虚拟机，所以直接图省事，把防火墙关闭，这样也不要老是去配端口。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>根据要求加上自己需要的端口，将<code>#Port 22</code>的注释去掉并且换行加入<code>Port 10022</code>，如果是不是增加而是想直接修改端口的话，这里<strong>建议先保留22端口，等新端口可以登录再去掉</strong>。</p><p>另外再介绍一下，443是https使用的端口，3128是squid使用的端口，一万以内的端口使用频率很高。</p><p>如果是自己使用建议使用大端口，比如10000~65535以上，基本不会有中间件和其他的冲突问题。</p><p>对于一些自己程序使用的端口，也是数建议千位数字前面加一个1,，基本可以保证不冲突。</p><p>修改完成之后一定要记得 <strong>重启ssh服务</strong>：<code>systemctl restart sshd.service</code>，或者直接重启虚拟机Linux系统。</p><h2 id="1-4-关闭linux内部防火墙"><a href="#1-4-关闭linux内部防火墙" class="headerlink" title="1.4 关闭linux内部防火墙"></a>1.4 关闭linux内部防火墙</h2><p><strong>检测自己添加了多少开放的端口</strong>  ：<code>firewall-cmd --zone=public --list-ports</code>。当然我这里演示是直接关掉防火墙，对外是畅通无阻的。</p><p>临时新增方法（不建议使用）：<code>firewall-cmd --zone=public --add-port=12280/tcp --permanent</code> ，<code>--permanent</code>就是让端口永久生效</p><p>不建议使用原因，第一个是不知道端口加来干嘛用的，后面容易忘，第二个是这个操作只能<strong>临时生效</strong>，重新启动又会还原。</p><blockquote><p>不建议使用的其他原因是执行此命令<strong>会把文件的所有注释清空</strong>！！</p></blockquote><p>注意改端口之后尝试外部连接是失效的，因为还有selinux和防火墙需要处理，这里依然图省事一并给他关了。</p><p>所以这里firewalld 的基本使用如下：</p><pre><code>启动：`systemctl start firewalld`关闭： `systemctl stop firewalld`查看状态：`systemctl status firewalld` 开机禁用  ： `systemctl disable firewalld`开机启用  ： `systemctl enable firewalld`</code></pre><p>我们需要关闭防火墙，当然这里只能在自己的虚拟机这么用，主要是减少自己捣鼓学习的时候避免各种不必要的麻烦，在真实的生产环境实际上更多情况是开启的。</p><p>此外如果是云服务器提供商，这个配置通常也是关闭的，取而代之的是在外部做了一个安全网。</p><p><strong>步骤</strong></p><p>使用<code>systemctl status firewalld</code>检查状态。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220523114235.png" alt=""></p><p>关闭<code>systemctl status firewalld.serivce</code>。</p><blockquote><p>这里有个挺蛋疼的踩坑点，感觉这块像是两个人写的（怪怪的），使用<code>systemctl stop firewalld</code>是临时关闭，重启之后防火墙又会自动打开，<code>systemctl status firewalld.serivce</code>是<strong>永久关闭防火墙服务</strong>。</p></blockquote><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220906162311.png" alt=""></p><h2 id="1-5-关闭-SeLinux"><a href="#1-5-关闭-SeLinux" class="headerlink" title="1.5 关闭 SeLinux"></a>1.5 关闭 SeLinux</h2><p><strong>简易解释</strong></p><p>关闭防火墙之后，接着是关闭 <strong>SeLinux</strong> 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 注意需要ROOT 权限</span></span><br><span class="line"> vi /etc/selinux/config</span><br><span class="line"><span class="meta">#</span><span class="bash">　将 SELINUX=disabled 表示关闭</span></span><br><span class="line">SELINUX=disabled</span><br></pre></td></tr></table></figure><p>操作完成之后使用 <code>:</code> 加上<code>-x</code> 保存，之后建议<code>reboot</code>一下。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220523112457.png" alt=""></p><blockquote><p> <strong>x 和 wq 的区别？</strong><br>       x 执行操作完毕，如果修改了文件，文件的最后修改时间会产生变化，没有，则不变化<br>       wq 执行操作完毕，不管文件有没有改动，最后修改时间都会产生变化</p></blockquote><p><strong>保姆解释</strong></p><p><strong>永久生效</strong>的方法，执行命令 <code>vi /etc/selinux/config</code> 【需要<strong>ROOT</strong>权限】，出现如下文本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> This file controls the state of SELinux on the system.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> SELINUX= can take one of these three values:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     enforcing - SELinux security policy is enforced.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     permissive - SELinux prints warnings instead of enforcing.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     disabled - No SELinux policy is loaded.</span></span><br><span class="line">SELINUX=enforcing</span><br><span class="line"><span class="meta">#</span><span class="bash"> SELINUXTYPE= can take one of three two values:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     targeted - Targeted processes are protected,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     minimum - Modification of targeted policy. Only selected processes are protected. </span></span><br><span class="line"><span class="meta">#</span><span class="bash">     mls - Multi Level Security protection.</span></span><br><span class="line">SELINUXTYPE=targeted</span><br></pre></td></tr></table></figure><p>默认情况下SELINUX是<code>enforcing</code>的，我们只需要修改这一部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELINUX&#x3D;disabled</span><br></pre></td></tr></table></figure><p>最后<code>reboot</code>一下。</p><h2 id="1-6-Sudo权限用户构建"><a href="#1-6-Sudo权限用户构建" class="headerlink" title="1.6 Sudo权限用户构建"></a>1.6 Sudo权限用户构建</h2><p>使用Root添加新用户，配置密码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加新用户</span></span><br><span class="line">useradd 想要添加的用户名（英文）</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改密码</span></span><br><span class="line">passwd 想要添加的用户名（英文）</span><br><span class="line"><span class="meta">#</span><span class="bash"> 之后提示输入密码</span></span><br></pre></td></tr></table></figure><p>让新用户具备SUDO的权限，<code>vi /etc/sudoers</code>，或者给这个文件赋予写入的权限<code>chmod u+w /etc/sudoers</code>（直接Root操作更方便）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Next comes the main part: which users can run what software on </span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># which machines (the sudoers file can be shared between multiple</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># systems).</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Syntax:</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#      user    MACHINE=COMMANDS</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># The COMMANDS section may have other options added to it.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Allow root to run any commands anywhere </span></span></span><br><span class="line">root    ALL=(ALL)       ALL</span><br><span class="line">zxd     ALL=(ALL)       ALL</span><br></pre></td></tr></table></figure><p>后续使用者加上sudo 命令， 就可以具有root权限了，但是会提示输入密码。</p><p>这样的用户既可以外部登录，操作的时候也相对安全一些，虽然有Sudo权限，但是实际上要比Root管的范围要小一点，Root依然是Linux的最高权限管理员。</p><p><strong>另一种方法：错误示范</strong></p><p>下面的方式通用是给普通用户穿一件Root的衣服，但是这样的话登录会被识别为Root登录，<strong>和禁用Root发生冲突</strong>，直白的说就是登不进系统（尴尬）。</p><blockquote><p>不建议从用户管理的角度做这种操作，因为本质上相当于复制了一个Root。</p></blockquote><p>创建一个新用户，但是给予root同等的权限，我们称之为伪Root的普通用户，换句话说叫做系统管理员。</p><p>我们需要执行下面的步骤：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加新用户</span></span><br><span class="line">useradd 想要添加的用户名（英文）</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改密码</span></span><br><span class="line">passwd 想要添加的用户名（英文）</span><br><span class="line"><span class="meta">#</span><span class="bash"> 之后提示输入密码</span></span><br></pre></td></tr></table></figure><p>接下来是配置用户的Root权限，这里要使用Root身份进行操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/passwd</span><br></pre></td></tr></table></figure><p>第一行是root身份，所以我们直接把相关配置赋给新用户。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#第一行内容</span><br><span class="line">root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</span><br><span class="line"># 新增用户（通常新增用户的最底部）</span><br><span class="line">zxd:x:1000:1000:zxd:&#x2F;home&#x2F;zxd:&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line"># 进行修改操作</span><br><span class="line"># 修改之前（通常新增用户的最底部）</span><br><span class="line">zxd:x:1000:1000:zxd:&#x2F;home&#x2F;zxd:&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line"># 修改之后</span><br><span class="line"># 删除掉</span><br><span class="line"># zxd:x:1000:1000:zxd:&#x2F;home&#x2F;zxd:&#x2F;bin&#x2F;bash</span><br><span class="line"># 新增下面这一行</span><br><span class="line">新增用户名:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p>最后验证一下，如果<code>su 新建用户名</code>之后前面显示的内容为Root则说明伪装成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost zxd]# su zxd</span><br></pre></td></tr></table></figure><h2 id="1-7-验证"><a href="#1-7-验证" class="headerlink" title="1.7 验证"></a>1.7 验证</h2><p>这里直接使用<strong>Xshell</strong>进行测试，使用10022登录，22端口无法登录，无法用root登录等均验证通过。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220907101420.png" alt=""></p><h1 id="二、扩展思考"><a href="#二、扩展思考" class="headerlink" title="二、扩展思考"></a>二、扩展思考</h1><p>弄完基础配置的Linux系统之后，我们可以从下面的方面入手，当然后半部分基本为扩展学习建议：</p><ul><li>关闭 selinux 。</li><li>SSH 改端口（ssh），1024以内的端口需要root启动的。比较常见的端口一般禁止占用：<ul><li>0 - 65535 ；</li><li>ssl 443 ；</li><li>22 ；</li><li>8080 ；</li><li>80 ；</li><li>1433 ；</li><li>3306； </li><li>10022（改完之后的登录端口） ；</li><li>5022；</li><li>禁止root登陆； </li></ul></li><li>新建用户和组，给予目录的权限。</li><li>开放linux内部防火墙（iptables 6（不维护）、firewalld 7） 。</li><li>挂载硬盘 。</li><li>NFS文件共享 。</li><li>局域网拷贝 。</li><li>文件自动同步 。</li><li>检测服务器磁盘空间 。</li><li>shell 自动清理磁盘 。</li><li>构建软链接，硬链接 （windows,linux）。</li><li>yum本地源。</li><li>挂载光驱 （【无法联网的情况，学会可以使用本地源】）</li><li>时间设置，时间同步，修改时区。 </li><li>常用的命令熟悉。</li><li>常用软件安装。</li><li>根据所学解决甲方安全测评等单位，给出的服务器安全整改报告，或者自己设置一些难度比较高的挑战目标（如果有可能的话）。</li></ul><h1 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h1><p>轻松简单的文章，希望这篇文章对于读者有帮助。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      拿到一台虚拟机Linux该干什么？
    
    </summary>
    
    
      <category term="服务端-linux" scheme="https://whitestore.top/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF-linux/"/>
    
    
      <category term="服务端-linux" scheme="https://whitestore.top/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF-linux/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 缓存技术</title>
    <link href="https://whitestore.top/2022/08/24/httphuancun/"/>
    <id>https://whitestore.top/2022/08/24/httphuancun/</id>
    <published>2022-08-24T13:01:55.000Z</published>
    <updated>2022-09-08T02:18:34.394Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP-缓存技术"><a href="#HTTP-缓存技术" class="headerlink" title="HTTP 缓存技术"></a>HTTP 缓存技术</h1><p>缓存技术出现在HTTP1.1当中，目的是尽可能的减少对于服务器进行请求。为了实现缓存技术，HTTP设计者在头部字段增加针对缓存的头部字段。HTTP 缓存有两种方式，<strong>强制缓存</strong>和<strong>协商缓存</strong>。</p><h2 id="认识缓存"><a href="#认识缓存" class="headerlink" title="认识缓存"></a>认识缓存</h2><p>介绍具体的缓存技术之前，我们先来认识一下HTTP中的缓存特点。</p><p>注意<strong>缓存只对获取文件有效</strong>，从服务器上拿到文件然后放入本地缓存，下次再获取则从本地缓存区获取文件，这样可以减轻服务器压力。</p><p>缓存技术在HTTP中的体现是通过几个请求字段的配合，按照一定的判断流程控制。HTTP1.1主要通过下面三个请求头部信息判定缓存有效性：</p><ul><li><code>Cache-Control</code>：服务器可以返回此字段指定浏览器和中间缓存应该存活多久。</li><li><code>ETag</code>：浏览器缓存过期的时候，通过Etag令牌检查文件是否出现改变。Etag 是特殊算法计算的唯一哈希值。</li><li><code>Last-Modified</code>：和Etag用途相同，但是它是基于时间的策略检查是否更改。</li></ul><p>这三个字段基本囊括大部分HTTP缓存技术的应用场景。</p><a id="more"></a><h3 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h3><p>缓存位置通常存在下面几种：</p><ul><li>Service Work</li><li>Memory Cache</li><li>Disk Cache（常用）</li><li>Push Cache</li></ul><h4 id="Service-Work"><a href="#Service-Work" class="headerlink" title="Service Work"></a>Service Work</h4><p>通常运行在浏览器的后台，主要功能是实现缓存，使用此组件需要请求协议为HTTPS，因为Service Work 本身会拦截请求，需要 HTTPS保证安全才能使用。</p><h4 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a>Memory Cache</h4><p>内存中的缓存，主要是当前页面已经捕获的资源。比如图片，脚本等，这种方式要比Disk Cache 要快上非常多，但是注意这个缓存寿命非常短，一旦关闭Tab，内存缓存会随着页面的关闭立马释放。</p><p>内存缓存中有一块重要的缓存资源是 <strong>preloader 相关指令</strong>，也是页面优化的手段之一，可以做到解析脚本和CSS文件的同时请求下一个资源。</p><h4 id="Disk-Cache"><a href="#Disk-Cache" class="headerlink" title="Disk Cache"></a>Disk Cache</h4><p>Disk Cache 存在于磁盘的缓存，读取虽然慢一点，但是可以实现持久化存储，并且容量比内存缓存要宽泛很多。</p><p>Disk Cache的覆盖面在浏览器中占用比重很大，通常结合HTTP头部字段进行判断，如果跨站点下载文件，已经下载过的文件不会再次请求，而是直接从<code>Disk Cache</code> 获取。</p><blockquote><p>如何判断缓存进内存还是进磁盘？<br>通常有两个依据：</p><ol><li>如果是大文件，通常会进入磁盘当中进行缓存。</li><li>如果是频繁访问的文件，也会放入磁盘。</li></ol></blockquote><h4 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h4><p>推送缓存是HTTP/2 新加入的内容，上面三种情况都没有命中的时候才会尝试使用。它是会话级别缓存，一旦会话结束，也会立即释放缓存，生命周期只比内存缓存长一点点。</p><h4 id="缓存过程"><a href="#缓存过程" class="headerlink" title="缓存过程"></a>缓存过程</h4><p>缓存的大致流程如下：</p><ol><li>客户端发起HTTP请求访问浏览器缓存，浏览器不存在缓存，告知客户端让它重新发请求。</li><li>客户端再次发起HTTP请求到原始服务器，原始服务器返回结果和缓存规则。</li><li>客户端再次发起请求，从浏览器的缓存中获取请求结果。</li></ol><p>注意第一步是隐式处理的，所以缓存过程主要有两个要点：</p><ul><li>每次请求都会检查浏览器是否存在缓存标识，以及请求的缓存结果。</li><li>如果没有特殊字段禁用缓存，缓存将会把请求结果缓存存在浏览器缓存当中。</li></ul><p>缓存判定主要依赖两项技术：<strong>强制缓存</strong>和<strong>协商缓</strong>存，也是HTTP缓存技术的要点。将在下文进行进行介绍。</p><h3 id="Pragma-头部"><a href="#Pragma-头部" class="headerlink" title="Pragma 头部"></a>Pragma 头部</h3><p>Pragma 于 HTTP1.0 中定义，单词含义叫做“编译指令”，几乎可以包含任何内容，目的是给浏览器发送请求中进行一些指令操作，但是主要的应用场景是缓存操控。</p><p>Pragma主要作用是保持 HTTP1.0 向后兼容，因为<strong>缓存技术是在HTTP1.1中才出现</strong>的。</p><p>比如让一些HTTP1.0的源服务识别客户端理解”无缓存“的请求头部，这时候Prama就可以派上用场。</p><p>Pragma 如果被发送，将会应用于所有的应用程序和客户端。如果存在HTTP1.1缓存技术的相关请求头部字段，在<strong>服务器可以识别的前提下</strong>，会优先解析HTTP1.1的请求头部，从而忽略Pragma头部。</p><p>但是这里介绍的所有内容都是 HTTP1.0 约定俗成的东西。HTTP1.0 本身不能算作标准，只能算作“草稿”，所以 <strong>Pragma 既没有明确规范，也没有可靠性</strong>，现在的网络环境这个字段基本不再使用。仅仅是有可能的向后兼容场景中用到。</p><blockquote><p>介绍这些内容，只是让大家知道点历史。</p></blockquote><p><strong>Pargma 头部使用方式</strong></p><p>基本语法 <code>Pragma: 1# pragma-directive</code><br>举例  <code>Pragma: no-cache</code>（实际上也是唯一取值）</p><h2 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h2><p>强制缓存指的是只要浏览器没有过期，就使用缓存进行返回，主动性在浏览器方。</p><p>比如下面的请求当中，使用了缓存进行返回，强缓存利用两个响应头部实现， <strong>相对时间“Cache-Control”</strong> 以及 <strong>“Expire”绝对时间</strong> 两个字段。</p><p>在讲述<code>Cache-Control</code>之前我们先停一下，先来了解后面这个过时的东西<strong>Expires</strong>。</p><p><strong>Expires 有什么用？</strong> 这个字段的作用是设置一个特殊的时间，一旦超过这个时间，就会过期。简而言之就是所谓的<strong>绝对时间</strong>，比如我们设置时间为 <code>Expires：Sat，13 May 2022 07:00:00  GMT</code>，意味着一旦超过这个时间就会失效。</p><p>但是这个时间是存在问题的，虽然原始服务器的时间无法更改，但是 <strong>客户端时间是可以自由改动的</strong>，这样就会导致客户端时间和服务器时间不一致，出现缓存一致性问题，你也可以把这种乱改时间的方式叫做<code>the world</code>（砸瓦鲁多）。</p><p>此外<strong>Expires</strong>日期时间必须是格林威治时间（GMT），而不能是本地时间，也不能随意指定日期格式，局限性比较大。</p><p>如果设置的Expires过期时间是固定时间，但是返回之前没有没有更新下一次过期时间，那么每一次客户端的请求都会进入到服务端，会加大服务端压力，缓存的意义也就失效了。</p><p>于是Cache-Control针对Expires的局限性进行改进而在HTTP1.1中登场。</p><p>如果同时有 <code>Cache-Control</code> 和 <code>Expires</code> 字段，<strong>Cache-Control的优先级高于 Expires</strong> 。所以通常情况下不建议使用 Expires，如果非要使用，建议用在静态资源上给资源设置绝对过期时间，或者作为双保险兼容所有HTTP代理服务使用。</p><p>此外<code>Cache-Control</code>和<code>Expires</code>这两个字段的区别是 <code>Cache-Control</code> 字段的选项要多一些，<code>Cache-Control</code>是HTTP1.1标准协议中出现并推荐使用的，<code>Expires</code> 是HTTP1.0的规定，但是HTTP1.0并不是明确标准，不具备任何约束力。</p><blockquote><p>HTTP 1.0 虽然明面上属于草稿纸协议，Expires看似也不推荐使用，但是后续的协议并没有废弃它，所以还是有一定的存在意义的（前后兼容问题）。</p></blockquote><p>首部字段 <code>Expires</code> 会将资源失效的日期告知客户端。如果不希望资源被缓存，则建议把首部字段 <code>Expires</code> 和首部字段<code>Date</code>设置相同的时间。</p><p><strong>强制缓存的使用策略</strong></p><ul><li><strong>第一次访问服务器资源</strong>，服务器会在返回资源的同时返回这两个字段，同时为这两个字段设置过期时间。</li><li>浏览器第二次乃至更多次访问，首先比对 <strong>Cache-Control</strong>的时间是否过期，如果有就使用缓存，没有就<strong>重新请求</strong>。</li><li>再次请求会更新 <code>Cache-Control</code>，之后以此反复。</li></ul><h3 id="Cache-Control例子"><a href="#Cache-Control例子" class="headerlink" title="Cache-Control例子"></a><code>Cache-Control</code>例子</h3><p>例子网址：<span class="exturl" data-url="aHR0cHM6Ly93ZWIuZGV2L2kxOG4vZW4vaHR0cC1jYWNoZS8jZXhhbXBsZXM=" title="https://web.dev/i18n/en/http-cache/#examples">https://web.dev/i18n/en/http-cache/#examples<i class="fa fa-external-link"></i></span></p><table><thead><tr><th align="left"><code>Cache-Control</code>价值</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left"><code>max-age=86400</code></td><td align="left">响应可以由浏览器和中间缓存缓存长达 1 天（60 秒 x 60 分钟 x 24 小时）。</td></tr><tr><td align="left"><code>private, max-age=600</code></td><td align="left">响应可以由浏览器（但不是中间缓存）缓存长达 10 分钟（60 秒 x 10 分钟）。</td></tr><tr><td align="left"><code>public, max-age=31536000</code></td><td align="left">响应可以由任何缓存存储 1 年。</td></tr><tr><td align="left"><code>no-store</code></td><td align="left">不允许缓存响应，并且必须在每次请求时全部获取。</td></tr></tbody></table><h3 id="Cache-Control-字段选项"><a href="#Cache-Control-字段选项" class="headerlink" title="Cache-Control 字段选项"></a>Cache-Control 字段选项</h3><ul><li><code>max-age</code>：此参数为高优先级，代表缓存的最大存活时间，单位为秒，其实时间为客户端接受响应的那一刻计算。</li><li><code>no-cache</code>：浏览器在每次使用缓存之前都必须使用服务器重新验证。注意这个字段并不是禁用缓存的真正含义，这里暂时卖个关子，下文继续解释。</li><li><code>no-store</code>：缓存不应该缓存任何客户端和服务端的内容，实际上的<strong>不使用缓存</strong>。和no-cache的区别是这个设置完全才是真实的不使用缓存。</li><li><code>public</code>：表示资源可以由任何代理进行缓存。</li><li><code>private</code>：表示指定资源专属于特定用户，虽然依然可以缓存，但<strong>只能在客户端缓存</strong>，比如私有的网页响应由桌面浏览器缓存，不能给CDN进行加速。</li></ul><blockquote><p>注意在<code>Cache-Control</code>指定<code>max-age</code>的属性时候，比起首部字段Expires，会优先处理max-age。</p></blockquote><p>在 <strong>《HTTP权威指南》</strong> 可以看到更多字段解释，上面仅仅列举一些常用字段。</p><blockquote><p>重点关注 no-cache，很容易误解含义的一个属性。</p></blockquote><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220815060304.png" alt="Cache-Control 常用字段 - 1"></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220815060414.png" alt="Cache-Control 常用字段 - 2"></p><p><strong>s-maxage</strong></p><p>有时候我们会看到下面的请求属性：<code>s-maxage</code></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220814190150.png" alt="s-maxage"></p><p>它所表示的含义是覆盖<code>max-age</code>或者<code>Expires</code>头，但是仅适用于共享缓存 (比如各个代理)，私有缓存会忽略它（private）。</p><p><strong>Cache-Control案例</strong></p><p>通过下面的案例可以看到，内容是从<code>disk cache</code>本地返回的，没有请求服务器。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220814182034.png" alt=""></p><p>强制缓存除了 <code>from disk cache</code> 之外，还有可能遇到使用<code>from memory cache</code>进行返回，表示同样不会访问服务器，但是返回的内容是从内存中来的，并且因为是内存所以如果关闭当前页面会被立马释放。</p><p>更多有关Cache-Control的内容可以看看下面的资料网站。</p><p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0NhY2hlLUNvbnRyb2w=" title="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control">Cache-Control - HTTP | MDN (mozilla.org)<i class="fa fa-external-link"></i></span></p><h3 id="Expires-和-Cache-Control-两者对比"><a href="#Expires-和-Cache-Control-两者对比" class="headerlink" title="Expires 和 Cache-Control 两者对比"></a>Expires 和 Cache-Control 两者对比</h3><p>这个比较容易被问到，所以这里再啰嗦一遍。其实本质上区别并不是很大，只不过Expires 是  HTTP1.0 出现的，要比Cache-Control （HTTP1.1）出得早而已，并且Cache-Control本身就是为了替换Expires 而存在的。</p><p>虽然目前大部分网站都是支持HTTP1.1 的，但是如果真的碰到只能识别HTTP1.0 的服务器，此字段依然有存在价值，所以这种做法只是一种保证前后兼容的稳定而已。</p><h3 id="Cache-Control-流程图"><a href="#Cache-Control-流程图" class="headerlink" title="Cache-Control  流程图"></a><code>Cache-Control</code>  流程图</h3><p>图来自老外的博客：<span class="exturl" data-url="aHR0cHM6Ly93ZWIuZGV2L2kxOG4vZW4vaHR0cC1jYWNoZS8=" title="https://web.dev/i18n/en/http-cache/"># Prevent unnecessary network requests with the HTTP Cache<i class="fa fa-external-link"></i></span></p><p>需要注意最后一步的Etag，是协商缓存中的重要判断依据，这部分内容会在下文解释。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202208160701622.png" alt="Cache-Control 流程图"></p><h3 id="no-cache-VS-no-store"><a href="#no-cache-VS-no-store" class="headerlink" title="no-cache VS no-store"></a>no-cache VS no-store</h3><p>“no store”请求指令指示缓存不能存储此请求或对其的任何响应的任何部分。</p><blockquote><p>The “no-store” request directive indicates that a cache MUST NOT store any part of either this request or any response to it. This directive applies to both private and shared caches.</p></blockquote><p>no-store 比较好理解，它是真正意义上的不使用缓存，含义是禁用中间代理（浏览器，CDN，缓存服务器、代理）缓存响应内容，行为类似非代理缓存服务，一旦碰到缓存就会删除。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220814211613.png" alt=""></p><p>“no cache”请求指令表示，如果未在源服务器上成功验证，缓存不得使用存储的响应来满足请求。</p><blockquote><p>The “no-cache” response directive indicates that the response MUST NOT be used to satisfy a subsequent request without successful validation on the origin server.</p></blockquote><p>上面是RFC协议的原话，这个定义非常容易误解，隐藏的含义是：<strong>实际上<code>no cache</code> 是会进行缓存的</strong>。</p><p>什么时候缓存呢？在与原始服务器进行新鲜度再验证之前，缓存不能将其提供给客户端使用。而如果再度验证服务器没有对于内容进行更改，那么还是使用缓存数据进行处理。</p><p>简而言之就是一句话：<strong>如果服务器没有更新内容，那么就会缓存数据，否则需要重新请求和服务器进行验证比对</strong>。</p><p>大多数人会理解错这一层含义，会误认为是“不接受服务器的缓存响应”，实际上它是会接受的。《HTTP权威指南》解释说这个首部更适合用 <strong>do-not-serve-from-cache-without-revalidation（不需要请求服务，直接用缓存，除非服务器重新验证）</strong> 这个名字会更恰当一些，我们同样可以按照作者的建议进行理解。</p><p>但是这里肯定又会问，你都<code>no-cache</code>了我怎么知道什么时候响应新内容呢？</p><p>先别急，这里有一套稍微复杂的判断机制：<strong>协商缓存</strong>，学东西一点一点来，我们接着看其他几个强制缓存的问题。</p><h3 id="max-age-0-和-no-cache-等价吗？"><a href="#max-age-0-和-no-cache-等价吗？" class="headerlink" title="max-age=0 和 no-cache 等价吗？"></a>max-age=0 和 no-cache 等价吗？</h3><p>这个问题比较偏门，但是作为面试题角度比较刁钻。</p><p>两者的区别是<code>max-age=0</code>通常是告诉浏览器<strong>建议</strong>刷新缓存，<code>max-age=0</code>是<strong>非强制性（Should）</strong> 的，<code>no-cache</code>要求强制和服务器进行验证才允许使用缓存，所以<code>no-cache</code> 具有强制（MUST）性。</p><p>但是怎么处理还得看浏览器的设计，所以不考虑浏览器设计的因素下，可以认为行为比较一致，或者直接自信点：它们差不多。</p><h3 id="什么样的请求方法会被缓存？"><a href="#什么样的请求方法会被缓存？" class="headerlink" title="什么样的请求方法会被缓存？"></a>什么样的请求方法会被缓存？</h3><ul><li>GET 请求通常具备缓存失效。</li><li>HEAD方法跟GET方法相同，只不过服务器响应时不会返回消息体，所以HEAD请求会被缓存。（比较容易被忽略）</li><li>PUT 无法被缓存。</li><li>POST 缓存在指定明确的过期请柬请求字段的时候可以使用，但是基本没有被实施。</li></ul><blockquote><p>HEAD 很容易被忽略，实际上它具备一定的作用：</p><ul><li>检查连接是否活跃（active）。</li><li>检查网页是否存在改动。</li><li>多用于获取RSS，网站标志等信息的场景使用。</li></ul></blockquote><h3 id="缓存优先级判断"><a href="#缓存优先级判断" class="headerlink" title="缓存优先级判断"></a>缓存优先级判断</h3><p>采用下面的顺序：</p><ol><li>如果是共享缓存并且存在<code>s-maxage</code>，则为最高优先级。</li><li>检查是否存在max-age。</li><li>检查是否存在Expires，需要使用此时间减去响应字段的Date字段值，算出来的数值就是有效期。</li></ol><p>需要提醒这些时间是不会和时区产生影响的，因为返回的都是<strong>原始服务器的时间</strong>。</p><p>但是在这里我们发现一个问题，如果上面条件都不满足，如果<strong>不存在到期时间</strong>咋办？</p><p>因为原始服务器的时间并不是总是可靠的，如果请求当中没有任何“新鲜度“（max-age、Expires等过期时间）设置，请求头部也没指定任何禁用缓存和任何限制，那么这时候需要用<code>heuristic expiration time</code>这个值。</p><p><code>heuristic expiration time</code>（中文说法：<strong>启发式缓存时间</strong>），在《HTTP权威指南》叫做试探性过期时间，其实是利用其他字段的算出一个“合理”的估计值（也就是 <code>Last-Modified</code>）。</p><p>关于计算的方法，在RFC规范柄中没有强制如何设计，而是在协议中给出下面这句话：</p><blockquote><p>If the response has a Last-Modified header field (Section 2.2 of [RFC7232]), caches are encouraged to use a heuristic expiration value that is no more than some fraction of the interval since that time. A typical setting of this fraction might be 10%.</p></blockquote><p>如果响应具有<code>Last-Modified header</code>的标头字段（RFC7232的第2.2节），<strong>则鼓励缓存使用启发式缓存时间值</strong>，该值会计算一个不超过自该时间起间隔 * 某个比例（的时间）。<strong>比例的经典设置可能为10%</strong>。</p><p>这是嘛意思？没看懂呀，其实这里要联系RFC原文的前后文了，这里就不贴英文了。大致意思是在优先级判断中的第三点判断，有效期计算被定义为<strong>Expires-Date字段</strong>。</p><p>如果服务端返回<code>Last-Modified header</code> ，则计算方式为 <strong>Date字段 - Last-Modified字段值</strong>。</p><p>但是如果直接这样计算有可能会太长了，RFC给出 10 % 的建议值。这个建议值有这两点考虑：</p><ul><li>很久之前存放的文档一般不会更改，所以留在缓存很安全，10%估计值的比率尚且可以接受（？）。</li><li>频繁更新的内容通常缓存收益很小，使用估计值10%可以尽可能减少缓存时间，尽可能的返回最新内容。</li></ul><blockquote><p>更新频率不同长短的资源都能收益，这样看起来这处理方式是不是很不错呀？但是<br>想法是好的，现实是这样做会带来更多麻烦，这点放到下面讨论。</p></blockquote><p>总而言之，不满足缓存优先级判断，浏览器通常会用  <strong>Last-Modified字段值</strong> 计算一个合适的参考值作为缓存过期时间存在，最终的计算公式为：</p><p><strong><code>Last-Modified Time - Date</code> * 0.1 (10%)`</strong></p><blockquote><p>当存储的响应中存在显式过期时间时，缓存不得使用启发式缓存时间来确定新鲜度。不能使用此算法。官方这话是在暗示你要尽量给资源设置缓存过期时间，因为我建议的这东西不是特别靠谱。</p></blockquote><p>目前多数浏览器使用 <code>LM-factor</code> 算法（也就是上面的公式），使用的也是RFC协议建议的比例 10 %，20% 这个说法现在来看已经过时。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220815063339.png" alt=""></p><blockquote><p>10%以及悲观估计依据：<br>This specification does not provide specific algorithms, but does impose worst-case constraints on their results.<br>  本规范未提供具体算法，但对其结果施加了最坏情况约束，所谓的最坏情况约束就是 10%。</p></blockquote><p><strong>113 响应状态码</strong></p><p>这里有个偏门的 113 响应状态码，表示如果缓存使用了超过24小时的有效时间并且响应时间大于24小时，不应该采取任何操作。1XX状态码需要后续的确认操作。</p><p>但是实际上很多浏览器压根没有搭理过这个建议，也没有做响应措施，这一点需要注意。</p><p><strong>如果Last-Modified都没有怎么办？</strong></p><p>乖乖，如果这都没有的话，缓存通常会为没有任何新鲜周期线索的文档，分配一个默认的新鲜周期（通常是一个小时或一天）。</p><p>有时比较保守的缓存会将这种试探性新鲜生存期设置为 0，强制缓存在每次将其提供给客户端之前验证一下这些数据是否仍然是新鲜的。</p><p><strong>启发式缓存时间坏处</strong></p><p>凡事都有例外，启发式缓存时间本意是好的，但是存在明显的弊端。</p><p>假如一个文件超过一个月没设置过期时间，并且已经经过一个月的时间，这时候发现文件存在严重问题，需要立刻修复。</p><p>这时候一旦修改，会导致上个版本3天之后才过期（1个月的10%=3天左右），意味着更新一个文件需要至少3天（20%就是将近一周），请求才会传新文件。如果使用CDN，这个时间还会更长。</p><p>当然这种问题解决方案也很多，比如在设置文件的时候带上<strong>版本号或者编号</strong>，比如对外进行 302 临时重定向到另一个位置并且设置过期时间，或者先删文件再后重新添加，并且手动强制同步。</p><p><strong>综上所述，尽量不要使用启发式缓存，尽量给每个请求设置过期时间，但是也不要设置过长时间，长时间的强缓存会因为CDN等缓存服务器的关系导致一个资源迟迟难以更新（哪怕没有启发式缓存时间）</strong>。</p><p><strong>新协议对RFC2616的改动</strong></p><p>注：[RFC2616] 第13.9节禁止缓存计算带有查询组件的URI的启发式新鲜度（即包含“？”的URI）。此项在实践中，这并没有得到广泛推广。</p><p>综上所述，如果源服务器希望排除缓存，则鼓励它们发送显式指令（例如，缓存控制：无缓存）。</p><h3 id="新响应的计算方式"><a href="#新响应的计算方式" class="headerlink" title="新响应的计算方式"></a>新响应的计算方式</h3><p>下面这个公式是判断依据：</p><p><strong>response_is_fresh = (freshness_lifetime &gt; current_age)</strong></p><p>判断依据十分简单，新鲜度的时间是否超过寿命，超过寿命就需要丢弃缓存重新请求。也正是因为这种简单粗暴的手法，使得缓存既能够提供便利的同时，不至于对于用户访问造成过多影响。</p><h3 id="响应表头设置建议"><a href="#响应表头设置建议" class="headerlink" title="响应表头设置建议"></a>响应表头设置建议</h3><p>因为启发式缓存时间的存在，强烈建议重要的文件资源都加上缓存有效期。针对缓存有效期的响应头设计，通常有下面的几点建议：</p><p><strong>版本化URL</strong></p><p>比如针对CSS文件设置了长达一年的缓存过期时间，如果出现临时更改，有的用户如果刚好清除缓存可以看到最新的内容，而没有清除缓存的可能拿到本地旧版本文件。这样可以有更好的用户体验，旧缓存数据的用户在刷新缓存之后就可以看到新内容。</p><p>通常情况下，在文件名中嵌入文件的版本号来执行此操作，例如<code>style.x234dff.css</code>。</p><p><strong>无版本化URL</strong></p><p>如果是没有版本化的URL很久突然要进行更新，则需要尽量添加头部。</p><p><code>Cache-Control</code>值可以帮助我们微调未版本化 URL 的缓存位置和方式：</p><ul><li>no-cache：缓存请求当前URL的版本数据之前需要和服务器进行验证。</li><li>no-store：屏蔽中间代理服务器的缓存行为，不存储缓存文件。</li><li>private：浏览器可以缓存文件，但是中间代理缓存服务器不能缓存。</li><li>public：响应可以被任何缓存进行存储。</li></ul><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>缓存生效的情况下，浏览器会返回304状态码。协商缓存是在强制缓存失效之后，需要重新对比缓存，由服务器决定是否失效的一种机制。</p><blockquote><p>304：请求的资源没有改变，但是被重定向到已缓冲的文件，所以也叫做缓存重定向，这个子弹主要是用于缓存处理。</p></blockquote><p>协商缓存的请求步骤通常分为两步。</p><p>初次访问：<br>    客户端请求依然需要发送到服务端，但是服务端会通知浏览器缓存请求响应信息，浏览器这时候会偷偷缓存请求。</p><p>第二至更多次访问：<br>    1. 假设客户端请求资源已经过期，则在请求中携带Etag 访问服务器。<br>    2. 服务器比对Etag进行校验，比较是否和本地一致。<br>    3. 如果一致返回304，浏览器可以继续使用资源。<br>    4. 如果不一致就需要重新返回请求结果，再次进行缓存。</p><p><strong>协商缓存实际上就是浏览器和服务器进行协商通过协商的结果判断是否使用本地缓存。</strong></p><p><strong>主要涉及的请求头部</strong></p><p>注意这里一共有<strong>两组四个字段</strong>进行判断，<code>ETag</code>和<code>If-None-Match</code>（一组）， <code>If-Modified-Since</code> 字段与 <code>Last-Modified</code> 字段（一组），<strong>前者优先级比后者高</strong>，同时出现会出现“短路效应”。</p><h4 id="ETag和If-None-Match"><a href="#ETag和If-None-Match" class="headerlink" title="ETag和If-None-Match"></a><code>ETag</code>和<code>If-None-Match</code></h4><p>两者的值都是资源的唯一标识符（实际为文件资源的哈希散列值）。</p><p>判断过程如下：</p><ul><li>浏览器请求资源，原始服务器返回报文中加入<code>Etag</code>值，资源更新则Etag值也会更新。</li><li>浏览器再次请求资源，此时请求报文会加入<code>If-None-Match</code>，值为上一次响应报文的Etag值。</li><li>服务器比对报文的<code>If-None-Match</code>和当前的<code>Etag</code>是否一致，不一致则更新Etag并且返回，下一次浏览器请求Etag将传输新的值。如果一致表示资源没有更新，状态码返回304，浏览器从本地缓存获取，<strong>此时响应头会同时返回Etag值</strong>。（虽然没有变化）</li></ul><h4 id="If-Modified-Since-字段与-Last-Modified-字段"><a href="#If-Modified-Since-字段与-Last-Modified-字段" class="headerlink" title="If-Modified-Since 字段与 Last-Modified 字段"></a><code>If-Modified-Since</code> 字段与 <code>Last-Modified</code> 字段</h4><p>位于请求头部的<code>If-Modified-Since</code> 字段以及位于响应头部中的 <code>Last-Modified</code> 字段。</p><ul><li>响应头部中的 <code>Last-Modified</code> 字段：表示资源的<code>Last-Modified</code>（ 最后修改时间）。</li><li>请求头部的<code>If-Modified-Since</code> 字段：资源过期并且接收响应头部出现 <code>Last-Modified</code> （最后修改时间）声明，会发送此字段，并且此字段值等于<code>Last-Modified</code>（ 最后修改时间）。</li></ul><p>判断流程如下：</p><ul><li>浏览器第一次向服务端请求之后，服务端响应中加入 <code>Last-Modified</code> 字段，表示资源最后一次修改时间。</li><li>浏览器再次请求，在请求报文中会加入<code>If-Modified-Since</code> 字段，字段值等于上一次浏览器返回的<code>Last-Modified</code> （最后一次修改时间）。</li><li>服务器比对<code>Last-Modified</code> 和<code>If-Modified-Since</code> 字段，如果不一致则接受请求并且返回更新之后的资源，如果一致表示资源没有更新，返回304状态码，此时浏览器会从本地缓存获取资源文件。值得注意的是，<strong>本地请求如果是304，此时响应头中不会再添加<code>Last-Modified</code>字段</strong>。</li></ul><h3 id="协商缓存和强制缓存流程图"><a href="#协商缓存和强制缓存流程图" class="headerlink" title="协商缓存和强制缓存流程图"></a>协商缓存和强制缓存流程图</h3><p>这个图来自参考文章的第一篇，画的很棒，为作者点个赞：</p><blockquote><p>注意：If-None-Match 和 If-Modified-Since 的关系是：<code>If-None-Match &amp;&amp; If-Modified-Since</code>。</p></blockquote><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202208170727835.png" alt=""></p><p>下面的图和上面类似，不过把<code>If-None-Match</code>和 <code>If-Modified-Since</code>丰富了一下：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202208170731807.png" alt=""></p><h3 id="如果同时发送If-None-Match-、If-Modified-Since字段怎么处理"><a href="#如果同时发送If-None-Match-、If-Modified-Since字段怎么处理" class="headerlink" title="如果同时发送If-None-Match 、If-Modified-Since字段怎么处理"></a>如果同时发送<code>If-None-Match</code> 、<code>If-Modified-Since</code>字段怎么处理</h3><p>此时服务器只要比较<code>If-None-Match</code>和<code>ETag</code>的内容是否一致即可，内容一致则返回304并且依然使用，不一致则返回新的请求结果，并且重新缓存。</p><p><code>If-None-Match</code>判断优先级总是要高一些，IETF同样如此建议。</p><h3 id="Etag-和-Last-Modifed-对比"><a href="#Etag-和-Last-Modifed-对比" class="headerlink" title="Etag 和 Last-Modifed 对比"></a>Etag 和 Last-Modifed 对比</h3><p><code>Etag</code>和<code>Last-Modifed</code>效果是相同的，为什么相同的功能需要两个字段控制？</p><p>首先说一下结论，<code>Etag</code> 实际上更为推荐并且更常使用，因为它的细粒度更小，下面我们举个例子，再进行总结。</p><p>我们先来举个栗子，假设一个资源从资源请求开始到当前请求过去了120秒接近过期节点，并且浏览器启用了同一个资源的新请求，此时HTTP刚好卡在过期节点之前找到缓存。虽然查到的缓存在获取那一刻是没有过期的，但是他不能这么干，因为此时在浏览器看来<strong>响应已经过期了</strong>，浏览器需要重新发一个新请求获得完整响应。</p><p>上面的例子本意是好的，但是如果资源没有出现改变，就没有必要下载已经在缓存本地的信息，这么做明显是浪费服务器资源。如果很多个请求都在这个临界点访问，这样会加大服务器资源的浪费。</p><p>所以基于时间的判断是不可靠的，Etag标头负责检查文件内容的哈希码，浏览器不需要知道哈希算法，只需要拿客户端请求的Etag值和当前本地缓存比对即可，如果Etag值一致，哪怕此时请求资源响应已经过期了，依然可以用本地缓存文件返回，跳过下载步骤。</p><p>有了上面的案例，下面我们知道了为什么要引入Etag，下面是相关<strong>结论</strong>。</p><p><strong>结论</strong></p><ul><li>有时候文件仅仅是改了日期（比如重新传了一份一模一样的覆盖），我们可以认为文件内容是没有改变的，依然可以用本地缓存而不是GET请求。</li><li>文件如果改动非常频繁但是内容没有改变，<code>Last-Modifed</code>是S（秒）级，控制粒度大，很容易出现请求响应过期，并且频繁的重新下载。</li><li>某些服务器不能精确表示最后修改时间，只能给出笼统的日期。</li></ul><p>总的来说就是基于时间的判断是不可靠的，使用Etag值可以更加精确控制缓存，所以引入服务器自动生成Etag校验码作为唯一标识符，如果资源频繁改动会重新生成Etag值，但是如果资源只是频繁的刷新修改日期，则Etag不变。</p><p>在默认的情况下这两个值可以一起使用，但是牢记<strong>优先校验ETag</strong>（原因请看上面的栗子）。</p><h2 id="用户行为对缓存影响"><a href="#用户行为对缓存影响" class="headerlink" title="用户行为对缓存影响"></a>用户行为对缓存影响</h2><p>这里直接用了网上的一张图，主要记住几个无效的项即可。</p><p>下面是日常用户操作</p><ol><li>大部分网站打开网页通常优先检查disk cache，有就使用，没有就发送请求。</li><li>F5刷新，因为此时TAB没有关闭，使用memory cache 是可用的，会被优先使用，而disk cache 会被滞后使用。</li><li>强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 <code>Cache-control: no-cache</code>(为了兼容，还带了<code>Pragma: no-cache</code>)，此时返回200状态码和最新内容。</li></ol><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202208170708552.png" alt=""></p><h2 id="缓存策略建议"><a href="#缓存策略建议" class="headerlink" title="缓存策略建议"></a>缓存策略建议</h2><p>因为缓存是作用于文件的，而文件资源基本情况有两种：<strong>频繁改动的资源</strong>和<strong>长久不变化的资源</strong>。</p><p>频繁变动的资源：</p><ul><li>首先需要使用 <code>Cache-Control: no-cache</code> 使浏览器每次都请求服务。</li><li>配合 <code>ETag</code> 或者 <code>Last-Modified</code> 来验证资源是否有效。</li></ul><p>这样的处理方法可以显著的减少响应内容的大小。</p><p>长久不变的资源：</p><p>直接给一个<code>Max-age=31536000</code> 一年的时间让浏览器强制使用缓存，所以通常建议在文件名中加入哈希码和版本号等信息，防止长久缓存文件突然需要更新的时候能及时反馈给客户端。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxNTgxNjMzMQ==" title="https://segmentfault.com/a/1190000015816331">一张图理解Http缓存 - SegmentFault 思否<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9yZmMyY24uY29tL3JmYzcyMzQuaHRtbA==" title="https://rfc2cn.com/rfc7234.html">RFC7234 中文翻译 中文RFC RFC文档 RFC翻译 RFC中文版 (rfc2cn.com)<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvY1Vxa0czTkVUbUpiZ2xEWGZTZjB0Zw==" title="https://mp.weixin.qq.com/s/cUqkG3NETmJbglDXfSf0tg">【第1398期】一文读懂前端缓存 (qq.com)<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93ZWIuZGV2L2kxOG4vZW4vaHR0cC1jYWNoZS8=" title="https://web.dev/i18n/en/http-cache/">Prevent unnecessary network requests with the HTTP Cache (web.dev)<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC85OTM0MDExMA==" title="https://zhuanlan.zhihu.com/p/99340110"># 深入理解浏览器的缓存机制<i class="fa fa-external-link"></i></span></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      HTTP缓存技术
    
    </summary>
    
    
      <category term="网络/网络基础" scheme="https://whitestore.top/categories/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="网络/网络基础" scheme="https://whitestore.top/tags/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>《网络是怎么样连接的》读书笔记 - 认识网络基础概念（一）</title>
    <link href="https://whitestore.top/2022/08/11/rswljcgn/"/>
    <id>https://whitestore.top/2022/08/11/rswljcgn/</id>
    <published>2022-08-10T21:30:06.000Z</published>
    <updated>2022-09-08T02:18:34.397Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《网络是怎么样连接的》读书笔记-认识网络基础概念（一）"><a href="#《网络是怎么样连接的》读书笔记-认识网络基础概念（一）" class="headerlink" title="《网络是怎么样连接的》读书笔记 - 认识网络基础概念（一）"></a>《网络是怎么样连接的》读书笔记 - 认识网络基础概念（一）</h1><h2 id="本章重点"><a href="#本章重点" class="headerlink" title="本章重点"></a>本章重点</h2><ol><li>关于互联网的一些历史补充</li><li>解析URL的过程简述</li><li>HTPP请求的基本结构和组成</li><li>IP 地址、子网掩码以及DNS的基本了解，掌握概念和相关知识点。</li></ol><h2 id="讲讲历史"><a href="#讲讲历史" class="headerlink" title="讲讲历史"></a>讲讲历史</h2><p>1991年8月6日，在瑞士日内瓦的核子研究中心（CERN）工作的英国物理学家蒂姆·伯纳斯·李（Tim Berners-Lee），正式提出了World Wide Web，也就是如今我们非常熟悉的www。</p><p>www是什么？万维网WWW是World Wide Web的简称，也称为Web、3W等。WWW是基于<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/lrqLmiLfmnLovNTE2ODE1Mw==" title="https://baike.baidu.com/item/客户机/5168153">客户机<i class="fa fa-external-link"></i></span>/<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/mnI3liqHlmagvMTAwNTcx" title="https://baike.baidu.com/item/服务器/100571">服务器<i class="fa fa-external-link"></i></span>方式的信息发现技术和<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/otoXmlofmnKwvMjgzMjQyMg==" title="https://baike.baidu.com/item/超文本/2832422">超文本<i class="fa fa-external-link"></i></span>的<strong>综合技术</strong>。</p><p>这里个人比较好奇我们天天都在说3w，3w，但是<strong>互联网是怎么出现的的书中并没有解释？</strong></p><p>这里查了下网上资料根据个人理解解释一波：</p><p>实际上网络最开始苗头出现在美苏冷战的时期美国建立的<strong>APRA</strong>科研部门，被突然扯出来的科研部门一盘散沙不知道干嘛，对付苏联的科研工作也没什么进展，直到一个叫做罗伯特·泰勒的哥们出现，他的突破口是发现小型的通信网络不能兼容不同型号的计算机，我们都知道技术的顶峰就是定规则，毫无疑问他选择构建一套协议让所有的计算机都能遵守这一套规则干活。</p><p>于是他找来了几个牛逼的大佬开始捣鼓，中间巴拉巴拉做了很多事绕了很多弯，目的其实就是为了实现上面说的东西，最终在一次失败的“LOGIN”验证中虽然仅仅传输了“LO”两个字母就断开了，但是这次失败是历史性的进步，因为两个不同的设备实实在在的通信了，最终修复之后完成了这五个字母的正常传输。</p><p>随后捯饬出的<strong>ARPANET（阿帕网）</strong> 这个项目，也就是正式的互联网雏形。</p><p>课外知识到此结束，现在我们看看第一章主要看点：</p><ol><li>如何解析网址？</li><li>DNS 服务器如何查询域名对应的 IP 地址？</li><li>DNS服务器如何接力？</li><li>浏览器如何将消息委托给操作系统发送给 Web 服务器？</li></ol><p>核心是理解DNS的角色地位和作用，以及浏览器如何跟DNS交互完成网址（域名）解析为IP这一个操作的，本章最后的委托流程是整个第二章的重点内容，笔记顺其自然的放到了第二章笔记当中，为了方便理解把笔记归纳到第二部分。</p><a id="more"></a><h2 id="如何解析网址"><a href="#如何解析网址" class="headerlink" title="如何解析网址"></a><strong>如何解析网址</strong></h2><p>我们从URL开始，什么是URL，URL是Uniform Resource Locator的简称，专业解释叫做统一资源定位符，除开我们常见的http、https协议之外，浏览器还可以进行ftp文件上传，下载文件，发送电子邮件，浏览新文化等操作。</p><p>我们把这些行为看作是资源交互，虽然不同的资源交互会存在不同的URL组合，但是不管URL的组合形式如何变化，最终是<strong>开头决定一切</strong>，开头部分决定对待资源方式。</p><p>解析网址我们可以看下面的例子：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205232140810.png" alt="img"></p><p>碰到省略文件名的情况，通常下面几种：</p><ul><li><code>http://xxxx/dir/</code>表示 <code>/dir/</code> 之后的内容被省略，这时候通常情况下会设置对应这个目录的真实访问路径进行<strong>补全</strong>。</li><li>对于web中最为经典的<code>http://localhost:8080/</code>访问路径，通常情况下Web服务器会访问到<code>/index.html</code>这个文件，如果没有就会返回404的页面。</li><li>如果只有域名，比如<code>www.baidu.com</code>，那就会直接访问web服务器设置的根路径对应的资源和相关文件。</li><li>含混不清的路径比如<code>http://localhost:8080/wishlist</code>，则会根据先判断是否为文件名，然后判断是否为目录的情况处理，或者看作一个请求映射到另一处资源，或者做一次重定向。</li></ul><p>上面的内容不必深究，只需要明白<strong>浏览器的第一步工作就是对 URL 进行解析</strong>。</p><h2 id="Http请求"><a href="#Http请求" class="headerlink" title="Http请求"></a><strong>Http请求</strong></h2><p>http请求简单来说可以简单概括为一句话：<strong>对什么做了什么样的操作</strong>，所谓对什么指的是URL，表示标识了的目标对象，做什么样的操作就是所谓的方法，方法主要是分为两个<code>POST</code>和<code>GET</code>方法，其他方法基本没啥用处，个人只在偶尔几个对接文档中遇到过<code>PUT</code>和<code>HEAD</code>方法。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205232259633.png" alt="img"></p><p><code>GET</code>方法：通常用于一些可见资源的访问，或者开放资源的访问，通常情况下不需要过多的限制就可以直接向具体的目录寻找需要的资源。</p><p><code>POST</code>方法：比较常见的是使用表单或者 AJAX的方式访问，并且通常会指向一个WEB的应用程序，获取应用程序的数据需要传递服务器需要的一些有效参数，否则服务端会根据具体情况通知客户端无权访问。</p><blockquote><p><strong>AJAX</strong>即“<strong>Asynchronous JavaScript and XML</strong>”（非同步的<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS9KYXZhU2NyaXB0" title="https://zh.m.wikipedia.org/wiki/JavaScript">JavaScript<i class="fa fa-external-link"></i></span>与<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS9YTUw=" title="https://zh.m.wikipedia.org/wiki/XML">XML<i class="fa fa-external-link"></i></span>技术），指的是一套综合了多项技术的<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS/ngI/opr3lmag=" title="https://zh.m.wikipedia.org/wiki/瀏覽器">浏览器<i class="fa fa-external-link"></i></span>端<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS/ntrLpoIE=" title="https://zh.m.wikipedia.org/wiki/網頁">网页<i class="fa fa-external-link"></i></span>开发技术。Ajax的概念由<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS/lgpHopb/Ct+ipueWnhuWjq8K36LOI55Ge54m5" title="https://zh.m.wikipedia.org/wiki/傑西·詹姆士·賈瑞特">杰西·詹姆士·贾瑞特<i class="fa fa-external-link"></i></span>所提出<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvemgtaGFucy9BSkFYI2NpdGVfbm90ZS0x" title="https://zh.m.wikipedia.org/zh-hans/AJAX#cite_note-1">[1]<i class="fa fa-external-link"></i></span>。</p></blockquote><p><strong>Http请求消息</strong></p><p>知道了 <strong>对什么做了什么样的操作</strong>，现在来看看Http 具体是怎么做这件事情的。</p><p>Http请求消息主要分为下面组织结构：</p><ul><li>第一行最开头的部分提取URL的内容，原封不动解析，末尾为HTTP版本号主要标记当前HTTP请求版本。</li></ul><blockquote><p>例如：<code>GET /cgi/sample.cgi?Field1=ABCDEFG&amp;SendButton=SEND HTTP/1.1</code></p></blockquote><ul><li><p>第二行为消息头，这里列举一些简单的内容：</p><ul><li><strong>Data</strong>：请求响应生成日期。</li><li><strong>Pragma</strong>：数据是否允许缓存。</li><li><strong>Transfer-Encoding</strong>：消息主体<strong>编码格式</strong>（重要）。</li><li><strong>Via</strong>：经过的代理和网关。</li></ul></li><li><p>消息头后面存在一行 <strong>完美没有内容的空行</strong>。</p></li><li><p>第四行为消息体，但是实验用的是GET方法所以通常内容为空。</p></li></ul><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205240734243.png" alt="img"></p><p>我们以访问谷歌为例，下面的内容访问谷歌搜索页面的一次请求参考，这里的内容直接通过谷歌浏览器的F12拷贝，可以看到基本包含了请求行，消息头和消息行（GET通常没有所以下面没有体现）三种。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">常规</span><br><span class="line"></span><br><span class="line">1.  请求网址:https://www.google.com/</span><br><span class="line">2.  请求方法:GET</span><br><span class="line">3.  状态代码:200</span><br><span class="line">4.  远程地址:127.0.0.1:7890</span><br><span class="line">5.  引荐来源网址政策:origin</span><br><span class="line"></span><br><span class="line">请求标头</span><br><span class="line"></span><br><span class="line">1.  :authority:www.google.com</span><br><span class="line">2.  :method:GET</span><br><span class="line">3.  :path:/</span><br><span class="line">4.  :scheme:https</span><br><span class="line">5.  accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">6.  accept-encoding:gzip, deflate, br</span><br><span class="line">7.  accept-language:zh,zh-TW;q=0.9,en-US;q=0.8,en;q=0.7,zh-CN;q=0.6</span><br><span class="line">8.  cache-control:no-cache</span><br><span class="line">9.  cookie:SID=KQi0QVpC_wxTynb6H6HjGmVq-9mYvCuIDOMx9EmEUJ8ii7dJzN_1F-ho69FdK6AN9ekOkA.; __Secure-1PSID=KQi0QVpC_wxTynb6H6HjGmVq-9mYvCuIDOMx9EmEUJ8ii7dJaTdIpqSfRfNb-BvF0haitA.; __Secure-3PSID=KQi0QVpC_wxTynb6H6HjGmVq-9mYvCuIDOMx9EmEUJ8ii7dJ6_WQQeEF09oAZ9MQfe21sA.; HSID=AOdmIhuBCutDeMwVS; APISID=ckyVXTB27QMaC2gQ/AVulr1cMnMbpD0e1x; SSID=AL0-0R0Ofsj3zaqrr; SAPISID=dqpTwJeh7bnii2Ki/AfsaDUfE8uMVR1aqv; __Secure-1PAPISID=dqpTwJeh7bnii2Ki/AfsaDUfE8uMVR1aqv; __Secure-3PAPISID=dqpTwJeh7bnii2Ki/AfsaDUfE8uMVR1aqv; SEARCH_SAMESITE=CgQIvJUB; 1P_JAR=2022-05-24-23; AEC=AakniGOKhznRpAD797X4u508i2XHJjEVYQQHANlqaJC2JSZ1F7mAe-vX_rg; NID=511=K-qt_LW-4ad1IYdJgfPLZjJw772wez2L3_FK9hwrrHAaksdhT8bTqz4icJEnJviOb92zcnyfS4h7P8HB_Is0f_FebYTe_5DR3qFEclHS1R9N1P7r9pv7Z4p12341S72RZRfzIlQ3-CVZUqQKBm1Xy1i9fKwejMGHTPMY2hk02sA--ey8nAEyt1_A7SVMe0RvrEkPnVm88fBnyyyFMMSCeSG1oqYKeC2x7iHJ0GwdbEpeGojpMQyQxAn1jAdxyXbC0oko0rCFjYn7eUREz2A9KA; SIDCC=AJi4QfGQeW0y_3pnzuBs7KI-WabF5XR_-dQchpcoNUN_bRVICBknb39qNQhP4IklnPn6kW4M3d8; __Secure-3PSIDCC=AJi4QfFOaoqiWv0mqmOskkIKVYy_-QNOATkPOyhNt9B8BBTMnRqnv-0zdgVgBNmIJRwlzBS4x6U</span><br><span class="line">10.  pragma:no-cache</span><br><span class="line">11.  sec-ch-dpr:2</span><br><span class="line">12.  sec-ch-ua:" Not A;Brand";v="99", "Chromium";v="101", "Google Chrome";v="101"</span><br><span class="line">13.  sec-ch-ua-arch:"arm"</span><br><span class="line">14.  sec-ch-ua-bitness:"64"</span><br><span class="line">15.  sec-ch-ua-full-version:"101.0.4951.64"</span><br><span class="line">16.  sec-ch-ua-full-version-list:" Not A;Brand";v="99.0.0.0", "Chromium";v="101.0.4951.64", "Google Chrome";v="101.0.4951.64"</span><br><span class="line">17.  sec-ch-ua-mobile:?0</span><br><span class="line">18.  sec-ch-ua-model:""</span><br><span class="line">19.  sec-ch-ua-platform:"macOS"</span><br><span class="line">20.  sec-ch-ua-platform-version:"12.3.1"</span><br><span class="line">21.  sec-ch-ua-wow64:?0</span><br><span class="line">22.  sec-ch-viewport-width:1440</span><br><span class="line">23.  sec-fetch-dest:document</span><br><span class="line">24.  sec-fetch-mode:navigate</span><br><span class="line">25.  sec-fetch-site:same-origin</span><br><span class="line">26.  sec-fetch-user:?1</span><br><span class="line">27.  upgrade-insecure-requests:1</span><br><span class="line">28.  user-agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.64 Safari/537.36</span><br><span class="line">29.  x-client-data:CLG1yQEIkrbJAQijtskBCMS2yQEIqZ3KAQjYjMsBCJShywEI2+/LAQjmhMwBCNupzAEI/qrMAQjDrMwBCKSvzAEYqKnKARirqcoB</span><br><span class="line">30. 已解码：message ClientVariations &#123; // Active client experiment variation IDs. repeated int32 variation_id = [3300017, 3300114, 3300131, 3300164, 3313321, 3327576, 3330196, 3340251, 3342950, 3347675, 3347838, 3348035, 3348388]; // Active client experiment variation IDs that trigger server-side behavior. repeated int32 trigger_variation_id = [3314856, 3314859]; &#125;</span><br></pre></td></tr></table></figure><p><strong>响应内容</strong></p><p>响应页面也是类似的需要回应请求行需要的内容信息，同时告知自己允许接受什么样的请求，如果目标IP找不到通常会变为404结果。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">响应标头</span><br><span class="line"></span><br><span class="line">1.  accept-ch: Sec-CH-Viewport-Width  </span><br><span class="line">2.  accept-ch: Sec-CH-Viewport-Height</span><br><span class="line">3.  accept-ch: Sec-CH-DPR</span><br><span class="line">4.  accept-ch: Sec-CH-UA-Platform</span><br><span class="line">5.  accept-ch: Sec-CH-UA-Platform-Version</span><br><span class="line">6.  accept-ch: Sec-CH-UA-Full-Version</span><br><span class="line">7.  accept-ch: Sec-CH-UA-Arch</span><br><span class="line">8.  accept-ch: Sec-CH-UA-Model</span><br><span class="line">9.  accept-ch: Sec-CH-UA-Bitness</span><br><span class="line">10.  accept-ch: Sec-CH-UA-Full-Version-List</span><br><span class="line">11.  accept-ch: Sec-CH-UA-WoW64</span><br><span class="line">12.  alt-svc: h3=":443"; ma=2592000,h3-29=":443"; ma=2592000,h3-Q050=":443"; ma=2592000,h3-Q046=":443"; ma=2592000,h3-Q043=":443"; ma=2592000,quic=":443"; ma=2592000; v="46,43"</span><br><span class="line">13.  bfcache-opt-in: unload</span><br><span class="line">14.  cache-control: private, max-age=0</span><br><span class="line">15.  content-encoding: br</span><br><span class="line">16.  content-length: 43734</span><br><span class="line">17.  content-type: text/html; charset=UTF-8</span><br><span class="line">18.  date: Tue, 24 May 2022 23:24:59 GMT</span><br><span class="line">19.  expires: -1</span><br><span class="line">20.  server: gws</span><br><span class="line">21.  set-cookie: 1P_JAR=2022-05-24-23; expires=Thu, 23-Jun-2022 23:24:59 GMT; path=/; domain=.google.com; Secure; SameSite=none</span><br><span class="line">22.  set-cookie: AEC=; expires=Mon, 01-Jan-1990 00:00:00 GMT; path=/; domain=www.google.com</span><br><span class="line">23.  set-cookie: AEC=; expires=Mon, 01-Jan-1990 00:00:00 GMT; path=/; domain=.www.google.com</span><br><span class="line">24.  set-cookie: AEC=; expires=Mon, 01-Jan-1990 00:00:00 GMT; path=/; domain=google.com</span><br><span class="line">25.  set-cookie: AEC=; expires=Mon, 01-Jan-1990 00:00:00 GMT; path=/; domain=.google.com</span><br><span class="line">26.  set-cookie: SIDCC=AJi4QfEXTiPm1BcAx1gfQzXOs-hmdcHylOVoSbbpy8cUIlP7hNwwfnfo_E8ZdTY1JZli8AqYYWk; expires=Wed, 24-May-2023 23:24:59 GMT; path=/; domain=.google.com; priority=high</span><br><span class="line">27.  set-cookie: __Secure-3PSIDCC=AJi4QfFdxOIbJrwDKltt2sBRVFIcLOCyqQmgTSfYjXTYwqbhh0GPLcR9cxsgyaIh1j_GITbGeHc; expires=Wed, 24-May-2023 23:24:59 GMT; path=/; domain=.google.com; Secure; HttpOnly; priority=high; SameSite=none</span><br><span class="line">28.  strict-transport-security: max-age=31536000</span><br><span class="line">29.  x-frame-options: SAMEORIGIN</span><br><span class="line">30.  x-xss-protection: 0</span><br></pre></td></tr></table></figure><p>响应内容相对比较简单，主要关注重点为第一行内容中的状态码和响应短语，请求执行结果是成功还是失败。上面的交互内容需要注意Http请求严格遵循一个请求对应一个响应内容。</p><blockquote><p>注意：1 条请求消息中只能写 1 个 URI。如果需要获取多个文件，必须对每个文件单独发送 1 条请求。</p></blockquote><p>“如何解析网址？”这个问题从头到尾的介绍到这里就完成的，接下来来看看下一个问题”DNS 服务器如何查询域名对应的 IP 地址？”。</p><h2 id="IP-和-DNS"><a href="#IP-和-DNS" class="headerlink" title="IP 和 DNS"></a><strong>IP 和 DNS</strong></h2><p>首先我们看看IP和DNS是啥，解析网址（域名）和发送请求和响应内容看似是浏览器完成的，实际上它并不具备这些功能， <strong>浏览器收发网络请求实际上需要依托操作系统完成</strong> ，而现代网络基本是<code>TCP/IP</code> 的天下，所以<code>IP</code>发挥关键作用，而<code>DNS</code>存储<code>IP</code>和域名映射的仓库。</p><ul><li>IP：可以类比做我们现实的具体位置，比如XX路XX号，XX路（网络号）对应的的是分配给<strong>整个子网</strong>的号码，而XX号（IP地址）的号码则分配给子网中的计算机，获得到IP地址之后就相当于锁定了当前计算机所在的具体位置，自然也可以可以找到了。</li><li>DNS：直白来讲就是存储了域名和IP映射的记录的站点，浏览器要获取真实地址需要找DNS才能知道，因为域名放任用户自由定义将会出现同一个域名映射多个IP。</li></ul><p>下面我们先观察XX路XX号的号也就是IP地址是如何被找到的。</p><p>发送网络的一方通过子网首先需要经过集线器，把内容转发到最近的路由器上，然后路由器会不断跨越找到离接受者更近的下一个路由器，最后再找到集线器然后在转发到接收者的路由器上，路由器在这里是方向盘的角色，而DNS寻址就像是导航。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205250802048.png" alt="img"></p><blockquote><p>集线器和路由器是什么？ A　路由器：一种对包进行转发的设备。 B　集线器：一种对包进行转发的设备， 分为中继式集线器和交换式集线器两种.</p></blockquote><h2 id="IP地址的组成"><a href="#IP地址的组成" class="headerlink" title="IP地址的组成"></a>IP地址的组成</h2><p>IP地址是一个32位的Bit数，通过8个bit为一组分为4组，每一组用十进制表示并且使用小圆点断开。</p><p>但是仅凭这32个bit是无法定位IP地址和网络号的，所以需要给IP地址附加信息。</p><p>通常IP地址的组合有下面的方法：</p><p>a）IP地址主体：<code>11.22.33.44</code></p><p>b）IP和子网掩码：<code>11.22.33.44/255.255.255.0</code></p><p>c）网络号的比特数作为子网掩码表示：<code>11.22.33.44/24</code></p><p>d）子网地址：<code>11.22.33.0/24</code>，此时代表了整个子网</p><p>e）子网广播地址：<code>11.22.33.255/24</code></p><p>首先整个IP分为32位固定长度，每四个为一组用圆点分隔，通过 0 - 255的十进制表示，比如0就是8个0，255就是8个1，但是仅仅凭借32个位数是<strong>没法辨别</strong>这32位那一部分是网络号，那一部分是主机号的，所以下面是IP的基本组成：</p><ul><li><code>11.22.33.44</code>：表示基本的IP。</li><li><code>11.22.33.44/255.255.255.0</code>：前面部分是基本IP，后面的部分表示子网掩码，表示方式和IP地址一致，注意最后的8位全部为0表示整个子网。</li><li><code>11.22.33.44/24</code>： 这个24也是子网掩码，但是表示子网的方式是使用比特数。</li><li><code>11.22.33.0/24</code>： 子网掩码没有变，IP地址变了，最后的8位0也是表示整个子网。</li><li><code>11.22.33.255/24</code>： 子网掩码没有变，IP地址变了，最后的8位全部位1表示<strong>广播</strong> 整个子网。</li></ul><h3 id="什么是子网掩码？"><a href="#什么是子网掩码？" class="headerlink" title="什么是子网掩码？"></a>什么是子网掩码？</h3><p>初学者可能比较难以理解的概念，这里如果看不懂建议多找找资料挑一个看得懂的解释（关键是自己理解并且能自己复述）。</p><p>下面是从书中原图，个人看完感觉并不是特别直观也不知道干嘛，所以做了一个补充说明。</p><p>实际上下面图中网络号用了AND（位操作 <code>&amp;</code>）计算出网络号码，计算之后确认出网络号是10.1.2，而后面省略的部分其实是8个0的掩码掩盖主机，这里的子网就是 10.1.2.0，对应的主机IP是10.1.2.3。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202206182257006.png" alt=""></p><p>如果看不懂上面说的是啥，这里补充解释一下：</p><p>首先我们需要清楚子网掩码这东西是干嘛的，说白了就是划分网络号和主机号的，网络号可以看作一栋楼，主机是里面的小房间，但是房间编号可能是<code>101</code>，也可能是<code>0101</code>，更有可能是<code>00101</code>，具体得看掩盖的房间号从0000到1111有多少个，决定能分配给多少主机，而计算机0又很特殊，所以网络号的部分+ 子网掩码掩盖的位数部分（表现全为0）组成一个子网，<strong>只有在同一个子网的主机才能互相通信</strong>。</p><p>所以<strong>子网掩码不能单独存在，它必须结合IP地址一起使用</strong>，子网掩码主要分为两个部分：全为1表示网络号，全为0表示的是主机号。</p><p>那么我们随便设置一个子网掩码比如<code>255.255.255.111</code>行不行？</p><p>答案是<strong>不行</strong>，<strong>不行</strong>，<strong>不行</strong>。因为<strong>子网掩码 必须是 连续的 1和0 组成</strong>，上面的掩码<code>255.255.255.0</code> 才是正确的用法，再举例比如<code>255.255.255.244</code>也是合格的子网掩码。</p><p>我们举例说明一下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1100 0000.1010 1000.0000 0001.1000 0001 <span class="comment">-- 192.168.1.129</span></span><br><span class="line">1111 1111.1111 1111.1111 1111.0000 0000 <span class="comment">-- 255.255.255.0</span></span><br><span class="line">———————————————————— </span><br><span class="line">1100 0000.1010 1000.0000 0001.0000 0000 <span class="comment">-- 划分出最终子网网段：192.168.1.0</span></span><br><span class="line">注：确认最终的网络号和主机网段使用了位操作 &amp; （1 &amp; 1 = 1，1 &amp; 0 = 0）</span><br></pre></td></tr></table></figure><p>从最终的结果来看<code>192.168.1.0</code> 的前面24位都为1是暴露的，而后面8位被子网掩码给遮掩住，所以他的另一种写法是<code>192.168.1.0/24</code>，表示24位是1代表网络号，剩余的8位用于表示主机号但是因为被掩盖了所以全部为0。</p><p>虽然被掩盖了，但是主机号位置是0是1不需要关心的，主机号如果落在<code>192.168.1.0</code>到<code>192.168.1.255</code>表示同在一个网段内子网一视同仁，比如<code>192.168.1.129</code>表示其中的129位，包含在这个网段之内。</p><p><strong>小结</strong></p><ol><li><strong>子网掩码 必须是 连续的 1和0 组成</strong>，简单记忆为1的部分来分割网络号，为0的部分用于掩盖主机号，同一个子网内的主机可以互相通信。</li><li>子网掩码有两种写入方式一种是使用和I P 地址一样的32位完全表示方式，另一种是使用数字计算1比特数进行替换，比如24就是下面图中的24个1。</li><li>IP 地址的主机号，全 0表示整个子网，全 1表示向子网上所有设备发送包。这里补充一下全为1的情况 - “广播”。</li></ol><blockquote><p>广播是什么意思？广播地址是专门用于同时向该网络中所有主机进行广播的一个地址，只要是在同一个网段的主机都可以收听到广播。（例如<code>192.168.211.32/24</code>的广播地址为：<code>192.168.211.255</code>）</p></blockquote><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>DNS： <code>Domain Name System</code> <strong>域名服务系统</strong>，最常见的用法是将服务器名称和 IP 地址进行关联，当然只是它的主业，他有一些副业也挺重要但是不是关键感兴趣了解即可。</p><p>IP是难以记忆的，而简短域名更容易被人记住。你可能会觉得域名长了也难记忆啊，虽然解析IP的速度要比解析域名来的快的很多，但是显然网民为了访问一个网站要记住一串数字显然是不可能的，同时域名实际上对于当时的互联网发展来说也是有意义的。</p><p>所以谁来告诉主机域名的真实IP是多少？这时候DNS就上场了，DNS的作用是说白了就是用来映射IP和域名的一个东西。</p><p>DNS是如何完成映射的？对于用户主机来说一定存在一个用于解析DNS的客户端，这个客户端通常被称为解析器，通过域名解析出IP地址的过程也被称为<strong>域名解析</strong>。</p><p><strong>调用解析器</strong></p><p>那么如何调用解析器？解析器实际上就是一段程序代码，这一段程序代码包含在底层操作系统的<code>Socket</code>库当中，通过<code>Socket</code>库调用解析器，然后解析器会向 DNS 服务器发送查询消息， DNS 服 务器根据请求查询IP然后返回响应消息。</p><p>Socket 解析域名的过程非常简单，只需要一行代码就可以完成：<code>gethostbyname(&quot;</code><a href="http://www.lab.glasscom.com" target="_blank" rel="noopener"><code>www.lab.glasscom.com</code></a><code>&quot;);</code>。</p><blockquote><p>库：指的是通用程序组件的集合，用于规范程序代码的规范组建。以解析器为例，Socket 库是用于调用网络功能的程序组件集合。</p></blockquote><p><strong>解析器内部又是如何工作的？</strong></p><p>在应用程序调用解析器的时候，此时控制权会转移到解析器，当控制权转为解析器之后解析器会生成要发送给 DNS 服务器的查询消息，生成过程类似构建一条“请告诉XXX的IP地址”的消息，并且发给DNS服务器完成解析。</p><p>特别注意注意<strong>发送请求不是由解析器完成</strong>，而是需要再次委托给操作系统的<strong>协议栈</strong>完成，所以此时权限会再次转移到协议栈，协议栈最终通过网卡把消息发给DNS，然后DNS查到IP返回消息，至此一次DNS解析请求就完成了。</p><p>值得注意的是 解析器会将取出的 IP 地址写入应用程序<strong>指定的内存地址</strong>中，此外还需要注意请求DNS服务器本身IP也是需要配置的，只不过这个 IP 地址是作为 TCP/IP 的项目事先设置好的，不需要再去查询直接就可以获取。</p><p>最后在不同的操作系统中获取DNS服务器的地址方式会有差别。</p><p>根据上面的描述，总结DNS解析流程：</p><ol><li>WEB浏览器发送域名解析请求，通过Socket向解析器进行请求解析，此时应用程序将会挂起。</li><li>解析器负责“翻译”应用程序的DNS解析请求，但是把具体的请求操作委托给系统栈。</li><li>系统栈负责将请求通过网卡发送给DNS服务器，等待DNS反馈结果。</li><li>DNS获取真实IP之后将结果通过链路反向回送到应用程序。</li></ol><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202206182256279.png" alt=""></p><p><strong>DNS工作</strong></p><p>接下来我们看看dns要如何工作，dns需要查询用户消息包含下面几个部分：</p><ul><li>域名：用来替代IP方便记忆。</li><li>class：考虑到互联网之外的情况，当然外部网络现在只有标识为in的互联网。</li><li>type：表示记录类型用于区分dns的解析方式，不同类型结果不同。</li></ul><p>需要注意的是所有a类型的记录在DNS上注册了，再比如所有邮件类型都是MX的类型，整个DNS工作其实就简单的根据类型和域名进行查表，找到匹配的就回传，否则就会找不到。</p><p>域名层次：所谓域名层次就是DNS不可能是一台服务器，而是需要多台服务器配合，各自管理自己范围的内容，而对于域名来说越靠右边的部分在域名的层次里面越高。</p><p>这样看来是不是有点意思，以日常生活举例并不是我们认为的<code>www</code>是最高，其实他是最低的等级，<code>.com</code>才是最高的。</p><p><strong>DNS查找步骤</strong></p><p>首先将负责管理下级域的 DNS 服务器的 IP 地址注册到它们的上级 DNS 服务器中，然后上级 DNS 服务器的 IP 地址再注册到更上一级的 DNS 服务器中，以此类推。</p><p>举个例子，需要解析等域名为<code>www.baidu.com</code>，DNS需要事先把整个<code>www.baidu.com</code>整个域名注册到<code>baidu.com</code>，再把<code>baidu.com</code>注册到<code>com</code>域名，再把<code>com</code>注册到根域，这样就可以通过上级找下级。</p><p>这里提到DNS有一个根域，根域名指的是就是一个句点 <code>.</code> ，和Linux的根路径意义表现形式上类似。</p><p>根据根域可以解释为什么任何奇怪等域名都可以被访问到，原因是所有的下级都会注册到上级中，最后都有一个共同的 ，如果所有下级要找到根域，自然需要注册根域这个句点。</p><p>DNS查找的过程是自下而上找最近的DNS然后自上而下找根域向下查找的的，也就是先找<strong>最近的dns</strong>找，没有找到就需要直接从根域进行查找，一路通过层级下探找到最终的ip，这也是为什么访问国外ip慢的原因，因为路由链路实在是很长，可能需要几十次dns搜索查找。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202206182255672.png" alt=""></p><p><strong>DNS缓存</strong></p><p>如果每个主机每次请求总是要通过DNS获取域名对应的IP信息，是不可能每次都DNS让找一遍的，实际上解析到的真实IP会预先缓存起来下次访问重复的数据直接返回即可。</p><p>另外虽然前面介绍的是查找自上而下从根域向下查找，实际上DNS还可以利用缓存特性通过多个层级的共享域名加快访问速度跨级查找，比如<code>www.baidu.com</code>和<code>www.baidu</code> 可以共享缓存直接跳两个层级快速找到（当然这里其实找最近的一个DNS就能找到，这里仅仅是举例）。</p><p>但是缓存有个副作用，就是不存在的ip地址消息也会缓存，不过为了防止这种情况一般会有过期时间，过期之后依然需要再次走一遍DNS查找流程。</p><blockquote><p>问题引导：问题</p><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5uaWtrZWlicC5jby5qcC8=" title="http://www.nikkeibp.co.jp/">http://www.nikkeibp.co.jp/<i class="fa fa-external-link"></i></span> 中的 http 代表什么意思？</li></ul><p>表示的是HTTP 协议</p><ul><li>下面两个网址有什么不同？</li></ul><p>a. <span class="exturl" data-url="aHR0cDovL3d3dy5uaWtrZWlicC5jby5qcC9zYW1wbGU=" title="http://www.nikkeibp.co.jp/sample">http://www.nikkeibp.co.jp/sample<i class="fa fa-external-link"></i></span></p><p>b. <span class="exturl" data-url="aHR0cDovL3d3dy5uaWtrZWlicC5jby5qcC9zYW1wbGUv" title="http://www.nikkeibp.co.jp/sample/">http://www.nikkeibp.co.jp/sample/<i class="fa fa-external-link"></i></span></p><p>区别点在于sample 可能被解析出和预期不符合的结果。</p><p>用来识别连接在互联网上的计算机和服务器的地址叫什么？</p><p>IP地址</p><p>根据 Web 服务器的域名来查询 IP 地址时所使用的服务器叫什么？</p><p>DNHS服务器</p><p>向 DNS 服务器发送请求消息的程序叫什么？</p><p>解析器。</p></blockquote><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      网络基础
    
    </summary>
    
    
      <category term="网络/网络基础" scheme="https://whitestore.top/categories/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="网络/网络基础" scheme="https://whitestore.top/tags/%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>《how to die alone》读书笔记</title>
    <link href="https://whitestore.top/2022/08/11/howtodie/"/>
    <id>https://whitestore.top/2022/08/11/howtodie/</id>
    <published>2022-08-10T21:28:25.000Z</published>
    <updated>2022-09-08T02:18:34.396Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《how-to-die-alone》读书笔记"><a href="#《how-to-die-alone》读书笔记" class="headerlink" title="《how to die alone》读书笔记"></a>《how to die alone》读书笔记</h1><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220604191654.png" alt=""></p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>算是个人真正意义上靠着翻译软件和自己掌握的拉胯的单词水平啃完的第一本全英文书，从封面到内容半个中文都没有，前前后后靠着自己的记录啃了2个月左右的时间，最终看完发现对于自己的单词积累量提升还是挺大的。</p><p>这本书是图文结合的一本娱乐向小说？作者用摆烂的布莱尔发泄自己被甩的怨恨和愤怒，比较有意思的书籍，整体看来来也并不会因为作者是一个外国人get不到点。</p><p>看这本书一方面是对于书名比较感兴趣，另一方面是顺带锻炼自己的英语能力。</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>这本书网上找不到电子版，可能是太小众了吧，不过实体书确实很贵，原因是100多页但是因为是彩页+漫画。</p><p>对比个人买的其他全英文书这本书的装订还是比较好的，国外的书籍喜欢用回收纸，并且看上去像是国内十几年前的盗版书纸质，没办法老外就是如此粗暴简单。</p><p>最终这本书是轻松娱乐向的，简单看看即可。</p><h1 id="个人评价"><a href="#个人评价" class="headerlink" title="个人评价"></a>个人评价</h1><p>这本书并不打算做个人笔记了，所有的笔记都是自己的翻译内容，个人在翻译过程中顺带记录了一些查询的单词，这本书个人查询的单词还是非常多的，所以基本会看到满屏的标签内容。</p><h1 id="笔记记录"><a href="#笔记记录" class="headerlink" title="笔记记录"></a>笔记记录</h1><p>相当于直接翻译了这本书了，当然质量堪忧，很多地方没有润色。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li>自我介绍：<strong>MEET BLAIR</strong>（密特，布莱尔）</li><li>布莱尔五条孤独终老的建议<ol><li>成为反社会隐士 #antisocial_hermit  </li><li>获得最糟糕朋友奖 #earn_worst_award </li><li>在工作中获得“F”</li><li>破坏你的健康 #wreck </li><li>避免就像是瘟疫的浪漫</li></ol></li><li>如何坟墓中获得笑声。</li><li>致谢</li></ol><h2 id="内容介绍（书的背面）"><a href="#内容介绍（书的背面）" class="headerlink" title="内容介绍（书的背面）"></a>内容介绍（书的背面）</h2><p>作者：莫，韦尔奇萨。单口喜剧演员，作家，漫画家，被前任甩了然后创造了布莱尔。</p><p>不接受任何形式的约会，布莱尔来了，生活的主人，穿着运动裤，只和猫说话，从阴暗但是诚实的角度来看，布莱尔会教你如何成为一个反社会隐士，在你无聊的工作中摆烂，破坏你的人际关系，总是，总是允许自己选择沙发而不是健身房。</p><h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>hi，我是布莱尔，我们从来没有朋友，大概是因为你的父母叫我“有点压抑 #depress  ”和“太愤世嫉俗”和“她的爸爸在哪”？在生活中我看你会有黑暗的看法，但是我总是积极 #postive 的并且活在一个充斥着极度积极的 youtube 人物的世界里，诚实 #honest 将会有所回报，难道不是么？</p><p>这个世界有太多自我拯救的书籍，他们提供克服 #overcome 社交焦虑 #social_anxiety  的步骤并开出不吃肉 #meat 的处方，在生活中通过无趣的饮食 #diets  减轻你的体重，这些书为一部分人服务，我不想浪费我的生命阅读如何改善 #conversation 自己生活的书籍，我更愿意浪费我的生命和我的猫单独对话。</p><p>所以这本自救指导书并不会帮助你如何自救，这本指导书适用于想要穿着运动裤，每顿饭只吃吃披萨并且在家过日子的勇敢灵魂。</p><p>在这本书中，我会教你如何成为反社会斗士，如何破坏你的友谊，我甚至会提供墓碑 #tombsone 建议 #suggest  来帮助你庆祝成功独自死去，当我们都去世的时候你可以感谢我。</p><h2 id="成为反社会隐士"><a href="#成为反社会隐士" class="headerlink" title="成为反社会隐士"></a>成为反社会隐士</h2><p>在某一点 #certain_point 上，参加聚会成为更多成为苦差事而不是奖励 #reward ，可能是因为没有令人惊喜 #surprise 的对象 #element ，每一次聚会都与之前相同 #identical ，当你挑选一套衣服 #outfit 时，你会感到羞耻 #fat-shame ，你太早的参加聚会，与你聊天的人你将再也不会见面，你花费 #spend. #whole  整晚都在想象自己在家里穿着运动裤看谋杀纪录片。</p><p>为什么要参加麻烦的聚会？为了某人？为了某事？如果你真的想孤独致死，从现在开始保持单独行动，再也不要离开你的房子去看望任何朋友或者家人，你的猫除外。</p><ul><li><p>一个女人的肖像，她所有的计划都在剥落</p></li><li><p>隐士秘诀 1：如果你不确定是否要出门，立刻说不</p><ul><li><p>在公共场所遇到熟人如何隐身？</p><ul><li><p>跳到那个衣架 #rack 的中间 #middle</p></li><li><p>躺在那灌木丛 #bush 中</p></li><li><p>躲在树后面 #behind</p></li><li><p>跟在后面（保持相同的步伐）</p></li><li><p>拉住一个小宝贝，说看我现在必须找到他的妈妈</p></li><li><p>把那个宝贝还给你，你还没准备好承担那种责任 #responsibility </p></li><li><p>跳进下水道，十几岁的突变忍者龟在他们看到杰拉德之前是普通的乌龟，他们不想和他们的朋友说话</p></li></ul></li></ul></li></ul><pre><code>-我们小时候玩捉迷藏 #hide_and_seck ， 是为了让我们准备好在成年后在公共场合见到我们认识的人呆在家里并且静止不动今日预测 #forecast ：外面人太多，适合呆在家里。</code></pre><ul><li><p>隐士秘诀2: 如果您在网上关注曾经生活过的人，您就不需要生活</p><ul><li><p>我想我会去里面滚动 #scroll #inside</p></li><li><p>在脱离你无聊的朋友时候经由我的猫太孤单了并且需要我，你一定可以理解。</p></li><li><p>锻炼？是的，锻炼，我必须去健身房 #gym 了</p></li><li><p>必须在日落前整理我的麦片盒 #sunset</p></li><li><p>我上班要迟到了！(你不用说你正在做的是在社交媒体上跟踪前朋友，你的办公室是一张床，你的同事是一只猫)</p></li><li><p>我在艰难的观察每一个谋杀 #murder  纪录片的可能性</p></li><li><p>我需要礼拜（祈祷 #pary ）（相信我，没有人在这一点上可以战胜你）</p></li></ul></li></ul><ul><li><p>和猫单独对话</p><ul><li><p>你整天都在干啥？</p></li><li><p>我们死了之后都会去哪？</p></li><li><p>你相信 #believe 奇迹？会发生在游戏里面么</p></li><li><p>你认为和 tim 和斯黛希会干什么？</p></li><li><p>诚实 #honest 回答，我死了时候；你会吃了我么？</p></li></ul></li><li><p>宠物因为没法学会喝酒的原因  #reason （所以）很孤独</p></li><li><p>差点离开基本上就是离开，指站在门口。</p></li><li><p>我想我在被关爱中（吹头发）</p></li><li><p>6种方法在五分钟内美化你的运动裤</p><ul><li><p>系上腰带 #belt</p></li><li><p>亮片 #sequin</p></li><li><p>戴上围巾</p></li><li><p>把口袋 #pocket 翻到外面，等到朋友来问 这是新趋势嘛？你的五分钟外出将会提升.</p></li><li><p>不穿 开玩笑 #kidding 的，不要这样</p></li><li><p>把它们挂在你的屁股上，你有燕尾服</p></li></ul></li><li><p>一个运动裤派对</p></li><li><p>一个人吃饭是和他人的新式吃法</p></li><li><p>完成家务本身就是家务，也就是不做家务</p></li><li><p>隐士秘诀3: 面无表情的盯着窗外，直到邻居最终标记你为“奇怪的猫女士”. 这是应得的</p></li><li><p>我付了很多房租 #rent 让里面 #inside 这么惨 #miserable<br> kmk </p></li><li><p>如果你独自生活，洗澡永远是你的todo 项目</p></li><li><p>Oh，这个地方你不能去</p></li><li><p>隐士秘诀4:随意计划活动，只是不要邀请任何人参加（ #events , #plan ， #invite ， #just ）</p><ul><li>看，一个反社会的冰淇淋</li></ul></li></ul><p>你真的是一个合格的反社会 #hermit 隐士？</p><ul><li><input disabled="" type="checkbox"> 夜间活动你的首选 #preferred 是疯狂TV SHOW（猜测是美国的很火的综艺节目）</li><li><input disabled="" type="checkbox"> 你的沙发上的毯子的数量 #The_number_of   超过了 #surpasses  装饰枕头的数量</li><li><input disabled="" type="checkbox"> 当你下班 #after_work 回到家时，你有很大的可能 #fat_chance 会离开</li><li><input disabled="" type="checkbox"> 当朋友问你要不要出去喝酒的时候你很恐慌 #panic</li><li><input disabled="" type="checkbox"> 你只有规定 #regurlar 的访客那就是送餐人 #delivery  。</li><li><input disabled="" type="checkbox"> 对了，送餐员在你的快速拨号里面</li><li><input disabled="" type="checkbox"> 雨过天晴 #rain 的时候，你会觉得很兴奋</li><li><input disabled="" type="checkbox"> 你用完整的句子和你的猫说话 #complete_sentences</li><li><input disabled="" type="checkbox"> 在一本叫做《如何孤独地死去》的书中，你住在这里并填写了检查表 #check_list #fill_out </li></ul><p>你是否勾选了超过7个选项？恭喜 #congrats ，你是合格隐士，但是你不是唯一的一个，在这个世界上还有我也填写了这份报告 #fill_out </p><h2 id="糟糕朋友奖"><a href="#糟糕朋友奖" class="headerlink" title="糟糕朋友奖"></a>糟糕朋友奖</h2><p>朋友是被高估 #overrited 的，你只有在学校的自助餐厅感到孤独的时候才真的需要他们，就像贫穷的史蒂夫一样，怀疑鬼鬼祟祟的在毕业之后和你的朋友失去联系？相信他</p><p>朋友永远不会告诉你真相，他们想让你像他们一样，所以他们只是会说一些你想听到的话，比如 “你需要完整的刘海”，“急需要尽快完成你的作业”，”你的牙齿上没有蔬菜叶，布莱尔，说茄子”。</p><p>如果你想要认真的单身生活，你应该让你朋友待会儿或者立刻滚蛋，不确定要这么做？跟随我的tip ，你也能获得著名 #prestigious 的糟糕朋友奖</p><p>当你因为无聊 #bored 和童年朋友聊天的时候，一定要带到 # bring up 一个旧的学校餐厅，你要战斗好几个小时。</p><p>10年了你还欠我3美元和两份双层芝士汉堡</p><p>在和你谈到机场层面之前，我可以接受任何层次的友谊。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I&#39;m confortable with any level of friendship before the talking you to the airport level</span><br></pre></td></tr></table></figure><p>你的纹身 #tatoo 完整含义是什么？</p><p>他的意思是：我讨厌小声说话的陌生人有趣，</p><p>所以，你是从哪里来的?</p><p>糟糕朋友标签2</p><p>如果你在外面没有 #out 食物和金钱，偷袭 #raid 你富有朋友的冰箱 #fridge ，如果他们抓到你，说你想念和他们在一起。</p><p>我对待 #treat  我的朋友的房子就像24小时便利店。</p><p>你的朋友不想听但你还是会说的真相:</p><ul><li>或许你的妈妈是对的（在任何事情上都适用）</li><li>嘿，你肯定 #definitely 选 #picked 错了职业 #career。</li><li>如果我被逮捕 #arrested  ，你是我最后一个会打电话的人。</li><li>当你告诉关于你生活中的故事时我会小睡 #naps 一下。</li><li>是的，实际 #actually 上你已经告诉我“快乐”的故事17次了。</li><li>你不能因为化妆品扼杀 #kill 你约会  #date  的时间（但是我能）。</li><li>你和你宠物的相性太糟糕了</li><li>是的，<strong>你的发型就像是用促销优惠券剪的</strong></li><li>你的新男朋友精确的像你旧男朋友</li><li>你有口臭（绝杀）</li></ul><p>当你要吃早午餐的时候，千万不要坐中间位置，人们通常会从你旁边经过并且会很吵，（建议是）抢夺最后一个位置坐下，无论何时只要你想你可以跑去卫生间。</p><p>我宁愿吃自己的手臂，也不愿意和你和你大学朋友去吃早午餐。</p><blockquote><p>I’d rather eat my own arm than go to brunch with you and your college friends</p></blockquote><p>我没有嘲笑你非常难过，我在笑是因为情绪让我感到不舒服。</p><p>当你假扮 #pretend 成你的成熟朋友我的宝贝改变了我，我爱你，我最乖的宝贝。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205181333674.png" alt=""></p><p>给你的猫一个人名，当你说你不能出去，因为你已经有计划，John，你的朋友认为你遇到了一个更 cool 的人。</p><p><strong>我不想去参加你的婚礼的原因</strong></p><ul><li>我不能给任何礼物在你的注册证上</li><li>我知道你会惩罚单身人士在儿童座位旁边</li><li>之后我不会尊重和你的关系见到你在单身派对</li><li>我讨厌在派对上和其他单身人士一起被迫捧着鲜花</li></ul><p>你是一个最糟糕的朋友么？如果你想要获得最糟糕朋友奖，下面这些检查清单可以帮助你：</p><ul><li><input disabled="" type="checkbox"> 你总是迟到。</li><li><input disabled="" type="checkbox"> 你不带任何吃的却到处蹭吃蹭喝。</li><li><input disabled="" type="checkbox"> 你从来不回群组消息。</li><li><input disabled="" type="checkbox"> 当朋友不在身边的时候说他们的坏话。</li><li><input disabled="" type="checkbox"> 你曾经告诉你最好多朋友她的宝贝看起来 很怪异。</li><li><input disabled="" type="checkbox"> 你 对待你朋友的厨房就像是在开酒吧。</li><li><input disabled="" type="checkbox"> 任何地方你从来不当司机。</li><li><input disabled="" type="checkbox"> 你借走你的朋友的外套，同时归还的时候带着猫身上的毛。</li><li><input disabled="" type="checkbox"> 你从不关注关于你朋友的生活，然而，非常关注他们宠物的生活。</li></ul><p>你选择超过7项么？恭喜，你获得最坏朋友奖项，你同你的猫保持居家，因为你的朋友不能接受你在任何地方。</p><p><strong>在你的工作上获得F</strong></p><p>如果你像我一样工作是为了生活，而不是因为其他任何事情，你 靠着薪水活下来，你每天都在幻想告诉你的老板，我要辞职，当然当咖啡越来越少的时候我从来没有填满咖啡壶，并且我经常从供应柜偷很多纸。</p><p>关于最糟糕的同事，我的意思是，我有点喜欢那个总是把妻子给他做的午饭里面薯片分给我的人，但是其他每个人都很糟糕，实际上一些人总是想要努力工作，我猜有一句老话说的对：“不要结交朋友也不要树立敌人，你的同事理你真的，真的很远”。</p><p>我们不应该工作，人生太短，但是如果你必须跋涉到办公室，这一节将会教你怎么样投入最少量的努力。</p><p>饼图看起来不是很美味，但是他们是给你无聊的同事表达你的对于工作不满最好的方式。</p><p>在工作中表现自己不舒服</p><ul><li>我不舒服 #sick（因为露面）。</li><li>我出了好多汗 #sweating ， 真的很多。</li><li>发型糟糕的一天，这是合理的，不是么。</li><li>从珍妮特那里抓住了一些东西（def 不知道怎么翻译）。</li><li>免费的午餐让我食物中毒 #poisoning ，都是你的错。</li><li>睫毛永久地卡在我的眼睛里 #eyelash 。</li><li>脱水了 #dehydarated</li><li>我的猫跑了，他去了另一间屋子，她喜欢那个地方。</li><li>我看了一部有关外星人的纪录片，那有什么意义。</li><li>晕车。</li><li>晕船。</li><li>晕火车。</li><li>赛格威病 #Segway</li><li>我扭伤我的脚腕，这次是真的</li><li>我没衣服穿了，很严重，我几个月没洗衣服了</li><li>我很难准备这一周的工作</li><li>我得了百日咳</li></ul><p>听起来像是 ？？？ 的笑声</p><p>你迟到了！</p><p>我总是迟到，只不过今天被抓 #caught 了而已</p><p>噢。。。。</p><p>在卫生间只花费20分钟看 Instagram。</p><blockquote><p>介绍：（Instagram（照片墙）是一款运行在移动端上的社交应用，以一种快速、美妙和有趣的方式将你随时抓拍下的<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlOUIlQkUlRTclODklODcvMzcyNDE2" title="https://baike.baidu.com/item/%E5%9B%BE%E7%89%87/372416">图片<i class="fa fa-external-link"></i></span>彼此分享。）</p></blockquote><p>糟糕雇员Tips3：<br>在你正在工作的时候查看另一个工作， 就像是你获得报酬并计划逃跑。</p><p>你是最差的员工吗？</p><p>下面这些简单清单你应该看看</p><p><strong>你是糟糕的雇员么？</strong></p><ul><li>在最后的一个星期你上班迟到了4天</li><li>你经常 #regular 停留 #park 在你老板的位置 #spot</li><li>你养成了经常提醒每个人的习惯，这份工作太适合你了</li><li>你剽窃 #steal 公司的补给品 #supply 并且放到黑市上去卖</li><li>你只会在有可能会有免费蛋糕的时候才说生日快乐</li><li>你带着你的猫去上班虽然你的同事对猫过敏</li><li>不管何时何地你会撕掉冰箱里的食物标签并且撕掉他</li><li>你从来没有填满咖啡机</li><li>我每天大约花四分之三的时间评判同事</li><li>每天保持四分之一的时间在社交媒体上</li></ul><p>最后一条感觉中招了，额</p><h2 id="报复健康"><a href="#报复健康" class="headerlink" title="报复健康"></a>报复健康</h2><p>我刚刚编造的一条新研究，我们思考锻炼 #work_out 和正确饮食百分之800比我们实际上要做的更多，我确定有一些励志名言列表，由一堆支持我的足球教练 #coache 来鼓励 #encourage 你锻炼和喝蔬菜汤，但是我想提供另一个选择 #alternative  ，丢掉汗湿的毛巾 #toweal ，我的意思是，就像我说的，他是汗湿 #sweat 的，不需要随身携带，这太恶心  #gross 了。</p><p>此外，你可以在你的生活中每天喝你的绿色饮料然后每天去参加黑暗的EDM碰撞旋转 #spin 课程，但是我们所有的书都以同样的方式结尾，开个玩笑，很明显 #obviosly ，保持单身，独自死去。</p><p>所以坐下来，绝对不要起床，打开一袋薯片，并且阅读本章如何做，你几乎什么都学不到  #exactly ，这真是棒极 #brilliant 了。</p><p>差不多 #almost 吃到肚子里有宝宝的重量 #weight 了</p><blockquote><p><strong>BYOSnacks</strong>: bring your onw Snacks 自带酒水或者食物。</p></blockquote><p>当你去你的乳糖 #lactose 不耐症 #intolerant 素食 #vegan 主义者朋友生日派对时</p><p>不喜欢热瑜伽 #yoga 。更多进入热口袋?（不太知道怎么翻译。）</p><p>我今天做的唯一锻炼是当我大喊“下班了“，并且离开办公室的时候。</p><p>我要放弃海滩身材换桃子 #peach 身材，圆滚滚 #fuzzy</p><p>放置一个开始标记在你的睡椅上，然后放一个结束的标记在你的冰箱 #fridge  上，看你只是想快点赢比赛 #race 而已。</p><p>我有糟糕 #terrible 的饮食结构，我总是欺骗 #cheat 他们。</p><p>我喜欢我的锻炼就像是鸡蛋这个单词的最前面的e一样easy</p><p>联系到能到达床边的快递</p><p>在周末对待你自己就像是对待垃圾流水线</p><p><strong>能给任何人留下深刻印象的单身晚餐</strong></p><ul><li>可以放进微波炉的 #Microwaveble 意大利面 #spaghetti</li><li>剩下一半 #half 的过期三明治</li><li>搅碎的沙拉和奶酪块 #cube</li><li>弹出蛋挞 #pop-Tarts 自助餐 #buffet ，又名 #aka 绝望 #despair 自助餐 </li><li>盒装葡萄酒 #wine</li><li>谷物面包 #cereal 和带有沉淀物 #dregs 的牛奶</li><li>偷来的面包和三滴带有钠的泪水</li></ul><p>这是协定。你每个月给我钱并且再也不要见到我</p><p>你滚蛋</p><p> 像烟雾一般消散</p><ul><li>不要调料</li><li>不要腌菜</li><li>不要西红柿</li><li>不要面包<br>我要她所有不要的东西</li></ul><p>连续第十年把跑一次马拉松放进新年绝对要完成的任务里面</p><p>备注：自从第七年开始没有动过一英里</p><p>#row ：有连续不断的意思</p><p>如果你躺着在一条羽毛编织的毛毯上你不需要出去锻炼身体</p><p><strong>你在沙发难题上已经完成你的转变了吗？</strong></p><ul><li>你在你的健身房穿着运动裤步行，并且强烈的要求 #demanded 注销 #cancel 你的健身卡会员 #membership</li><li>你还在回家的路上叫披萨的外卖，这是唯一的毒药和肾上激素你在公共场合烧掉你 ·的游泳衣</li><li>当你应该跑步的时候你可以散步</li><li>当你应该散步的时候可以坐下</li><li>当你应该坐下的时候你应该躺平</li><li>你购买了时候一直想要的谷物食物，种类差不多是那种小饼干</li><li>你渴望设置一项世界纪录，不要锻炼</li><li>你参加5k比赛只是想要一件免费T恤</li></ul><p><strong>什么是应该买的而不是不怎么使用的健身房会员</strong></p><ul><li>48条运动裤</li><li>一个给我猫的无技术 #technology 修养所 #retreat</li><li>装在车里面的按摩椅 #massage</li><li>更多的TV流媒体订阅 #subscriptions</li><li>1995年别克车 #Buick</li><li>电子游戏 所有的按钮都在一个控制器里面，包含所有的锻炼内容</li><li>伊利诺斯州一栋普通房子</li><li>一台跑步机 #treadmill ，用来挂我的48条运动裤</li><li>一个奶酪汉堡 #cheeseburger</li><li>很多比特币 #bitcoin</li></ul><h2 id="避免瘟疫浪漫"><a href="#避免瘟疫浪漫" class="headerlink" title="避免瘟疫浪漫"></a>避免瘟疫浪漫</h2><p>在线约会应该会让事情变简单，但是不知道怎么浪漫比任何事情都难，</p><p>另一方面，人们在坠入爱河时候会感到无聊，他们变得非常乐观并且脸上总是洋溢着笑容，你想要过上这样的生活吗？不！有更多有趣的事情等待着永远单身的朋友们享受生活时间，不需要分享披萨和和大量的床上空间。</p><p>如果你已经有女朋友，或者甚至想要成为其中一员，立马停下，抛弃，卷走他，在这个单元我会告诉你如何让你的浪漫点燃你的生活，以及让他看起来像是荣耀探险。</p><p>家庭假日全套装备</p><p>是的，还是单身</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220526132526.png" alt=""></p><p><strong>愤世嫉俗方法</strong></p><p>在你约会的时候展示你的宠物照片，如果他们露出奇怪的样子，拿起你的饮料泼到他们脸上。</p><p>我只会回应一种也就是猫的呼叫</p><p>如果你快乐并且你知道它。把那狗屎留给自己：if you are happy and you konw it. keepthat shit to yourself</p><p>我在修剪指甲的时候才会感觉我住我的手</p><p>如果你想要避免第二次约会，你需要在第一次约会的时候明确的内容</p><p>如果你快乐并且你知道它。把那狗屎留给自己</p><blockquote><p>if you are happy and you konw it. keepthat shit to yourself</p></blockquote><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220604190605.png" alt=""></p><p>你喜欢什么类型的音乐，经典传统摇滚</p><p>我喜欢旧货币</p><p>每周五的晚上我都会得大量皮疹，你呢？</p><p>当你的紧急联系人是你的妈妈的时候你知道你单身知道你单身</p><p>正好约会后告诉我他们不喜欢猫。</p><p>讽刺的看家庭剧，大声喊出像是“哈，没有任何人是真实的”，和“给我三年时间，他毫无疑问爱上他最好的朋友”。</p><p>第一次恋爱，结婚，然后生孩子，我太孤独了</p><p><strong>如何分手?</strong></p><ol><li>是时候决定反弹 #bounce 了。</li><li>看部电影破坏自己的预先准备富兰克林，亲爱的，不会是我的错。</li><li>通知杂货店，你待会儿需要他们的帮助。</li><li>传递你的嘘声（抱怨） #boo ，告诉他们你离家出走了。</li><li>等待直到他们去上班，然后悄悄溜到他们房子附近对他们的宠物说goodbye</li><li>烧掉你的手机</li><li>吃掉杂货店买的零食 #groceries</li></ol><p>不要线上或者线下约会</p><p>多米诺披萨APP &gt; Tinder（一款APP），因为我可以看到进度条。</p><p>手牵手散步应该是违法 #illegal</p><p>刚发了我的第一个sext（祷告），那是一张丹麦奶酪的照片。</p><p>补充：这里不太懂sext如何翻译，于是查了一下，个人猜想是宗教的一种俚语，简单理解为<strong>中午</strong>这个时间点即可。</p><blockquote><p><strong>六时经</strong>为<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTk3JUE1JUU4JUFGJUJFJUU3JUJCJThG" title="https://zh.wikipedia.org/wiki/%E6%97%A5%E8%AF%BE%E7%BB%8F">日课经<i class="fa fa-external-link"></i></span>的一部分，是<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JThGJUE0JUU3JUJEJTk3JUU5JUE5JUFD" title="https://zh.wikipedia.org/wiki/%E5%8F%A4%E7%BD%97%E9%A9%AC">古罗马<i class="fa fa-external-link"></i></span>的六点 ，等于现在的中午。是正午时的一次<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUE1JTg4JUU3JUE1JUI3" title="https://zh.wikipedia.org/wiki/%E7%A5%88%E7%A5%B7">祈祷<i class="fa fa-external-link"></i></span>。这一时间的祈祷主要是为了纪念<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JTgwJUI2JUU3JUE4JUEz" title="https://zh.wikipedia.org/wiki/%E8%80%B6%E7%A8%A3">耶稣<i class="fa fa-external-link"></i></span>被钉在十字架上的那一刻：“第六日的第六时被钉在十字架上的耶稣撕毁了<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU0JUJBJTlBJUU1JUJEJTkz" title="https://zh.wikipedia.org/wiki/%E4%BA%9A%E5%BD%93">亚当<i class="fa fa-external-link"></i></span>的赎罪行径”（<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JThCJTlDJUU1JThEJUEwJUU1JUJBJUFEJUU3JUE0JUJD" title="https://zh.wikipedia.org/wiki/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E7%A4%BC">拜占庭礼<i class="fa fa-external-link"></i></span>）。</p></blockquote><blockquote><p>按照<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUJFJTg1JUU5JUE2JUFDJUU3JUE2JUFF" title="https://zh.wikipedia.org/wiki/%E7%BE%85%E9%A6%AC%E7%A6%AE">罗马礼<i class="fa fa-external-link"></i></span>习俗，六时经应由一首<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUI1JTlFJUU2JUFEJThD" title="https://zh.wikipedia.org/wiki/%E8%B5%9E%E6%AD%8C">赞歌<i class="fa fa-external-link"></i></span>、三首<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JTgxJTk2JUU4JUE5JUE5" title="https://zh.wikipedia.org/wiki/%E8%81%96%E8%A9%A9">圣诗<i class="fa fa-external-link"></i></span>（或几节圣诗）、一段简短的<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JTgxJTk2JUU2JTlCJUI4" title="https://zh.wikipedia.org/wiki/%E8%81%96%E6%9B%B8">圣书<i class="fa fa-external-link"></i></span>阅读、一段<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3cvaW5kZXgucGhwP3RpdGxlPSVFNyVCQiU4RiVFNiU5NiU4NyZhY3Rpb249ZWRpdCZyZWRsaW5rPTE=" title="https://zh.wikipedia.org/w/index.php?title=%E7%BB%8F%E6%96%87&action=edit&redlink=1">经文<i class="fa fa-external-link"></i></span>和一段<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUE1JUI3JUU1JTkxJThB" title="https://zh.wikipedia.org/wiki/%E7%A5%B7%E5%91%8A">祷告<i class="fa fa-external-link"></i></span>组成。某些<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU0JUJGJUFFJUU5JTgxJTkzJUU5JTk5JUEy" title="https://zh.wikipedia.org/wiki/%E4%BF%AE%E9%81%93%E9%99%A2">修道院<i class="fa fa-external-link"></i></span>还会在降福前或降福后（根据具体地点而定），增加一首献给<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JTgxJTk2JUU2JUFGJThEJUU5JUE2JUFDJUU1JTg4JUE5JUU0JUJBJTlF" title="https://zh.wikipedia.org/wiki/%E8%81%96%E6%AF%8D%E9%A6%AC%E5%88%A9%E4%BA%9E">圣母马利亚<i class="fa fa-external-link"></i></span>的<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3cvaW5kZXgucGhwP3RpdGxlPSVFNSU5QyVBMyVFNiVBRiU4RCVFOCVCNSU5RSZhY3Rpb249ZWRpdCZyZWRsaW5rPTE=" title="https://zh.wikipedia.org/w/index.php?title=%E5%9C%A3%E6%AF%8D%E8%B5%9E&action=edit&redlink=1">圣母赞<i class="fa fa-external-link"></i></span>。</p></blockquote><p><strong>你是否成功避免了浪漫瘟疫？</strong><br>这个清单将帮助您确定您是否已经掌握 #mastered 了单身的艺术 </p><ul><li><input disabled="" type="checkbox"> 醒来的时候学猫叫 #meows 而不是你好</li><li><input disabled="" type="checkbox"> 没有人可以花你的钱来购买你</li><li><input disabled="" type="checkbox"> 你的感情对象应该是一袋薯条</li><li><input disabled="" type="checkbox"> 醉酒不是给你的前任发短信，而是给你的税务会计师 #accountant 发电子邮件</li><li><input disabled="" type="checkbox"> 你不必与任何人一起检查 #check ，做出一个可怕的决定</li><li><input disabled="" type="checkbox"> 当你的朋友邀请您参加 #invite 他们的婚礼 #wedding 时，你的朋友已经停止给你+1 #plusone （点赞）了<ul><li><input disabled="" type="checkbox"> 你有几个室内植物 #houseplant</li></ul></li><li><input disabled="" type="checkbox"> 你的洗发水 #shampoo 可以永久 #forever 使用</li><li><input disabled="" type="checkbox"> 您更喜欢 #prefer #onion 洋葱戒指 #ring 而不是结婚戒指</li></ul><p>你勾选了7个或者更多么，恭喜你已经正式避免了困扰，你的奖品？在Netflix上观看您想要的任何内容，不受阻挡。 #uninterrupted </p><p><strong>如何从严肃中找到笑点</strong></p><p>好吧，总有一天我们都会死这太糟糕了，但是死亡是不值得恐惧的 #scary ，就像生活它可以变得温和而愉快  #amusing 。所以为什么不放声大笑？有了正确的墓碑 #grave 你可以使墓地变成喜剧舞台</p><p>这里有一些墓碑会招待游客，路过的陌生人和墓地 #graveyard 的鬼魂 #ghost</p><p>他死后在做自己想做的事情，睡觉</p><p>那个果汁清理的不干净</p><p>我想要意大利香肠 #pepperoni 在我的墓碑上</p><p>一些感同身受的悲伤音乐</p><p>访问你最喜欢的幽灵请选择最喜欢的节目</p><p>贩卖机 #vending #machine 墓碑，吃掉你的感觉。</p><p>篮球场墓碑</p><p>反弹一些悲伤 #sorrow 的好方法</p><p>你更像一个骨灰 #urn 盒人？不用担心 #worry ，我会帮你盖住他。如果你有无法逃脱 #shake 的亲人，用这个可爱的饼干骨灰盒对他们恶作剧</p><p>来吧，瓮已经  #urned 笑了</p><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>感谢布莱尔的（原始 #original ）粉丝，你的美丽评论和鼓励的话语改变了当然是我的职业生涯 #career ，填补我心中的空洞 #gaping #hole 。</p><p>致所有甩了我的前任 – 那场龙卷风 #tornado  般失恋心碎导致我画了布莱尔。</p><p>致Workman Publishing – 埃文，格里菲斯是完美的猫 – 有爱的编辑，感谢您修正我的语法错误因为我真得不喜欢逗号而且我无论如何也喜欢连续不断向公立学校大喊太谢谢你了诶文你太伟大 #magniffisent 了（惊喜？）</p><p>感谢安东尼 * 马特罗 让一切顺利并相信他，你的积极性 #positivity 真的会让布莱尔失望。</p><p>致贾斯汀的信，他非常努力的说服让我的工作充满信息，大机会 #fat_chance </p><p>致我聪明又了不起的祖父母 Ed 和 Mary.</p><p>最后，致我的妈妈玛丽，作为5个孩子的单身母亲，，但你总是设法 #managed 找到并且拿起我的小漫画，并且丢掉他们，所有的垃圾导致了这本书。</p><p>啊，本节结束了么，我饿了并且所有的爱让我食欲不振 #appetite 。（By 布莱尔）</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>总的来说挺有意思的书，对于我来说能坚持看下去就已经是一种突破了。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      how-to-die-alone
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://whitestore.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="书籍" scheme="https://whitestore.top/tags/%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>《银河铁道之夜》读书笔记-为了谁而活？</title>
    <link href="https://whitestore.top/2022/06/02/bywholive/"/>
    <id>https://whitestore.top/2022/06/02/bywholive/</id>
    <published>2022-06-02T10:16:09.000Z</published>
    <updated>2022-06-02T10:17:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220601171128.png" alt=""></p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>非常“美丽”的书名，实际上却是一个十分悲伤的故事，大概悲剧更能引起读者的共鸣，本文标题起了一个叫做“为了谁”和这本书的作者身世有关，作者是为妹妹而坚持活着的人，像我这样的绝大多数普通人都难以做到吧。</p><p>这本书总是和《小王子》放到一起比较，因为两者都是源自于一场旅行的成长，我很少去了解作者过去，看书也很少去关注书名，但是因为不是很懂作品说了啥和故事背景，之后开始了解宫泽贤治的身世，不免对他抱持信念以及执着十分钦佩，能为了谁而活的人本身就是伟大的。</p><p>当我看完这本书再看看书中夹着的能通往任何地方的“车票”时候，这场旅行的回忆深深刻在脑海。</p><p><strong>下面的内容涉及剧透，如果对这本书感兴趣建议查看下面的资源了解了解。</strong></p><h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><p>链接：<span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMUVqRHhpMjJvQVpSUkQzX1psZHFkZmc/cHdkPTJramE=" title="https://pan.baidu.com/s/1EjDxi22oAZRRD3_Zldqdfg?pwd=2kja">https://pan.baidu.com/s/1EjDxi22oAZRRD3_Zldqdfg?pwd=2kja<i class="fa fa-external-link"></i></span> 提取码：2kja</p><a id="more"></a><h1 id="书籍简介"><a href="#书籍简介" class="headerlink" title="书籍简介"></a>书籍简介</h1><p>宫泽贤治的代表作《银河铁道之夜》，本作大约写于1927年，1934年被列入<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvdy9pbmRleC5waHA/dGl0bGU9JUU2JTk2JTg3JUU1JTlDJTgzJUU1JUEwJTgyJmFjdGlvbj1lZGl0JnJlZGxpbms9MQ==" title="https://zh.m.wikipedia.org/w/index.php?title=%E6%96%87%E5%9C%83%E5%A0%82&action=edit&redlink=1">文圃堂<i class="fa fa-external-link"></i></span>出版的《宫泽贤治作品集》中第三卷正式发表。其实全书仍在草稿阶段，现存4个版本，以最后一个最为人所熟知，不同版本间差异较大，学者对此众说纷纭。不过作品充满唯美幻想色彩的独特描写，因此仍受到许多人喜爱。</p><p>这本书被定义为儿童作品，却有着很多对成年人有非常多有感触的内容。</p><p>银河列车的轨迹：整个银河列车从北十字到南十字，经过的站点按照顺序排序为：<strong>银河火车站北十字星车站天鹅站普利奥辛海岸阿尔卑列监测站天鹰座停车场高原半人马星村南十字车站煤袋星云</strong>。</p><p>关联作品：</p><ul><li>银河铁道999</li><li>《银河铁道之夜》同名动画电影（B站有）</li><li>《银河铁道之夜》CG动画电影（B站有），虽然2006年但是个人感觉制作的十分精美。</li><li>《永诀の朝》（宫泽贤治所做的诗）</li></ul><p><strong>主角介绍</strong></p><p>一共两位 <strong>乔凡尼</strong> 和 <strong>坎帕内拉</strong>，当然那位落水被救的还会高级黑的小朋友忘记名字了，姑且算上。可以看到主角的人名都比较潮，男主叫乔丹尼，男主最好的朋友以及同学叫做坎培内拉，名字比较拗口但是意外的让人印象深刻。</p><p>这种新潮的起名方式和作者所处的家乡岩手县有关系。作者把岩手县叫 INATOBU，这是自创的词语，个人猜想应该是结合宗教和英语有关，然后我用上神奇的谷歌翻译查了一下，没想到还有意外的惊喜。</p><p><code>岩手 =&gt; no fly</code>，宫泽贤治奇特的想象力确实很有意思。顺带自夸一下我的联想能力。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220601164421.png" alt=""></p><p>书籍年代：太正时代的书籍。也就是从1912年7月30日至1926年12月25日止。</p><blockquote><p><strong>大正</strong>（日语：大正／たいしょう <em>Taishō</em> <span class="exturl" data-url="aHR0cHM6Ly9qYS53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUE0JUE3JUU2JUFEJUEz" title="https://ja.wikipedia.org/wiki/%E5%A4%A7%E6%AD%A3">*<i class="fa fa-external-link"></i></span>/<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS9IZWxwOiVFNiU5NyVBNSVFOCVBQSU5RQ==" title="https://zh.m.wikipedia.org/wiki/Help:%E6%97%A5%E8%AA%9E">?<i class="fa fa-external-link"></i></span>）是<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTYlOTclQTUlRTYlOUMlQUM=" title="https://zh.m.wikipedia.org/wiki/%E6%97%A5%E6%9C%AC">日本<i class="fa fa-external-link"></i></span><span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTUlQTQlQTclRTYlQUQlQTMlRTUlQTQlQTklRTclOUElODc=" title="https://zh.m.wikipedia.org/wiki/%E5%A4%A7%E6%AD%A3%E5%A4%A9%E7%9A%87">大正天皇<i class="fa fa-external-link"></i></span>在位期间使用的<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTYlOTclQTUlRTYlOUMlQUMlRTUlQjklQjQlRTglOTklOUY=" title="https://zh.m.wikipedia.org/wiki/%E6%97%A5%E6%9C%AC%E5%B9%B4%E8%99%9F">年号<i class="fa fa-external-link"></i></span>，使用时间从1912年7月30日至1926年12月25日止。承续年号为<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTYlOTglOEUlRTYlQjIlQkI=" title="https://zh.m.wikipedia.org/wiki/%E6%98%8E%E6%B2%BB">明治<i class="fa fa-external-link"></i></span>，接续年号为<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTYlOTglQUQlRTUlOTIlOEM=" title="https://zh.m.wikipedia.org/wiki/%E6%98%AD%E5%92%8C">昭和<i class="fa fa-external-link"></i></span><span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvemgtaGFucy8lRTUlQTQlQTclRTYlQUQlQTMjY2l0ZV9ub3RlLTowLTE=" title="https://zh.m.wikipedia.org/zh-hans/%E5%A4%A7%E6%AD%A3#cite_note-:0-1">[1]<i class="fa fa-external-link"></i></span>。 大正天皇体弱多病，加上第一次民主化在欧洲的遍地开花，这也促使东亚日本的政治权力从旧的<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTUlQUYlQTElRTUlQTQlQjQ=" title="https://zh.m.wikipedia.org/wiki/%E5%AF%A1%E5%A4%B4">寡头<i class="fa fa-external-link"></i></span>政治集团<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTklOTclQTglRTklOTglODA=" title="https://zh.m.wikipedia.org/wiki/%E9%97%A8%E9%98%80">门阀<i class="fa fa-external-link"></i></span>或<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTUlODYlOUIlRTQlQkElQkE=" title="https://zh.m.wikipedia.org/wiki/%E5%86%9B%E4%BA%BA">军人<i class="fa fa-external-link"></i></span>转移到<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTUlQjglOUQlRTUlOUMlOEIlRTglQUQlQjAlRTYlOUMlODNfKCVFNiU5NyVBNSVFNiU5QyVBQyk=" title="https://zh.m.wikipedia.org/wiki/%E5%B8%9D%E5%9C%8B%E8%AD%B0%E6%9C%83_(%E6%97%A5%E6%9C%AC)">帝国议会<i class="fa fa-external-link"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTYlQjAlOTElRTQlQjglQkIlRTUlODUlOUElRTYlQjQlQkU=" title="https://zh.m.wikipedia.org/wiki/%E6%B0%91%E4%B8%BB%E5%85%9A%E6%B4%BE">民主党派<i class="fa fa-external-link"></i></span>。 因此，这个时代被认为是日本被称为“<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTUlQTQlQTclRTYlQUQlQTMlRTYlQjAlOTElRTQlQjglQkI=" title="https://zh.m.wikipedia.org/wiki/%E5%A4%A7%E6%AD%A3%E6%B0%91%E4%B8%BB">大正民主<i class="fa fa-external-link"></i></span>”的<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTglODclQUElRTclOTQlQjElRTQlQjglQkIlRTQlQjklODk=" title="https://zh.m.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E4%B8%BB%E4%B9%89">自由主义<i class="fa fa-external-link"></i></span>运动的时代，它通常区别于<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTYlOTglOEUlRTYlQjIlQkI=" title="https://zh.m.wikipedia.org/wiki/%E6%98%8E%E6%B2%BB">明治时代<i class="fa fa-external-link"></i></span>的混乱和随后由<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTUlODYlOUIlRTUlOUIlQkQlRTQlQjglQkIlRTQlQjklODk=" title="https://zh.m.wikipedia.org/wiki/%E5%86%9B%E5%9B%BD%E4%B8%BB%E4%B9%89">军国主义<i class="fa fa-external-link"></i></span>驱动的<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTYlOTglQUQlRTUlOTIlOEM=" title="https://zh.m.wikipedia.org/wiki/%E6%98%AD%E5%92%8C">昭和时代<i class="fa fa-external-link"></i></span>初期<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvemgtaGFucy8lRTUlQTQlQTclRTYlQUQlQTMjY2l0ZV9ub3RlLTowLTE=" title="https://zh.m.wikipedia.org/zh-hans/%E5%A4%A7%E6%AD%A3#cite_note-:0-1">[1]<i class="fa fa-external-link"></i></span>。大正纪元与<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTYlQjAlOTElRTUlOUMlOEIlRTclQjQlODAlRTUlODUlODM=" title="https://zh.m.wikipedia.org/wiki/%E6%B0%91%E5%9C%8B%E7%B4%80%E5%85%83">民国纪元<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly96aC5tLndpa2lwZWRpYS5vcmcvd2lraS8lRTQlQjglQkIlRTQlQkQlOTMlRTclQkElQUElRTUlODUlODM=" title="https://zh.m.wikipedia.org/wiki/%E4%B8%BB%E4%BD%93%E7%BA%AA%E5%85%83">主体纪元<i class="fa fa-external-link"></i></span>共享相同的元年。</p></blockquote><p>可能让人看不下去的原因有：</p><ul><li>开头比较黑暗，因为美丽的书名，会让人以为一开始就觉得</li><li>新潮的名字，特别是人名会让人退却。</li></ul><p>这两点可能会觉得莫名其妙，但是换位并且结合日本人排外的思想想象一下相信不是很难理解。</p><p><strong>几点重要的暗示：</strong></p><ol><li>叙事基调：在黑暗之后，是无比美丽和光明的生活。</li><li>无论何时都要对未来抱有期望。</li><li>乔丹尼的母亲叮嘱乔丹可以去看灯会，但是不要到水里去成为贯穿整个故事的伏笔。</li><li>乔丹尼所在的城镇每一年又一次叫做“银河祭”的盛会，成为引出整个故事的基础。</li><li><strong>今晚是银河祭，请大家外出观看银河</strong>，盛大的节日和悲剧形成强烈对比。</li></ol><h1 id="为什么要写这样的故事？"><a href="#为什么要写这样的故事？" class="headerlink" title="为什么要写这样的故事？"></a>为什么要写这样的故事？</h1><p>作者写这本书的目的似乎可以从他过去写的一首诗中可以体现，这首诗叫做永诀の朝。为什么要聊到这首诗呢？因为这和宫泽贤治的妹妹有关系，这是他为了缅怀早早逝去的妹妹写的一首诗。</p><p>下面找来了两个版本的翻译：</p><p>第一个版本</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">就在今天  </span><br><span class="line"></span><br><span class="line">我的妹妹啊要去远方  </span><br><span class="line"></span><br><span class="line">雨雪交加，前门异常明亮  </span><br><span class="line"></span><br><span class="line">　　（请给我些雨雪）  </span><br><span class="line">　　</span><br><span class="line">从暗红的阴惨的云中  </span><br><span class="line"></span><br><span class="line">雨雪凄凄地落下来  </span><br><span class="line"></span><br><span class="line">　　（请给我些雨雪）  </span><br><span class="line">　　</span><br><span class="line">拿着有两棵蓝色菜图案的陶碗 </span><br><span class="line"></span><br><span class="line">给你去盛雨雪  </span><br><span class="line"></span><br><span class="line">我像出了膛的子弹  </span><br><span class="line"></span><br><span class="line">冲向那暗淡的雨雪之中  </span><br><span class="line"></span><br><span class="line">　　（请给我些雨雪）  </span><br><span class="line">　　</span><br><span class="line">从铅灰色的暗淡云中  </span><br><span class="line"></span><br><span class="line">雨雪凄凄地沉落下来  </span><br><span class="line"></span><br><span class="line">啊，敏子  </span><br><span class="line"></span><br><span class="line">在这死亡的时刻  </span><br><span class="line"></span><br><span class="line">为了使我一生光明  </span><br><span class="line"></span><br><span class="line">你让我拿给你  </span><br><span class="line"></span><br><span class="line">一碗清凉的雪  </span><br><span class="line"></span><br><span class="line">谢谢你，我的勇敢的妹妹  </span><br><span class="line"></span><br><span class="line">我一定勇往直前  </span><br><span class="line"></span><br><span class="line">　　（请给我些雨雪） </span><br><span class="line">　　 </span><br><span class="line">你是在高烧和喘息之中  </span><br><span class="line"></span><br><span class="line">让我</span><br><span class="line"></span><br><span class="line">从那称为银河，太阳，大气层的  </span><br><span class="line"></span><br><span class="line">大宇宙落下来的雪中取来最后一碗  </span><br><span class="line"></span><br><span class="line">在两块花岗岩石上  </span><br><span class="line"></span><br><span class="line">雨雪寂寞地存留着  </span><br><span class="line"></span><br><span class="line">我小心地站在上面  </span><br><span class="line"></span><br><span class="line">雪和水，纯白的雪和水  </span><br><span class="line"></span><br><span class="line">从挂满透明冰冷水珠的  </span><br><span class="line"></span><br><span class="line">光润美丽的松树枝上  </span><br><span class="line"></span><br><span class="line">给心爱的妹妹取来最后的一餐  </span><br><span class="line"></span><br><span class="line">在我们一块长大的日子里  </span><br><span class="line"></span><br><span class="line">看惯了的茶碗的蓝色图案  </span><br><span class="line"></span><br><span class="line">今天你也要与它告别  </span><br><span class="line"></span><br><span class="line">　　（我一个人死去）  </span><br><span class="line">　　</span><br><span class="line">你今天真的要告别  </span><br><span class="line"></span><br><span class="line">啊，那封锁了的病室里  </span><br><span class="line"></span><br><span class="line">在那黑暗的屏风和帐子里  </span><br><span class="line"></span><br><span class="line">我的勇敢的妹妹啊  </span><br><span class="line"></span><br><span class="line">优美地苍白地燃尽她最后的生命  </span><br><span class="line"></span><br><span class="line">不管从哪里挑选这雪  </span><br><span class="line"></span><br><span class="line">都是那么洁白  </span><br><span class="line"></span><br><span class="line">从那可怕的混乱的天空  </span><br><span class="line"></span><br><span class="line">落下这美丽的雪  </span><br><span class="line"></span><br><span class="line">　　（假如再次托生  </span><br><span class="line">　　</span><br><span class="line">　　不单为自己  </span><br><span class="line">　　</span><br><span class="line">　　也要为别人把苦来尝）</span><br><span class="line">　　  </span><br><span class="line">我对着你吃的两碗雪  </span><br><span class="line"></span><br><span class="line">内心祈祷  </span><br><span class="line"></span><br><span class="line">愿它变为上天的赐予  </span><br><span class="line"></span><br><span class="line">为你和大家  </span><br><span class="line"></span><br><span class="line">得到圣粮  </span><br><span class="line"></span><br><span class="line">我宁愿舍弃一切的幸福</span><br></pre></td></tr></table></figure><p>第二个版本（个人认为第二版翻译略好一些，更有诗词的律动感）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">《永诀之朝》</span><br><span class="line"></span><br><span class="line">今昔你就要远去了，</span><br><span class="line"></span><br><span class="line">我的妹妹。</span><br><span class="line"></span><br><span class="line">门外的世界风雨交叠，</span><br><span class="line"></span><br><span class="line">却异常的明媚。</span><br><span class="line"></span><br><span class="line">从隐隐泛红却又愈发阴沉的天空，</span><br><span class="line"></span><br><span class="line">迅疾地飘飞着雨雪。</span><br><span class="line"></span><br><span class="line">那两个缺口的陶瓷碗。</span><br><span class="line"></span><br><span class="line">绘着那熟悉的蓝色莼菜花纹。</span><br><span class="line"></span><br><span class="line">为了让碗里盛满你所渴求着的雪，</span><br><span class="line"></span><br><span class="line">我像破了膛的弧线的子弹一般，</span><br><span class="line"></span><br><span class="line">冲向外面黯淡交加的雨雪。</span><br><span class="line"></span><br><span class="line">那铅灰色沉寂的天空中，</span><br><span class="line"></span><br><span class="line">雨雪一阵又一阵的紧紧催促着。</span><br><span class="line"></span><br><span class="line">啊，妹妹。</span><br><span class="line"></span><br><span class="line">你为了让我释怀乐观起来，</span><br><span class="line"></span><br><span class="line">求我接一碗那圣洁冰凉的雪。</span><br><span class="line"></span><br><span class="line">尽管你已生命垂危。</span><br><span class="line"></span><br><span class="line">谢谢你啊，</span><br><span class="line"></span><br><span class="line">我勇敢可敬的妹妹。</span><br><span class="line"></span><br><span class="line">我也一定会勇敢向前，无畏风雪。</span><br><span class="line"></span><br><span class="line">随着激烈又炽热的喘息，</span><br><span class="line"></span><br><span class="line">你拜托我。</span><br><span class="line"></span><br><span class="line">为你捧来从被称为银河、太阳、大气层的世界的天空中，</span><br><span class="line"></span><br><span class="line">飘落下的最后一轮雪。</span><br><span class="line"></span><br><span class="line">在两块光滑的花岗岩上，</span><br><span class="line"></span><br><span class="line">雨雪静静地沉寂着。</span><br><span class="line"></span><br><span class="line">我小心翼翼地站在那上面，</span><br><span class="line"></span><br><span class="line">保持着雪与水那纯洁的联系，</span><br><span class="line"></span><br><span class="line">满载着透明的冰冷安静的雪水，</span><br><span class="line"></span><br><span class="line">从这闪烁着残微光亮的脆嫩松枝上，</span><br><span class="line"></span><br><span class="line">为我那心爱的善良美好的妹妹取下那最后的渴求。</span><br><span class="line"></span><br><span class="line">在伴随着我们一起长大的岁月里，</span><br><span class="line"></span><br><span class="line">早已熟悉了这陶瓷碗上的蓝色花纹。</span><br><span class="line"></span><br><span class="line">如是今朝却也要与你永诀，</span><br><span class="line"></span><br><span class="line">（我将独自前行）</span><br><span class="line"></span><br><span class="line">在那封闭了的病房里，</span><br><span class="line"></span><br><span class="line">在那昏暗的屏风和帐子里，</span><br><span class="line"></span><br><span class="line">你正面色苍白温情脉脉地燃尽着生命啊</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">我亲爱的妹妹，</span><br><span class="line"></span><br><span class="line">无论是抉择着哪里的雪，</span><br><span class="line"></span><br><span class="line">它都是那么的洁白。</span><br><span class="line"></span><br><span class="line">从那昏暗的雨雪交加的可怕天空中，</span><br><span class="line"></span><br><span class="line">竟落下如此美丽动人的雪。</span><br><span class="line"></span><br><span class="line">（假如获得重生，这次要活的轻松，不再遭受苦难）</span><br><span class="line"></span><br><span class="line">面对你所渴求的那两碗雪，</span><br><span class="line"></span><br><span class="line">我衷心的祈祷着。</span><br><span class="line"></span><br><span class="line">愿它变成上天的赐予，</span><br><span class="line"></span><br><span class="line">为你和大家，</span><br><span class="line"></span><br><span class="line">得到神圣的粮食</span><br><span class="line"></span><br><span class="line">我宁愿舍弃这一切的幸福</span><br><span class="line"></span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>十分优美并且让人看完有种想哭的冲动的诗，因为包含了作者真挚的情感。</p><p>上面的故事是宫泽贤治和他妹妹的真实的故事，宫泽贤治的妹妹在生命的最后一刻让哥哥给他带点雪尝尝，宫泽贤治焦急的跑到屋外找雪的身影，最后却回家却发现妹妹已经永远闭上双眼。</p><p>令我最感动的是”你拜托我。为你捧来从被称为银河、太阳、大气层的世界的天空中，飘落下的最后一轮雪。”这句话。</p><p>妹妹的死直接影响了宫泽贤治对人生和世界的看法，也让他写出印象深刻的作品。也引导出《银河铁道之夜》中十分启发人的一句话：</p><p><strong>如果能为了某人而活着，我想大概是一件幸福的事情吧。</strong></p><p>宫泽贤治确实是十分温柔并且也确实是诚恳真实的人，最好的体现是他在生前所有畅销世界的巨作其实都是<strong>写给自己</strong>的，很多十分优秀的作品并没有发表（包括这本影响力最大的书），所以从这一些细节可以看到宫泽贤治确实一直贯彻自己的理念，为自己的妹妹而活并且很少考虑自己，是十分值得欣赏的人。</p><p>那么为什么要写出《银河铁道之夜》呢？这里就必须要探究作者妹妹死后的故事，当然个人也是从日本人的书评讲解里面才明白的。在宫泽贤治的妹妹死后宫泽贤治和家人闹掰了，因为家人要用传统的方式让妹妹下葬，而宫泽贤治则更希望用自己的方式向妹妹告别，最终结果就是导致妹妹一直无法安然入土魂归天灵。</p><p>经过很长时间的争吵，宫泽贤治最终选择离开家庭独自营生，这也导致宫泽贤治没有和自己的妹妹好好告别，所以<strong>《银河铁道之夜》实际上是宫泽贤治为了给自己妹妹告别所写的一本书</strong>，正如书中的角色一般，他用银河列车和绝美的风景送走了妹妹化身的坎培内拉，最后再将一切回忆随着牛奶瓶一般带在他的身上。</p><h1 id="个人评价"><a href="#个人评价" class="headerlink" title="个人评价"></a>个人评价</h1><p>蕴含了宗教，科学，信仰，以及自己的真挚祝愿，融合在一个小孩子也看得懂的书中，宫泽贤治确实是一个厉害的人，看这本书甚至让我有些理解宗教的魅力是什么，而信仰究竟有什么样的力量。</p><p>实际上个人在读完第一遍之后其实并不是很了解上面这些内容的，故事很吸引人但是很多地方十分奇怪作者为什么要写这样的故事，虽然故事看到一半在各种暗示中透露了各种信息可以明显看出是一个悲伤的故事，但是依然摸不着头脑写本书的用意是什么，所以我果断找了个日本的书评靠着字幕翻译大概看懂了这本书讲了什么，另外看了下油管500多万粉丝，确实是一个大佬。</p><p>整本书开头两章从主角乔丹尼悲惨的命运，到视角一转却有些莫名其妙的坐上了开往银河的列车，当下的痛苦与黑暗和壮阔的银河列车鲜明对比，乔丹尼是作者的化身，在艰苦过后是幸福的邂逅，先抑后扬也让后面列车上的故事回忆更为深刻。</p><p>然而这一段奇幻的旅行却终究是悲伤的故事，故事最后突然急转直下，这是作者对于现实和理想的刻意安排，个人认为这也是暗指得与失的哲学。</p><p>其中让我印象最为深刻的是关于蝎子的故事，蝎子本身是有毒的，它一辈子都在伤害别人，但是到了死前的那一刻却决定要献出自己的生命，“反正我都要死了，不如就为你而死吧”，所以蝎子的本性似乎并不坏？我们是否愿意为了谁做出牺牲？</p><p>大概伟大的作家都会伴随着悲惨的命运，有时候只能感叹上天的不公，宫泽贤治只活了37年也因病匆匆离开了人世。</p><h1 id="佳句摘录"><a href="#佳句摘录" class="headerlink" title="佳句摘录"></a>佳句摘录</h1><ul><li>我不知道什么是真正的幸福，但我知道即使遭遇再大的痛苦，只要我们走在正确的道路上，那么无论顺境或逆境，都会距离真正的幸福越来越近。</li><li>如果能为了某人而活着，我想大概是一件幸福的事情吧。</li><li>人生的幸福在于每一个小小瞬间。</li></ul><h1 id="内容分析"><a href="#内容分析" class="headerlink" title="内容分析"></a>内容分析</h1><p>下面是个人看书过程中的一些疑问和看法，有些内容是个人看完之后查资料明白是什么意思的，属于意外之喜，顺便涨了一些知识。</p><h2 id="捡铅字"><a href="#捡铅字" class="headerlink" title="捡铅字"></a>捡铅字</h2><p>捡铅字是第二章乔丹尼给印刷厂打工的工作内容，这一段个人第一次看的时候完全不知道主角在干什么，所以这里有必要补充解释一下，在作者的那个年代，印刷是需要在铅块和板上面放上假名和汉字的，使用的是活版印刷术，印刷一本书需要把“字”捡到一个个的板上面才能印刷，然后下一页再用同样的方式捡到一起印刷下一章，是非常辛苦单调但是需要很强注意力的工作。所以不难理解为什么拿到报酬的乔丹尼会如此开心了。</p><p>另外这里再次回忆这一章的内容，又要被人嘲笑“小放大镜”，又要急急忙忙的捡铅字，实在是有够憋屈，难怪前面两章比较劝退人。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220601153653.png" alt=""></p><h2 id="海獭皮"><a href="#海獭皮" class="headerlink" title="海獭皮"></a>海獭皮</h2><p>乔丹尼的父亲是渔民，需要外出捕鱼，在出海之前答应给乔丹尼一件海獭皮的衣服，然而迟迟未归的父亲却也这件事成为了同学嘲笑乔丹尼的笑点。</p><p>拿不到海獭皮的外套而被同学嘲笑是为什么呢？其实是由于当时海獭都是当地人偷猎，后面因为大肆杀害野生动物而被政府禁止，嘲笑乔丹尼拿不到海獭皮是暗指的他爸被抓去坐牢了，属于不骂人的“高级黑”，看书过程不免想要吐槽小学生都已经这么强了么。</p><p>当然只有坎佩内拉不会嘲笑他，并且主角的父亲和坎佩内拉的父亲在读书的时候是朋友，所以他们之间也是能互相理解的朋友。</p><h2 id="四维空间"><a href="#四维空间" class="headerlink" title="四维空间"></a>四维空间</h2><p>在天鹅站，主人公一行人遇到了考古的学者，随后的火车行驶过程中遇到了红胡子老头，红胡子老头是一个捕鸟人，之后是乔丹尼和坎佩内拉与捕鸟人的一些互动。</p><p>捕鸟人的剧情不长，但是看到捕鸟人能闪现到白鹭的旁边，并且在主角询问之后回答这是轻而易举的事情，不知道为什么让我想起来《三体》中那个“徒手”摘心脏的故事，很明显作者在这里提出了自己对于四维空间的一种遐想，实在是难以想象100年前就有这生动的想象力，并且在书中用简单明了的方式体现，虽然没有过多深入但是可以看出作者的知识渊博。</p><h2 id="得与失"><a href="#得与失" class="headerlink" title="得与失"></a>得与失</h2><p>在故事的最后是乔丹尼在现实世界得知了坎佩内拉为了救同学自己淹死的消息，乔丹尼带着装满了回忆的牛奶瓶赶回家中却意外得知父亲归来的消息，大概作者在暗示<strong>当你失去某样东西的时候，有新的事物在向你走来</strong>，所以作者的温柔总是藏在这种看不见的地方。</p><p>转念一想，牛奶瓶和雪一样都是白色的，为了让母亲喝上牛奶而捧着牛奶瓶的乔丹尼映射了为了妹妹捧着雪的宫泽贤治，这大概也是宫泽贤治激励自己哪怕过去无法挽回，却依然可以为了某种事物而活的心态吧。</p><p>这大概也是作者自己不愿意把《银河铁道之夜》公开于世，只愿让他督促和勉励自己的一份记录。</p><h1 id="写到最后"><a href="#写到最后" class="headerlink" title="写到最后"></a>写到最后</h1><p>书里书外都有着看似悲伤的故事，作者是为了为了妹妹坚持活下去，我们又是为了谁而活呢？</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      非常“美丽”的书名，实际上却是一个十分悲伤的故事
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://whitestore.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="书籍" scheme="https://whitestore.top/tags/%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>谷歌三件套 - Bigtable</title>
    <link href="https://whitestore.top/2022/05/21/google-bigtable/"/>
    <id>https://whitestore.top/2022/05/21/google-bigtable/</id>
    <published>2022-05-21T11:16:54.000Z</published>
    <updated>2022-06-02T10:09:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="谷歌三件套-Bigtable"><a href="#谷歌三件套-Bigtable" class="headerlink" title="谷歌三件套 - Bigtable"></a>谷歌三件套 - Bigtable</h1><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>如标题所言，这一篇文章简单介绍BigTable，其实个人更建议看LevelDB这款开源数据库，因为这数据库也是Bigtable的作者 <strong>JeffreyDean</strong> 设计的，很多内容不能说像简直就是一模一样。</p><p>值得注意的是，看Bigtable的内容<strong>千万不要带着关系型数据库的思维</strong>，建议看之前看看《数据密集型应用系统设计》的第三章，里面提到了LSM-Tree以及大数据系统设计思想，或者看看个人之前写的文章 [[《数据密集型型系统设计》LSM-Tree VS BTree]]</p><h1 id="三件套论文资料"><a href="#三件套论文资料" class="headerlink" title="三件套论文资料"></a>三件套论文资料</h1><p>Bigtable 原始在线论文： <strong><span class="exturl" data-url="aHR0cHM6Ly9zdGF0aWMuZ29vZ2xldXNlcmNvbnRlbnQuY29tL21lZGlhL3Jlc2VhcmNoLmdvb2dsZS5jb20vemgtQ04vL2FyY2hpdmUvYmlndGFibGUtb3NkaTA2LnBkZg==" title="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/bigtable-osdi06.pdf">Bigtable: A Distributed Storage System for Structured Data<i class="fa fa-external-link"></i></span></strong></p><p>MapReduct 原始在线论文：<span class="exturl" data-url="aHR0cHM6Ly9zdGF0aWMuZ29vZ2xldXNlcmNvbnRlbnQuY29tL21lZGlhL3Jlc2VhcmNoLmdvb2dsZS5jb20vemgtQ04vL2FyY2hpdmUvbWFwcmVkdWNlLW9zZGkwNC5wZGY=" title="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf">MapReduce: Simplified Data Processing on Large Clusters<i class="fa fa-external-link"></i></span></p><p>GFS 原始在线论文：<span class="exturl" data-url="aHR0cHM6Ly9zdGF0aWMuZ29vZ2xldXNlcmNvbnRlbnQuY29tL21lZGlhL3Jlc2VhcmNoLmdvb2dsZS5jb20vemgtQ04vL2FyY2hpdmUvZ2ZzLXNvc3AyMDAzLnBkZg==" title="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/gfs-sosp2003.pdf">The Google File System<i class="fa fa-external-link"></i></span></p><p>如果看不懂英文或者想要线下阅读，个人从某全是广告的技术网站买了一份中文翻译以及原始英文论文PDF，合并到一起免费分享给大家（虽然掏钱买也没几个钱）：</p><p>链接: <span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMTVaMjRhcTYydTI1WV9MckhTYU5DQ3c=" title="https://pan.baidu.com/s/15Z24aq62u25Y_LrHSaNCCw">Google-GFS,Bigtable,Mapreduce三大论文英文原版+中文翻译<i class="fa fa-external-link"></i></span> 提取码: 82ok </p><blockquote><p>（如果链接失效可以关注公众号“懒时小窝” 回复“谷歌三件套”或者“谷歌”获取这些内容）</p></blockquote><a id="more"></a><h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>下面Bigtable介绍内容可以跳过，论文巴拉巴拉吹了一大堆，其实关键也就是关注这几个点：</p><ul><li>大数据、分布式存储、异地多活容灾（侧面反应）。</li><li>GFS和BigTable的关系。</li><li>Chubby。</li><li>LSM-Tree 数据结构。</li><li>SSTable（LSM-Tree）。</li></ul><p>Bigtable 是一个<strong>分布式存储系统</strong>，用于管理旨在扩展到非常大的结构化数据<br>大小：数千种商品的 PB 级数据服务器。 Google 的许多项目都将数据存储在 Bigtable 中，包括网络索引、谷歌地球和谷歌财经。 这些应用提出了非常不同的要求</p><p>在 Bigtable 上，无论是在数据大小方面（从 URL 到网页到卫星图像）和延迟要求<br>（从后端批量处理到实时数据服务）。尽管有这些不同的需求，Bigtable 还是成功地为所有用户提供了灵活、高性能的解决方案这些 Google 产品。 在本文中，我们描述了 Bigtable 提供的简单数据模型，它为客户提供对数据布局和格式的动态控制，我们描述了 Bigtable 的设计和实现。</p><p>Bigtable看起来像一个数据库，采用了很多数据库的实现策略。但是Bigtable并不支持完整的关系型数据模型；而是为客户端提供了一种简单的数据模型，客户端可以动态地控制数据的布局和格式，并且利用底层数据存储的局部性特征。Bigtable将数据统统看成无意义的字节串，客户端需要将结构化和非结构化数据串行化再存入Bigtable。</p><p>前面提到相当多的google应用使用了BigTable，比如Google Earth和Google Analytics，这里建议有条件高级上网的同学推荐看一下<strong>Google Earth</strong> 找找你家位置，你会发现在这个世界上你没有啥秘密可言（地理位置上），也能最直观的明白现代导弹为什么可以精准无误的打击，挺恐怖的事情。</p><p>题外话就扯到这，由于网上有很多介绍的文章，这里也同样结合原始论文和理解摘录自己感兴趣的部分，因为个人是看完一整个LevelDB的源代码之后再回来看的，很多东西都省略了，没看过的更多内容可以参考下面这篇文章：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L09wZW5OYWl2ZS9hcnRpY2xlL2RldGFpbHMvNzUzMjU4OQ==" title="https://blog.csdn.net/OpenNaive/article/details/7532589">BigTable解读<i class="fa fa-external-link"></i></span></p><p>我们不需要关注谷歌吹逼自己的高性能，高负载介绍，毕竟都会这么对外宣传，我们只要了解Bigtable干了啥和怎么实现即可。</p><h1 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h1><p>首先介绍最为重要的数据组织结构也就是数据模型，论文第二节开头对于SSTable做了定义：</p><p> A Bigtable is a sparse（稀疏）, distributed（分布式）, persistent（持久化） multidimensional（多维度） sorted map（排序哈希表）。</p><p>简单的数据模型意味着灵活和很强的扩展性，SSTable 使用 <code>row</code>、<code>column</code> 和 <code>timestamp</code> 三个字段作为这个哈希的键，值是字节数组，其实也就是字符串。</p><p>一条数据最小单位可以抽象理解为这样的存储形式：</p><p><code>(row:string, column:string, time:int64) → string</code></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205201448701.png" alt=""></p><p>再次强调这里的数据格式<strong>不能按照关系型数据库理解</strong>，原因是他本质上是<strong>Key/Value</strong>的存储格式，这三个值不能按照单纯行或者列存储格式理解，而是使用<strong>混合存储</strong>+多维数据的存储方式，所以这三个值抽象理解为<strong>行键（row）、列键（column）、时间戳（timestamp）</strong>，最终由这三个参数构成三维参数。</p><p><strong>行键（row）</strong></p><p>行键是原子操作，行数据可以是任意的字符串，最大可以扩展到64个KB，当然多数情况为10 - 100个字节，每一个读和写操作都是一个独立原子性的。</p><p>行的范围是可以动态划分的，行的数据切分称为切片，通过切片用户只需要和更加少量的数据通信，通过分片也可以更好的获取更加准确和可控的数据范围。</p><p>切片在行键中被称为 tablet，切片支持负载均衡，随着表的扩展片也会自动进行分裂，最终一个分片控制在100 MB - 200MB 当中。</p><p><strong>列键（column）</strong></p><p>列的存储格式涉及到一个被称之为 <strong>列族</strong> 的概念，通过列族的方式把相似的值组合到一起，一个列族里的列一般存储相同类型的数据，所以通常情况下列族的数据变动比较小，但是列族是可以随意添加和删除的，并且通过谷歌特定的格式进行命名，列族</p><p>这里补充列族的概念，指的是<strong>把一行中的所有列和行主键保存到一起</strong>，并且不使用列压缩的形式存储。其实这种用行转列基本就可以实现，所以列族严格意义上依然是行存储的变体，和真正的列存储还是存在差异的。</p><p>由于列族的存在，使得SSTable实现一个key的多维度映射，所以多维的概念就是在列族上出现的，同时可以把列族看做是二级索引。</p><p><strong>时间戳</strong></p><p>时间戳负责标记每一个行列索引的版本号，每个单元格可以包含多个版本，版本通过时间戳管理，BigTable的时间戳是64位整数，通常情况为微秒级别的单位，可以使用客户端进行指定单位。</p><p>时间戳显然就是三级别索引了，读取的时候通过最新的时间戳可以认为是数据的最新版本。另外在查询时如果 只给出行列，那么返回的是<strong>最新版本的数据</strong>；如果给出了行列时间戳，那么返回的是时间<strong>小于或等于时间戳的数据</strong>。</p><blockquote><p>这也是现在大数据框架的存储格式特点，比如目前前景不错的<strong>Tidb</strong>，支持OLTP也支持OLAP。</p></blockquote><h1 id="支撑组件"><a href="#支撑组件" class="headerlink" title="支撑组件"></a>支撑组件</h1><p>BigTable除开SSTable之外，还存在其他的支持组件：</p><ul><li>用GFS来存储日志和数据文件.</li><li>按SSTable文件格式存储数据.</li><li>用Chubby管理元数据.</li></ul><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205201416964.png" alt=""></p><p><strong>GFS（Google File System）</strong></p><p>从上面的内容可以看到，GFS先于memtable操作，显然充当了整个系统的日志部分，这一部分牵扯到谷歌三件套的另一个系统设计GFS，不是本文讨论的重点，这里只需要知道它干了所有和Log和数据存储位置有关的事情即可。</p><p>既然是日志和数据的存储，那么GFS自然也知道数据的具体位置，因为属于SSTable的前置组件，所以 SSTable 的具体位置需要GFS提前记录。</p><p>另外memtable相当于SSTable的缓存，当memtable成长到一定规模会被冻结，Bigtable随之创建一个新的memtable，并且将冻结的memtable转换为SSTable格式写入GFS，这个操作称为<code>minor compaction</code>。</p><blockquote><p>在 LevelDB中体现的是Level0的SSTable 压缩合并。</p></blockquote><p><strong>Chubby</strong></p><p>Bigtable 依赖于一个高可用和持久的分布式锁服务称为 <strong>Chubby</strong>，它由五个活动副本组成，其中一个是选举为主节点的Master，节点正常的时候可以进行互相通信，Chubby 使用Paxos算法保持一致。</p><p>Chubby提供了命名空间，内部通过小文件和目录组成，目录或者文件可以配置单独的锁，使得读和写操作都是原子性的，Chubby 客户端提供一致性的文件缓存，每一个Chubby 都必须和另一个 Chubby 保持会话，如果客户端会话过期会丢失全部的锁。</p><p><strong>SSTable</strong></p><p>终于要进入重点部分了，可惜的是原始论文并没有详细的介绍SSTable的内部数据结构，仅仅在论文第六个小节中介绍了SSTable的作用。</p><p>首先看看BigTable和GFS 是什么关系呢？在论文中我们可以看到一个类似树的结构，其中根节点为主服务器，主服务器负责接受请求，通过管理分片服务器将请求分片到不同的片服务器中，所以从外层看最终干活的是<strong>片服务器</strong>。</p><p>然而片服务器实际上本身也只是负责管理自己分片的SSTable，它也通过特殊索引知道数据在那个SSTable分片中，然后从GFS中读取SSTable文件的数据，而GFS则可能要从多个Chuncker server里面搜索数据。</p><p>而图中的metatable原数据表可以看作是和SSTable绑定的类似<strong>索引</strong>的关系，元数据表的数据是<strong>不能被外界访问</strong>的，外界访问的是元数据对应的SSTable分片。</p><h1 id="Bigtable集群"><a href="#Bigtable集群" class="headerlink" title="Bigtable集群"></a>Bigtable集群</h1><p>BigTable集群通过三个层级配套组件完成工作。</p><p>第一层是<strong>主服务器（master server</strong>）也就是我们上面提到的Chubby，本身也通过集群的方式保证root tablet正常访问，也可以直接看作我们广为使用的中间件节点集群。</p><p>第二层是<strong>分片服务器</strong>，也称 tablet，其中root tablet是元数据表（METADATA table）的第一个分片，</p><p>第三层是<strong>元数据</strong>的部分，和 root tablet 组成元数据映射表，元数据包含很多的用户数据分片。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205211600915.png" alt=""></p><p>关于三个层级内部的组成这里不用过多猜测到底长啥样，还是那句话去看LevelDB吧。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章简单介绍了一下BigTable 中一些核心部分，有很大部分内容都被忽略了，对于大数据方向的同学来说这三篇论文基本是必看的资料，因为说白了这三驾马车放到现在基本也可以通用，提到的很多理念对现在的中间件有很深的影响。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>关于<strong>Bigtable</strong>部分就介绍到这里了，虽然论文还要很多理论的部分，但是个人看下来之后基本在LevelDB都有体现，所以想要了解使用的直接看LevelDB源代码理解起来更快。</p><h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDA0MTY1MjAwMw==" title="https://segmentfault.com/a/1190000041652003">[《数据密集型型系统设计》LSM-Tree VS BTree]<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDA0MTcyMDIwNQ==" title="https://segmentfault.com/a/1190000041720205">[LSM-Tree - LevelDb了解和实现]<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDA0MTg2NDU3OQ==" title="https://segmentfault.com/a/1190000041864579">[LSM-Tree - LevelDb 源码解析]<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDA0MTg2OTU4Ng==" title="https://segmentfault.com/a/1190000041869586">[LSM-Tree - LevelDb Skiplist跳表]<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDA0MTg3MzQwMA==" title="https://segmentfault.com/a/1190000041873400">[LSM-Tree - LevelDb 布隆过滤器]<i class="fa fa-external-link"></i></span></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      bigtable数据结构解析
    
    </summary>
    
    
      <category term="谷歌三件套" scheme="https://whitestore.top/categories/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97/"/>
    
    
      <category term="LevelDB" scheme="https://whitestore.top/tags/LevelDB/"/>
    
      <category term="谷歌" scheme="https://whitestore.top/tags/%E8%B0%B7%E6%AD%8C/"/>
    
  </entry>
  
  <entry>
    <title>《生之欲》观影感悟</title>
    <link href="https://whitestore.top/2022/05/21/szygw/"/>
    <id>https://whitestore.top/2022/05/21/szygw/</id>
    <published>2022-05-21T11:15:11.000Z</published>
    <updated>2022-06-02T10:09:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>乘着假期的尾巴看了这一部电影，不得不说虽然豆瓣的高分不一定是好电影，但是这一部上世纪五十年代的电影还是值得观看。</p><p>本文内容<strong>包含剧透</strong>。</p><blockquote><p>兑现前两天立得看电影的Flag，个人认为不管是好的电影还是书籍都是值得记录和回忆的， 为了让自己不忘记电影留下点东西也为不白白浪费两个小时的 宝贵人生。</p></blockquote><h1 id="故事内容"><a href="#故事内容" class="headerlink" title="故事内容"></a><strong>故事内容</strong></h1><p>一句话概括：《生之欲》讲述了一位官僚在发现自己患了晚期癌症后，试图在他的生活中找到意义。</p><blockquote><p>A bureaucrat tries to find a meaning in his life after he discovers he has terminal cancer.</p></blockquote><p>《<strong>生之欲</strong>》（日语：生きる）在<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JUE2JTk5JUU2JUI4JUFG" title="https://zh.wikipedia.org/wiki/%E9%A6%99%E6%B8%AF">香港<i class="fa fa-external-link"></i></span>译作《<strong>流芳颂</strong>》，乃是1952年由<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTk3JUE1JUU2JTlDJUFD" title="https://zh.wikipedia.org/wiki/%E6%97%A5%E6%9C%AC">日本<i class="fa fa-external-link"></i></span>知名<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUIwJThFJUU2JUJDJTk0" title="https://zh.wikipedia.org/wiki/%E5%B0%8E%E6%BC%94">导演<i class="fa fa-external-link"></i></span><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JUJCJTkxJUU2JUJFJUE0JUU2JTk4JThF" title="https://zh.wikipedia.org/wiki/%E9%BB%91%E6%BE%A4%E6%98%8E">黑泽明<i class="fa fa-external-link"></i></span>执导的<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTlCJUJCJUU1JUJEJUIx" title="https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%BD%B1">电影<i class="fa fa-external-link"></i></span>，曾获得日本<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JUFGJThGJUU2JTk3JUE1JUU5JTlCJUJCJUU1JUJEJUIxJUU3JThEJThF" title="https://zh.wikipedia.org/wiki/%E6%AF%8F%E6%97%A5%E9%9B%BB%E5%BD%B1%E7%8D%8E">每日电影最佳影片奖<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTlCJUJCJUU1JUJEJUIxJUU2JTk3JUFDJUU1JUEwJUIx" title="https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%BD%B1%E6%97%AC%E5%A0%B1">电影旬报<i class="fa fa-external-link"></i></span>年度最佳影片奖、<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTlGJThGJUU2JTlFJTk3JUU1JUJEJUIxJUU1JUIxJTk1" title="https://zh.wikipedia.org/wiki/%E6%9F%8F%E6%9E%97%E5%BD%B1%E5%B1%95">柏林影展<i class="fa fa-external-link"></i></span>特别奖等奖项。</p><p>在市公所工作30年的市民课课长渡边勘治每天过着盖章、签公文的乏味生活，某日因身体不适前往<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTg2JUFCJUU5JTk5JUEy" title="https://zh.wikipedia.org/wiki/%E9%86%AB%E9%99%A2">医院<i class="fa fa-external-link"></i></span>检查，结果竟被告知罹患<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JTgzJTgzJUU3JTk5JThD" title="https://zh.wikipedia.org/wiki/%E8%83%83%E7%99%8C">胃癌<i class="fa fa-external-link"></i></span>末期，只剩下约半年的生命。回到家中，<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTg1JTkyJUU1JUFEJTkw" title="https://zh.wikipedia.org/wiki/%E5%85%92%E5%AD%90">儿子<i class="fa fa-external-link"></i></span>与<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUFBJUIzJUU1JUE5JUE2" title="https://zh.wikipedia.org/wiki/%E5%AA%B3%E5%A9%A6">媳妇<i class="fa fa-external-link"></i></span>对他并不友善，甚至可谓不孝。感到悲伤的渡边，带了毕生积蓄离家出走，也不去上班了。他在外头遇见一位<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUIwJThGJUU4JUFBJUFB" title="https://zh.wikipedia.org/wiki/%E5%B0%8F%E8%AA%AA">小说<i class="fa fa-external-link"></i></span><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU0JUJEJTlDJUU1JUFFJUI2" title="https://zh.wikipedia.org/wiki/%E4%BD%9C%E5%AE%B6">作家<i class="fa fa-external-link"></i></span>，告之自己将不久于人世，他认为从未替自己好好活过。小说家同情其遭遇，带他去打<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUJEJTg4JUU3JThGJUEwJUU2JUE5JTlG" title="https://zh.wikipedia.org/wiki/%E5%BD%88%E7%8F%A0%E6%A9%9F">小钢珠<i class="fa fa-external-link"></i></span>，甚至去<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUE2JTkzJUU5JTk5JUEy" title="https://zh.wikipedia.org/wiki/%E5%A6%93%E9%99%A2">声色场所<i class="fa fa-external-link"></i></span>。对渡边来说，虽然这些事很新鲜，但到头来却觉得空虚落寞。第二天他就告别了小说家，一个人孤独的走在街上。</p><p>他遇见了市公所的一位年轻女职员小田切丰，后者表示她厌倦公务员无聊的工作，已觅得新职，却因课长没来上班，没人批准<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUJFJUFEJUU4JTgxJUI3" title="https://zh.wikipedia.org/wiki/%E8%BE%AD%E8%81%B7">辞呈<i class="fa fa-external-link"></i></span>。渡边便将小田切带回家中，为她盖离职同意书；见她丝袜破掉，想为她买双新的。这天他要求小田切带他去玩，两人也度过快乐的一天。但回家后却遭到儿子辱骂，认为他之前带走的存款算是家用的一部分；儿子同时误会小田切是他的年轻<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTg0JTlCJUU0JUJBJUJB" title="https://zh.wikipedia.org/wiki/%E6%84%9B%E4%BA%BA">情人<i class="fa fa-external-link"></i></span>，要求父亲自重。</p><p>过了几天后，渡边前往小田切新任职的<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JThFJUE5JUU1JTg1JUI3" title="https://zh.wikipedia.org/wiki/%E7%8E%A9%E5%85%B7">玩具<i class="fa fa-external-link"></i></span>工厂，希望她再陪着出去玩。小田切原本不想答应，但渡边苦苦哀求，她只好同意。晚上来到一家<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUE1JUJGJUU5JUE0JTkwJUU1JUJCJUIz" title="https://zh.wikipedia.org/wiki/%E8%A5%BF%E9%A4%90%E5%BB%B3">西餐厅<i class="fa fa-external-link"></i></span>，渡边的举动让小田切以为他要对她不轨，十分害怕。没想到渡边告诉她自己得了不治之症，来日无多，但是见到小田切如此年轻有活力，希望小田切告诉他究竟活着是为了什么。小田切只好战战兢兢的拿出一只玩具<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTg1JTk0" title="https://zh.wikipedia.org/wiki/%E5%85%94">兔<i class="fa fa-external-link"></i></span>子告诉他，她平常在工厂工作就是做这种东西；只要想到自己做出的东西是为别人带来欢乐，自己也就很开心。渡边突然想到自己想要什么了，向小田切道谢后便离开餐厅。此时碰巧有群年轻人替一位少女庆生，众人唱起<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUE1JTlEJUU0JUJEJUEwJUU3JTk0JTlGJUU2JTk3JUE1JUU1JUJGJUFCJUU0JUI5JTkw" title="https://zh.wikipedia.org/wiki/%E7%A5%9D%E4%BD%A0%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90">生日快乐歌<i class="fa fa-external-link"></i></span>，仿佛在庆祝渡边的重生。</p><p>翌日渡边再度回到市公所上班，将他请假这些日子的公文全数拿出来，发觉有件案子是许多妇女前来陈情，希望将某条臭水沟改建为<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTg1JUFDJUU1JTlDJTky" title="https://zh.wikipedia.org/wiki/%E5%85%AC%E5%9C%92">公园<i class="fa fa-external-link"></i></span>，却屡屡遭到各单位互踢皮球不愿处理。他决定要处理这件事，带着下属开始各处奔走。5个月后，渡边过世，在灵堂上大家开始回忆他生命最后5个月的过程，发觉他非常努力奔走以建立公园，最后甚至选择在大<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTlCJUFB" title="https://zh.wikipedia.org/wiki/%E9%9B%AA">雪<i class="fa fa-external-link"></i></span>的夜里独自快乐的唱着歌，死于自己亲手建立的公园里。虽然在守灵的酒会上，大家如此怀念渡边所做的一切，但等到第二天上班时市公所 依就弥漫着官僚之气。尽管有职员看不过去，心中认为应该要继承渡边的精神，但也仅止于缅怀而已。</p><a id="more"></a><h1 id="个人评价"><a href="#个人评价" class="headerlink" title="个人评价"></a>个人评价</h1><p>十分推荐所有人去看的一部电影，虽然剧情大致的走向都能猜到，但是在看完之后绝对不会后悔的电影，顺带一提如果难以忍受电影时长可以多倍速观看，不过看着看着就会自然减速。</p><p>志村乔的演技也确实入木三分，不仅演绎出不知人生目的的活着，在醒悟之后眼神的那种光，以及和儿子的关系疏远，所谓好的演员是电影成功的另一半。</p><p>另外感叹上世纪50年代的电影质量和现在真的没法比，虽然是一部黑白电影，但是这部电影在个人心目中地位不亚于《肖申克的救赎》。</p><h1 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h1><p>黑白片加上2小时的电影时长估计没有多少读者可以坚持下来。</p><p>虽然人物的表情略显夸张，表情也有点用力过度的样子，但是看到主角眼睛都要瞪出来的那种孤独依然为之动容。</p><p>令人讽刺是最后葬礼上小职员虽然高歌要做出改变，然而最后却都按部就班的在体制内做着无用的零件，这样的事情像极了每天都在打鸡血的普通人。</p><p>然而更令人讽刺的是在葬礼上最关系最为紧密的儿子以及陪伴一旁的儿媳却一直沉默，最为亲近的人却成为了距离最遥远的陌生人，只在最后寥寥数语中知道父亲死前竟然为自己处理后事并且把身价财产传给儿子，直到这时才后悔一切无法挽回，然而现今这样的人似乎越来越多，这样的场面也越来越多……</p><p><strong>真切的活着最好的办法是培养利他之心，为他人和社会做出贡献</strong>，这也是为什么主角在听到小田切的感受之后能涅槃重生的根本原因。</p><h1 id="影评摘录"><a href="#影评摘录" class="headerlink" title="影评摘录"></a>影评摘录</h1><p>下面是摘自豆瓣的影评，在个人看来是对这部电影比较中肯的评价了。</p><p>个人心目中黑泽明最杰出的电影，同行朋友评价说“后劲太大”。这种电影，看一部少一部，看到就是赚到。世界没有进步，电影也没有进步，我无法相信一部讲故事的电影，能做的比《生之欲》更好。 说理蕴含在叙事中，因此显得格外通透。每个人都能从电影里看到自己，思考如何抵抗庸俗的生活。</p><p>当你的生命只剩半年，你会怎么做？——这是每个人都听过但无法给出确凿回答的问题。黑泽明不仅提出问题，他还给出了答案，这答案不仅领先于观众（叙事技巧），而且每一层次的回答都是对之前的超越（主题）。 </p><p>从后悔到享乐再到认真生活，最后落在对政府及个人辛辣无情的批判。</p><p>每个人酒后都振臂高呼继承遗志却无一改变，而真正觉醒的人无非也是独木难支、黯然神伤。不是理想主义，而是现实主义。人生的真相就这样向我摊开，印证了心中所想后也难免要陷入深深的失落。</p><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><p>电影原片：<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL2Jhbmd1bWkvcGxheS9lcDMxMTYxNT90aGVtZT1tb3ZpZSZzcG1faWRfZnJvbT0zMzMuNzg4LnJlY29tbWVuZF9tb3JlX3ZpZGVvLjE=" title="https://www.bilibili.com/bangumi/play/ep311615?theme=movie&spm_id_from=333.788.recommend_more_video.1">生之欲正片-电影-高清在线观看<i class="fa fa-external-link"></i></span></p><p>最为感动的部分是 ゴンドラの唄 这首歌。</p><p>个人认为最好的一个剪辑：<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVFzNDExVjdIbi8/c3BtX2lkX2Zyb209MzMzLjc4OC5yZWNvbW1lbmRfbW9yZV92aWRlby4y" title="https://www.bilibili.com/video/BV1Qs411V7Hn/?spm_id_from=333.788.recommend_more_video.2">ゴンドラの唄 - 船歌 - The Gondola Song -志村乔（《生之欲》黑泽明1952）_哔哩哔哩_bilibili<i class="fa fa-external-link"></i></span></p><p>光是曲子都非常好听：<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMUR0NDExRzdtTS8/c3BtX2lkX2Zyb209MzMzLjc4OC5yZWNvbW1lbmRfbW9yZV92aWRlby4x" title="https://www.bilibili.com/video/BV1Dt411G7mM/?spm_id_from=333.788.recommend_more_video.1">【手风琴】《凤尾船之歌》2011 ゴンドラの唄_哔哩哔哩_bilibili<i class="fa fa-external-link"></i></span></p><p>下面是对应的歌词：</p><blockquote><p>生命苦短 恋爱吧！少女！<br>    在朱唇褪色之前，<br>    在热血冷却之前，<br>    明天就没有这样的好时光了。<br>    生命苦短 恋爱吧！少女！<br>    来吧！彼此手牵手 登上他的船，<br>    让他滚烫的面颊贴在你的面庞上，<br>    在这里有谁也追求不到的东西。<br>    生命苦短 恋爱吧！少女！<br>    在你黑发染上白霜之前，<br>    在你心灵的火焰还未熄灭之前，<br>    因为今日是不会再来临的。</p></blockquote><h1 id="剧情摘录"><a href="#剧情摘录" class="headerlink" title="剧情摘录"></a>剧情摘录</h1><p>下面是边看电影边做的一些细节笔记，简单看看即可。</p><ol><li>市民科长不知道为什么而活。</li><li>政府踢皮球，造公园的事情跑了不下十几个部门，市民科长如同木乃伊一般的处理公务。</li><li>被下级戏谑30年不请假记录打破。</li><li>医院的旁人讲述胃癌反应，科长胃癌的反应被旁人看出来惊慌躲避，</li><li>医生说只是轻型胃溃疡，实际上只有不到半年的命。</li><li>儿子想要动用父亲的养老金，父亲听到之后却只是想着活着的意义。</li><li>看着死去妻子的照片，回忆妻子过去。儿子的过去回忆：棒球，割盲肠，儿子被征兵，然而长久的分割父子之间关系疏远。（镜头语言和场景切换都是神来之笔）</li><li>遇到小说家，诉说自己的苦衷。</li><li>小说家带领主角享受人生。</li><li>被人拿了戴了几十年的帽子而换新帽子。（意味着抛弃过去）。</li><li>后悔人生，歌唱：ゴンドラの唄。</li><li>儿子不理解父亲认为父亲的不配合令人失望，父亲也因儿子之间天堑般的隔阂痛苦。</li><li>遇到离职的下属小田切，追随并追问存在的意义。</li><li>陌生人的生日歌为庆祝主角的涅槃重生。</li><li>主角想要解决公园问题，生命却戛然而止。</li><li>利用各种职员的对话，阐述主角光辉事迹。</li><li>振臂高呼改变现状，第二天却又沦入体制，真正觉醒之人看清世界的面貌，然而想要反抗却是独木难支。</li><li>最后公园的一幕，是主角曾经存在最好的证明。</li><li>批判一个人要在一个人死去之后。<br>电影结束。</li></ol><h2 id="时间轴"><a href="#时间轴" class="headerlink" title="时间轴"></a>时间轴</h2><p>26:32 镜头切换，主角后悔这几张画面很有镜头语言的感觉，父亲和儿子之间某种看不见的隔阂。</p><p>38:30 无可奈何的接受现实<br><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205042157854.png" alt=""></p><p>41:56秒 和小说家倾诉自己想要知道如何体验人生，甚至连自己存了大半辈子的钱也不知道怎么花，于是小说家带他尽情享受人生。</p><p>49:24 第一次唱<strong>ゴンドラの唄</strong>，后悔自己如同行尸走肉的活了30年。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041928283.png" alt=""></p><p>忍受胃癌的痛苦却没有目的空洞活着的表情。另外这个动作莫名像是拿破仑。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041948309.png" alt=""></p><p>1小时24分<br>请求小田切告诉主角为什么会如此年轻活力，请教人生的存在意义。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041954734.png" alt=""></p><p>1小时28分<br>饭店陌生人庆祝友人的生日歌代表了主角的涅槃重生。</p><p>1小时32分<br>然而主角涅槃重生的之时，主角生命戛然而止。个人最为惊讶的地方。</p><p>02:05:48 几句名台词：</p><ul><li>我不能憎恨别人，我没有这种时间。</li><li>30年以来我从没见过黄昏，它太美丽了，但是我已经没有这种时间。</li></ul><p>02:16:30 荡秋千，第二次唱<strong>ゴンドラの唄</strong>，和第一次唱不同，这一次主角是认真而活的尽情歌唱，以至于巡逻警官也为止动容。</p><p>最后一幕：<br>真正觉醒的人看着主角建成的公园而感叹，然而现实却依旧如此的残酷。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>人一旦有了目的，大抵只会感叹人生的短暂，就如电影的主角一般，拼尽全力，人的伟大也只活在别人眼中，珍惜现在的每一刻，就是为自己而活。</p><p>19年电影院刷了2，30部电影，然后几乎没怎么看过电影了，感叹曾经美好年代，也感叹时间易逝。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      乘着假期的尾巴看了这一部电影
    
    </summary>
    
    
      <category term="其他" scheme="https://whitestore.top/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="其他" scheme="https://whitestore.top/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>LSM-Tree - LevelDb 源码解析</title>
    <link href="https://whitestore.top/2022/05/21/leveldb-source/"/>
    <id>https://whitestore.top/2022/05/21/leveldb-source/</id>
    <published>2022-05-21T11:13:33.000Z</published>
    <updated>2022-06-02T10:09:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LSM-Tree-LevelDb-源码解析"><a href="#LSM-Tree-LevelDb-源码解析" class="headerlink" title="LSM-Tree - LevelDb 源码解析"></a>LSM-Tree - LevelDb 源码解析</h1><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在上一篇文章[[LSM-Tree - LevelDb了解和实现]]中介绍了LevelDb相关的数据结构和核心组件，LevelDB的核心读写部分，以及为什么在这个数据库中写入的速度要比读取的速度快上好几倍。 </p><p>LevelDB的源代码还是比较好懂的，好懂到我只学过学JAVA只有定点基础C语言入门知识的人也能看懂，另一方面作者在关键的地方都给了注释，甚至告诉你为什么要这么设计<s>（写的很好很棒让人落泪为什么自己没这样的同事）</s>。</p><p>如果还是看不懂，作者也写了很多数据结构介绍的md文档（在doc目录中）告诉你核心组件的作用。</p><p>总之，不要惧怕这个数据库，无论是作为优秀代码和设计模式还是各种主流数据结构算法应用都非常值得学习和参考。</p><blockquote><p>Tip：这一节代码内容非常多，所以不建议在手机或者移动设备阅读，更适合在PC上观看。</p></blockquote><a id="more"></a><h2 id="源码运行"><a href="#源码运行" class="headerlink" title="源码运行"></a>源码运行</h2><p>LevelDB的编译是比较简单的，可以从官网直接克隆代码。</p><p>地址：<span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzJTNBLy9naXRodWIuY29tL2dvb2dsZS9sZXZlbGRi" title="https://link.zhihu.com/?target=https%3A//github.com/google/leveldb">https://github.com/google/leveldb<i class="fa fa-external-link"></i></span></p><p>具体操作步骤如下(也可以参考仓库中的<code>README</code>)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone --recurse-submodules https://github.com/google/leveldb.git</span><br><span class="line">mkdir -p build &amp;&amp; cd build</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Release .. &amp;&amp; cmake --build .</span><br></pre></td></tr></table></figure><p>完成整个编译动作之后，我们可以新增一个动态库，一个静态库和test目录，接着就可以编写单元测试了，同时官方的源代码中有很多的单元测试可以提供自己编写的测试程序进行调试使用，当然这里跳过这些内容，直接从源码开始。</p><h2 id="底层存储存储结构"><a href="#底层存储存储结构" class="headerlink" title="底层存储存储结构"></a>底层存储存储结构</h2><p>关联：[[SSTable]]</p><p>在LevelDB中<strong>SSTable</strong>是整个数据库最重要的结构，所有的SSTable文件本身的内容是<strong>不可修改</strong>的，虽然通常数据在内存中操作，但是数据不可能无限存储，当数据到达一定量之后就需要持久化到磁盘中，而压缩合并的处理就十分考验系统性能了，为此LevelDb使用分层的结构进行存储，下面我们从外部的使用结构开始来了解内部的设计。</p><p>整个外部的黑盒就是数据库本身了，以事务性数据库为例，通常的操作无非就是ACID四种，但是放到LSM-Tree的数据结构有点不一样，因为更新和删除其实都会通过“新增”与“合并”的方式完成新数据对旧数据的覆盖。</p><p>扯远了，我们从简单的概念开始，首先是整个DB的源代码，DB源代码可以通过以下路径访问：</p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9sZXZlbGRiL2Jsb2IvbWFpbi9pbmNsdWRlL2xldmVsZGIvZGIuaA==" title="https://github.com/google/leveldb/blob/main/include/leveldb/db.h">https://github.com/google/leveldb/blob/main/include/leveldb/db.h<i class="fa fa-external-link"></i></span></p><p>首先我们需要了解DB存储结构，可以看到存储引擎的对外提供的接口十分简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LEVELDB_EXPORT</span> <span class="title">DB</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置数据库的key-value结构，如果没有返回OK则视为操作失败，</span></span><br><span class="line"><span class="comment">// 备注：考虑默认打开sync=true操作，`Put` 方法在内部最终会调用 `Write` 方法，只是在上层为调用者提供了两个不同的选择。</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Status <span class="title">Put</span><span class="params">(<span class="keyword">const</span> WriteOptions&amp; options, <span class="keyword">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> Slice&amp; value)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功返回OK，如果异常则不返回OK，如果什么都返回，说明被删除的Key不存在，</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Status <span class="title">Delete</span><span class="params">(<span class="keyword">const</span> WriteOptions&amp; options, <span class="keyword">const</span> Slice&amp; key)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入操作</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Status <span class="title">Write</span><span class="params">(<span class="keyword">const</span> WriteOptions&amp; options, WriteBatch* updates)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据key获取数据</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Status <span class="title">Get</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options, <span class="keyword">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="built_in">std</span>::<span class="built_in">string</span>* value)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Get</code> 和 <code>Put</code> 是 LevelDB 为上层提供的用于读写的接口，注意这个接口的<code>Update</code>和<code>Delele</code>操作 实际上是通过<code>Put</code>完成的，实现方式是内部做了类型判断，十分有意思，这里可以先留意一下。</p><h2 id="write部分"><a href="#write部分" class="headerlink" title="write部分"></a>write部分</h2><p>下面先从写入操作开始，看看数据是如何进入到LevelDb，以及内部是如何管理的。</p><p>Write的内部逻辑算是比较复杂的，所以这里画了下基本流程图：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204171601989.png" alt=""></p><p>我们从DB的<code>Write()</code>接口方法切入，简化代码之后大致的流程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  为写入构建足够的空间，此时可以不需要加锁。</span></span><br><span class="line">Status status = MakeRoomForWrite(updates == <span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">//  通过 `AddRecord` 方法向日志中追加一条写操作的记录；</span></span><br><span class="line">status = log_-&gt;AddRecord(WriteBatchInternal::Contents(write_batch));</span><br><span class="line"><span class="comment">//  如果日志记录成功，则将数据进行写入</span></span><br><span class="line"><span class="keyword">if</span> (status.ok()) &#123;</span><br><span class="line">status = WriteBatchInternal::InsertInto(write_batch, mem_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个执行流程如下：</p><ul><li>首先调用 <code>MakeRoomForWrite</code> 方法为即将进行的写入提供足够的空间。<ul><li>如果当前空间不足需要冻结当前的<code>memtable</code>，此时发生<code>Minor Compaction</code>并创建一个新的 <code>MemTable</code> 对象。</li><li>如果满足触发<code>Major Compaction</code>需要对数据进行压缩并且对于SSTable进行合并。</li></ul></li><li>通过<code>AddRecord</code>方法向日志中追加一条写操作记录。</li><li>最终调用<strong>memtable</strong>往内存结构中添加<strong>key/value</strong>，完成最终写入操作。</li></ul><p>将写入操作的源代码逻辑简化之后最终如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DBImpl::Write</span><span class="params">(<span class="keyword">const</span> WriteOptions&amp; options, WriteBatch* my_batch)</span> </span>&#123;</span><br><span class="line">  <span class="function">Writer <span class="title">w</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  w.batch = my_batch;</span><br><span class="line"></span><br><span class="line">  MakeRoomForWrite(my_batch == <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">uint64_t</span> last_sequence = versions_-&gt;LastSequence();</span><br><span class="line">  Writer* last_writer = &amp;w;</span><br><span class="line">  WriteBatch* updates = BuildBatchGroup(&amp;last_writer);</span><br><span class="line">  WriteBatchInternal::SetSequence(updates, last_sequence + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 记录最终的操作记录点</span></span><br><span class="line">  last_sequence += WriteBatchInternal::Count(updates);</span><br><span class="line"><span class="comment">// 日志编写</span></span><br><span class="line">  log_-&gt;AddRecord(WriteBatchInternal::Contents(updates));</span><br><span class="line"><span class="comment">// 将数据写入memtable</span></span><br><span class="line">  WriteBatchInternal::InsertInto(updates, mem_);</span><br><span class="line"></span><br><span class="line">  versions_-&gt;SetLastSequence(last_sequence);</span><br><span class="line">  <span class="keyword">return</span> Status::OK();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码有较多的方法封装，这里我们一个个来看。</p><p><code>MaybeScheduleCompaction()</code>压缩合并（如果觉得这里突兀可以请参阅上文的流程图）在源码中系统会定时检查是否可以进行压缩合并，if/else用于多线程并发写入的时候进行合并写入的操作，当发现有不同线程在操作就会等待结果或者等到拿到锁之后接管合并写入的操作。</p><blockquote><p>如果对于下面的代码有疑问可以阅读[[LSM-Tree - LevelDb了解和实现]]中关于“合并写入”的部分，为了节省时间，可以在网页中直接输入关键字“<strong>合并写入</strong>”快速定位，这里假设读者已经了解基本的工作流程，就不再赘述了。</p></blockquote><p>#LevelDb合并写入操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::MaybeScheduleCompaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">mutex_.AssertHeld();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (background_compaction_scheduled_) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Already scheduled</span></span><br><span class="line"><span class="comment">// 正在压缩</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DB is being deleted; no more background compactions</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DB正在被删除；不再有后台压缩</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!bg_error_.ok()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Already got an error; no more changes</span></span><br><span class="line"><span class="comment">// 已经发生异常，不能做更多改动。</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm_ == <span class="literal">nullptr</span> &amp;&amp; manual_compaction_ == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line"></span><br><span class="line">!versions_-&gt;NeedsCompaction()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不需要合并则不工作</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 设置当前正常进行压缩合并</span></span><br><span class="line"></span><br><span class="line">background_compaction_scheduled_ = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 开始压缩合并</span></span><br><span class="line"></span><br><span class="line">env_-&gt;Schedule(&amp;DBImpl::BGWork, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>不可变memtable</strong>：</p><p>在write的函数内部有这样一串代码，此时会暂停解锁等待写入，这个写入又是干嘛的？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Status status = MakeRoomForWrite(updates == <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><p>进入方法内部会发现通过一个<code>while</code>循环判断当前的 <code>memtable</code>状态，一旦发现memtable写入已经写满整个<code>mem</code>，则需要停止写入并且将当前的<code>memtable</code>转为<strong>imutiablememtable</strong>，并且创建新的<code>mem</code>切换写入，此时还会同时根据一些条件判断是否可以进行压缩 <code>mem</code>。</p><p>这里额外解释源码中<strong>GUARDED_BY</strong>含义：</p><p>GUARDED_BY是数据成员的属性，该属性声明数据成员受给定功能保护。对数据的读操作需要<strong>共享</strong>访问，而写操作则需要<strong>互斥</strong>访问。</p><p>该 GUARDED_BY属性声明线程必须先锁定<strong>listener_list_mutex</strong>才能对其进行读写listener_list，从而确保增量和减量操作是原子的。</p><p><strong>总结：其实就是一个典型的互斥共享锁，至于实现不是本文的重点。</strong></p><p>mem可以看作是当前的系统备忘录或者说临时的记账板，和大多数的日志或者关系型数据库类似，都是先写入日志在进行后续的所有“事务”操作，也就是<strong>日志优先于记录操作</strong> 原则，根据日志写入操作加锁来完成并发操作的正常运行。</p><p><code>MakeRoomForWrite</code> 方法中比较关键的部分都加了注释，很多操作作者都有介绍意图，代码逻辑都比较简单，多看几遍基本了解大致思路即可。（C++语法看不懂不必过多纠结，明白他要做什么就行，主要是我也看不懂，哈哈）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!bg_error_.ok()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Yield previous error</span></span><br><span class="line"></span><br><span class="line">s = bg_error_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (allow_delay &amp;&amp; versions_-&gt;NumLevelFiles(<span class="number">0</span>) &gt;=</span><br><span class="line"></span><br><span class="line">config::kL0_SlowdownWritesTrigger) &#123;</span><br><span class="line"><span class="comment">// 我们正接近于达到对L0文件数量的硬性限制。L0文件的数量。当我们遇到硬性限制时，与其将单个写操作延迟数而是在我们达到硬限制时，开始将每个mem单独写1ms以减少延迟变化。另外。这个延迟将一些CPU移交给压缩线程，因为 如果它与写入者共享同一个核心的话。</span></span><br><span class="line"></span><br><span class="line">mutex_.Unlock();</span><br><span class="line"></span><br><span class="line">env_-&gt;SleepForMicroseconds(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 不要将一个单一的写入延迟超过一次</span></span><br><span class="line">allow_delay = <span class="literal">false</span>; </span><br><span class="line">mutex_.Lock();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!force &amp;&amp;</span><br><span class="line"></span><br><span class="line">(mem_-&gt;ApproximateMemoryUsage() &lt;= options_.write_buffer_size)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在当前的mem中还有空间</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们已经填满了当前的memtable，但之前的的mem还在写入，所以需要等待</span></span><br><span class="line"></span><br><span class="line">background_work_finished_signal_.Wait();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (versions_-&gt;NumLevelFiles(<span class="number">0</span>) &gt;= </span><br><span class="line">config::kL0_StopWritesTrigger) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">background_work_finished_signal_.Wait();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A试图切换到一个新的memtable并触发对旧memtable的压缩</span></span><br><span class="line">assert(versions_-&gt;PrevLogNumber() == <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 新建文件号</span></span><br><span class="line"><span class="keyword">uint64_t</span> new_log_number = versions_-&gt;NewFileNumber(); <span class="comment">//return next_file_number_++;</span></span><br><span class="line"></span><br><span class="line">WritableFile* lfile = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">// 新建可写入文件, 内部通过一个map构建一个文件：文件状态的简易文件系统</span></span><br><span class="line"><span class="comment">// typedef std::map&lt;std::string, FileState*&gt; FileSystem;</span></span><br><span class="line">s = env_-&gt;NewWritableFile(LogFileName(dbname_, new_log_number), &amp;lfile);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line"><span class="comment">// 避免死循环重复新增文件号</span></span><br><span class="line">versions_-&gt;ReuseFileNumber(new_log_number);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> log_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> logfile_;</span><br><span class="line"></span><br><span class="line">logfile_ = lfile;</span><br><span class="line"></span><br><span class="line">logfile_number_ = new_log_number;</span><br><span class="line"><span class="comment">// 写入日志</span></span><br><span class="line">log_ = <span class="keyword">new</span> <span class="built_in">log</span>::Writer(lfile);</span><br><span class="line"><span class="comment">// **重点：imm_ 就是immutable 他将引用指向当前已经写满的mem，其实和mem对象没什么区别，就是加了一个互斥共享锁而已（写互斥，读共享）**</span></span><br><span class="line">imm_ = mem_;</span><br><span class="line"></span><br><span class="line">has_imm_.store(<span class="literal">true</span>, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line"><span class="comment">// 新建新的memtable</span></span><br><span class="line">mem_ = <span class="keyword">new</span> MemTable(internal_comparator_);</span><br><span class="line"><span class="comment">// 引用至新块</span></span><br><span class="line">mem_-&gt;Ref();</span><br><span class="line"></span><br><span class="line">force = <span class="literal">false</span>; <span class="comment">// Do not force another compaction if have room</span></span><br><span class="line"><span class="comment">// 尝试对于已满mem压缩合并 ，此处承接上文</span></span><br><span class="line">MaybeScheduleCompaction();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面用一个简单的示意图了解上面的大致流程：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204181000328.png" alt=""></p><p>注意这对于[[SSTable]]的原始理论的实现结构显然是有一定出入，当然这是很正常的理论和实践的差别。</p><p>在通常情况下<code>memtable</code>可以通过短暂的延迟读写请求等待压缩完成，但是一旦发现mem占用的内存过大，此时就需要给<strong>当前的mem加锁变为_imu状态</strong>，然后创建一个新的 MemTable 实例并且把<strong>新进来的请求转到新的mem中</strong>，这样就可以继续接受外界的写操作，不再需要等待 <code>Minor Compaction</code> 的结束了。</p><blockquote><p>再次注意此处会通过函数 <strong>MaybeScheduleCompaction</strong> 是否进行压缩合并的操作判断。</p></blockquote><p>这种无等待的设计思路来自于：[[Dynamic-sized NonBlocking Hash table]]，可以自己下下论文来看看，当然也可以等我后面的文章。</p><h2 id="log部分"><a href="#log部分" class="headerlink" title="log部分"></a>log部分</h2><p>写入的大致操作流程了解之后，下面来看看LevelDb的日志管理也就是<code>AddRecord()</code>函数的操作：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204172014056.png" alt=""></p><p>注意日志的核心部分并不在<code>AddRecord()</code>内部，因为内部只有一些简单的字符串拼接操作，这里将核心放到了<code>RecordType</code>的部分，可以看到这里通过当前日志字符长度判断不同的类型，<code>RecordType</code>标识当前记录在块里面的位置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//....</span></span><br><span class="line"><span class="keyword">enum</span> RecordType &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Zero is reserved for preallocated files</span></span><br><span class="line"></span><br><span class="line">kZeroType = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">kFullType = <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// For fragments</span></span><br><span class="line"></span><br><span class="line">kFirstType = <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">kMiddleType = <span class="number">3</span>,</span><br><span class="line"></span><br><span class="line">kLastType = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//....</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RecordType type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">bool</span> <span class="built_in">end</span> = (left == fragment_length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">begin</span> &amp;&amp; <span class="built_in">end</span>) &#123;</span><br><span class="line"></span><br><span class="line">type = kFullType;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">begin</span>) &#123;</span><br><span class="line"></span><br><span class="line">type = kFirstType;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">end</span>) &#123;</span><br><span class="line"></span><br><span class="line">type = kLastType;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">type = kMiddleType;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>First：是用户记录第一个片段的类型，<br>Last：是用户记录的最后一个片段的类型。<br>   Middle：是一个用户记录的所有内部片段的类型。</p></blockquote><p>如果看不懂源代码，可以根据作者的md文档介绍也可以大致了解日志文件结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">record :=</span><br><span class="line">     checksum: uint32     <span class="comment">// crc32c of type and data[] ; little-endian</span></span><br><span class="line">     length: uint16       <span class="comment">// little-endian</span></span><br><span class="line">     type: uint8          <span class="comment">// One of FULL, FIRST, MIDDLE, LAST</span></span><br><span class="line">     data: uint8[length]</span><br></pre></td></tr></table></figure><p>我们可以根据描述简单画一个图：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204171749969.png" alt=""></p><p>从<code>RecordType</code>内部的定义可以看到日志固定为<strong>32KB</strong>大小，在日志文件中将分为多部分，但是一个日志只包含在一个单一的文件块。</p><p>RecordType 存储的内容如下：</p><ul><li>前面4个字节用于CRC校验</li><li>接着两个字节是块数据长度</li><li>接着是一个字节的类型标识（标识当前日志记录在块中位置）</li><li>最后是数据payload部分</li></ul><p><strong>32kb</strong>大小选择是考虑到日志记录行的磁盘对齐和日志读写，针对日志写的速度也非常快，写入的日志先写入内存的文件表，然后通过<code>fdatasync(...)</code>方法将缓冲区<code>fflush</code>到磁盘中并且持久化，最后通过日志完成故障恢复的操作。</p><p>需要注意如果日志记录较大可能存在于多个block块中。</p><p>一个记录永远不会在一个块的最后六个字节内开始，理由是一个记录前面需要一些其他部分占用空间（也就是记录行的校验和数据长度标识信息等）。</p><p>为了防止单个日志块被拆分到多个文件以及压缩考虑，这种“浪费”是可以被接受。</p><p>如果读者非要清楚最后几个字节存储的是什么，想满足自己的好奇心，可以看下面的代码：</p><p><code>dest_-&gt;Append(Slice(&quot;\x00\x00\x00\x00\x00\x00&quot;, leftover));</code></p><p><strong>日志写流程图</strong>：</p><p>日志写的流程比较简单，主要分歧点是当前块剩余空间是否够写入一个header，并且最后6个字节将会填充空格进行补齐。</p><p>在日志写入的过程中通过一个<code>while(ture)</code>不断判断<code>buffer</code>大小，如果大小超过<strong>32KB</strong>-最后6个字节，则需要停止写入并且把开始写入到现在位置为一个数据块。</p><p>下面是日志写流程图：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204171802290.png" alt="日志写流程图"></p><p>下面是日志读流程图：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204171802000.png" alt="日志读流程图"></p><p>既然日志大小为32kb，那么日志的读写单位也应该是32kb，接着便是扫描数据块，在扫描chunk的时候如果发现CRC校验不通过则返回错误信息，如果数据破损则丢弃当前chunk。</p><p>翻了一下代码，简单来说就是读取通过<code>while(true)</code>循环<code>read</code>，直到读取到类型为<code>Last</code>的<code>chunk</code>，日志记录读取完成。</p><p><code>memtable</code>比较有意思的特点是无论插入还是删除都是通过“新增”的方式实现的（你没有看错），内部通过<code>Mainfest</code>维护状态，同时根据版本号和序列号维护一条记录是新增还是删除并且保证读取到的内容是最新值，具体介绍同样在上一节[[LSM-Tree - LevelDb了解和实现]]中。</p><p>注意<strong>写入日志之后记录是不能查询</strong>的（因为中间有可能存在断电故障导致真实记录没有写入），日志仅作为故障恢复，只有<strong>数据写入到mem之后才被访问到</strong>。</p><p>关于mem新增和删除的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemTableInserter</span> :</span> <span class="keyword">public</span> WriteBatch::Handler &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">SequenceNumber sequence_;</span><br><span class="line"></span><br><span class="line">MemTable* mem_;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Put</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">mem_-&gt;Add(sequence_, kTypeValue, key, value);</span><br><span class="line"></span><br><span class="line">sequence_++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">mem_-&gt;Add(sequence_, kTypeDeletion, key, Slice());</span><br><span class="line"></span><br><span class="line">sequence_++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace</span></span><br></pre></td></tr></table></figure><p>在<code>Add()</code>函数的内部通过一个[[LSM-Tree - LevelDb Skiplist跳表]]完成数据的插入，在数据的node中包含了记录键值，为了保证读取的数据永远是最新的，记录需要在<code>skiplist</code>内部进行排序，节点排序使用的是比较常见的比较器<code>Compare</code>，如果用户想要自定义排序（例如处理不同的字符编码等）可以编写自己的比较器实现。</p><p>对于一条记录的结构我们也可以从 <code>Add()</code> 函数中看到作者的注释：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Format of an entry is concatenation of:</span></span><br><span class="line">  <span class="comment">//  key_size     : varint32 of internal_key.size()</span></span><br><span class="line">  <span class="comment">//  key bytes    : char[internal_key.size()]</span></span><br><span class="line">  <span class="comment">//  tag          : uint64((sequence &lt;&lt; 8) | type)</span></span><br><span class="line">  <span class="comment">//  value_size   : varint32 of value.size()</span></span><br><span class="line">  <span class="comment">//  value bytes  : char[value.size()]</span></span><br></pre></td></tr></table></figure><blockquote><p>[[VarInt32编码]]：在这里虽然是变长整型类型但是实际使用4个字节表示。<br><code>uint64((sequence &lt;&lt; 8) | type</code>：位运算之后实际为7个字节的sequence长度<br>注意在tag和value_size中间有一个ValueType标记来标记记录是新增还是删除。</p></blockquote><p>VarInt32 (vary int 32)，即：长度可变的 32 为整型类型。一般来说，int 类型的长度固定为 32 字节。但 VarInt32 类型的数据长度是不固定的，VarInt32 中每个字节的最高位有特殊的含义。如果最高位为 1 代表下一个字节也是该数字的一部分。</p><p>因此，表示一个整型数字最少用 1 个字节，最多用 5 个字节表示。如果某个系统中大部分数字需要 &gt;= 4 字节才能表示，那其实并不适合用 VarInt32 来编码。</p><p>根据<code>get()</code>代码内部通过<code>valueType</code>进行区分，<code>valueType</code>占用一个字节的空间进行判断新增还是删除记录，默认比较器判断新增或者删除记录逻辑如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (comparator_.comparator.user_comparator()-&gt;Compare(</span><br><span class="line"></span><br><span class="line">Slice(key_ptr, key_length - <span class="number">8</span>), key.user_key()) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Correct user key</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint64_t</span> tag = DecodeFixed64(key_ptr + key_length - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (<span class="keyword">static_cast</span>&lt;ValueType&gt;(tag &amp; <span class="number">0xff</span>)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> kTypeValue: &#123;</span><br><span class="line"></span><br><span class="line">Slice v = GetLengthPrefixedSlice(key_ptr + key_length);</span><br><span class="line"></span><br><span class="line">value-&gt;assign(v.data(), v.size());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> kTypeDeletion:</span><br><span class="line"></span><br><span class="line">*s = Status::NotFound(Slice());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据代码定义和上面的描述画出下面的结构图：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204171916505.png" alt=""></p><p><strong>Compare键排序</strong></p><p>LevelDb的memtable通过跳表维护了键，内部默认情况下通过<code>InternalKeyComparator</code>对于键进行比较，下面是比较内部逻辑：</p><p>比较器通过 <code>user_key</code> 和 <code>sequence_number</code> 进行排序，同时按照user_key进行升序排序，<strong>序列号通过插入的时间递增</strong>，以此来保证无论是增加还是删除都是获取到最新的信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 一个用于内部键的比较器，它使用一个指定的比较器用于用户键部分比较，并通过递减序列号来打破平衡。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InternalKeyComparator::Compare</span><span class="params">(<span class="keyword">const</span> Slice&amp; akey, <span class="keyword">const</span> Slice&amp; bkey)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Order by:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加用户密钥（根据用户提供的比较器）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递减序列号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递减类型（尽管序列号应该足以消除歧义）。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> r = user_comparator_-&gt;Compare(ExtractUserKey(akey), ExtractUserKey(bkey));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint64_t</span> anum = DecodeFixed64(akey.data() + akey.size() - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint64_t</span> bnum = DecodeFixed64(bkey.data() + bkey.size() - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (anum &gt; bnum) &#123;</span><br><span class="line"></span><br><span class="line">r = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (anum &lt; bnum) &#123;</span><br><span class="line"></span><br><span class="line">r = +<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意被比较key<strong>可能包含完全不同的内容</strong>，这里读者肯定会有疑问对于key获取值进行提取信息是否会有影响，然而从get的逻辑来看它可以通过键长度，和序列号等信息进行获取Key，并且获取是<strong>header的头部信息</strong>，所以key是任何类型都是没有影响的。</p><p><strong>记录查询</strong></p><p>现在我们再回过头来看一下<code>memtable</code>是如何读取的，从<code>memtable</code>和<code>imumemble</code>的关系可以看出有点类似<strong>缓存</strong>，当<code>memtable</code>写满之后转为<code>imumem</code>并且等待同步至磁盘。</p><p>key读取和查找的顺序如下：</p><ul><li>在memtable中获取指定Key，如果数据符合条件则结束查找。</li><li>在Imumemtable中查找指定Key，如果数据符合条件则结束查找。</li><li>按低层至高层的顺序在level i层的sstable文件中查找指定的key，若搜索到符合条件的数据项就会结束查找，否则返回Not Found错误，表示数据库中不存在指定的数据。</li></ul><p>记录按照层级关系进行搜索，首先是从当前内存中正在写入<code>memtable</code>搜索，接着是<code>imumemtable</code>，再接着是存在于磁盘不同层级的<code>SSTable</code>，SSTable通过<code>*.ldb</code>的形式进行标记，可以快速找到。</p><p>最终我们可以把LevelDb的查询看作下面的形式：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204172111973.png" alt=""></p><p><strong>小结</strong>：</p><p>这一部分我们了解了LevelDB源代码部分等基础结构DB，介绍了LevelDB的基础对外接口，LevelDB和map的接口看起来十分类似，这一部分重点讲述了读写操作等源代码，以及内部合并压缩的一些细节。</p><p>另外记录查询等动作和之前介绍LevelDB等读写流程大致类似，当然代码简化了很多的内容，读者可以根据自己感兴趣的内容研究。</p><h2 id="SSTable操作"><a href="#SSTable操作" class="headerlink" title="SSTable操作"></a>SSTable操作</h2><p>前面我们提到了记录的增删改查底层查询，和日志的读写细节，下面则针对谷歌发明的特殊数据结构<code>SSTable</code>进行介绍。</p><p><strong>SSTable如何工作？</strong></p><p><code>SSTable</code>在初始的论文中可以总结出下面的特点：</p><ul><li>写入的时候不写入磁盘而是先写入内存表的数据结构。</li><li>当数据结构内存占用超过一定的阈值就可以直接写入到磁盘文件由于已经是排好序的状态，所以可以直接对旧结构覆盖，写入效率比较高。并且写入和数据结构改动可以同时进行。</li><li>读写顺序按照 内存 - 磁盘 - 上一次写入文件 - 未找到。</li><li>后台定时线程定时合并和压缩排序分段，将废弃值给覆盖或者丢弃。</li></ul><p>[[SSTable]] 最早出现在谷歌2006年的论文当中，LevelDB的SSTable设计也有部分特性体现这个数据结构，当然并不是完全一致的，LevelDB利用SSTable在磁盘中维护多层级的数据节点。</p><p>可以认为了解SSTable结构就相当于了解了LevelDb的核心数据结构设计。</p><p><strong>多层级SSTable</strong></p><p>我们重点看看多层级的SSTable部分，levelDB在磁盘中扫描SSTable的时候LevelDB并不会跳过层级，这里肯定会有疑问每个层级都扫一遍的效率问题，针对这个问题作者在db中设计了下面的数据结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FileMetaData</span> &#123;</span></span><br><span class="line"></span><br><span class="line">FileMetaData() : refs(<span class="number">0</span>), allowed_seeks(<span class="number">1</span> &lt;&lt; <span class="number">30</span>), file_size(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">int</span> refs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> allowed_seeks; <span class="comment">// 允许压缩搜索</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> number;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> file_size; <span class="comment">// 文件大小</span></span><br><span class="line"></span><br><span class="line">InternalKey smallest; <span class="comment">// 表提供的最小内部密钥</span></span><br><span class="line"></span><br><span class="line">InternalKey largest; <span class="comment">// 表提供最大内部密钥</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上面的结构体声明中定义了压缩SSTable文件的全部信息，包括最大值和最小值，运行查找次数，文件引用次数和文件号，SSTable会按照固定的形式存储到同一个目录下面，所以可以通过文件号进行快速搜索。</p><p>查找和记录key顺序类似，都是按照<strong>从小到大</strong>的顺序进行读取的，以Level0为例，里面通常包含<strong>4个固定的SSTable</strong>，并且内部通常存在key交叉，所以会按照从SSTable1-4的顺序进行读取，而更高层次的层级则通过查找上面结构体的最大值和最小值的信息（smallest和largest）。</p><p>具体的文件搜索细节可以通过<code>TableCache::FindTable</code>查找 ，由于篇幅有限这里就不贴代码了，简要逻辑是配合缓存和<code>RandomAccessFile</code>对于文件进行读写，然后把读到的文件信息写入到内存中方便下次获取。</p><blockquote><p>如果了解Mysql Btree设计会发现文件搜索有些类似页目录的查找。不同的是Btree页目录通过页目录等稀疏搜索。</p></blockquote><p><strong>SSTable合并</strong></p><p>我们再来看看SSTable是如何合并的，之前提到过SSTable通过<strong>MaybeScheduleCompaction</strong>尝试合并，需要注意这个合并压缩和Bigtable的形式类似，都是根据不同的条件判断是否进行合并，一旦可以合并便执行<code>BackgroundCompaction</code>操作。</p><p>合并分为两种情况，一种是<strong>Minor Compaction</strong>，另一种是将<strong>Memtable</strong>数据写满转为不可变对象（实际就是加锁），执行<code>CompactMemtable</code>进行压缩。</p><p>合并操作简化版源代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::CompactMemTable</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">VersionEdit edit;</span><br><span class="line">Version* base = versions_-&gt;current();</span><br><span class="line">WriteLevel0Table(imm_, &amp;edit, base);</span><br><span class="line">versions_-&gt;LogAndApply(&amp;edit, &amp;mutex_);</span><br><span class="line">RemoveObsoleteFiles();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CompactMemTable方法会先构建当前的修改版本号，然后调用<code>WriteLevel0Table()</code>方法尝试把当前的Imumtable写入到Level0的层级。<br>如果发现Level0的层级SSTable过多，则进一步进行<strong>Major Compaction</strong>，同时根据<code>BackgroudCompcation()</code>选择合适的压缩层级和压缩方式。</p><p>下面是<code>writeLevel0</code>的简化代码：</p><p>简化代码的最后几行代码会获取文件信息的最大值和最小值以此判断是否在当前SSTable搜索还是跳转到下一个。</p><p>数据如果是写入Level0我们可以看作是<strong>Major Compaction</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::WriteLevel0Table</span><span class="params">(MemTable* mem, VersionEdit* edit,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">Version* base)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SSTable文件信息</span></span><br><span class="line">FileMetaData meta;</span><br><span class="line"></span><br><span class="line">meta.number = versions_-&gt;NewFileNumber();</span><br><span class="line"></span><br><span class="line">pending_outputs_.insert(meta.number);</span><br><span class="line"></span><br><span class="line">Iterator* iter = mem-&gt;NewIterator();</span><br><span class="line"><span class="comment">// 构建SSTable文件</span></span><br><span class="line">BuildTable(dbname_, env_, options_, table_cache_, iter, &amp;meta);</span><br><span class="line"></span><br><span class="line">pending_outputs_.erase(meta.number);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，如果 file_size 为零，则该文件已被删除，并且不应被添加到清单中。</span></span><br><span class="line"><span class="comment">// 获取文件信息的最大值和最小值</span></span><br><span class="line"><span class="keyword">const</span> Slice min_user_key = meta.smallest.user_key();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Slice max_user_key = meta.largest.user_key();</span><br><span class="line"><span class="comment">// level层级扫描</span></span><br><span class="line">base-&gt;PickLevelForMemTableOutput(min_user_key, max_user_key);</span><br><span class="line"><span class="comment">// 写入文件</span></span><br><span class="line">edit-&gt;AddFile(level, meta.number, meta.file_size, meta.smallest,</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Status::ok();</span><br></pre></td></tr></table></figure><p>结合上下两段源码可以发现文件管理最终是通过<code>VersionEdit</code>来完成的，如果写入成功了则返回当前的SSTable的<code>FileMetaData</code>，在<code>VersionEdit</code>内部通过<code>logAndApply</code>的方式记录文件内部的变化，也就是前文介绍的日志管理功能了，完成之后通过<code>RemoveObsoleteFiles()</code>方法进行数据的清理操作。</p><p>如果<code>Level0</code>写满了此时就需要进行<strong>Major Compaction</strong>，这个压缩会比前面的要复杂一些因为涉及低层级到高层级的压缩。</p><p>这里需要再回看<code>BackgroundCompaction</code>的代码，具体代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::BackgroundCompaction</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"><span class="comment">// 如果存在不可变imumem,进行压缩合并</span></span><br><span class="line">CompactMemTable();</span><br><span class="line">  </span><br><span class="line">versions_-&gt;PickCompaction();</span><br><span class="line"></span><br><span class="line">VersionSet::LevelSummaryStorage tmp;</span><br><span class="line"></span><br><span class="line">CompactionState* compact = <span class="keyword">new</span> CompactionState(c);</span><br><span class="line"></span><br><span class="line">DoCompactionWork(compact);</span><br><span class="line"></span><br><span class="line">CleanupCompaction(compact);</span><br><span class="line"></span><br><span class="line">c-&gt;ReleaseInputs();</span><br><span class="line"></span><br><span class="line">RemoveObsoleteFiles();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先根据<code>VersionSet</code> 查找需要压缩的信息，并且打包加入到 <strong>Compaction</strong> 对象，这个对象根据查询次数和大小限制来选择需要压缩的<strong>两个层级</strong>，因为level0中包含很多重叠键，则会在更高层级找到有重叠的键的SSTable，再通过<code>FileMetaData</code>找到需要压缩的文件，另外查询频繁的SSTable将会“升级”到更高层级进行压缩存储，并且更新文件信息方便下一次查找。</p><p><strong>合并的触发条件</strong></p><p>每个 SSTable 在创建之后的 <code>allowed_seeks</code> 都为 100 次，当 <code>allowed_seeks &lt; 0</code> 时就会触发该文件的与更高层级和合并，因为频繁查询的数据通常会降低系统性能。</p><p>这样的设计理由是<strong>在高层级搜索键说明在上一层肯定是相同的键查找</strong>，同时也是为了减少每次都覆盖扫描多层级扫描寻找数据。最终这种设计方式核心是以更新<strong>FileMetaData</strong> 来减少下一次查询的性能开销。</p><p>另外这种处理可以简单理解为我们在操作系统中进行深层次文件夹搜索的时候，如果频繁查询某个深层次的数据很麻烦，解决此问题的第一种方式是建立一个“快捷方式”的文件夹，另一种是直接做标签直接指向这个目录，其实两者都是差不多的，所以压缩设计也是同理。</p><p>LevelDB 中的 <code>DoCompactionWork</code> 方法会对所有传入的 SSTable 中的键值使用<strong>归并排序</strong>进行合并，最后会在更高层级中生成一个新的 SSTable。</p><blockquote><p>归并排序主要是对于key进行归并，使得迭代的时候key就是有序的可以直接合并到指定的高高层级。关键代码存在于下面的代码<br><code>Iterator* input = versions_-&gt;MakeInputIterator(compact-&gt;compaction);</code></p></blockquote><p><strong>归并排序</strong></p><p><strong>DoCompactionWork</strong> 归并排序 的源代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::DoCompactionWork</span><span class="params">(CompactionState* compact)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int64_t</span> imm_micros = <span class="number">0</span>; <span class="comment">// Micros spent doing imm_ compactions</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (snapshots_.empty()) &#123;</span><br><span class="line"><span class="comment">// 快照为空，找到直接采用记录信息的最后序列号</span></span><br><span class="line"></span><br><span class="line">compact-&gt;smallest_snapshot = versions_-&gt;LastSequence();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 快照存在，则抛弃之前所有的序列</span></span><br><span class="line">compact-&gt;smallest_snapshot = snapshots_.oldest()-&gt;sequence_number();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 对于待压缩数据进行，内部生成一个MergingIterator，当构建迭代器之后键内部就是有序的状态了，也就是前面说的归并排序的部分</span></span><br><span class="line">Iterator* input = versions_-&gt;MakeInputIterator(compact-&gt;compaction);</span><br><span class="line"></span><br><span class="line">input-&gt;SeekToFirst();</span><br><span class="line"></span><br><span class="line">Status status;</span><br><span class="line"></span><br><span class="line">ParsedInternalKey ikey;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> current_user_key;</span><br><span class="line"><span class="comment">//当前记录user key</span></span><br><span class="line"><span class="keyword">bool</span> has_current_user_key = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">SequenceNumber last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (input-&gt;Valid() &amp;&amp; !shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优先考虑imumemtable的压缩工作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (has_imm_.load(<span class="built_in">std</span>::memory_order_relaxed)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint64_t</span> imm_start = env_-&gt;NowMicros();</span><br><span class="line"></span><br><span class="line">imm_micros += (env_-&gt;NowMicros() - imm_start);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Slice key = input-&gt;key();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (compact-&gt;compaction-&gt;ShouldStopBefore(key) &amp;&amp;</span><br><span class="line"></span><br><span class="line">compact-&gt;builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line"></span><br><span class="line">status = FinishCompactionOutputFile(compact, input);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理键/值，添加到状态等。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> drop = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ParseInternalKey(key, &amp;ikey)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除和隐藏呗删除key</span></span><br><span class="line"></span><br><span class="line">current_user_key.clear();</span><br><span class="line"></span><br><span class="line">has_current_user_key = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 更新序列号</span></span><br><span class="line">last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!has_current_user_key ||</span><br><span class="line"></span><br><span class="line">user_comparator()-&gt;Compare(ikey.user_key, Slice(current_user_key)) !=</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户key第一次出现</span></span><br><span class="line"></span><br><span class="line">current_user_key.assign(ikey.user_key.data(), ikey.user_key.size());</span><br><span class="line"></span><br><span class="line">has_current_user_key = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (last_sequence_for_key &lt;= compact-&gt;smallest_snapshot) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩以后旧key边界的被新的覆盖</span></span><br><span class="line"></span><br><span class="line">drop = <span class="literal">true</span>; <span class="comment">// (A)</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ikey.type == kTypeDeletion &amp;&amp;</span><br><span class="line"></span><br><span class="line">ikey.sequence &lt;= compact-&gt;smallest_snapshot &amp;&amp;</span><br><span class="line"></span><br><span class="line">compact-&gt;compaction-&gt;IsBaseLevelForKey(ikey.user_key)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于这个用户密钥：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (1) 高层没有数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (2) 较低层的数据会有较大的序列号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (3) 层中的数据在此处被压缩并具有</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 较小的序列号将在下一个被丢弃</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个循环的几次迭代（根据上面的规则（A））。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因此，此删除标记已过时，可以删除。</span></span><br><span class="line"></span><br><span class="line">drop = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">last_sequence_for_key = ikey.sequence;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>归并排序并且处理完键值信息完成跨层级压缩，之后便是是一些收尾工作，收尾工作需要对于压缩之后的信息统计。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">CompactionStats stats;</span><br><span class="line"></span><br><span class="line">stats.micros = env_-&gt;NowMicros() - start_micros - imm_micros;</span><br><span class="line"><span class="comment">//选择两个层级的SSTable</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> which = <span class="number">0</span>; which &lt; <span class="number">2</span>; which++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; compact-&gt;compaction-&gt;num_input_files(which); i++) &#123;</span><br><span class="line"></span><br><span class="line">stats.bytes_read += compact-&gt;compaction-&gt;input(which, i)-&gt;file_size;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; compact-&gt;outputs.size(); i++) &#123;</span><br><span class="line"></span><br><span class="line">stats.bytes_written += compact-&gt;outputs[i].file_size;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 压缩到更高的层级</span></span><br><span class="line">stats_[compact-&gt;compaction-&gt;level() + <span class="number">1</span>].Add(stats);</span><br><span class="line"><span class="comment">// 注册压缩结果</span></span><br><span class="line">InstallCompactionResults(compact);</span><br><span class="line"><span class="comment">// 压缩信息存储</span></span><br><span class="line">VersionSet::LevelSummaryStorage tmp;</span><br><span class="line">Log(options_.info_log, <span class="string">"compacted to: %s"</span>, versions_-&gt;LevelSummary(&amp;tmp));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> status;</span><br></pre></td></tr></table></figure><p>最后层级压缩的默认层级为<strong>7个层级</strong>，在源代码中有如下定义：</p><p><code>static const int kNumLevels = 7;</code></p><p><strong>小结</strong></p><p>这里我们小结一下合并压缩的两个操作：<code>Minor Compaction</code>和<code>Major Compaction</code>：</p><p><code>Minor Compaction</code>：这个GC主要是Level0层级的一些压缩操作，由于Level0层级被较为频繁使用，类似一级缓存，键值不会强制要求进行排序，所以重叠的键会比较多，整个压缩的过程比较好理解，关键部分是skiplist（跳表）中构建一个新的SSTable并且插入到指定层级。</p><p>注：<code>Minor Compaction</code>进行的时候会暂停<code>Major Compaction</code>操作。</p><p><strong>Minor Compaction</strong>：这个比Minor Compaction复杂不少，不仅包含跨层级压缩，还包括键范围确定和迭代器归并排序和最终的统计信息操作，其中最最关键的部分是归并排序压缩列表，之后将旧文件和新文件合并生产新的<code>VersionSet</code>信息，另外这里除开全局的压缩进度和管理操作之外。</p><p>另外Minor Compaction完成之后还会再尝试一次Minor Compaction，因为Minor Compaction可能带来更多的重复键，所以再进行一次压缩可以进一步提高查找效率。</p><p><strong>Major Compaction</strong>：这个操作需要暂停整个LevelDB的读写，因为此时需要对于整个LevelDb的多层级进行跨层级合并，跨层级压缩要复杂很多，具体的细节会在后面介绍。</p><blockquote><p>这里可以认为是作者在测试的过程发现一种情况并且做的优化。</p></blockquote><p><strong>存储状态 - VersionSet</strong></p><p>从这个对象名称来看直接理解为“版本集合”，在内部通过一个Version的结构体对于键值信息进行“版本控制”，毫无疑问这是由于多线程压缩所带来的特性，所以最终是一个双向链表+历史版本的形式串联，但是永远只有一个版本是当前版本。<br>VersionSet最为频繁也是比较关键的一个操作函数<code>LogAndApply</code>，下面是简化之后的<code>VersionSet::LogAndApply</code>代码：</p><blockquote><p>这里可以对照关系型数据库Mysql的Mvcc中的undo log类比进行理解</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">VersionSet::LogAndApply</span><span class="params">(VersionEdit* edit, port::Mutex* mu)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 更新版本链表信息</span></span><br><span class="line"><span class="keyword">if</span> (!edit-&gt;has_prev_log_number_) &#123;</span><br><span class="line"></span><br><span class="line">edit-&gt;SetPrevLogNumber(prev_log_number_);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">edit-&gt;SetNextFile(next_file_number_);</span><br><span class="line"></span><br><span class="line">edit-&gt;SetLastSequence(last_sequence_);</span><br><span class="line"></span><br><span class="line">Version* v = <span class="keyword">new</span> Version(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">// 构建当前的版本version，委托给建造器进行构建</span></span><br><span class="line"><span class="function">Builder <span class="title">builder</span><span class="params">(<span class="keyword">this</span>, current_)</span></span>;</span><br><span class="line"></span><br><span class="line">builder.Apply(edit);</span><br><span class="line"></span><br><span class="line">builder.SaveTo(v);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键方法：内部通过打分机制确定文件所在的层级，值得注意的是level0的层级确定在源代码中有较多描述</span></span><br><span class="line">Finalize(v);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如有必要，通过创建包含当前版本快照的临时文件来初始化新的描述符日志文件。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> new_manifest_file;</span><br><span class="line"><span class="comment">//  没有理由在这里解锁*mu，因为我们只在第一次调用LogAndApply时（打开数据库时）碰到这个路径。</span></span><br><span class="line">new_manifest_file = DescriptorFileName(dbname_, manifest_file_number_);</span><br><span class="line"><span class="comment">// 写入mainfest文件</span></span><br><span class="line">env_-&gt;NewWritableFile(new_manifest_file, &amp;descriptor_file_);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入版本信息快照</span></span><br><span class="line">WriteSnapshot(descriptor_log_);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把记录写到 MANIFEST中</span></span><br><span class="line"></span><br><span class="line">descriptor_log_-&gt;AddRecord(record);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果创建了新的文件，则将当前版本指向这个文件</span></span><br><span class="line"></span><br><span class="line">SetCurrentFile(env_, dbname_, manifest_file_number_);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册新版本</span></span><br><span class="line"></span><br><span class="line">AppendVersion(v);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Status::OK();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键部分注释已给出，这里的<strong>Mainfest</strong>细节在之前没有提到过，在作者提供的<code>impl.md</code>是这样介绍mainfest的：</p><blockquote><p>MANIFEST 文件列出了组成每个级别的排序表集、相应的键范围和其他重要的元数据。 每当重新打开数据库时，都会创建一个新的 MANIFEST 文件（文件名中嵌入了一个新编号）。 MANIFEST 文件被格式化为日志，并且对服务状态所做的更改（随着文件的添加或删除）被附加到此日志中。</p></blockquote><p>从个人的角度来看，这个文件有点类似BigTable中的元数据<code>Meta</code>。</p><p><strong>SSTable文件格式</strong></p><p>理解这部分不需要急着看源代码，在仓库中的<code>table_format.md</code>的文件中同样有相关描述，这里就直接照搬官方文档翻译了：</p><blockquote><p>leveldb 文件格式<br><beginning_of_file><br>[数据块 1]<br>[数据块 2]<br>…<br>[数据块N]<br>[元块 1]<br>…<br>[元块K]<br>[元索引块]<br>[索引块]<br>[页脚]（固定大小；从 file_size - sizeof(Footer) 开始）<br><end_of_file></p></blockquote><p>我们可以根据描述画一个对应的结构图：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204172242656.png" alt=""></p><p>上面的结构图从上至下的介绍如下：</p><ul><li>数据块：按照LSM-Tree的数据存储规范，按照key/value的顺序形式进行排序，数据块根据<code>block.builder.cc</code>的内部逻辑进行格式化，并且可以选择是否压缩存储。</li><li>元数据块：元数据块和数据块类似也使用<code>block.builder.cc</code>进行格式化，同时可选是否压缩，元数据块后续扩展更多的类型（主要用作数据类型记录）</li><li>“元索引”块：为每个其他元数据块索引，键为元块的名称，值为指向该元块的 BlockHandle。</li><li>“索引块”：包含数据块的索引，键是对应<strong>字符串&gt;=数据块的最后一个键</strong>，并且在连续的数据块的第一个键之前，值是 数据块的 BlockHandle。</li><li>文件的最后是一个固定长度的页脚，其中包含元索引和索引块的 BlockHandle 以及一个<strong>幻数</strong>。</li></ul><blockquote><p>幻数又被称为魔数，比如JAVA的字节码第一个字节8位是<code>CAFEBABE</code>，数值和字节大小没什么意义，更多是作者的兴趣。</p></blockquote><p>注意Footer页脚固定48个字节的大小，我们能在其中拿到 <strong>元索引块</strong> 和 <strong>索引块</strong>的位置，然后通过这两个索引寻找其他值对应的位置。</p><p>更详细的内容可以继续参考<code>table_format.md</code>介绍，这里就不再赘述了。</p><p><strong>TableBuilder</strong>：</p><p>SSTable接口定义于一个<code>TableBuilder</code>构建器当中，<strong>TableBuilder</strong> 提供了用于构建 Table 的接口，关于此接口的定义如下：</p><p>TableBuilder提供了用于建立表的接口  (一个从键到值的不可变和排序的映射)。</p><p>多个线程可以在一个TableBuilder上调用const方法而不需要外部同步。但如果任何一个线程可能调用一个非常量方法，所有访问同一个TableBuilder的线程必须使用外部同步。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TableBuilder 提供了用于构建 Table 的接口</span></span><br><span class="line"><span class="comment">//（从键到值的不可变且排序的映射）。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 多个线程可以在 TableBuilder 上调用 const 方法，而无需</span></span><br><span class="line"><span class="comment">// 外部同步，但如果任何线程可能调用</span></span><br><span class="line"><span class="comment">// 非常量方法，所有访问同一个 TableBuilder 的线程都必须使用</span></span><br><span class="line"><span class="comment">// 外部同步。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LEVELDB_EXPORT</span> <span class="title">TableBuilder</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">TableBuilder(<span class="keyword">const</span> Options&amp; options, WritableFile* file);</span><br><span class="line"></span><br><span class="line">TableBuilder(<span class="keyword">const</span> TableBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">TableBuilder&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> TableBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">改变该构建器所使用的选项。注意：只有部分的</span></span><br><span class="line"><span class="comment">选项字段可以在构建后改变。如果一个字段是</span></span><br><span class="line"><span class="comment">不允许动态变化，并且其在结构中的值</span></span><br><span class="line"><span class="comment">中的值与传递给本方法的结构中的值不同。</span></span><br><span class="line"><span class="comment">结构中的值不同，该方法将返回一个错误</span></span><br><span class="line"><span class="comment">而不改变任何字段。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Status <span class="title">ChangeOptions</span><span class="params">(<span class="keyword">const</span> Options&amp; options)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Flush</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">status</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Finish</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">表示应该放弃这个建设者的内容。停止</span></span><br><span class="line"><span class="comment">在此函数返回后停止使用传递给构造函数的文件。</span></span><br><span class="line"><span class="comment">如果调用者不打算调用Finish()，它必须在销毁此构建器之前调用Abandon()</span></span><br><span class="line"><span class="comment">之前调用Abandon()。</span></span><br><span class="line"><span class="comment">需要。Finish()、Abandon()未被调用。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Abandon</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">NumEntries</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">FileSize</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ok</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> status().ok(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WriteBlock</span><span class="params">(BlockBuilder* block, BlockHandle* handle)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WriteRawBlock</span><span class="params">(<span class="keyword">const</span> Slice&amp; data, CompressionType, BlockHandle* handle)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rep</span>;</span></span><br><span class="line"></span><br><span class="line">Rep* rep_;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>小结</strong>：</p><p>SSTable 相关的设计在整个LevelDB中有着重要的地位和作用，我们介绍了SSTable的多层级合并和压缩的细节，以及两种不同的压缩形式，第一种是针对Level0的简单压缩，简单压缩只需要把存在于内存中的SSTable也就是将Imumemtable压缩到磁盘中存储，特别注意的是这个动作在第一次完成之后通常还会再执行一次，目的是为了防止合并之后产生的。</p><p>另一种是针对频繁Key查询进行的多层级压缩，多层级压缩要比简单压缩复杂许多，但是多层级压缩是提高整个LevelDB写入性能和查询性能到关键。</p><p>最后，从LevelDB中也可以看到很多经典数据结构和算法的实现，比键管理利用了跳表+归并排序的方式提高管理效率，排序的内容不仅利于查询，在存储的时候也有利于数据的顺序扫描。</p><h2 id="Skiplist跳表"><a href="#Skiplist跳表" class="headerlink" title="Skiplist跳表"></a>Skiplist跳表</h2><p>跳表不仅在LevelDb中使用，还在许多其他的中间件中存在实现，这一部分内容将会放到下一篇文章单独介绍。</p><p>压缩文件使用了归并排序的方式进行键合并，而内部的数据库除了归并排序之外还使用了比较关键的[[LSM-Tree - LevelDb Skiplist跳表]]来进行有序键值管理，在了解LevelDB跳表的细节之前，需要先了解跳表这个数据结构的基本概念。</p><p>[[LevelDb跳表实现]]</p><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>Bloom Filter是一种空间效率很高的随机数据结构，它利用位数组很简洁地表示一个集合，并能判断一个元素是否属于这个集合。Bloom Filter的这种高效是有一定代价的：在判断一个元素是否属于某个集合时，有可能会把不属于这个集合的元素误认为属于这个集合（false positive）。因此，Bloom Filter不适合那些“零错误”的应用场合。而在能容忍低错误率的应用场合下，Bloom Filter通过极少的错误换取了存储空间的极大节省。</p><p>leveldb中利用布隆过滤器判断指定的key值是否存在于sstable中，若过滤器表示不存在，则该key一定不存在，由此加快了查找的效率。</p><p>布隆过滤器在不同的开源组件中用的也比较多，所以这里同样放到了一篇单独文章讲解。</p><p>[[LSM-Tree - LevelDb布隆过滤器]]</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>LevelDB的设计还是很有意思的，关键是大部分的代码都有解释和介绍。</p><p>源代码内容很多，但是仔细分析的话不难分析，感谢看到最后。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sZXZlbGRiLWhhbmRib29rLnJlYWR0aGVkb2NzLmlvL3poL2xhdGVzdC9pbmRleC5odG1s" title="https://leveldb-handbook.readthedocs.io/zh/latest/index.html">leveldb-handbook<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kcmF2ZW5lc3MubWUvYmlndGFibGUtbGV2ZWxkYi8=" title="https://draveness.me/bigtable-leveldb/">bigtable-leveldb<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC85ZDgyOTY1NjI4MDY=" title="https://www.jianshu.com/p/9d8296562806">Skip List–跳表（全网最详细的跳表文章没有之一） - 简书 (jianshu.com)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppYW9tZW5nL2FydGljbGUvZGV0YWlscy8xNDk1NTAw" title="https://blog.csdn.net/jiaomeng/article/details/1495500"># Bloom Filter概念和原理<i class="fa fa-external-link"></i></span></li></ul><h1 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h1><ul><li><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDA0MTcyMDIwNQ==" title="https://segmentfault.com/a/1190000041720205">LSM-Tree - LevelDb了解和实现<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDA0MTY1MjAwMw==" title="https://segmentfault.com/a/1190000041652003">《数据密集型型系统设计》LSM-Tree VS BTree<i class="fa fa-external-link"></i></span></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      源码解析
    
    </summary>
    
    
      <category term="数据库-LevelDB" scheme="https://whitestore.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-LevelDB/"/>
    
    
      <category term="数据库" scheme="https://whitestore.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>LSM-Tree - LevelDb Skiplist跳表</title>
    <link href="https://whitestore.top/2022/05/21/level-skiplist/"/>
    <id>https://whitestore.top/2022/05/21/level-skiplist/</id>
    <published>2022-05-21T11:10:02.000Z</published>
    <updated>2022-09-08T02:18:34.395Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LSM-Tree-LevelDb-Skiplist跳表"><a href="#LSM-Tree-LevelDb-Skiplist跳表" class="headerlink" title="LSM-Tree - LevelDb Skiplist跳表"></a>LSM-Tree - LevelDb Skiplist跳表</h1><h1 id="跳表介绍"><a href="#跳表介绍" class="headerlink" title="跳表介绍"></a>跳表介绍</h1><p>跳表（SkipList）是由William Pugh提出的。他在论文<Skip lists: a probabilistic alternative to balanced trees>中详细地介绍了有关跳表结构、插入删除操作的细节。</p><blockquote><p>文档：Skiplist跳表原始论文 - pugh-skiplists-cacm1990.pdf<br>链接：<span class="exturl" data-url="aHR0cDovL25vdGUueW91ZGFvLmNvbS9ub3Rlc2hhcmU/aWQ9NjY3YWVkOTZmMDEyZWRjYWRhMDQ3YmFmNzVhYTE3NjkmYW1wO3N1Yj1CNDI3RTAwQzgxOEI0MjhBQkQzOEE4MTMxODBBRjlBOA==" title="http://note.youdao.com/noteshare?id=667aed96f012edcada047baf75aa1769&amp;sub=B427E00C818B428ABD38A813180AF9A8">http://note.youdao.com/noteshare?id=667aed96f012edcada047baf75aa1769&amp;sub=B427E00C818B428ABD38A813180AF9A8<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在线性的数据数据结构中我们经常可以想到数组和链表，数组是插入慢查询快，而链表是插入快，查询要稍微慢一些，而跳表主要是针对链表<strong>查询速度</strong>进行优化的一种数据结构，多层级的跳表实际上是对底层链表的索引，非常典型的空间换时间，把链表的查询时间尽量控制在O(logN)。</p><a id="more"></a><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>由于使用了类似索引点数据维护方式，所以新增和删除需要同时维护跳表结构，跳表利用概率平衡的方式简化新增和删除操作，和树操作利用左旋和右旋等操作维持数据平衡不同，跳表利用了类似猜硬币的方式抉择出在哪一层插入或者删除节点和更新索引。</p><p>从下面的abcde图中，我们可以看一下跳表的演进：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220519072104.png" alt=""></p><p>首先a是一个典型的链表结构，对于查询来说需要<code>O(n)</code>的时间，链表长度越长查询越慢。</p><p>b在a的基础上，每次隔2个节点加一个额外的指针，通过这样的操作，每次查询时间就减少了【n/2】+次数。</p><p>c、d、e继续按照这样的思路继续加额外指针，最终只留下从头到尾的一层指针结束。</p><p>但是可以看到如果按照统一的思路每一层这样加节点对于维护整个节点的效率十分低，我们将拥有额外指针的节点看作一个K层节点，按照图中整理可以看到对于1层的节点占了50%，2层为25%，3层为12.5%……如果插入新节点能按照这样的规律进行插入删除，那么效率提升就不会出现很大的性能影响。</p><p>维护辅助指针会带来更大的复杂度，索引在每一层的节点中都会指向当前层所在的下一个节点，也就是说每一层都是一个链表。</p><p><strong>时间复杂度如何计算的？</strong></p><p>推导公式如下：</p><p><code>n/2^k =&gt; n / 2^k = 2 =&gt; h = log2n -1 =&gt; O(logn)</code></p><p>k代表节点层数，h表示最高级</p><p>原始的链表有n个元素，则一级索引有n/2 个元素、二级索引有 n/4 个元素、k级索引就有 n/(2^k)个元素。最高级索引一般有2个元素（头指向尾），最高级索引指向2 = n/(2^h)，即 h =(log2)n-1，最高级的索引h为索引层高度+原数据高度，最终跳表高度为 h = (log2) n。</p><p>经过索引的优化之后，整个查询的时间复杂度可以近似看作<strong>O(logn)</strong> ，和 二分查找的效率类似。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220519075430.png" alt=""></p><p><strong>空间复杂度如何计算？</strong></p><p>随着层数的增加，建立索引的空间开销是越来越小的，一层索引为 n/2，二层索引为 n/4，三层为 n/8 …..最后 n/2 + n/4 + n/8 +…. + 2（最高层一般为2个节点）最后因为分母相加可以认为是近似 <strong>O(n)</strong> 的空间复杂度。</p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>下面是跳表的增删改查的处理流程，由于删除和插入都依赖查询，我们先从查询开始介绍：</p><p>查询的操作方式可以看下面的绘图，比如如果需要查找存在于中间的节点17，则会根据线条顺序查找，这里简述查询顺序：</p><ol><li>从索引的最高层进行查找，直接找到下一个节点。</li><li>如果当前内容大于节点内容，则直接找下一个节点比较。</li><li>如果当前节点等于查找节点则直接返回。</li><li>如果当前节点大于节点，并且下一个节点大于当前节点，并且层高不为0，则继续往层高更低的一个层级节点查找同时<strong>回到更低层级前一个节点</strong>，如果层高为0，则返回当前节点，当前节点的key要大于查找的key。</li></ol><p>查找比较好理解，就是用索引快速跨越多个链表节点减少搜索次数，然后层数下探找到相关的节点，注意拥有索引的节点，通常在上层节点会有指向下层的指针。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220519073220.png" alt=""></p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>插入操作比较关键，因为这里涉及到非常影响跳表性能的索引节点选举动作。按照之前的查找操作步骤，插入操作需要<strong>每次记录每一层的前任节点</strong>。</p><p><strong>关键点</strong>：插入的关键点在于选举那个节点增加层高来维持二分查找的效率，在找到位置之后，通常使用随机抛硬币的方式随机为节点增加层高，层级越高被选中的概率通常会指数倍的降低，之后根据三个参数：种子（用于实现概率随机）以及当前节点的层数和概率值P或者其他的随机值算法进行计算，但是为了防止单节点层高过高，通常会限制最终层高防止单一节点的层高超过上限。</p><blockquote><p>根据墨菲定律，无论单一节点层高过高可能性再低，都需要做限制。</p></blockquote><p>这里挑了LevelDB跳表数据结构的一段代码进行介绍：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func (p *DB) randHeight() (h <span class="keyword">int</span>) &#123;</span><br><span class="line"><span class="comment">// 限制跳表扩展的最高层级</span></span><br><span class="line">    <span class="keyword">const</span> branching = <span class="number">4</span></span><br><span class="line">    h = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> h &lt; tMaxHeight &amp;&amp; p.rnd.Int()%branching == <span class="number">0</span> &#123;</span><br><span class="line">        h++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入节点之后，会根据记录的前任节点在每一层的位置按照跳表规则建立新节点的索引。</p><p>跳表插入新节点本身的更新十分非常简单，只需要把<strong>当前节点下一个节点指向插入节点的下一个节点的下一个节点，插入节点的下一个节点指向当前节点</strong> 即可。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20220519075520.png" alt=""></p><p><strong>插入操作时间复杂度</strong></p><p>如果是单链表，那么一次遍历就可以完成，结果永远都是<strong>O(1)</strong>，对于跳表的插入，最坏的情况也就是需要在所有层都更新索引，这种情况是<strong>O(logN)</strong>。</p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除也是依赖查询完成的，根据查询找到待删除节点之后在每一层按照查询的规则把当前节点删除即可。</p><p>删除的时间复杂度快慢取决于于查询的层数，假设需要删除N个元素，而每一层其实都是一个单向的链表，单链表的查询是O(1)，同时是因为跳表最优是近似二分查找的效率，索引层数为logn，删除的层数也是logN，N取决于层级。</p><p>最终删除元素的总时间包含：</p><p>查找元素的时间 + _删除 logn个元素的时间 = <code>O(logn) + O(logn) = 2O(logn)</code>，忽略常数部分最终结果为 O(logn)。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>其实多数和Key-Value有关的LST-Tree 数据结构都有类似的跳表实现，因为链表在业务方面使用可能比较少，但是在数据结构和数据库设计上面却是至关重要的地位：</p><ul><li>HBase</li><li>Redis</li><li>LevelDB</li></ul><p><strong>小结</strong></p><ul><li>跳表让链表也能够完成二分查找的操作</li><li>元素的插入会根据抛硬币和权重分配随机选举Level</li><li>最底层永远是原始链表，而上层则是索引数据</li><li>索引节点通常会多一个指针指向下层节点，但是不是所有的程序设计都是按照这种方式，有其他的处理方式间接实现此功能（具体可以看redis 的 zset源代码）</li><li>跳表查询、插入、删除的时间复杂度为O(log n)，与平衡二叉树接近</li></ul><h1 id="LevelDb跳表实现"><a href="#LevelDb跳表实现" class="headerlink" title="LevelDb跳表实现"></a>LevelDb跳表实现</h1><p>在之前讨论合并压缩文件使用了归并排序的方式进行键合并，而内部的数据库除了归并排序之外还使用了比较关键的[[LSM-Tree - LevelDb Skiplist跳表]]来进行有序键值管理。</p><p>跳表在Redis和Kafka中都有实现，这里的Skiplist其实也是类似的，可以看作C++版本的跳表案例。</p><p>这部分就不看作者的文档了，我们直接源码开干。</p><h2 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h2><p>首先我们需要清楚LevelDB的跳表包含了什么东西？在代码的一开始定义了 <strong>Node</strong>节点用来表示链表节点，以及 <strong>Iterator</strong>迭代器的内容进行迭代，内部定义了<code>std::atomic&lt;Node*&gt; next_[1]</code> 长度等于节点高度的数组。 </p><p>next_[0]是最底层的节点（用于跳表跨层获取数据），核心是作者自认为写的一般的Random 随机器（通过位操作生成随机的一个位号码）。</p><p>LevelDB的整个实现比较简洁规范，在设计上定义了很多函数来简化复杂代码的增加，建议看不懂就多看几遍跳表的理论。</p><h2 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h2><p>#levelDB插入操作 #levelDB查询操作</p><p>在了解过[[LSM-Tree - LevelDb Skiplist跳表]]之后，我们发现对于跳表这种数据结构来说，核心部分在于查询和插入两个部分，当然查询是理解插入点前提，但是对于插入抛硬币选举的实现有必要深究一下。</p><h2 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h2><p>查询操作比较好理解，和跳表的数据结构规定差不多，和[[LSM-Tree - LevelDb Skiplist跳表]]的实现类似：</p><p>可以发现和跳表原始的实现方式如出一辙，这里相当于复读理论的内容：</p><ol><li>从索引的最高层进行查找，直接找到下一个节点。</li><li>如果当前内容大于节点内容，则直接找下一个节点比较。</li><li>如果当前节点等于查找节点则直接返回。</li><li>如果当前节点大于节点，并且下一个节点大于当前节点，并且层高不为0，则继续往层高更低的一个层级节点查找同时<strong>回到更低层级前一个节点</strong>，如果层高为0，则返回当前节点，当前节点的key要大于查找的key。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回层级最前的节点，该节点位于键的位置或之后。如果没有这样的节点，返回nullptr。如果prev不是空的，则在[0...max_height_1]中的每一级，将prev[level]的指针填充到前一个 节点的指针来填充[0...max_height_1]中的每一级的 "level"。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">SkipList</span>&lt;Key, Comparator&gt;:</span>:Node*</span><br><span class="line"></span><br><span class="line">SkipList&lt;Key, Comparator&gt;::FindGreaterOrEqual(<span class="keyword">const</span> Key&amp; key,</span><br><span class="line"></span><br><span class="line">Node** prev) <span class="keyword">const</span> &#123;</span><br><span class="line"></span><br><span class="line">Node* x = head_;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 防止无限for循环</span></span><br><span class="line"><span class="keyword">int</span> level = GetMaxHeight() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">Node* next = x-&gt;Next(level);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (KeyIsAfterNode(key, next)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果当前节点在层级之后，则查找下一个链表节点</span></span><br><span class="line"></span><br><span class="line">x = next;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (prev != <span class="literal">nullptr</span>) prev[level] = x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> next;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 层级下沉</span></span><br><span class="line"></span><br><span class="line">level--;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><p>插入操作的代码如下，注意跳表需要在插入之前对于节点进行加锁的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">SkipList</span>&lt;Key, Comparator&gt;:</span>:Insert(<span class="keyword">const</span> Key&amp; key) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为前置节点最多有kMaxHeight层，所以直接使用kMaxHeight 简单粗暴</span></span><br><span class="line">Node* prev[kMaxHeight];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回层级最前的节点，该节点位于键的位置或之后。如果没有这样的节点，返回nullptr。如果prev不是空的，则在[0...max_height_1]中的每一级，将prev[level]的指针填充到前一个 节点的指针来填充[0...max_height_1]中的每一级的 "level"。</span></span><br><span class="line">Node* x = FindGreaterOrEqual(key, prev);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不允许进行重复插入操作（同步加锁）</span></span><br><span class="line">assert(x == <span class="literal">nullptr</span> || !Equal(key, x-&gt;key));</span><br><span class="line"></span><br><span class="line"><span class="comment">// **新增层级选举**，使用随机函数和最高层级限制，按照类似抛硬币的规则选择是否新增层级。</span></span><br><span class="line"><span class="comment">// 随机获取一个 level 值</span></span><br><span class="line"><span class="keyword">int</span> height = RandomHeight();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前随机level是否大于 当前点跳表层数</span></span><br><span class="line"><span class="keyword">if</span> (height &gt; GetMaxHeight()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头指针下探到最低层</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = GetMaxHeight(); i &lt; height; i++) &#123;</span><br><span class="line">prev[i] = head_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这部分建议多读读原注释。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">机器翻译：在没有任何同步的情况下突变max_height_是可以的。与并发读取器之间没有任何同步。一个并发的读者在观察到的新值的并发读者将看到max_height_的旧值。的新水平指针（nullptr），或者在下面的循环中设置一个新的值。下面的循环中设置的新值。在前一种情况下，读者将立即下降到下一个级别，因为nullptr会在所有的键之后。在后一种情况下，读取器将使用新的节点</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">理解：意思是说这一步不需要并发加锁，这是因为并发读读取到更新的跳表层数，哪怕现在这个节点没有插入，也会返回nullptr，在leveldb的比较器当中的nullpt会在最前面，默认看作比所有的key都要大，所以会往下继续找，这样就可以保证写入和读取都是符合预期的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">max_height_.store(height, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增跳表节点</span></span><br><span class="line">x = NewNode(key, height);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123;</span><br><span class="line"><span class="comment">// NoBarrier_SetNext()就够了，因为当我们在prev[i]中发布一个指针 "x "时，我们会添加一个障碍。我们在prev[i]中发布一个指向 "x "的指针。</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 更新指针引用</span></span><br><span class="line"><span class="comment">// 为了保证并发读的准确性，需要先设置节点指针然后再设置原始表的prev 指针</span></span><br><span class="line">x-&gt;NoBarrier_SetNext(i, prev[i]-&gt;NoBarrier_Next(i));</span><br><span class="line"><span class="comment">// 内部会强制进行同步</span></span><br><span class="line">prev[i]-&gt;SetNext(i, x);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跳表实现的难点在于层数的确定，而LevelDB的难点在于<strong>插入节点如何保证并发写入的时候能够正确的并发读</strong>。</p><p><strong>RandomHeight() 新增层级选举</strong>：</p><p>在LevelDb中层级选举的核心的代码是：<code>height &lt; kMaxHeight &amp;&amp; rnd_.OneIn(kBranching)</code>，内部在控制跳表层数最多不超过<code>kMaxHeight</code>层的情况下，对于4取余的操作实现<strong>构造 P = 3/4 的几何分布</strong>，最终判断是否新增层数。</p><blockquote><p>原始情况下跳表增加1层为 1/2，2层为1/4，3层为1/8，4层为1/16。LevelDB的11层最高层限制key的数量，但是11层的节点概率通常会非常非常小。<br>最终LevelDB选择的结果是3/4 的节点为 1 层节点，3/16 的节点为 2 层节点，3/64 的节点为 3 层节点，依此类推。</p></blockquote><p>层级选举的特点：</p><ol><li>插入新节点的指针数通过独立计算一个概率值决定，使全局节点的指针数满足几何分布即可。</li><li>插入时不需要做额外的节点调整，只需要先找到其需要放的位置，然后修改他和前驱的指向即可。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">SkipList</span>&lt;Key, Comparator&gt;:</span>:RandomHeight() &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在kBranching中以1的概率增加高度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> kBranching = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> height = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// rnd_.OneIn(kBranching):"1/n "的时间会返回真没其他情况会返回假</span></span><br><span class="line"><span class="comment">// 相当于层数会按照4 的倍数减小， 4层是3层的4分之一，简单理解为 每次加一层概率就要乘一个 1/4。</span></span><br><span class="line"><span class="keyword">while</span> (height &lt; kMaxHeight &amp;&amp; rnd_.OneIn(kBranching)) &#123;</span><br><span class="line"></span><br><span class="line">height++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">assert(height &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">assert(height &lt;= kMaxHeight);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> height;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看到概率P使用了1/4计算方式，使用1/4的好处是让层数更为分散，典型的时间换空间的操作，虽然会牺牲一部分空间，但是获得更高的性能，<strong>在此情况下，可以最多支持 n = (1/p)^kMaxHeight 个节点的情况</strong>。</p><blockquote><p>对于LevelDB这种写快过读的业务，效率是最优考虑。</p></blockquote><p>12层高的节点最多可以存储多少数据？那么可以直接使用4^12 计算约等于 <strong>16M</strong>。当然12层的概率微乎其微。</p><h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><p>LevelDB跳表是没有删除这个概念的，相对应的更新也是针对next指针的变动。</p><ol><li>除非跳表被销毁，跳表节点<strong>只会增加而不会被删除</strong>，因为跳表<strong>根本不对外提供删除接口</strong>。</li><li>被插入到跳表中的节点，除了 next 指针其他域都是不可变的，并且只有插入操作会改变跳表。（以此来替代更新）</li></ol><h2 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h2><p>之前的[[LSM-Tree - LevelDb 源码解析]] 分析解释过整个跳表的遍历通过<code>Iterator</code>完成，内部使用了归并排序对于key进行排序，同时<code>null ptr</code>作为特殊值永远排在最前面。</p><p>LevelDB自带的迭代器实现较为丰富，除开迭代器经典的<code>remove()</code>，<code>next()</code>、<code>haseNext()</code>之外，还有<code>Seek</code>，<code>SeekToFirst</code>，<code>SeekToLast</code>、以及<code>Prev</code>向前遍历的操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Advances to the next position.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// REQUIRES: Valid()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Advances to the previous position.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// REQUIRES: Valid()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prev</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Advance to the first entry with a key &gt;= target</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">const</span> Key&amp; target)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Position at the first entry in list.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Final state of iterator is Valid() iff list is not empty.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeekToFirst</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Position at the last entry in list.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Final state of iterator is Valid() iff list is not empty.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeekToLast</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>这里需要特意强调的是向前遍历这个操作<strong>并不是通过增加prev指针反向迭代</strong>的，而是<strong>从head开始查找</strong>，也是时间换空间。</p><p>最后有两个比较频繁的使用操作<code>FindLast</code>和<code>FindLessThan</code>，注释写的简单明了，就不多介绍了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return the latest node with a key &lt; key.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Return head_ if there is no such node.</span></span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">FindLessThan</span><span class="params">(<span class="keyword">const</span> Key&amp; key)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">// Return the last node in the list.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Return head_ if list is empty.</span></span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">FindLast</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>LevelDB的跳表设计难点主要体现在并发读写的维持以及节点的层级选举上面，这一部分是和原始的跳表差别比较大的地方，而其他地方基本可以看作原始跳表的理论设计的，所以把 LevelDB 作为跳表的模板代码学习也是十分推荐的。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC85ZDgyOTY1NjI4MDY=" title="https://www.jianshu.com/p/9d8296562806">Skip List–跳表（全网最详细的跳表文章没有之一） - 简书 (jianshu.com)<i class="fa fa-external-link"></i></span></p><p>跳表数据结构的实现，JAVA版本的链表可以看下面的代码：<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dhbmd6aGVuZzA4MjIvYWxnby9ibG9iL21hc3Rlci9qYXZhLzE3X3NraXBsaXN0L1NraXBMaXN0LmphdmE=" title="https://github.com/wangzheng0822/algo/blob/master/java/17_skiplist/SkipList.java">algo/SkipList.java at master · wangzheng0822/algo · GitHub<i class="fa fa-external-link"></i></span></p><h1 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h1><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDA0MTY1MjAwMw==" title="https://segmentfault.com/a/1190000041652003">[《数据密集型型系统设计》LSM-Tree VS BTree]<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDA0MTcyMDIwNQ==" title="https://segmentfault.com/a/1190000041720205">[LSM-Tree - LevelDb了解和实现]<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDA0MTg2NDU3OQ==" title="https://segmentfault.com/a/1190000041864579">[LSM-Tree - LevelDb 源码解析]<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDA0MTg2OTU4Ng==" title="https://segmentfault.com/a/1190000041869586">[LSM-Tree - LevelDb Skiplist跳表]<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDA0MTg3MzQwMA==" title="https://segmentfault.com/a/1190000041873400">[LSM-Tree - LevelDb 布隆过滤器]<i class="fa fa-external-link"></i></span></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      Skiplist跳表
    
    </summary>
    
    
      <category term="数据库-LevelDB" scheme="https://whitestore.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-LevelDB/"/>
    
    
      <category term="数据库" scheme="https://whitestore.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>LSM-Tree - LevelDb 布隆过滤器</title>
    <link href="https://whitestore.top/2022/05/21/leveled-bloom/"/>
    <id>https://whitestore.top/2022/05/21/leveled-bloom/</id>
    <published>2022-05-21T11:07:44.000Z</published>
    <updated>2022-06-02T10:09:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LSM-Tree-LevelDb布隆过滤器"><a href="#LSM-Tree-LevelDb布隆过滤器" class="headerlink" title="LSM-Tree - LevelDb布隆过滤器"></a>LSM-Tree - LevelDb布隆过滤器</h1><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>布隆过滤器有点类似哈希表，但是比哈希表的效率要更高，因为使用了位来判断Key是否存在，布隆过滤器在完成高效搜索key是否存在的同时带来一定的副作用– <strong>不保证Key一定存在</strong>，所以它只适用于允许一定容错率的系统。</p><p>一句话概括：<code>Bloom Filter</code> 是一个<strong>基于概率的数据结构</strong>，它只能告诉我们一个元素绝对不在集合内或<strong>可能</strong>在集合内。</p><p>布隆过滤器比较悬浮的东西是它不保证元素百分百在一个集合内，所以适用于具备一定容错的业务，关于它的理论和实践很多内容都是参考或者直接摘自网上的资料加上自己的理解，如有错误欢迎指正。</p><a id="more"></a><h1 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h1><p>理论基础相关文章都大同小异，这里归纳自这一篇大神写的文章：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppYW9tZW5nL2FydGljbGUvZGV0YWlscy8xNDk1NTAw" title="https://blog.csdn.net/jiaomeng/article/details/1495500">Bloom Filter概念和原理_jiaomeng的博客-CSDN博客_bloomfilter<i class="fa fa-external-link"></i></span>，简洁易懂，另外建议多参考原始论文，这里很多内容其实也是归纳自老外早已写出来的论文。</p><p>在这个网址中可以通过JS代码查看实际的运行效果：<br><span class="exturl" data-url="aHR0cHM6Ly9sbGltbGxpYi5naXRodWIuaW8vYmxvb21maWx0ZXItdHV0b3JpYWwvemhfQ04v" title="https://llimllib.github.io/bloomfilter-tutorial/zh_CN/">Bloom Filters by Example (llimllib.github.io)<i class="fa fa-external-link"></i></span></p><blockquote><p>注意在案例中使用了<code>Fnv</code>和 <code>Murmur</code> 这两个简单的哈希函数。</p></blockquote><p>对于一个布隆过滤器，通常有如下定义：</p><ol><li>n 个 key。</li><li>m bits 的空间 v，全部初始化为0。</li></ol><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205031233283.png" alt=""></p><ol start="3"><li><p>Bloom Filter 理论建议使用k个相互独立的哈希函数（Hash Function），用于表示<code>S={x1, x2,…,xn}</code>的n个元素的集合，对任意一个元素x，第 i 个哈希函数映射的位置hi(x) 就会被置为1（1≤i≤k）。</p><p> 如果有多个哈希函数位置都为1，那么只有 <strong>第一个哈希结果被使用</strong>。比如下面的图中从左往右数第二个“1”所在的位置就是最终哈希函数选中位置。</p></li></ol><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205031235855.png" alt=""></p><ol start="4"><li><p>为了判断当前的元素是否在集合当中，需要对于当前的元素y进行k次的哈希函数，如果所有的hi(y)次数是1（i &lt;= i &lt;= k中的次数都是1）就认为当前的元素y<strong>可能</strong>在集合中，否则就绝对不存在。</p><p> 以下面的内容y1因为存在hash为0的结果，所以认为不存在于集合，而y2所有的hash都落在1上，可以认为<strong>可能</strong>存在集合。</p></li></ol><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205031927973.png" alt=""></p><p>布隆过滤器的理论内容相对简单，关键部分是哈希函数的选择和错误率的平衡。</p><p><strong>错误率计算</strong></p><p>首先布隆过滤器需要注意bit位长度，也就是数组长度。通常一个大的布隆过滤器会比小的布隆过滤器有更小的错误率。</p><p>误判率的计算公式为：<code>(1-e^(-kn/m))^k</code>。</p><p>推导过程如下，过程不是特别重要，了解最终公式即可：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205032059650.png" alt=""></p><blockquote><p>n为key的个数，m为bits的位数（也就是数组大小）</p></blockquote><p>根据这个公式可以发现，需要先确定可能插入的数据集的容量大小 <em>n</em>, 然后再调整 k 和 <em>m</em> 来为你的应用配置过滤器，m 越大，k 越大， n 越小，那么误判率越小。</p><p>考虑到 p 为设置为0的概率，因此可以认为 m 有一半设置为1，一半设置为0时，误判率最低，注意这句话在最后的推导部分会详细介绍。</p><p><strong>多少个哈希函数？</strong></p><p>根据错误率计算结论，这里又有一个问题，就是究竟应该选择多少个哈希函数，哈希函数的过多容易导致计算效率降低影响性能，太少又会让误判率升高。</p><p>高兴的是，这个公式也有人推导出来了：</p><p><strong>hash 函数 k 的最优个数为 ln2 * (m/n)</strong>。</p><p>可以通过以下的步骤来确定 Bloom filter 的大小:</p><ol><li>确定 <em>n</em> 的变动范围</li><li>选定 <em>m</em> 的值</li><li>计算 <em>k</em> 的最优值</li><li>对于给定的n, <em>m</em>,  k计算错误率。如果这个错误率不能接受，那么回到第二步，否则结束</li></ol><p><strong>Bloom filter 的时间复杂度和空间复杂度?</strong></p><p>插入和测试操作的时间复杂度都是 O(k)，这是因为如果想要插入或者查询一个元素，只需要对于元素进行k次数的函数运算。</p><p>空间复杂度就比较难以估算了，因为误差率的存在，大小是难以确定的，如果难以估算一个过滤器的大小，最好选择一个哈希表或者一个可拓展的 Bloom filter。</p><blockquote><p>注意⚠️：LevelDB的过滤器大小是不能少于64位的bit数组。</p></blockquote><p><strong>m中多少位数为1合适</strong></p><p>直接记住结论：<strong>可以认为 m 有一半设置为1，一半设置为0时，误判率最低</strong>。</p><h1 id="levelDB实现"><a href="#levelDB实现" class="headerlink" title="levelDB实现"></a>levelDB实现</h1><p>LevelDB的布隆过滤器精髓在哈希函数上，它通过一个哈希达到多个哈希的性能，同时保证误判率在一定的限制。</p><p>具体的代码实现可以阅读<strong>bloom.cc</strong>：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9sZXZlbGRiL2Jsb2IvbWFpbi91dGlsL2Jsb29tX3Rlc3QuY2M=" title="https://github.com/google/leveldb/blob/main/util/bloom_test.cc">leveldb/bloom_test.cc at main · google/leveldb · GitHub<i class="fa fa-external-link"></i></span></p><h2 id="index-md介绍"><a href="#index-md介绍" class="headerlink" title="index.md介绍"></a>index.md介绍</h2><p>这里先不深入源代码，先看看作者在<code>index.md</code>是如何解释的：<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9sZXZlbGRiL2Jsb2IvbWFpbi9kb2MvaW5kZXgubWQjZmlsdGVycw==" title="https://github.com/google/leveldb/blob/main/doc/index.md#filters">leveldb/index.md at main · google/leveldb · GitHub<i class="fa fa-external-link"></i></span></p><p>由于leveldb数据在磁盘上的组织方式，一个<code>Get()</code>的调用可能涉及到从磁盘上多次读取，所以可选的<code>FilterPolicy</code>机制可以被用来可以用来大大减少磁盘读取的次数，其实这里就是指的使用布隆过滤器提高过滤效率。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">leveldb::Options options;</span><br><span class="line"></span><br><span class="line">options.filter_policy = NewBloomFilterPolicy(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">leveldb::DB* db;</span><br><span class="line"></span><br><span class="line">leveldb::DB::Open(options, <span class="string">"/tmp/testdb"</span>, &amp;db);</span><br><span class="line"></span><br><span class="line">... use the database ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> db;</span><br><span class="line"><span class="comment">// 注意，关闭leveldb的时候需要手动释放过滤器所占用内存空间</span></span><br><span class="line"><span class="keyword">delete</span> options.filter_policy;</span><br></pre></td></tr></table></figure><p>前面的代码将基于布隆过滤器的过滤策略与数据库联系起来。 </p><p>基于布隆过滤器的过滤依赖于在内存中为每个密钥保留一定数量的数据（本例中每个密钥为10bits，因为这是我们传递给<code>NewBloomFilterPolicy</code>的参数）。</p><p>这个过滤器将减少<code>Get()</code>调用所需的不必要的磁盘IO次数，提升效率大约是<strong>100倍</strong>。增加每一个key的位数将导致更大的减少，但<strong>代价占用是更多的内存</strong>。我们建议那些工作集不适合放在内存中的应用程序不适合在内存中使用，并且进行大量随机读取的应用程序设置一个过滤策略。</p><h2 id="FilterPolicy"><a href="#FilterPolicy" class="headerlink" title="FilterPolicy"></a>FilterPolicy</h2><p>整个过滤器通过对外的接口<code>FilterPolicy</code>，目的是减少<code>DB::Get()</code>函数调用时间，通常内部默认使用布隆过滤器。</p><p>下面是接口定义的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Slice</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LEVELDB_EXPORT</span> <span class="title">FilterPolicy</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> ~FilterPolicy();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return the name of this policy. Note that if the filter encoding</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// changes in an incompatible way, the name returned by this method</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// must be changed. Otherwise, old incompatible filters may be</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// passed to methods of this type.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回该策略的名称。注意如果过滤器的编码变化，此方法返回的名称必须被改变。否则不兼容旧的过滤器可能被传递给这种类型的方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">Name</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// keys[0,n-1] contains a list of keys (potentially with duplicates)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// that are ordered according to the user supplied comparator.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Append a filter that summarizes keys[0,n-1] to *dst.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Warning: do not change the initial contents of *dst. Instead,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// append the newly constructed filter to *dst.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* keys[0,n-1] 包含一个键的列表（可能有重复的）。根据用户提供的比较器进行排序。将一个总结keys[0,n-1]的过滤器追加到*dst。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 警告：不要改变*dst的初始内容。 相反将新构建的过滤器追加到*dst中。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">CreateFilter</span><span class="params">(<span class="keyword">const</span> Slice* keys, <span class="keyword">int</span> n,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="built_in">std</span>::<span class="built_in">string</span>* dst)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// "filter" contains the data appended by a preceding call to</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CreateFilter() on this class. This method must return true if</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the key was in the list of keys passed to CreateFilter().</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This method may return true or false if the key was not on the</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// list, but it should aim to return false with a high probability.</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> "filter "包含了前面对这个类的CreateFilter()的调用所附加的数据。如果键在传递给CreateFilter()的键列表中，该方法必须返回true。如果键不在列表中，该方法可能会返回true或false，但它应该以返回false的概率大为目标。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">KeyMayMatch</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; filter)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这一部分注释较多，放到后文介绍</span></span><br><span class="line"></span><br><span class="line"><span class="function">LEVELDB_EXPORT <span class="keyword">const</span> FilterPolicy* <span class="title">NewBloomFilterPolicy</span><span class="params">(<span class="keyword">int</span> bits_per_key)</span></span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace leveldb</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// STORAGE_LEVELDB_INCLUDE_FILTER_POLICY_H_</span></span></span><br></pre></td></tr></table></figure><h2 id="bloom-cc"><a href="#bloom-cc" class="headerlink" title="bloom.cc"></a>bloom.cc</h2><p>关于具体的代码解释放在了注释当中，比较值得关注的是创建过滤器的部分以及哈希函数的部分，这部分介绍的是过滤器本身的源代码，关键的哈希函数放到了下面的小节。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright (c) 2012 The LevelDB Authors. All rights reserved.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style license that can be</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// found in the LICENSE file. See the AUTHORS file for names of contributors.</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"leveldb/filter_policy.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"leveldb/Slice.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"util/hash.h"</span></span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint32_t</span> <span class="title">BloomHash</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 注意 0xbc9f1d34</span></span><br><span class="line"><span class="keyword">return</span> Hash(key.data(), key.size(), <span class="number">0xbc9f1d34</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BloomFilterPolicy</span> :</span> <span class="keyword">public</span> FilterPolicy &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">BloomFilterPolicy</span><span class="params">(<span class="keyword">int</span> bits_per_key)</span> : <span class="title">bits_per_key_</span><span class="params">(bits_per_key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We intentionally round down to reduce probing cost a little bit</span></span><br><span class="line"><span class="comment">// 我们有意四舍五入，以减少一点探测成本</span></span><br><span class="line">k_ = <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(bits_per_key * <span class="number">0.69</span>); <span class="comment">// 0.69 =~ ln(2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (k_ &lt; <span class="number">1</span>) k_ = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (k_ &gt; <span class="number">30</span>) k_ = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">Name</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">"leveldb.BuiltinBloomFilter2"</span>; &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateFilter</span><span class="params">(<span class="keyword">const</span> Slice* keys, <span class="keyword">int</span> n, <span class="built_in">std</span>::<span class="built_in">string</span>* dst)</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compute bloom filter size (in both bits and bytes)</span></span><br><span class="line"><span class="comment">// 计算布过滤器的大小（包括比特和字节）。</span></span><br><span class="line"><span class="keyword">size_t</span> bits = n * bits_per_key_;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// For small n, we can see a very high false positive rate. Fix it</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// by enforcing a minimum bloom filter length.</span></span><br><span class="line"><span class="comment">// 对于小的n，我们可以看到一个非常高的误判率。通过强制执行最小Bloom filter长度来解决这个问题。</span></span><br><span class="line"><span class="comment">// tip: 这里就是之前说的如果bit位数过小会增加误判率</span></span><br><span class="line"><span class="keyword">if</span> (bits &lt; <span class="number">64</span>) bits = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> bytes = (bits + <span class="number">7</span>) / <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 至少有64个bits</span></span><br><span class="line">bits = bytes * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> init_size = dst-&gt;size();</span><br><span class="line"><span class="comment">// 调整容器的大小，使其包含_n个_元素。</span></span><br><span class="line">dst-&gt;resize(init_size + bytes, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">dst-&gt;push_back(<span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(k_)); <span class="comment">// Remember # of probes in filter</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* <span class="built_in">array</span> = &amp;(*dst)[init_size];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use double-hashing to generate a sequence of hash values.</span></span><br><span class="line"><span class="comment">// See analysis in [Kirsch,Mitzenmacher 2006].</span></span><br><span class="line"><span class="comment">// 使用双重哈希法生成一连串的哈希值。见[Kirsch,Mitzenmacher 2006]中的分析。</span></span><br><span class="line"><span class="comment">// tips: 原始论文请看参考资料 -&gt; LNCS 4168 - Less Hashing, Same Performance: Building a Better Bloom Filter (harvard.edu)</span></span><br><span class="line"><span class="keyword">uint32_t</span> h = BloomHash(keys[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> delta = (h &gt;&gt; <span class="number">17</span>) | (h &lt;&lt; <span class="number">15</span>); <span class="comment">// // 向右旋转17位</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; k_; j++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> bitpos = h % bits;</span><br><span class="line"></span><br><span class="line"><span class="built_in">array</span>[bitpos / <span class="number">8</span>] |= (<span class="number">1</span> &lt;&lt; (bitpos % <span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">h += delta;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">关键函数：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">KeyMayMatch</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; bloom_filter)</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> len = bloom_filter.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有1位的过滤器无意义</span></span><br><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="built_in">array</span> = bloom_filter.data();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> bits = (len - <span class="number">1</span>) * <span class="number">8</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// Use the encoded k so that we can read filters generated by</span></span><br><span class="line"><span class="comment">// bloom filters created using different parameters.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用编码的k，这样我们就可以读取由 使用不同参数创建的bloom过滤器。</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> k = <span class="built_in">array</span>[len - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (k &gt; <span class="number">30</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 超过我们设定 k 个数，直接返回 true，不滤掉该 SSTable.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Reserved for potentially new encodings for short bloom filters.</span></span><br><span class="line"><span class="comment">// Consider it a match.</span></span><br><span class="line"><span class="comment">// 保留给可能出现的新编码的短Bloom过滤器。认为它是一种匹配。</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键：哈希函数</span></span><br><span class="line"><span class="keyword">uint32_t</span> h = BloomHash(key);</span><br><span class="line"><span class="comment">// 右旋17位</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> delta = (h &gt;&gt; <span class="number">17</span>) | (h &lt;&lt; <span class="number">15</span>); <span class="comment">// Rotate right 17 bits</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> bitpos = h % bits;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">array</span>[bitpos / <span class="number">8</span>] &amp; (<span class="number">1</span> &lt;&lt; (bitpos % <span class="number">8</span>))) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">h += delta;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> bits_per_key_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> k_;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 新的布隆过滤器策略（请看下文注释）</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> FilterPolicy* <span class="title">NewBloomFilterPolicy</span><span class="params">(<span class="keyword">int</span> bits_per_key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> BloomFilterPolicy(bits_per_key);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace leveldb</span></span><br></pre></td></tr></table></figure><p><strong>NewBloomFilterPolicy</strong>函数</p><p>为什么叫做新的布隆过滤器策略，可以看作者所给的注释：</p><blockquote><p>返回一个新的过滤策略，该策略使用一个Bloom过滤器，每个密钥大约有指定的每个密钥的比特数。键的比特数是10。<br>最终测试最佳值是10，这将产生一个误报率为1%的过滤器。</p></blockquote><p>注意使用之后必须要<strong>手动</strong>释放掉相关对象内存：</p><blockquote><p>调用者必须在使用该结果的<strong>任何数据库关闭后删除该结果</strong>，数据库被关闭后，调用者必须删除该结果。</p></blockquote><p>如果使用的是自定义的比较器，它忽略了被比较的键的某些部分以及被比较的键的某些部分，这时候不允许使用<code>NewBloomFilterPolicy()</code>，而必须提供自定义的<code>FilterPolicy</code>实现，因为原始的过滤器它也忽略了键的相应部分。</p><p>例如，如果<strong>比较器忽略了尾部的空格</strong>，那么使用一个的<code>FilterPolicy</code>（比如<code>NewBloomFilterPolicy</code>），原始对<code>FilterPolicy（如NewBloomFilterPolicy）</code>行为就会出现失误，因为它<strong>不会忽略键的尾部空格</strong>。</p><h2 id="hash-cc"><a href="#hash-cc" class="headerlink" title="hash.cc"></a>hash.cc</h2><p>之前说过关键的代码其中之一是优质的哈希函数，下面是<code>hash.cc</code>的相关代码：</p><p>注意这里的哈希函数使用的伪随机数种子为<code>0xbc9f1d34</code>，对应的10进制为<code>9134</code>。</p><p>这里也可以看到LevelDB利用自己的优质哈希函数，使得一个函数取代N个函数的效果，这算是对理论的调整，内部也控制levelDB长度最少为64个bit位。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">data：bit 位数</span></span><br><span class="line"><span class="comment">n：n 个 key</span></span><br><span class="line"><span class="comment">seed：种子，实际固定为 0xbc9f1d34</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">Hash</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* data, <span class="keyword">size_t</span> n, <span class="keyword">uint32_t</span> seed)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Similar to murmur hash</span></span><br><span class="line"><span class="comment">// 类似杂音哈希</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> m = <span class="number">0xc6a4a793</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> r = <span class="number">24</span>;</span><br><span class="line"><span class="comment">// limit指向了char*数组的最后一个位置的下一个位置，类似于迭代器end()</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* limit = data + n;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">uint32_t</span> h = seed ^ (n * m);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pick up four bytes at a time</span></span><br><span class="line"><span class="comment">// 以4个字节作为一次解析</span></span><br><span class="line"><span class="keyword">while</span> (data + <span class="number">4</span> &lt;= limit) &#123;</span><br><span class="line"><span class="comment">//  每次解码前4个字节，直到最后剩下小于4个字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DecodeFixed32 低级别的Get...版本，直接从字符缓冲区读取 而不进行任何边界检查，最近的clang和gcc将其优化为一条 mov / ldr 指令。</span></span><br><span class="line"><span class="keyword">uint32_t</span> w = DecodeFixed32(data);</span><br><span class="line"></span><br><span class="line">data += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">h += w;</span><br><span class="line"></span><br><span class="line">h *= m;</span><br><span class="line"></span><br><span class="line">h ^= (h &gt;&gt; <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pick up remaining bytes</span></span><br><span class="line"><span class="comment">// 处理剩余的字节</span></span><br><span class="line"><span class="keyword">switch</span> (limit - data) &#123;</span><br><span class="line"><span class="comment">// 将剩下的字节转化到uint32_t里面</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="comment">// static_cast 表示的是良性转换，含义表示</span></span><br><span class="line">h += <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(data[<span class="number">2</span>]) &lt;&lt; <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FALLTHROUGH_INTENDED宏可以用来注解开关标签之间的隐性落差。真正的定义应该由外部提供。 这个是为不支持的编译器提供的后备版本。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#ifndef FALLTHROUGH_INTENDED</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#define FALLTHROUGH_INTENDED \</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">do &#123; \</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125; while (0)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">FALLTHROUGH_INTENDED;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">h += <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(data[<span class="number">1</span>]) &lt;&lt; <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">FALLTHROUGH_INTENDED;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">h += <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(data[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">h *= m;</span><br><span class="line"></span><br><span class="line">h ^= (h &gt;&gt; r);</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> h;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Slice-h"><a href="#Slice-h" class="headerlink" title="Slice.h"></a>Slice.h</h2><p>可以看作类似Redis的简单字符串sds设计，只不过语言使用的是c++。</p><p>相关解释可以阅读文档：</p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9sZXZlbGRiL2Jsb2IvbWFpbi9kb2MvaW5kZXgubWQjU2xpY2U=" title="https://github.com/google/leveldb/blob/main/doc/index.md#Slice">leveldb/index.md at main · google/leveldb · GitHub<i class="fa fa-external-link"></i></span></p><p>Slice 是一个简单的数据结构，包含一个进入一些外部存储的指针和size。 Slice的用户必须确保在相应的外部存储被取消分配后不使用该Slice（用完必须手动释放内存）。</p><p>多个线程可以在一个Slice上调用<strong>const方法</strong>而不需要外部同步（线程安全对象），但如果任何一个线程可能会调用非const方法，所有访问同一Slice的线程都必须使用外部同步。</p><p>C++ 或者类C的 字符串可以简单的转化为Slice：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">leveldb::Slice s1 = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">"world"</span>)</span></span>;</span><br><span class="line">leveldb::Slice s2 = str;</span><br></pre></td></tr></table></figure><p>反过来也是一样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str = s1.ToString();</span><br><span class="line">assert(str == <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"hello"</span>));</span><br></pre></td></tr></table></figure><p>在使用Slice时要小心因为要由调用者来确保Slice所指向的外部字节数组在Slice使用时保持有效。例如，下面的例子是错误的：</p><p>下面的例子中Slice将可能指向一个外部的引用，同时不保证外部引用存在。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">leveldb::Slice Slice;</span><br><span class="line"><span class="keyword">if</span> (...) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> str = ...;</span><br><span class="line">  Slice = str;</span><br><span class="line">&#125;</span><br><span class="line">Use(Slice);</span><br></pre></td></tr></table></figure><p>当if语句超出范围时，str将被销毁，Slice的存储内容将消失。</p><h1 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h1><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>作者编写的单元测试可以更为直观的看到具体效果，路径为：<code>/leveldb-main/util/bloom_test.cc</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright (c) 2012 The LevelDB Authors. All rights reserved.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style license that can be</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// found in the LICENSE file. See the AUTHORS file for names of contributors.</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"gtest/gtest.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"leveldb/filter_policy.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"util/coding.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"util/logging.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"util/testutil.h"</span></span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kVerbose = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Slice <span class="title">Key</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">char</span>* buffer)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">EncodeFixed32(buffer, i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Slice(buffer, <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BloomTest</span> :</span> <span class="keyword">public</span> testing::Test &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">BloomTest() : policy_(NewBloomFilterPolicy(<span class="number">10</span>)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">~BloomTest() &#123; <span class="keyword">delete</span> policy_; &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">keys_.clear();</span><br><span class="line"></span><br><span class="line">filter_.clear();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">const</span> Slice&amp; s)</span> </span>&#123; keys_.push_back(s.ToString()); &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Build</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Slice&gt; key_Slices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; keys_.size(); i++) &#123;</span><br><span class="line"></span><br><span class="line">key_Slices.push_back(Slice(keys_[i]));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter_.clear();</span><br><span class="line"></span><br><span class="line">policy_-&gt;CreateFilter(&amp;key_Slices[<span class="number">0</span>], <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(key_Slices.size()),</span><br><span class="line"></span><br><span class="line">&amp;filter_);</span><br><span class="line"></span><br><span class="line">keys_.clear();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (kVerbose &gt;= <span class="number">2</span>) DumpFilter();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">FilterSize</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> filter_.size(); &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DumpFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"F("</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; filter_.size(); i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> c = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(filter_[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%c"</span>, (c &amp; (<span class="number">1</span> &lt;&lt; j)) ? <span class="string">'1'</span> : <span class="string">'.'</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">")\n"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 匹配</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Matches</span><span class="params">(<span class="keyword">const</span> Slice&amp; s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!keys_.empty()) &#123;</span><br><span class="line"></span><br><span class="line">Build();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> policy_-&gt;KeyMayMatch(s, filter_);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">FalsePositiveRate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buffer[<span class="keyword">sizeof</span>(<span class="keyword">int</span>)];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Matches(Key(i + <span class="number">1000000000</span>, buffer))) &#123;</span><br><span class="line"></span><br><span class="line">result++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result / <span class="number">10000.0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> FilterPolicy* policy_;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> filter_;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; keys_;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">TEST_F(BloomTest, EmptyFilter) &#123;</span><br><span class="line"></span><br><span class="line">ASSERT_TRUE(!Matches(<span class="string">"hello"</span>));</span><br><span class="line"></span><br><span class="line">ASSERT_TRUE(!Matches(<span class="string">"world"</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">TEST_F(BloomTest, Small) &#123;</span><br><span class="line"></span><br><span class="line">Add(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">Add(<span class="string">"world"</span>);</span><br><span class="line"></span><br><span class="line">ASSERT_TRUE(Matches(<span class="string">"hello"</span>));</span><br><span class="line"></span><br><span class="line">ASSERT_TRUE(Matches(<span class="string">"world"</span>));</span><br><span class="line"></span><br><span class="line">ASSERT_TRUE(!Matches(<span class="string">"x"</span>));</span><br><span class="line"></span><br><span class="line">ASSERT_TRUE(!Matches(<span class="string">"foo"</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">NextLength</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (length &lt; <span class="number">10</span>) &#123;</span><br><span class="line"></span><br><span class="line">length += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (length &lt; <span class="number">100</span>) &#123;</span><br><span class="line"></span><br><span class="line">length += <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (length &lt; <span class="number">1000</span>) &#123;</span><br><span class="line"></span><br><span class="line">length += <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">length += <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> length;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">TEST_F(BloomTest, VaryingLengths) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buffer[<span class="keyword">sizeof</span>(<span class="keyword">int</span>)];</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// Count number of filters that significantly exceed the false positive rate</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mediocre_filters = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> good_filters = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> length = <span class="number">1</span>; length &lt;= <span class="number">10000</span>; length = NextLength(length)) &#123;</span><br><span class="line"></span><br><span class="line">Reset();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line"></span><br><span class="line">Add(Key(i, buffer));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Build();</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">ASSERT_LE(FilterSize(), <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;((length * <span class="number">10</span> / <span class="number">8</span>) + <span class="number">40</span>))</span><br><span class="line"></span><br><span class="line">&lt;&lt; length;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// All added keys must match</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line"></span><br><span class="line">ASSERT_TRUE(Matches(Key(i, buffer)))</span><br><span class="line"></span><br><span class="line">&lt;&lt; <span class="string">"Length "</span> &lt;&lt; length &lt;&lt; <span class="string">"; key "</span> &lt;&lt; i;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// Check false positive rate</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> rate = FalsePositiveRate();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (kVerbose &gt;= <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">"False positives: %5.2f%% @ length = %6d ; bytes = %6d\n"</span>,</span><br><span class="line"></span><br><span class="line">rate * <span class="number">100.0</span>, length, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(FilterSize()));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ASSERT_LE(rate, <span class="number">0.02</span>); <span class="comment">// Must not be over 2%</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rate &gt; <span class="number">0.0125</span>)</span><br><span class="line"></span><br><span class="line">mediocre_filters++; <span class="comment">// Allowed, but not too often</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">good_filters++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (kVerbose &gt;= <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Filters: %d good, %d mediocre\n"</span>, good_filters,</span><br><span class="line"></span><br><span class="line">mediocre_filters);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ASSERT_LE(mediocre_filters, good_filters / <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// Different bits-per-byte</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace leveldb</span></span><br></pre></td></tr></table></figure><h2 id="c-语法"><a href="#c-语法" class="headerlink" title="c++语法"></a>c++语法</h2><p>补充：<br>个人并没有学过C++，所以这部分补充一些不理解的关键字和语法含义。</p><p><strong>explicit</strong></p><p><span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzJTNBLy96aC5jcHByZWZlcmVuY2UuY29tL3cvY3BwL2xhbmd1YWdlL2V4cGxpY2l0" title="https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/language/explicit">C++ 参考手册<i class="fa fa-external-link"></i></span>如下解释：</p><ul><li><code>explicit</code>修饰的构造函数不能被隐式调用。</li><li>禁止类对象之间的隐式转换。</li></ul><p>这篇文章我们关注的就是第一点：<strong>构造函数被<code>explicit</code>修饰后, 就不能再被隐式调用了</strong>。</p><p>这里用了网上相关的案例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Explicit</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Explicit(<span class="keyword">int</span> <span class="built_in">size</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" the size is "</span> &lt;&lt; <span class="built_in">size</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Explicit(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> _str = str;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" the str is "</span> &lt;&lt; _str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Explicit(<span class="keyword">const</span> Explicit&amp; ins)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" The Explicit is ins"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Explicit(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" the a is "</span> &lt;&lt; a  &lt;&lt; <span class="string">" the b is "</span> &lt;&lt; b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Explicit <span class="title">test0</span><span class="params">(<span class="number">15</span>)</span></span>;</span><br><span class="line">    Explicit test1 = <span class="number">10</span>;<span class="comment">// 隐式调用Explicit(int size)</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Explicit <span class="title">test2</span><span class="params">(<span class="string">"RIGHTRIGHT"</span>)</span></span>;</span><br><span class="line">    Explicit test3 = <span class="string">"BUGBUGBUG"</span>;<span class="comment">// 隐式调用Explicit(const char* str)</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Explicit <span class="title">test4</span><span class="params">(<span class="number">1</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    Explicit test5 = test1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然程序没有错误，但是把一个<code>int</code>类型或者<code>const char*</code>类型的变量赋值给<code>Explicit</code>类型的变量看起来总归不是很好，并且一旦使用出错很难排查，所以这时候构造函数被<code>explicit</code>修饰后, 就不能再被隐式调用了，添加关键字之后的效果不演示了，加上之后整个程序是无法通过编译的。</p><p>吐槽：很神经病的东西，在过去的版本中使用隐式调用提高编码效率，结果后面发现坑太大挖坑自己填。</p><p><strong>resize函数</strong></p><p>直接看下面的案例更容易理解：</p><ul><li>myvector.resize(5);<br>将原来有10个数的vector数组，调整为5个数的长度，多余的数删掉，释放内存。 <strong>5 &lt; 10 减小数组长度</strong></li><li>myvector.resize(8,100);<br>将5个数长度的vector数组的长度调整为8，不够的数用100来填补，即增加了3个100。 <strong>8 &gt; 5 增大数组长度，指定填充元素</strong></li><li>myvector.resize(12);<br>将8个数长度的vector数组的长度调整为12，用0默认填补，即增加了4个0。 <strong>12 &gt; 8 增大数组长度，未指定填充元素</strong></li></ul><h2 id="数学推导"><a href="#数学推导" class="headerlink" title="数学推导"></a>数学推导</h2><p>推导部分给想要更加深入了解的人，可以直接记住上面的结论，看不懂也没关系。</p><p>下面的大部分内容来自论文根据 <span class="exturl" data-url="aHR0cDovL3d3dy5lZWNzLmhhcnZhcmQuZWR1L35taWNoYWVsbS9wb3N0c2NyaXB0cy9lc2EyMDA2YS5wZGY=" title="http://www.eecs.harvard.edu/~michaelm/postscripts/esa2006a.pdf">LNCS 4168 - Less Hashing, Same Performance: Building a Better Bloom Filter (harvard.edu)<i class="fa fa-external-link"></i></span> 翻译。</p><blockquote><p> <code>false position</code>：误判率，也就是随着哈希和为1的bit位增加导致的误判率上升。</p></blockquote><p>根据 bloom filter 的组成，对一个指定的 bit，其被设置为0、1的概率分别为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P(<span class="number">1</span>) = <span class="number">1</span>/m</span><br><span class="line">P(<span class="number">0</span>) = <span class="number">1</span> - <span class="number">1</span>/m</span><br></pre></td></tr></table></figure><p>k 个 hash 函数，该 bit 设置为 0 的概率为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P<span class="number">'</span>(<span class="number">0</span>) = P(<span class="number">0</span>) ** k = (<span class="number">1</span> - <span class="number">1</span>/m) ** k</span><br></pre></td></tr></table></figure><p>再经过 n 个 key，该 bit 设置为 0 的概率为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P<span class="number">''</span>(<span class="number">0</span>) = P<span class="number">'</span>(<span class="number">0</span>) ** n = (<span class="number">1</span> - <span class="number">1</span>/m) ** kn</span><br></pre></td></tr></table></figure><p>根据自然对数e的公式：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041413726.png" alt=""></p><p>我们可以近似计算前面的<code>P&#39;&#39;(0)</code></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041414674.png" alt=""></p><p>关于自然对数 e 的值，可以看下面的内容:</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041327457.png" alt=""></p><p>当检测某个实际不存在的 key 时，满足条件：</p><p>其对应的 k 个 bit 恰好都设置为了1，此时即 false positive 的场景。</p><p>概率为：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041418134.png" alt=""></p><p>问题是，怎么最小化 false_positive 呢？</p><p>为了简化描述，先定义 p (即<code>P&#39;&#39;(0)</code>：某个 bit 设置为0的概率)：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041423865.png" alt=""></p><p>根据公式推导：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041424497.png" alt=""></p><p>底数是 e，为固定值，那么最小化 false_positive_rate 即为最小化指数</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041424841.png" alt=""></p><p>根据之前的计算结果，我们可以做下面的变形：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041431847.png" alt=""></p><p>最终得到结果 g：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041431129.png" alt=""></p><p>根据对称性，当 <code>p = 1/2</code> 时，f 取得最小值。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041435792.png" alt=""></p><p>此时k、f最小值为：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041436632.png" alt=""></p><p>最终的推导结果：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041441884.png" alt=""></p><p>考虑到 p 为设置为0的概率，因此<strong>可以认为 m 有一半设置为1，一半设置为0时，误判率最低</strong>。</p><p><code>false position</code>和m/n、k 的组合关系表例子可以下面的截图：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202205041219187.png" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Bloom Filter 通常用于快速判断某个元素是否在集合中。其本质上容忍一定的错误率来换取时空的高效性。</p><p>对于LevelDB的意义：在哈希表的基础上省下了冲突处理部分，LevelDB 在实现时使用了某种优化：<strong>利用一个哈希函数来达到近似 k 个哈希函数的效果</strong>。这样做实现了高效的并发写入同时不会牺牲过多的性能。</p><p>LevelDB除开哈希函数和针对并发写入的优化部分之外，其他部分都非常贴合布隆过滤器的理论基础，也是优秀的学习案例，作为C++版本的过滤器生产案例应用也是一个不错的参考范本。</p><p>最后，有问题找布隆准没错。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>下面的资料绝对能让你吃透布隆过滤器。</p><blockquote><p>公众号请“阅读原文”获取访问链接。</p></blockquote><ul><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppYW9tZW5nL2FydGljbGUvZGV0YWlscy8xNDk1NTAw" title="https://blog.csdn.net/jiaomeng/article/details/1495500">Bloom Filter概念和原理_jiaomeng的博客-CSDN博客_bloomfilter<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sbGltbGxpYi5naXRodWIuaW8vYmxvb21maWx0ZXItdHV0b3JpYWwvemhfQ04v" title="https://llimllib.github.io/bloomfilter-tutorial/zh_CN/">Bloom Filters by Example (llimllib.github.io)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2MuYmlhbmNoZW5nLm5ldC9jcHAvYmlhbmNoZW5nL3ZpZXcvMzI5Ny5odG1s" title="http://c.biancheng.net/cpp/biancheng/view/3297.html">C++四种类型转换运算符：static_cast、dynamic_cast、const_cast和reinterpret_cast_C语言中文网 (biancheng.net)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5lZWNzLmhhcnZhcmQuZWR1L35taWNoYWVsbS9wb3N0c2NyaXB0cy9lc2EyMDA2YS5wZGY=" title="http://www.eecs.harvard.edu/~michaelm/postscripts/esa2006a.pdf">LNCS 4168 - Less Hashing, Same Performance: Building a Better Bloom Filter (harvard.edu)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9sZXZlbGRiL2Jsb2IvbWFpbi9kb2MvaW5kZXgubWQjZmlsdGVycw==" title="https://github.com/google/leveldb/blob/main/doc/index.md#filters">leveldb/index.md at main · google/leveldb · GitHub<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5lZWNzLmhhcnZhcmQuZWR1L35taWNoYWVsbS9wb3N0c2NyaXB0cy9pbTIwMDViLnBkZg==" title="http://www.eecs.harvard.edu/~michaelm/postscripts/im2005b.pdf">im2005b.pdf (harvard.edu)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5lZWNzLmhhcnZhcmQuZWR1L35taWNoYWVsbS9wb3N0c2NyaXB0cy90b24yMDAyLnBkZg==" title="http://www.eecs.harvard.edu/~michaelm/postscripts/ton2002.pdf">Compressed bloom filters - Networking, IEEE/ACM Transactions on (harvard.edu)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9penVhbHpoeS5jbi9sZXZlbGRiLWJsb29tLWZpbHRlcg==" title="https://izualzhy.cn/leveldb-bloom-filter">leveldb笔记之9:bloom filter - Ying’s Blog (izualzhy.cn)<i class="fa fa-external-link"></i></span></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      有问题找布隆
    
    </summary>
    
    
      <category term="数据库-LevelDB" scheme="https://whitestore.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-LevelDB/"/>
    
    
      <category term="数据库" scheme="https://whitestore.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>14岁懂社会-《被你讨厌的昆虫们》读书笔记</title>
    <link href="https://whitestore.top/2022/05/21/bntydkcm/"/>
    <id>https://whitestore.top/2022/05/21/bntydkcm/</id>
    <published>2022-05-21T10:57:38.000Z</published>
    <updated>2022-06-02T10:09:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="14岁懂社会-《被你讨厌的昆虫们》读书笔记"><a href="#14岁懂社会-《被你讨厌的昆虫们》读书笔记" class="headerlink" title="14岁懂社会-《被你讨厌的昆虫们》读书笔记"></a>14岁懂社会-《被你讨厌的昆虫们》读书笔记</h1><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p><strong>曾经为之讨厌的东西，实际接触之后才发现那么多喜爱</strong>，这是看完这本书之后感触最深的一句话。对于作者来说昆虫们因为不被人接受逐渐淡出视野惋惜，真正喜爱的人才能发现昆虫的魅力。个人观察过最多的动物大概是蚂蚁的，不知道为什么特别喜欢蚂蚁搬东西的场景，每次看到这样的画面都会忍不住看上几眼或者放空电脑盯上很久。</p><p>最后作者提到的《生之欲》这部电影倒是意外收获，打算后续无聊打发时间的时候看看。</p><p>《<strong>生之欲</strong>》（日语：生きる）在<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JUE2JTk5JUU2JUI4JUFG" title="https://zh.wikipedia.org/wiki/%E9%A6%99%E6%B8%AF">香港<i class="fa fa-external-link"></i></span>译作《<strong>流芳颂</strong>》，乃是1952年由<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTk3JUE1JUU2JTlDJUFD" title="https://zh.wikipedia.org/wiki/%E6%97%A5%E6%9C%AC">日本<i class="fa fa-external-link"></i></span>知名<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUIwJThFJUU2JUJDJTk0" title="https://zh.wikipedia.org/wiki/%E5%B0%8E%E6%BC%94">导演<i class="fa fa-external-link"></i></span><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JUJCJTkxJUU2JUJFJUE0JUU2JTk4JThF" title="https://zh.wikipedia.org/wiki/%E9%BB%91%E6%BE%A4%E6%98%8E">黑泽明<i class="fa fa-external-link"></i></span>执导的<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTlCJUJCJUU1JUJEJUIx" title="https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%BD%B1">电影<i class="fa fa-external-link"></i></span>，曾获得日本<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JUFGJThGJUU2JTk3JUE1JUU5JTlCJUJCJUU1JUJEJUIxJUU3JThEJThF" title="https://zh.wikipedia.org/wiki/%E6%AF%8F%E6%97%A5%E9%9B%BB%E5%BD%B1%E7%8D%8E">每日电影最佳影片奖<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTlCJUJCJUU1JUJEJUIxJUU2JTk3JUFDJUU1JUEwJUIx" title="https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%BD%B1%E6%97%AC%E5%A0%B1">电影旬报<i class="fa fa-external-link"></i></span>年度最佳影片奖、<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTlGJThGJUU2JTlFJTk3JUU1JUJEJUIxJUU1JUIxJTk1" title="https://zh.wikipedia.org/wiki/%E6%9F%8F%E6%9E%97%E5%BD%B1%E5%B1%95">柏林影展<i class="fa fa-external-link"></i></span>特别奖等奖项。</p><a id="more"></a><h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><p>实体书阅读，可惜这本书个人并没有从网上找到资源。</p><h1 id="佳句摘录"><a href="#佳句摘录" class="headerlink" title="佳句摘录"></a>佳句摘录</h1><p><strong>曾经为之讨厌的东西，实际接触之后才发现那么多喜爱</strong>。</p><blockquote><p>令人回味无穷的一句话，个人阅历越是丰富，对于这句话越是深有感触。</p></blockquote><h1 id="个人评价"><a href="#个人评价" class="headerlink" title="个人评价"></a>个人评价</h1><p>《为什么长大》中提到人的成长会逐渐失去惊奇，渐渐忘记了自己曾经的好奇心，说什么波澜不惊，随遇而安，不过都是用来掩盖自己越长大越无趣的借口。</p><p>对于这本书最大的感受是佩服作者能对于自己喜爱之物变为事业之后依然保持热情，另一方面对于昆虫世界的残酷又纯粹的生存法则十分感慨。</p><p>另外鲁迅《朝花夕拾》中提到的“人禽之辨其实本不必那么严”，发现和这本书倒是比较贴合，人类和昆虫真的有天差地别么？看过这本书之后发现其实人和昆虫只是多了理性和道德而已。</p><p>看这本书总是有一种小时候看动物世界的错觉，内容整体写的比较有趣，对于个人感兴趣的部分都记录到了此次的读书笔记当中。</p><h1 id="昆虫处世之道"><a href="#昆虫处世之道" class="headerlink" title="昆虫处世之道"></a>昆虫处世之道</h1><p>昆虫常见的三种处世之道，昆虫为虫的样子很像是做人为人的样子。</p><ul><li>喜欢就去追求。</li><li>有危险就需要隐蔽和伪装。</li><li>遇到困难互相帮助，共生和共存。</li></ul><h1 id="竞争与共生"><a href="#竞争与共生" class="headerlink" title="竞争与共生"></a>竞争与共生</h1><p>昆虫之间的竞争和共生都是单纯的，然而人的共生和竞争确实十分复杂的，相比昆虫的纯粹不免让人为之吸引。</p><p>当然昆虫之间也不单单只有竞争，昆虫也存在共生共存关系，当然共生共存也分为互惠互利或者一方白嫖，比如书中提到的下面内容：</p><ul><li><strong>蚜虫和瓢虫</strong>：保镖和老板的关系，保镖保护老板不受伤害，老板提供保镖的薪水，也就是蜜汁，供其食用，这种各取所需的关键是一种微妙的平衡。</li><li><strong>黑灰蝶和蚂蚁</strong>：黑灰蝶的幼虫会散发雄性蚂蚁的气味，因为雄性蚂蚁在蚂蚁中是不需要干活的，所以伪装成蚂蚁的黑灰蝶可以躺着分享蜜汁给其他蚂蚁，也就可以一直无所事事。直到化为飞蝶的时候，蚂蚁才会知道被骗了，但是到这时候一切都晚了。这种共生关系其实一切说白了都是蚂蚁自给自足，蜜汁都是蚂蚁辛苦劳动的成果，实在是狡猾。</li></ul><h1 id="人类是基因的载体"><a href="#人类是基因的载体" class="headerlink" title="人类是基因的载体"></a>人类是基因的载体</h1><p>“生命就是传递基因并且进化而来的”这句话怎么理解？性的诞生仅仅是为了传递基因的手段，而人类的道德和理性也是为了获取更加优异的异性，留下更好的后代基因。</p><p>人类和昆虫没有什么本质的差别，为了追求生命和基因的延续，人类会想方设法来培养更优秀的后代，这种为了后代获得更好发展的强烈渴望究竟是生物本能还是基因的本能犹未可知。</p><p>基因载体的另一个思考是关于大刘的书《三体》中提到的“<strong>失去人性，失去很多，失去兽性，失去一切</strong>”，对于这句话的理解个人看法为这里的人性指的是道德法律的约束，其实道德和法律的约束更多的基于<strong>环境</strong> 而不是人类本身，因为人性是经不起考验的，做人的基本底线也是建立在整个生存环境做的“妥协”。如果真的要到了三体那样的情况人类真的会为了基因延续而战么？</p><p>我想外在的敌人不足为虑，但是永远要小心内部的敌人，所谓“攘外必先安内”这一点放在任何场合都适用，很多时候伤害自己的人是自己最熟悉的人。</p><h1 id="喜欢就要大胆追求"><a href="#喜欢就要大胆追求" class="headerlink" title="喜欢就要大胆追求"></a>喜欢就要大胆追求</h1><p>昆虫如果有了喜欢的对象就会大胆追求，想想昆虫为了追求异性不惜粉身碎骨也要留下自己的后代，感叹为了生存和繁衍生物的行为都是十分纯粹的，昆虫的后代存活率非常低更会为获得和异性交配的权利而不择手段。</p><p>抛开动物生存法则这一点不谈，能在自己喜欢的事情尽情的投入（或者说）时间本身就是幸福的事情，因为很多人干着自己根本不喜欢的工作，对于这一点有幸在大学的时候有了认识，所以<strong>心中抱持着强烈的愿望，愿望就会悄悄来到你的身边</strong>。</p><p>兴趣作为事业会逐渐消磨热情这是避免不了的，但是这种无论干多久都不会腻的事情是可遇而不可求的。</p><p>当然这里要排除机械和无思考的劳动，这才是害人之根本，消耗精神的同时还消耗肉体，建议大家不要尽量接触这一类的工作。</p><h1 id="伪装和趋光性"><a href="#伪装和趋光性" class="headerlink" title="伪装和趋光性"></a>伪装和趋光性</h1><p><strong>昆虫之所以令人喜爱是因为他们总是只有一个目标不断的追去</strong>。无论是进行伪装还是“飞蛾扑火”的冲击，对于昆虫来说永远追求最大的存活率。</p><p>伪装是昆虫中的基本有的虫伪装成树枝，有的伪装成树叶，有的直接伪装同类的气味，还有伪装则是为食物伪装做诱饵，这些技巧都是为了生存做的一系列努力。</p><p>为了生存，昆虫会隐蔽自己，萤火虫会通过发光诱骗其他萤火虫吃掉别的属的萤火虫然后发出原本的光，昆虫的狡猾和智慧是赖以生存的资本。</p><p>飞行类动物之所以会趋光性是因为在飞行的时候也需要看清周围环境才能正常飞行，对于夜晚月光和星星的光亮当然不足以和电灯相比了。不只是动物，晚上走漆黑的巷道看到光亮人也会产生安心的感觉，昆虫会如此执着光明也不是不能理解。</p><p>人类也为了光明坚持不懈的努力，电的到来无论如何都是人类历史上最伟大的发明（在我看来没有之一）。</p><h1 id="真正可怕之物"><a href="#真正可怕之物" class="headerlink" title="真正可怕之物"></a>真正可怕之物</h1><p>对于昆虫来说真正应该害怕的是那些会带来生命危险的东西，而不那些看似危险实则无害的生物，很多看似无害的小虫子才是真正的杀手，比如隐翅虫这种呼一巴掌基本手是废了。</p><p>个人过去也遭受过“虫子”的道，现在想想还有些后怕，过去在老家山里劈柴的时候不小心掠过一只小虫不在意，结果晚上通红一片，本以为上点止痒的药就会好的，结果第二天手便肿成了”肉球“，没错真的是肉球，为此当时还拍过照做过纪念。</p><p>虽然手机换了几次之后相片已经没了，但是对于那种胀痛依旧还有深刻的记忆。</p><blockquote><p>后面找长辈问了一下才知道是马蜂，不过好在只有一只。只怪小时候懵懂不懂事，老天保佑算是捡了一条命。另外个人在朋友眼中算是黑历史比较少的，这一次手肿成肉球让朋友也有深刻记忆，每次提起都会吐槽一遍=-=。</p></blockquote><p>所以对于生活中可能碰到的昆虫建议都做一个了解，不明不白当蚊子拍了会有意想不到的后果。</p><h1 id="失去惊奇"><a href="#失去惊奇" class="headerlink" title="失去惊奇"></a>失去惊奇</h1><p>沉重的话就放到最后部分了。</p><p>失去惊奇大概是成年人最大的悲哀了，成长总是伴随着无尽的代价，当我们失去惊奇我们会逐渐原地踏步活在安逸和舒适圈还是寻找新的可能性，大部分都是会选择安逸平凡的生活，这大概是成年人的另一种悲哀 – 放弃追求。</p><p>然而给昆虫的生存环境是没有惊奇，失去惊奇意味着死亡。</p><h1 id="生之欲"><a href="#生之欲" class="headerlink" title="生之欲"></a>生之欲</h1><p>下面的内容都是从网络上拷过来的，可以随便看看。</p><p>书中作者在某一小节的结尾提到了《生之欲 》这部电影，查了下是一部上世纪50年代的电影，观感应该不会太好，但是豆瓣居然有9点几分瞬间来了兴趣，后续抽空看一下说说观后感。</p><p>《生之欲》讲述了一位官僚在发现自己患了晚期癌症后，试图在他的生活中找到意义。</p><p>A bureaucrat tries to find a meaning in his life after he discovers he has terminal cancer.</p><blockquote><p>2007年日本有再编过，这里不要下载错了哦。</p></blockquote><blockquote><p>《生之欲》电影链接：</p></blockquote><p>链接: <span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMVdTWU1zWDZCdkdzeXVGSV9LUGUyb0E=" title="https://pan.baidu.com/s/1WSYMsX6BvGsyuFI_KPe2oA">https://pan.baidu.com/s/1WSYMsX6BvGsyuFI_KPe2oA<i class="fa fa-external-link"></i></span> 提取码: zfqc 复制这段内容后打开百度网盘手机App，操作更方便哦 –来自百度网盘超级会员v7的分享</p><p>另外下面是维基的介绍，这里直接搬过来了：</p><p>《<strong>生之欲</strong>》（日语：生きる）在<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JUE2JTk5JUU2JUI4JUFG" title="https://zh.wikipedia.org/wiki/%E9%A6%99%E6%B8%AF">香港<i class="fa fa-external-link"></i></span>译作《<strong>流芳颂</strong>》，乃是1952年由<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTk3JUE1JUU2JTlDJUFD" title="https://zh.wikipedia.org/wiki/%E6%97%A5%E6%9C%AC">日本<i class="fa fa-external-link"></i></span>知名<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUIwJThFJUU2JUJDJTk0" title="https://zh.wikipedia.org/wiki/%E5%B0%8E%E6%BC%94">导演<i class="fa fa-external-link"></i></span><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JUJCJTkxJUU2JUJFJUE0JUU2JTk4JThF" title="https://zh.wikipedia.org/wiki/%E9%BB%91%E6%BE%A4%E6%98%8E">黑泽明<i class="fa fa-external-link"></i></span>执导的<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTlCJUJCJUU1JUJEJUIx" title="https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%BD%B1">电影<i class="fa fa-external-link"></i></span>，曾获得日本<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JUFGJThGJUU2JTk3JUE1JUU5JTlCJUJCJUU1JUJEJUIxJUU3JThEJThF" title="https://zh.wikipedia.org/wiki/%E6%AF%8F%E6%97%A5%E9%9B%BB%E5%BD%B1%E7%8D%8E">每日电影最佳影片奖<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTlCJUJCJUU1JUJEJUIxJUU2JTk3JUFDJUU1JUEwJUIx" title="https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%BD%B1%E6%97%AC%E5%A0%B1">电影旬报<i class="fa fa-external-link"></i></span>年度最佳影片奖、<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTlGJThGJUU2JTlFJTk3JUU1JUJEJUIxJUU1JUIxJTk1" title="https://zh.wikipedia.org/wiki/%E6%9F%8F%E6%9E%97%E5%BD%B1%E5%B1%95">柏林影展<i class="fa fa-external-link"></i></span>特别奖等奖项。</p><h2 id="故事内容"><a href="#故事内容" class="headerlink" title="故事内容"></a><strong>故事内容</strong></h2><p>在市公所工作30年的市民课课长渡边勘治每天过着盖章、签公文的乏味生活，某日因身体不适前往<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTg2JUFCJUU5JTk5JUEy" title="https://zh.wikipedia.org/wiki/%E9%86%AB%E9%99%A2">医院<i class="fa fa-external-link"></i></span>检查，结果竟被告知罹患<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JTgzJTgzJUU3JTk5JThD" title="https://zh.wikipedia.org/wiki/%E8%83%83%E7%99%8C">胃癌<i class="fa fa-external-link"></i></span>末期，只剩下约半年的生命。回到家中，<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTg1JTkyJUU1JUFEJTkw" title="https://zh.wikipedia.org/wiki/%E5%85%92%E5%AD%90">儿子<i class="fa fa-external-link"></i></span>与<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUFBJUIzJUU1JUE5JUE2" title="https://zh.wikipedia.org/wiki/%E5%AA%B3%E5%A9%A6">媳妇<i class="fa fa-external-link"></i></span>对他并不友善，甚至可谓不孝。感到悲伤的渡边，带了毕生积蓄离家出走，也不去上班了。他在外头遇见一位<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUIwJThGJUU4JUFBJUFB" title="https://zh.wikipedia.org/wiki/%E5%B0%8F%E8%AA%AA">小说<i class="fa fa-external-link"></i></span><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU0JUJEJTlDJUU1JUFFJUI2" title="https://zh.wikipedia.org/wiki/%E4%BD%9C%E5%AE%B6">作家<i class="fa fa-external-link"></i></span>，告之自己将不久于人世，他认为从未替自己好好活过。小说家同情其遭遇，带他去打<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUJEJTg4JUU3JThGJUEwJUU2JUE5JTlG" title="https://zh.wikipedia.org/wiki/%E5%BD%88%E7%8F%A0%E6%A9%9F">小钢珠<i class="fa fa-external-link"></i></span>，甚至去<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUE2JTkzJUU5JTk5JUEy" title="https://zh.wikipedia.org/wiki/%E5%A6%93%E9%99%A2">声色场所<i class="fa fa-external-link"></i></span>。对渡边来说，虽然这些事很新鲜，但到头来却觉得空虚落寞。第二天他就告别了小说家，一个人孤独的走在街上。</p><p>他遇见了市公所的一位年轻女职员小田切丰，后者表示她厌倦公务员无聊的工作，已觅得新职，却因课长没来上班，没人批准<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUJFJUFEJUU4JTgxJUI3" title="https://zh.wikipedia.org/wiki/%E8%BE%AD%E8%81%B7">辞呈<i class="fa fa-external-link"></i></span>。渡边便将小田切带回家中，为她盖离职同意书；见她丝袜破掉，想为她买双新的。这天他要求小田切带他去玩，两人也度过快乐的一天。但回家后却遭到儿子辱骂，认为他之前带走的存款算是家用的一部分；儿子同时误会小田切是他的年轻<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTg0JTlCJUU0JUJBJUJB" title="https://zh.wikipedia.org/wiki/%E6%84%9B%E4%BA%BA">情人<i class="fa fa-external-link"></i></span>，要求父亲自重。</p><p>过了几天后，渡边前往小田切新任职的<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JThFJUE5JUU1JTg1JUI3" title="https://zh.wikipedia.org/wiki/%E7%8E%A9%E5%85%B7">玩具<i class="fa fa-external-link"></i></span>工厂，希望她再陪着出去玩。小田切原本不想答应，但渡边苦苦哀求，她只好同意。晚上来到一家<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUE1JUJGJUU5JUE0JTkwJUU1JUJCJUIz" title="https://zh.wikipedia.org/wiki/%E8%A5%BF%E9%A4%90%E5%BB%B3">西餐厅<i class="fa fa-external-link"></i></span>，渡边的举动让小田切以为他要对她不轨，十分害怕。没想到渡边告诉她自己得了不治之症，来日无多，但是见到小田切如此年轻有活力，希望小田切告诉他究竟活着是为了什么。小田切只好战战兢兢的拿出一只玩具<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTg1JTk0" title="https://zh.wikipedia.org/wiki/%E5%85%94">兔<i class="fa fa-external-link"></i></span>子告诉他，她平常在工厂工作就是做这种东西；只要想到自己做出的东西是为别人带来欢乐，自己也就很开心。渡边突然想到自己想要什么了，向小田切道谢后便离开餐厅。此时碰巧有群年轻人替一位少女庆生，众人唱起<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUE1JTlEJUU0JUJEJUEwJUU3JTk0JTlGJUU2JTk3JUE1JUU1JUJGJUFCJUU0JUI5JTkw" title="https://zh.wikipedia.org/wiki/%E7%A5%9D%E4%BD%A0%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90">生日快乐歌<i class="fa fa-external-link"></i></span>，仿佛在庆祝渡边的重生。</p><p>翌日渡边再度回到市公所上班，将他请假这些日子的公文全数拿出来，发觉有件案子是许多妇女前来陈情，希望将某条臭水沟改建为<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTg1JUFDJUU1JTlDJTky" title="https://zh.wikipedia.org/wiki/%E5%85%AC%E5%9C%92">公园<i class="fa fa-external-link"></i></span>，却屡屡遭到各单位互踢皮球不愿处理。他决定要处理这件事，带着下属开始各处奔走。5个月后，渡边过世，在灵堂上大家开始回忆他生命最后5个月的过程，发觉他非常努力奔走以建立公园，最后甚至选择在大<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTlCJUFB" title="https://zh.wikipedia.org/wiki/%E9%9B%AA">雪<i class="fa fa-external-link"></i></span>的夜里独自快乐的唱着歌，死于自己亲手建立的公园里。虽然在守灵的酒会上，大家如此怀念渡边所做的一切，但等到第二天上班时市公所 依就弥漫着官僚之气。尽管有职员看不过去，心中认为应该要继承渡边的精神，但也仅止于缅怀而已。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>昆虫的生活似乎每天只有成王败寇，其中最大的启发就是“活着就要感谢”。</p><p>开头的那句话换一下词也可以说成：<strong>曾经为之喜爱的东西，实际接触之后才发现那么多讨厌</strong>，相比于昆虫作为人看起来有更多的无可奈何，但是那又怎么样呢？终究是选择的代价罢了。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      曾经为之讨厌的东西，实际接触才发现如此喜欢
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://whitestore.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="书籍" scheme="https://whitestore.top/tags/%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>阿里云OSS图床搭建</title>
    <link href="https://whitestore.top/2022/05/21/abioss/"/>
    <id>https://whitestore.top/2022/05/21/abioss/</id>
    <published>2022-05-21T10:50:06.000Z</published>
    <updated>2022-06-02T10:09:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阿里云OSS图床搭建"><a href="#阿里云OSS图床搭建" class="headerlink" title="阿里云OSS图床搭建"></a>阿里云OSS图床搭建</h1><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>过去介绍过Gitee的图床搭建，用了一年多都挺稳定了，访问速度尚可，但是2022年开始发现不是很稳定，并且部分网站会发现“图片消失”的情况，F12看一下发现是很多外国网站给直接<strong>302临时重定向</strong>了。</p><p>所以为了保证数据安全，这里无奈只能掏钱买阿里云的 OSS做图床了，查了下价钱也还能接受，标准LRS存储一年也就10块钱。</p><p>本文就根据OSS配置再结合个人常用的几个软件来总结阿里云OSS相关配置和应用。</p><a id="more"></a><h2 id="计费方式"><a href="#计费方式" class="headerlink" title="计费方式"></a>计费方式</h2><p>在了解具体的使用之前，这里简要介绍一下计费的方式。</p><p>阿里云有目前有两种计费方式，如果你不想买资源包等等操作，那么默认开通OSS之后就可以直接拿来用，直接<strong>按量计费</strong>的方式即可，先使用，后付费。</p><ul><li><p>按量收费计费公式：OSS的使用费用每小时结算一次，计算公式为：<strong>费用=实际资源使用量×对应资源每小时单价</strong>。</p></li><li><p>资源包：预先购买针对不同的计费项推出的优惠资源包，在费用结算时，优先从资源包抵扣用量，先购买，后抵扣，适用于业务用量相对稳定的场景。</p></li></ul><blockquote><p>注意：资源包一定要根据自己创建和使用的Bucket进行购买，比如标准存储就买标准存储的，低频存储的就买低频存储的，<strong>千万不要买错了，买错了不能反悔</strong>。当然标准的LRS比较便宜，但是粗略看了一下其他几个Burket选项都挺贵的，购买之前一定要确认清楚自己的需求和使用的Bucket类型。<br>如果对于费用计费有顾虑，可以阅读“资源包管理“中的”购买了资源包为什么还会欠费？“，里面都有相关解释。<br><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202204032203859.png" alt=""></p></blockquote><p>这里假定读者都是给个人学习或者简单使用的情况，所以使用的是购买资源包计费方式。</p><h2 id="存储类型"><a href="#存储类型" class="headerlink" title="存储类型"></a>存储类型</h2><p>官方做了一张表，其实一般使用“标准类型”就够了，可能有的读者还想图便宜会想要买一个“低频访问”来玩玩，但是只要你去看一下低频访问资源包价格就会发现你会被文字游戏给坑了。</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202204032207275.png" alt=""></p><h2 id="新人优惠"><a href="#新人优惠" class="headerlink" title="新人优惠"></a>新人优惠</h2><p>新人优惠很重要，查了一下很多文章不会说这个东西，这里有必要强调一下，阿里云的OSS对于新人来说有送3个月免费100GB流量，基本相当于让你免费用3个月，这一点还是挺香的（<s>到期了薅完阿里薅腾讯云的</s>），所以创建OSS之后先不要急着用，先把免费的资源包领一下：</p><p>地址：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYWxpeXVuLmNvbS9wcm9kdWN0L29zcz9zcG09NTE3Ni4yMTIxMzMwMy5KXzY3MDQ3MzM5MjAuMTEuNDAyNzUzYzk3QVlCODQjSl8zMzMyMjQzMjIw" title="https://www.aliyun.com/product/oss?spm=5176.21213303.J_6704733920.11.402753c97AYB84#J_3332243220">对象存储OSS_云存储服务_企业数据管理_存储-阿里云 (aliyun.com)<i class="fa fa-external-link"></i></span>。</p><p>滚动条下拉选择套餐即可。</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202204032156464.png" alt=""></p><p>地域选择大陆通用即可：</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202204032157443.png" alt=""></p><p>购买之后我们创建相关的Burket然后上传的时候就会从资源包扣费了。<br>注意你创建的Burket一定要和你的资源包匹配！<br>注意你创建的Burket一定要和你的资源包匹配！<br>注意你创建的Burket一定要和你的资源包匹配！</p><p>很重要，否则不明不白的额外扣费让人恼火和后悔。</p><h1 id="阿里云-OSS基础配置"><a href="#阿里云-OSS基础配置" class="headerlink" title="阿里云 OSS基础配置"></a>阿里云 OSS基础配置</h1><p>进入官网：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYWxpeXVuLmNvbS8/c3BtPTUxNzYuMjEyMTMzMDMuSl8zMjA3NTI2MjQwLjEuMjg4MTUzYzlUREdrdHg=" title="https://www.aliyun.com/?spm=5176.21213303.J_3207526240.1.288153c9TDGktx">阿里云-上云就上阿里云 (aliyun.com)<i class="fa fa-external-link"></i></span>，在产品中选择 OSS，如果从来没开通过OSS，阿里云这里会给一份协议确认然后确认用户开通，这里就不截图了。</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202204032023825.png" alt=""></p><p>进入管理页面，刚进去看不知道要干啥，所以直接点击右边的OSS新手入门来了解也是一种方式。<br><span class="exturl" data-url="aHR0cHM6Ly9oZWxwLmFsaXl1bi5jb20vbGVhcm4vbGVhcm5pbmdwYXRoL29zcy5odG1sP3NwbT01MTc2Ljg0NjU5ODAuZ3VpZGUuMS40MTIzMTQ1MG1oNUxsNw==" title="https://help.aliyun.com/learn/learningpath/oss.html?spm=5176.8465980.guide.1.41231450mh5Ll7">OSS阿里云_ OSS是什么意思_对象储存OSS_阿里云OSS学习路径图_OSS Learning Path - 阿里云 (aliyun.com)<i class="fa fa-external-link"></i></span></p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202204032036671.png" alt=""></p><p>我们切换到B<strong>ucket</strong>列表，选择“创建Bucket”。</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202204032105135.png" alt=""></p><p>进入页面之后，我们填写下面的内容：</p><ul><li>Bucket名称，唯一命名，起个自己喜欢的名字即可</li><li>地域：选择和自己所在城市比较近的城市，国内选择国内的区域和节点即可。</li><li>Endpoint：需要的话可以记录一下，比如我我选择的是：oss-cn-shenzhen.aliyuncs.com</li><li>存储类型：如果仅仅作为备份使用，低频访问比较合适，但是如果是对外使用不管流量多少还是建议用标准的，归档存储一般用于永久存储备份重要数据。</li><li>同城冗余和版本控制没啥必要，不用开</li><li>读写权限：如果我们作为图床，需要用“公共读”允许匿名用户访问数据。（和PicGo配置有关）</li><li>实时日志和定期备份个人认为如果是自己用也是没有必要，骗钱玩意。</li></ul><h2 id="购买资源包"><a href="#购买资源包" class="headerlink" title="购买资源包"></a>购买资源包</h2><p>创建完成之后，我们先不急着操作，我们先买个资源包，这里个人使用了“新人优惠”不给买了，这里就不演示购买操作了。</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202204032215220.png" alt=""></p><h2 id="AccessKey管理"><a href="#AccessKey管理" class="headerlink" title="AccessKey管理"></a>AccessKey管理</h2><p>接着是用户配置部分，我们需要在OSS中配置允许对外访问的AccessKey，这里我们点击右上角“头像”的”AccessKey管理“，这里其实用户体验不是很好。<br><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202204032249369.png" alt=""></p><p>由于图床会对外访问，所以建议不要使用主账户的AccessToken进行操作，而是使用子账户方式进行操作处理，这里进入之后可以看到RAM用户管理，点击“创建用户”。</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202204032253953.png" alt=""></p><p>“创建用户”其他都可以自由操作，但是一定要选择“Open API”，这里需要进行安全验证。创建完整之后，我们便拥有了<strong>AccessKey ID，AccessKey Secret</strong>这两个关键配置，注意这两个配置只能查看一次，建议复制到自己本地存储后面需要使用到。</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202204032254752.png" alt=""></p><p><strong>Burke授权</strong><br>创建用户之后，我们需要给创建的子用户授权，在管理页面选择新建子商户之后选择给商户添加权限。</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202204041251396.png" alt=""></p><p>然后回到刚刚创建的bucket，在文件管理内给新建的用户授权。</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202204041300935.png" alt=""></p><h2 id="配置PicGo"><a href="#配置PicGo" class="headerlink" title="配置PicGo"></a>配置PicGo</h2><p>PicGo是什么这里就略过了，我们直接来看PicGo的配置</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202204041303779.png" alt=""></p><p>关键部分：在软件中我们选择“阿里云OSS配置”然后根据参数填写下面的内容：</p><ul><li>keyId：这里用之前新建的<strong>子用户</strong>的 <strong>AccessKey</strong>。</li><li>KeySecret：这里使用新建<strong>子用户</strong>的 <strong>AcessSecret</strong>。</li><li>存储空间名称：这里按照下图填写<strong>Bucket域名</strong>，注意这里只需要<code>.aliyuncs.com</code>需要删除。</li><li>默认存储区域：这里按照下图填写<strong>Endpoint</strong>，注意这里只需要<code>.aliyuncs.com</code>需要删除。</li></ul><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202204041306584.png" alt=""></p><p>最后个人的配置如下：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204041315333.png" alt=""></p><h2 id="配置Typera"><a href="#配置Typera" class="headerlink" title="配置Typera"></a>配置Typera</h2><p>安装Typera这里就跳过了，我们打开软件之后选择“图像”，然后切换到PicGo，验证一把之后会提示成功信息，之后我们修改上面“插入图片时….”的操作改为“上传图片”，以后图片都会往PicGo进行上传，不会出现在本地的一个临时路径了。</p><blockquote><p>这里不是很建议直接执行上传操作，更建议先放到一个指定文件夹然后确认无误之后进行复制粘贴的上传替换，当然OSS流量基本够用。</p></blockquote><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204041345412.png" alt=""></p><h2 id="obsidian配置"><a href="#obsidian配置" class="headerlink" title="obsidian配置"></a>obsidian配置</h2><p>具体可以看作者的文章，基本上安装一个插件之后“Enable”即可直接使用，直接往Obsidian进行粘贴就会直接委托PicGo上传，然后出翔相关路径。<br><span class="exturl" data-url="aHR0cHM6Ly9mb3J1bS16aC5vYnNpZGlhbi5tZC90L3RvcGljLzM4OA==" title="https://forum-zh.obsidian.md/t/topic/388">在Obsidian中使用图床实现“一次上传、多次搬运”省心又省力 - 经验分享 - Obsidian 中文论坛<i class="fa fa-external-link"></i></span></p><p>最后，我们截图粘贴查看是否触发PicGo上传，最终截图的路径如下：</p><p><span class="exturl" data-url="aHR0cHM6Ly9hZG9uZy1waWN0dXJlLm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vYWRvbmcvMjAyMjA0MDQxMzMzMzgzLnBuZw==" title="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204041333383.png">https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204041333383.png<i class="fa fa-external-link"></i></span></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204041333383.png" alt=""></p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>gitee的图床个人目前已经不再进行上传，后续都将会改用OSS，另外个人建议定期给图床做一下本地备份，虽然可能并没有特别大的意义。</p><p>另外如果对于图片的重要性不大，可以直接使用免费的图床。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      图床处理
    
    </summary>
    
    
      <category term="其他" scheme="https://whitestore.top/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="其他" scheme="https://whitestore.top/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>14岁懂社会-《给想要成为医生的你》读书笔记</title>
    <link href="https://whitestore.top/2022/05/05/gxycwysdn/"/>
    <id>https://whitestore.top/2022/05/05/gxycwysdn/</id>
    <published>2022-05-05T06:36:15.000Z</published>
    <updated>2022-06-02T10:09:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="14岁懂社会-《给想要成为医生的你》读书笔记"><a href="#14岁懂社会-《给想要成为医生的你》读书笔记" class="headerlink" title="14岁懂社会-《给想要成为医生的你》读书笔记"></a>14岁懂社会-《给想要成为医生的你》读书笔记</h1><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204232131277.png" alt=""></p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>看到这样的书名难免让人止步，但是即使是不想成为医生我看完之后依然认为十分有收获的一本书，而对于渴望成为医生的人来说这本书大概是在“浇冷水”，因为挽救生命的职业既是天使也有可能是魔鬼。</p><p>这本书也是比较著名的医生写的，也确实看得出是医生写的出来的书，但是行文却和医生严肃的面容大相径庭。</p><blockquote><p>不过日本人给作者取了一个“上帝之手”的称号属实没绷住</p></blockquote><a id="more"></a><h1 id="个人评价"><a href="#个人评价" class="headerlink" title="个人评价"></a>个人评价</h1><p>虽然我对于医生行业一窍不通但是看这本书的时候还是被作者的文字所吸引，看到作者是世界上第一例胃网膜右动脉搭桥手术还是心生佩服。</p><p>寻常职业大概可以把自己的职业成果当作鼓励和夸奖，而每天都有可能见证死亡的外科医生却是时刻在和死神搏斗，这种济世救人的成就对于他们来说都是日常工作应该做到的事情罢了，所以“<strong>应该做到的事情</strong>”上医生毫无疑问承受了最大的压力。</p><p>现代人似乎丢失了耐心和责任对自己的工作负责心越来越轻，以个人从事的 IT 行业为例有时候出一些小BUG在用户没有发现的时候无伤大雅，或许也不会有任何的金钱损失最多遭受一顿骂然后及时改正即可，然而医生一旦犯错不仅会丢了饭碗甚至有可能葬送一个家庭，大概没有哪一个行业需要比医生更多责任心，丰富的学识以及想象力了，<strong>医生是上帝的同时也是恶魔</strong>。</p><p>最后看完这本书之后不仅少了几分对于医生的讨厌，更多的是更多了几分对于医生的尊敬。</p><h1 id="佳句收藏"><a href="#佳句收藏" class="headerlink" title="佳句收藏"></a>佳句收藏</h1><ul><li>人拥有无限的潜力，成长之所以停止是因为人失去的进取之心，人的可能性其实没有界限。</li><li><strong>想象成功的愿景和强烈的愿望是医生不会犯错的前提，套用在任何事情上也是通用的</strong></li><li>与其畏惧死亡不如充分享受生命才会更加幸福。</li><li>你的人生就像是坐着最快列车在最前面车厢的最前列向前方驶去，周围是什么景色你从来没有看过吧？当人生飘过死亡气息与充满生机的时候感受是完全不同的。</li><li><strong>一旦意识到生命的短暂，人生观就会改变</strong>。</li><li><strong>不如预想并且期待和欢喜的时候，未知世界的大门正在打开。</strong></li><li>世界上有四种人：创造者、挑剔者、破坏者、使用者，只要不是挑剔者大概都不会活在这个世上产生烦恼吧。</li><li>遗憾的是生命并不平等，虽然大家都拥有一条生命，但是大家生命的长度、死亡的痛苦程度各不相同。</li></ul><h1 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h1><p>拥有实体书可以看看目录中对应正文的<strong>如何发展能力</strong>部分，相信任何人看完都能有所收获，如果时间有限不想看后面的内容也可以看看下面部分几点总结，也是我认为这本书能带给我一些价值和深入思考的地方：</p><ul><li><strong>绝对自信</strong>：没有人天生就是绝对自信的，也没有人能在生死攸关的场景保持绝对冷静，外科医生这种走钢丝的职业不能有丝毫差错，需要在经验和成功中不断证明自己“我能行”，站上手术台之前无数次的预演成功，从相信自己不可能犯错到肯定自己不会犯错便是成熟和实现绝对自信的过程。</li><li><strong>进取之心</strong>：根据自己的位置设置合理的进取目标，人才不会安于现状毫无进取之心。哪怕没有成熟的本领和技术每天进步一点点，也是微小成长的过程，也好过安于现状。</li><li><strong>想象成功</strong>：如果医生不想象从进入手术室到家属高高兴兴出院的场景，那么成为一名合格的“运动员”。</li><li><strong>拼尽全力的成功和拼尽全力的失败</strong>：如果把失败是成功之母放在医生这个职业上，这和鼓励杀人犯去杀人是没有区别的，正如作者所说如果没有4950的成功治愈的病例而只有50例没能挽回的生命，医生和刽子手是没有区别的，他也绝对无法达成现在的成就，即使如此，哪怕拯救了上千的人没有挽回的每一例生命都会医生无尽的心里创伤和痛苦。</li><li><strong>榜样是最好的教育</strong>：十分认可作者对于给孩子的教育不需要传授知识，只需要给孩子树立一个正确并且值得模仿和学习的榜样的理念，同时我也认为很多熊孩子的问题归根结底是家庭教育的问题，“管不了”和“管不住”这种借口是无法抵赖的。</li><li><strong>拥抱挑战就是拥抱机遇</strong>：如果作者没有成为主刀医生的欲望那么可能成为一个教授，作者到了40多岁依然在寻找新的手术方案，不断在寻找新的可能性，纵观现在35岁就好像要退休要被社会断绝生路的年代毫无疑问是值得反思的。</li><li><strong>学习榜样和模仿是最好的学习方式</strong>：就像这本书一样，作者看似一些有感而发的肺腑之言和经验之谈才是真正学不到的经验，所谓经验、预判和直觉才是比知识更重要的东西。</li><li><strong>生命并不平等</strong>：现实是每一个人的生命长度各不相同，所以活在当下是对自己最好的祝福。</li></ul><blockquote><p>可以思考医生能在你没有具体描述病情的情况下能预判你的病根，这种经验和直觉是知识无法带来的。</p></blockquote><h1 id="每天都将面对死亡"><a href="#每天都将面对死亡" class="headerlink" title="每天都将面对死亡"></a>每天都将面对死亡</h1><p>医生是见到生死画面最多的职业，既要承担外界的家属压力，同时还要接受自己的压力，对于每一位医生来说无论何时都不能失去自己的冷静判断。</p><p>和殡仪馆的面对死亡不同，医生面对的是生命陨落的过程，在医院中隐藏着生命最本质的样子，就如《活着》核心活着的本质就是为了活着一样，人生在世尝尽酸甜苦辣咸方得圆满。</p><h1 id="心脏是可爱的脏器"><a href="#心脏是可爱的脏器" class="headerlink" title="心脏是可爱的脏器"></a>心脏是可爱的脏器</h1><p>心脏在我们左胸肋骨和肺部的交界处，每天要跳动十几万次都不会疲劳，心脏的重量在130到200克左右。</p><p>心脏任务是输送向脏器输送氧气，通常被称为动脉血，而消耗完氧气的血是静脉血。&#x20;</p><p>心脏可能会因为下面的原因逐渐衰竭：一个是冠状动脉堵塞，另一个是心脏瓣膜受损，这两个问题都是容易导致心脏肌肉衰弱的问题。</p><p>心脏有四个腔，左心房右心房，左心室右心室，血液从左心室通过强大的压力送往心房和肺动脉流向全身，最后通过肺静脉回到右心房，右心房在肺部送往右心室通过肺动脉接受氧气之后回流到左心房和左心室，接着完成下一个循环。</p><blockquote><p>文科生直接按照书上摘抄的，如果有错误欢迎指正。</p></blockquote><p>为了保证回流的时候不会逆流，在心脏中会存在瓣膜保证血液只能单向流动。</p><p>心脏的运作有点儿类似发动机的工作方式，只不过带来的价值完全不同。</p><p>换成是我会怎么做？从第三者眼光虽然觉得自己会理智感性，然而真正身处那样的环境通常情况下行动和言行都会不一致。所谓知行合一，大概才是最难做到的。</p><p>虽然手术是需要多个人配合的过程，但是实际上手术更多情况下是主刀医生一个人的责任，因为责任重大主刀医生压力也很大，因为患者和家属只会把希望寄托在主刀医生身上。</p><p>心脏停止才是真正的死亡？是否心脏停止才是真正的停止不得而知，但是脑死亡的人确实像是活在地狱当中，心脏无疑是身体中和大脑同样重要的脏器，一个控制精神，一个控制生命。</p><p>作者认为心脏十分的美丽，为了让心脏病患者重新回到生活正轨</p><h1 id="医生是运动员-x20"><a href="#医生是运动员-x20" class="headerlink" title="医生是运动员&#x20;"></a>医生是运动员&#x20;</h1><p>比较有趣的是外科医生起源于<strong>理发店的理发师</strong>，其实仔细想想也可以理解理发店的理发师给人理发如果不小心刮伤了那么需要会各种止血和包扎，慢慢的逐渐发展出专门处理伤口的人员，最后转变为医生，我想很多职业的起源都是十分有趣并且让人意外的。</p><blockquote><p>就好像程序C语言的诞生最开始只不过是作者为了帮助老婆看菜谱炒菜以及想打游戏的心情逐渐发展成构建编程语言的。</p></blockquote><p>那么为什么说医生是运动员呢？因为都和运动员一样需要三个最为重要的特征：<strong>想象力，技术和判断力</strong>。如果没有这三样是无法成为一名合格的医生的。</p><p>虽然外科手术是一项群体项目，但是没有人会认为责任会分担给其他的助手，家属也不会对着主刀医生以外的人说希望可以手术顺利等等话语，主刀医生是没有上台了再想办法这种情况的，换句话说手术其实早在进入手术室之前就已经开始，也就是之前提到的在脑海中不断构建成功的画面，才绝无失败的可能。</p><h2 id="想象力"><a href="#想象力" class="headerlink" title="想象力"></a>想象力</h2><p>为什么说需要想象力，因为作为医生没有见到急救病人之前无法判断病人的情况，这时候需要思考家属的心情，思考从进入手术室到医好病人，最终病人安全回家整个流程，在脑海中需要不断的进行预演。如果不能想象成功的画面，就无法在紧张的手术中预想通往成功的方案。</p><p>另一方面想象力需要反复的预演形成下意识才能完成，这也是专家和普通人的区别，专家的想象力来自于能在执行某些专业的流程同时腾出思考空间对于结果反复的排练和预演，同样脑海中需要不断的决策。</p><p><strong>预读是可以训练的才能，不是身高这种没有办法训练的天赋。</strong></p><h2 id="判断力"><a href="#判断力" class="headerlink" title="判断力"></a>判断力</h2><p>学习的时候还有明天继续的说法，但是手术是没有明天继续的说法的，任何判断和决定都应该在几秒内完成，这就牵扯到作为医生最为重要的准则，那就是时刻保持镇静，哪怕内心已经失去冷静也绝对不能把慌张写在脸上。</p><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><p>书中让我比较难以想象是冠状动脉手术的血管移植，血管移植在表面上看像是嫁接，但是难度之大令人咋舌，首先需要在血管开一个2毫米的孔，之后需要用比发丝远远小的线把血管进行<strong>缝合</strong>，没错就是和缝衣服一样缝血管上，所以需要的惊人的判断和专注力。</p><p>让我想到过去看日本外科医生的考试画面，需要用镊子折出比指甲盖还要小很多的千纸鹤，很难想象日常生活中要下多大的功夫和时间才能完成。</p><p>另外像是医生这样的职业让我想到了律师，律师在个人看来也是学的越多越容易失去感性的。</p><blockquote><p>冠状动脉移植难点：需要找到粗细适中并且不会影响其他脏器的血管，在人体中仅仅有几条可供使用并且很难发现。</p></blockquote><h1 id="第一次手术"><a href="#第一次手术" class="headerlink" title="第一次手术"></a>第一次手术</h1><p>和其他绝大多数的第一次不同，第一次手术是关乎性命的事情并且绝对不能失败，对于书中患者家属听说医生第一次主刀，很难想象作者究竟有多大的压力，仅仅是想象一下就可以让心跳加速，身历其境可想而知。</p><p>医生不允许失败，<strong>失败意味着死亡。</strong></p><p>唯一可以感同身受的大概是紧张的心情了，一场手术之后忘记自己干了啥和考试的之后不知道自己干了啥的心情有些许类似吧，不过紧张程度当然完全无法比较。</p><h1 id="想象成功"><a href="#想象成功" class="headerlink" title="想象成功"></a>想象成功</h1><p>医生大概是最需要想象成功的人，同时需要不断预演成功的人，因为保持着绝对不能失败的心情。</p><p>对于医生团队来说无外乎需要三点：</p><ul><li><p>目标：要有具体的目标，包括步骤，愿景</p></li><li><p>到达目标：确定目标之后便是用尽全力完成目标。</p></li><li><p>做出榜样：只有做出榜样才能带领团队实现目标，只有自己能拥有绝对的自信才能够带领团队纠正错误和到达正确的目标</p></li></ul><h1 id="绝对自信"><a href="#绝对自信" class="headerlink" title="绝对自信"></a>绝对自信</h1><p>绝对自信是医生走向成熟的标志，哪怕经验再成熟的人站上手术台的时候依然会紧张，所以想象完美的结果很重要，作者在不断想象病人和家属高高兴兴走出医院的画面，提升自己的自信同时让自己不断成熟。当从渴望成功到肯定自己不会失败不再畏惧死亡的时候，大概是医生成熟的标志。</p><p>也就是因为绝对的自信，作者在36岁完成了世界上第一例胃网膜右动脉搭桥手术，并且在40岁归国之后收到全国的关注，并且被越来越多的患者拜托拯救。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这本书最大的受众大概还是医学生吧，我认为拥有学医治病救人的这样崇高理想的人所应该仔细研读的一本书。</p><p>看完这本书的另一个感受是：啊！原来医生也是普通人。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      医生,护士，未来
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://whitestore.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="书籍" scheme="https://whitestore.top/tags/%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>LSM-Tree - LevelDb了解和实现</title>
    <link href="https://whitestore.top/2022/05/05/leveldblj/"/>
    <id>https://whitestore.top/2022/05/05/leveldblj/</id>
    <published>2022-05-05T06:31:32.000Z</published>
    <updated>2022-06-02T10:09:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LSM-Tree-LevelDb了解和实现"><a href="#LSM-Tree-LevelDb了解和实现" class="headerlink" title="LSM-Tree - LevelDb了解和实现"></a>LSM-Tree - LevelDb了解和实现</h1><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>自从[[《数据密集型型系统设计》LSM-Tree VS BTree]]这篇文章完成之后，对于LSM-Tree这种结构非常感兴趣，于是趁热打铁在之后的几天静下心来研究了一下LevelDB的具体实现，最终阅读了一下源代码。</p><p>本文涉及了LevelDB的基础功能和相关数据结构的介绍，最后讲述LevelDB中至关重要的读写操作，通过设计数据结构和读写操作的讲解，相信读者可以自行解答为什么LevelDB可以做到极为高效的读写操作，并且比查询操作要远远优秀。</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Levledb是Google的两位Fellow （Jeaf Dean和Sanjay Ghemawat）设计和开发的嵌入式K-V系统，读写性能非常彪悍，官方网站报道其写性能40万/s，读性能达到6万/s，写操作要远快于读操作。</p><blockquote><p>如果对于这个数据结构感兴趣，可以访问下面的github:<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9sZXZlbGRi" title="https://github.com/google/leveldb">https://github.com/google/leveldb<i class="fa fa-external-link"></i></span></p></blockquote><h1 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h1><p>需要注意的是Level-DB不仅是LSM-Tree日志存储结构的代表作品，同时也是对于Bigtable中SSTable的实践和扩展。</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>首先底层的基础数据结构是LSM-Tree，同时存储结构为Key-Value形式，但是在此基础上进行了一些调整，比如让数据存储在磁盘并且保证数据的<strong>顺序读写</strong>，为了高效读取设计了大小树结构，也就是将LSM- Tree一分为二，大的存磁盘，小的常驻内存，两者共同维护同一个。</p><p>当数据不断写入导致树不断的膨胀，此时为了频繁的磁盘写入对于数据肯定会有很大的影响，索引LevelDb将树在此基础上又拆分了多层，当一层的数据到达一定量的时候就往下一层归并，最终形成一颗自上而下的增长树。LevelDb的Level就是这么来的。</p><p>下面是这种特殊结构的设计图：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204162304929.png" alt=""></p><h2 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h2><ul><li>键和值是任意字节数组。</li><li>数据按key排序存储。</li><li>调用者可以提供自定义比较函数来覆盖排序顺序。</li><li>基本运算是<code>Put(key,value)</code>, <code>Get(key)</code>, <code>Delete(key)</code>.</li><li>可以在一个原子批处理中进行多项更改。</li><li>用户可以创建临时快照以获得一致的数据视图。</li><li>支持对数据进行前向和后向迭代。</li><li><span class="exturl" data-url="aHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL3NuYXBweS8=" title="https://google.github.io/snappy/">使用Snappy 压缩库<i class="fa fa-external-link"></i></span>自动压缩数据。</li><li>外部活动（文件系统操作等）通过虚拟接口中继，因此用户可以自定义操作系统交互。</li><li>系统可移植性很强，因为底层使用了C++编写。</li></ul><h2 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h2><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204162304981.png" alt=""></p><p>下面是各个组件介绍：</p><ul><li><p><strong>Memtable</strong>：LevelDB在写入数据的时候并不会直接写入磁盘，而是和多数的数据库工具一样先写入到内存的数据结构，内存数据结构通过跳表实现，新的数据会首先写入这里，<strong>Memtable</strong>负责管理所有的Key数据，这种数据结构效率可以比拟二叉查找树，绝大多数操作的时间复杂度为O(log n)。</p></li><li><p><strong>Log</strong>：Level-DB是典型的日志存储结构形式，在写入<strong>Memtable</strong>之前首先写入日志文件，对于写入日志以单纯的<strong>追加</strong>形式进行写入，这一点相比Btree相关的注重事务的复杂日志维护要简单不少，Level-DB和多数的LSM-Tree没有太大区别，日志的主要作用是数据库崩溃之后进行数据恢复，比如当程序出现下面的问题之后可以通过Log进行数据恢复：</p></li></ul><ol><li>写log期间进程异常。</li><li>写log完成，写内存未完成。</li><li>write动作完成（即log、内存写入都完成）后，进程异常。</li><li>Immutable memtable持久化过程中进程异常。</li><li>其他压缩异常（较为复杂，首先不在这里介绍）。</li></ol><ul><li><strong>Immutable Memtable</strong>：顾名思义不可变的内存数据结构，当内存数据结构数据满了之后就需要触发数据合并的操作，此时需要停掉数据读写并且对数据进行压缩。</li></ul><blockquote><p>不可变的数据结构其实是通过简单的C++ 锁机制实现的，不需要额外的维护锁对象控制。</p></blockquote><ul><li><p><strong>SST文件：</strong>：磁盘数据存储文件，分为Level 0到Level N多层，每一层包含多个SST文件；单层SST文件总量随层次增加成倍增长。SST文件本身是不可被修改的，这是Level-DB 设计哲学的一环，通过追加的和定期合并文件的方式实现了“删除”的操作，同时在读取的时候通过特殊的标记来判断更新还是删除操作，借此保证获取到最新的数据，这些内容在源代码中都能很好的发现，在后续的文章中会详细的解释，这里只需要有个大概的概念即可。</p></li><li><p><strong>Manifest文件</strong>： Level-Db存在版本控制的概念，版本信息的差别主要来自于每一层维护的元信息的差别。Manifest文件在整个系统中十分关键，不仅维护了最大key和最小key，Manifest文件中还记录SST文件在不同Level的分布，同时MainFest主要管理SST文件的层级，在进行<strong>合并</strong>操作的时候需要依赖Mainfest文件中的元信息完成合并的关键步骤。</p></li></ul><blockquote><p>元信息包括：(1)最大Key值，(2)最小Key值，(3)文件大小。</p></blockquote><ul><li><strong>Current文件</strong>：LevelDB启动时的首要任务就是找到当前的Manifest，而Manifest可能有多个，Current文件记录了<strong>Manifest文件</strong>相关的文件名。</li></ul><h1 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h1><p>在了解源代码之前我们从数据库的读写操作进行分析。如果了解Btree和事务型数据库的生态就会发现两者的差别是非常大的，Level-DB 的最大优点是读写速度要优秀于查询动作，由于不需要事务所以他的性能要比Btree的高非常多。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204162028858.png" alt=""></p><p>可以看到整个Level-DB分为两次写操作，头一次是写入log，接着才是写入记录数据，但是写入记录的数据并不会立刻写到磁盘，而是通过一些触发机制完成。</p><p>由于记录日志的方式够简单直接，所以Level-DB可以拥有很好的写入性能，如果在用户写入完成但是数据没入盘的时候突然发生系统宕机没有影响，因为数据压根没有写入硬盘，只要再次读日志还原相关操作即可。</p><h2 id="写操作实现"><a href="#写操作实现" class="headerlink" title="写操作实现"></a>写操作实现</h2><p>LevelDb对外提供了1）Put2）Delete两种接口，但是更新的操作和删除的操作可以看作是同一个操作，一个Delete操作会被转换成一个value为空的Put操作。</p><p>另外LevelDB 专门提供了批量操作的工具Batch完成批量操作的动作，为了保证数据的完整性，内部会通过加锁的方式实现原子操作。</p><p>Batch的整体结构大致如下：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204162042324.png" alt=""></p><blockquote><p>注意：这个结构图并不完整，在源代码里面还有其他的信息，这里简化了部分数据</p></blockquote><p>批量操作的每一个操作项都是通过类似上面的结构组成，通过type来标记整个记录的数据项类型，在记录key的内容之前，会记录key的长度，同样记录value的值之前会记录整个value的长度。</p><p>另外batch中还会维护一个size值表示key+value长度的总和，以及每条数据项额外的8个字节表示，这8个字节标识用于存储一条数据项额外的一些信息。</p><p><strong>原子性</strong>操作：</p><p>写操作的原子性体现日志记录操作上，一条日志记录的所有内容代表了一次写操作，这也是日志的写入最小单位。</p><p>既然是日志写入就会出现下面两种情况：</p><ul><li>未开始写入或者日志写一半断电。</li><li>日志写入完成真实数据没有变动。</li></ul><p><strong>合并写入</strong>操作：<br>#LevelDb合并写入操作<br>合并写入是对于日志问题的最大挑战， 为了保证操作原子性，并发写入的时候只有一个线程允许操作日志和追加数据，但是这样显然会影响写入的性能并且导致多线程阻塞等待，为了提高写入的性能，对于多线程频繁的写入的操作进行“合并”，将单一线程对于同一个日志的多次操作进行合并。</p><p>整个合并写入的流程如下：<br><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204162252652.png" alt=""></p><ul><li>第一次写入获取写入锁。</li><li>写操作没有达到出发合并写入的阈值，并且存在其他写入线程等待的情况下，将会“帮忙”把其他线程的写操作和自己进行合并。</li><li>如果到达了合并写入的阈值，并且没有其他线程等待的时候，把所有的内容合并写入到日志文件，然后再存储到数据库当中。</li><li>通知其他“被帮忙”的线程我已经帮你们把活干完了并且把操作结果告诉你们，同时释放写锁给下一个访问线程。</li></ul><p>对于其他的线程来说合并写入的操作类似下面的情况：</p><ul><li>等待上一个锁的持有者完成合并写入操作，如果操作成功接受结果并且返回。</li><li>如果上一个线程操作失败或者没有进行表明当前的锁可以进行合并写入了，则自动接任务继续尝试合并写入的操作。</li><li>如果还是没有合并完成继续等待锁和合并结果。</li></ul><p>通过这样的处理可以发现无论那个线程进来都可以尝试帮其他线程工作，但是仅限于和自己的操作相关的内容可以尝试合并。</p><h2 id="读操作实现"><a href="#读操作实现" class="headerlink" title="读操作实现"></a>读操作实现</h2><p>读操作的实现通过下面两种方式完成：</p><ul><li>通过<code>get</code>接口完成数据的获取。</li><li>为了提高读取的效率，会通过快照对于当前读到的数据进行缓存，最终通过快照的<code>get</code>接口完成数据获取。</li></ul><blockquote><p>从这里来看，快照即是缓存也是代理。</p></blockquote><p>其实两个操作类似，只不过一次读操作之前加入了快照，但是快照读到的数据不会因为后续的记录操作出现改动。</p><p>快照类似数据库某一个时刻状态的一个拷贝，对于大量的读操作来说可以减轻数据查找的压力。<br><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204162251954.png" alt=""></p><p>这里可能会存在疑问，读取的快照出现更新的时候会出现什么情况？<br>这里就必须要简单描述一下快照的实现了，快照的实现是通过 <strong>乐观锁</strong> 的方式实现的，内部通过维护一个 <strong>版本号</strong>的方式记录同一个Key的操作结果，同时一条记录有唯一的序列号，序列号在每次记录变动的时候不断+1，意味着序列号越大记录的值越新。</p><p>也就是说通过<strong>序列号</strong>和<strong>版本号</strong>这两个值可以模拟整个数据项的变更状态，同时为了保证快照的有效性，可以通过版本号和序列号检查是否对应，反过来说，如果当前序列号超过快照的序列号，则直接“掩盖”保证快照不会读到最新的数据。</p><blockquote><p>如果你了解Mysql的InnoDB中的MVCC机制，那么相信更好理解。</p></blockquote><p><strong>读取</strong>的步骤：</p><ul><li>在memtable中获取指定Key，如果数据符合条件则结束查找。</li><li>在Imumemtable中查找指定Key，如果数据符合条件则结束查找。</li><li>按低层至高层的顺序在level i层的sstable文件中查找指定的key，若搜索到符合条件的数据项就会结束查找，否则返回Not Found错误，表示数据库中不存在指定的数据。<br><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204162252669.png" alt=""></li></ul><blockquote><p>在LevelDB的每一层扫描SSTable 是按照顺序扫描的方式进行查找的（中间不会跳过）。<br>Level0层最为特殊，因为SSTable之间的Key会出现重合的情况，所以这时候会根据文件编号更大的作为查找参考<br>PS：为什么要文件编号更大的数据作为参考，因为序列号是递增的，所以更大的文件编号会存在更新的数据。<br>Level N层的数据，Key之间不会存在重合，并且由于每一层通过Mainfest的元数据找到最大key和最小key进行快速的定位操作，最终每一层只需要扫描一个SSTable就可以往下查找。</p></blockquote><p>在memory db或者sstable的查找过程中，需要根据指定的序列号拼接一个<strong>internalKey</strong>，如果查找用户key一致且seq号<strong>不大于</strong>指定seq的数据。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本节内容简单介绍了LevelDB，并且介绍了内部几个重要的数据结构内容，之后介绍了有关Level读写操作的细节，这些内容的理解对于后续介绍源代码是一个前提和铺垫。</p><p>在介绍完数据结构和读写操作的大致流程之后，下一节将会深入具体的源代码进行拓展介绍。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      关于LevelDB的拓展
    
    </summary>
    
    
      <category term="数据库-LevelDB" scheme="https://whitestore.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-LevelDB/"/>
    
    
      <category term="LevelDB" scheme="https://whitestore.top/tags/LevelDB/"/>
    
  </entry>
  
  <entry>
    <title>三高Mysql - Mysql索引和查询优化（偏实战部分）</title>
    <link href="https://whitestore.top/2022/04/06/suoyinshizhan/"/>
    <id>https://whitestore.top/2022/04/06/suoyinshizhan/</id>
    <published>2022-04-06T06:08:47.000Z</published>
    <updated>2022-06-02T10:09:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三高Mysql-Mysql索引和查询优化（偏实战部分）"><a href="#三高Mysql-Mysql索引和查询优化（偏实战部分）" class="headerlink" title="三高Mysql - Mysql索引和查询优化（偏实战部分）"></a>三高Mysql - Mysql索引和查询优化（偏实战部分）</h1><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>​    实战部分挑选一些比较常见的情况，事先强调个人使用的是<strong>mysql 8.0.26</strong>，所以不同版本如果出现不同测试结果也不要惊讶，新版本会对于过去一些不会优化的查询进行优化。</p><p>​    实战部分承接上一篇文章：<span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDA0MTY2MTQwMw==" title="https://segmentfault.com/a/1190000041661403">三高 Mysql - Mysql 索引和查询优化（偏理论部分）<i class="fa fa-external-link"></i></span></p><a id="more"></a><h1 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h1><p>​    这里还是要再啰嗦一遍，所有的数据库和表均来自官方的<strong>sakila-db</strong>，作为学习和熟悉mysql数据库操作非常好。</p><h2 id="sakila-db"><a href="#sakila-db" class="headerlink" title="sakila-db"></a>sakila-db</h2><p>​    sakila-db是什么？国外很火的一个概念，指的是国外电影租赁市场外国人使用租赁的方式进行电影的观看，过去十分受外国人的喜欢，这里拿出来介绍是因为后续的内容都用到了这个案例，所以我们需要提前把相关的环境准备好，从如下地址进行下载：</p><p>​    下载地址：<span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy9pbmRleC1vdGhlci5odG1s" title="https://dev.mysql.com/doc/index-other.html">https://dev.mysql.com/doc/index-other.html<i class="fa fa-external-link"></i></span></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204061302118.png" alt=""></p><h2 id="work-bench"><a href="#work-bench" class="headerlink" title="work-bench"></a>work-bench</h2><p>​    work-bench是官方开发的数据库关系图的可视化工具，使用官方案例的具体关系图展示效果如下，通过这些图可以看到Sakila-db之间的大致关系：</p><blockquote><p>work-bench 是免费软件，下载地址如下：</p><p><span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2Rvd25sb2Fkcy93b3JrYmVuY2gv" title="https://dev.mysql.com/downloads/workbench/">https://dev.mysql.com/downloads/workbench/<i class="fa fa-external-link"></i></span></p></blockquote><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204061302376.png" alt=""></p><p>​    </p><p>​    安装<code>workbench</code>和下载<code>sakila-db</code>的过程这里不做记录，在运行的时候需要注意先建立一个数据库运行<code>Sheme</code>文件，然后执行data的sql文件，最终借助navicat中查看数据和表结构关系：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204061302205.png" alt=""></p><p>​    </p><h1 id="正文部分"><a href="#正文部分" class="headerlink" title="正文部分"></a>正文部分</h1><h2 id="where查询太慢怎么办？"><a href="#where查询太慢怎么办？" class="headerlink" title="where查询太慢怎么办？"></a>where查询太慢怎么办？</h2><p>​    遇到where查询太慢，我们第一步是需要分析数据类型的组成以及数据表的设置是否合理，其次我们可以使用<code>explain</code>对于查询语句进行分析，使用方式十分简单在需要优化的查询语句前面添加<code>explain</code>语句，对于所有的查询来说，覆盖索引的查找方式是最优解，因为覆盖索引不需要回表查数据。</p><p>​    覆盖索引：覆盖索引是查询方式，他不是一个索引，指的是在查询返回结果的时候和使用的索引是同一个，这时候可以发现他压根不需要回表，直接查辅助索引树就可以得到数据，所以覆盖索引的查询效率比较高。</p><blockquote><p>如何使用sql语句查看某一个表的建表语句：</p><p>回答：使用<code>show create table 表名称</code>即可。 </p></blockquote><p>​    </p><p>​    那么什么情况下会使用覆盖索引：</p><ol><li>查询字段为辅助索引的字段或者聚簇索引的字段。</li><li>符合<strong>最左匹配原则</strong>，如果不是最左匹配则不能走索引。</li></ol><p>​    我们使用上面提到的<code>sakila-db</code>进行实验，这里可以使用<code>inventory</code>表作为实验，但是这个表需要进行一些调整，下面请看具体的sql：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`inventory_test`</span> (</span><br><span class="line">  <span class="string">`inventory_id`</span> mediumint <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`film_id`</span> <span class="built_in">smallint</span> <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`store_id`</span> <span class="built_in">tinyint</span> <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`last_update`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`inventory_id`</span>),</span><br><span class="line">  <span class="comment">-- KEY `idx_fk_film_id` (`film_id`),</span></span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_store_id_film_id`</span> (<span class="string">`store_id`</span>,<span class="string">`film_id`</span>)</span><br><span class="line">  <span class="comment">-- CONSTRAINT `fk_inventory_film` FOREIGN KEY (`film_id`) REFERENCES `film` (`film_id`) ON DELETE RESTRICT ON UPDATE CASCADE,</span></span><br><span class="line">  <span class="comment">-- CONSTRAINT `fk_inventory_store` FOREIGN KEY (`store_id`) REFERENCES `store` (`store_id`) ON DELETE RESTRICT ON UPDATE CASCADE</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">4582</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COLLATE</span>=utf8mb4_0900_ai_ci;</span><br></pre></td></tr></table></figure><p>​    我们将原始的sql建表语句只保留一个辅助索引，比如在上面的语句中删除了<code>idx_fk_film_id</code>索引，下面删除这个索引之后的实验效果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> inventory_test <span class="keyword">where</span> film_id = <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 案例1. 不符合最左原则不走索引 </span></span><br><span class="line"><span class="comment">-- 1  SIMPLE  inventory_test    ALL          1  100.00  Using where</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> inventory_test <span class="keyword">where</span> store_id = <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 案例2: 使用了辅助索引（联合索引）：</span></span><br><span class="line"><span class="comment">-- 1  SIMPLE  inventory_test    ref  idx_store_id_film_id  idx_store_id_film_id  1  const  1  100.00  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> inventory_id,film_id,store_id <span class="keyword">from</span> inventory_test <span class="keyword">where</span> store_id = <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 案例3:  正常使用索引 </span></span><br><span class="line"><span class="comment">-- 1 SIMPLE  inventory_test    ref  idx_store_id_film_id  idx_store_id_film_id  1  const  1  100.00  Using index</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> film_id,store_id <span class="keyword">from</span> inventory_test <span class="keyword">where</span> store_id = <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 案例4:  覆盖索引 </span></span><br><span class="line"><span class="comment">-- 1  SIMPLE  inventory_test    ref  idx_store_id_film_id  idx_store_id_film_id  1  const  1  100.00  Using index</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> film_id,store_id <span class="keyword">from</span> inventory_test <span class="keyword">where</span> film_id = <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 案例5: 正常使用索引，但是type存在区别 </span></span><br><span class="line"><span class="comment">-- 1  SIMPLE  inventory_test    index  idx_store_id_film_id  idx_store_id_film_id  3    1  100.00  Using where; Using index</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> inventory_id,film_id,store_id <span class="keyword">from</span> inventory_test <span class="keyword">where</span> film_id = <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 案例6: 使用索引返回结果，但是type存在区别 </span></span><br><span class="line"><span class="comment">-- 1  SIMPLE  inventory_test    index  idx_store_id_film_id  idx_store_id_film_id  3    1  100.00  Using where; Using index</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> inventory_id,film_id,store_id <span class="keyword">from</span> inventory_test <span class="keyword">where</span> store_id = <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 案例7: 覆盖索引 </span></span><br><span class="line"><span class="comment">-- 1  SIMPLE  inventory_test    ref  idx_store_id_film_id  idx_store_id_film_id  1  const  1  100.00  Using index</span></span><br></pre></td></tr></table></figure><p>​    案例1和案例2是较为典型的<strong>索引最左匹配原则</strong>的错误使用反面教材，也是很多新手建立索引但是可能用错的陷阱之一，最左匹配原则指的是where条件需要从建立索引的最左列开始进行搜索，可以看到这里的星号和建表的时候字段的顺序是一样的，也就是<code>inventory_id</code>，<code>film_id,store_id</code>，<code>last_update</code>，所以是虽然是<code>select *</code>但是是正常走索引的。</p><p>（实际干活时候千万不要这么做，这里是为了演示偷懒而已）</p><blockquote><p>不用星号我使用<strong>乱序</strong>的列查询会怎么样，其实这时候如果你把查询列的数据换一下会…..没啥影响，<strong>随意调换查询列顺序依然可以走索引</strong>。</p></blockquote><p>​    接下来是案例3 - 案例7的几个查询，这几个查询意图解释的是针对覆盖索引使用的细节问题，在上面的测试案例语句当中可以看到案例4由于查询的结果和where条件都是使用了索引的，所以最终mysql使用了完整的覆盖索引，同时符合联合索引的最左匹配原则，所以查询的效率达到了<code>ref</code>级别（这个级别暂时简单理解就是非常快就行）。</p><p>​    接着案例5又把where条件换了一下，可以看到虽然还是走了索引，但是效率一下子就低了下来，因为他不符合最左匹配原则，另外这个案例5的查询级别可以理解为它需要把整个辅助索引也就是联合索引的树扫完再去进行where筛选，效率自然就不如直接检索排序索引值快了，但是index这个级别还是比ALL这个龟速快不少。</p><p>​    理解了上面的这一层意思，再来理解案例6和7就很简单了，可以看到只多了一个主键列查询。</p><p>​    这里读者可能会觉得你这上面不是说返回结果全是索引列才会覆盖么，怎么加入了主键列还是奏效呢？主键不是在聚簇索引上嘛不是需要回表么？其实这两个问题很好回答，因为辅助索引当中key存储的确实是索引列的值，但是他的索引值放的是主键ID，当mysql在搜索索引列的时候发现这里多了一个列，但是又发现这个列是主键，所以最后发现可以直接通过联合索引直接返回结果不需要回表，所以这样覆盖索引的条件同样是成立的。</p><p>​    如果读者不清楚查询<code>explain</code>结果列代表的含义，可以参考下面的内容对比：</p><ul><li>id: 首先，一个select就会出现一个id, 通常在复杂的查询里面会包含多张表的查询，比如join, in等等</li><li>select_type：这个表示的是查询的类型</li><li>table：表名称</li><li>partitions：这个表示表空间，分区的概念</li><li><strong>type</strong> : 比如查询的优化等级,  const, index, all，分别代表了聚簇索引，二级索引(辅助索引)，全表扫描的查询搜索方式</li><li>Possiblekeys：和type一样确定访问方式，确定有哪些索引可以选择，</li><li>key：确定有哪些可以提供选择，同时提供索引的对应长度</li><li>key_len： 表示的是索引的长度</li><li>ref： 等值匹配的时候出现的一些匹配的相关信息</li><li>Rows： 预估通过所索引或者别的方式读取多少条数据</li><li>filtered：经过搜索条件过滤之后的剩余数据百分比。</li><li>extra：额外的信息不重要，主要用于用户判定查询走了什么索引。</li></ul><p>总结</p><p>通过上面的案例我们可以从下面的角度思考来如何提升索引查询速度：</p><ul><li>使用<strong>覆盖索引</strong>查询方式提高效率，再次强调覆盖索引不是索引是优化索引查询一种方式。</li><li>如果数据不只使用索引列那么就构不成覆盖索引。</li><li>可以优化sql语句或者优化联合索引的方式提高覆盖索引的命中率。</li></ul><h2 id="如何确认选择用什么索引？"><a href="#如何确认选择用什么索引？" class="headerlink" title="如何确认选择用什么索引？"></a>如何确认选择用什么索引？</h2><p>​    这里涉及一个索引基数（cardinality）的问题，索引基数是什么，其实就是利用算法和概率学统计的方式确定最优化的索引方案，这个值可以通过<code>show index from 表名</code>的方式进行获取，比如下面的200和121就是<strong>索引基数（cardinality）</strong>。</p><blockquote><p>因为索引基数的存在如果索引不符合我们到使用预期可以尝试强制使用某索引。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; show index from actor;</span><br><span class="line">actor  <span class="number">0</span>  PRIMARY  <span class="number">1</span>  actor_id  A  <span class="number">200</span>        BTREE      YES  </span><br><span class="line">actor  <span class="number">1</span>  idx_actor_last_name  <span class="number">1</span>  last_name  A  <span class="number">121</span>        BTREE      YES</span><br></pre></td></tr></table></figure><p>​    索引基数的定义官方文档的介绍：</p><p>​    下面一坨东西简单来说就是mysql会根据基数的数值根据一定的算法选择使用索引，但是有时候如果查询不能符合预期要求就需要强制使用索引了。</p><blockquote><p>表列中不同值的数量。当查询引用具有关联索引的列时，每列的基数会影响最有效的访问方法。<br />例如，对于具有唯一约束的列，不同值的数量等于表中的行数。如果一个表有一百万行，但特定列只有 10 个不同的值，<br />则每个值（平均）出现 100,000 次。 SELECT c1 FROM t1 WHERE c1 = 50 等查询因此可能会返回 1 行或大量行，<br />并且数据库服务器可能会根据 c1 的基数以不同方式处理查询。<br /><br />如果列中的值分布非常不均匀，则基数可能不是确定最佳查询计划的好方法。例如，SELECT c1 FROM t1 WHERE c1 = x;<br />当 x=50 时可能返回 1 行，当 x=30 时可能返回一百万行。在这种情况下，您可能需要使用索引提示来传递有关哪种<br />查找方法对特定查询更有效的建议。<br /><br />基数也可以应用于多个列中存在的不同值的数量，例如在复合索引中。<br />参考：<strong>列、复合索引、索引、索引提示、持久统计、随机潜水、选择性、唯一约束</strong>。</p></blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">原文：</span><br><span class="line">The number of different values in a table column. When queries refer to columns that have an </span><br><span class="line">associated index, the cardinality of each column influences which access method is most </span><br><span class="line">efficient. For example, for a column with a unique constraint, the number of different </span><br><span class="line">values is equal to the number of rows in the table. If a table has a million rows but </span><br><span class="line">only 10 different values for a particular column, each value occurs (on average) 100,000 times.</span><br><span class="line"> A query such as SELECT c1 FROM t1 WHERE c1 = 50; thus might return 1 row or a huge number of </span><br><span class="line"> rows, and the database server might process the query differently depending on the cardinality </span><br><span class="line"> of c1.</span><br><span class="line"></span><br><span class="line">If the values in a column have a very uneven distribution, the cardinality might not be </span><br><span class="line">a good way to determine the best query plan. For example, SELECT c1 FROM t1 WHERE c1 = x;</span><br><span class="line"> might return 1 row when x=50 and a million rows when x=30. In such a case, you might need </span><br><span class="line"> to use index hints to pass along advice about which lookup method is more efficient for a </span><br><span class="line"> particular query.</span><br><span class="line"></span><br><span class="line">Cardinality can also apply to the number of distinct values present in multiple columns, </span><br><span class="line">as in a composite index.</span><br><span class="line"></span><br><span class="line">See Also column, composite index, index, index hint, persistent statistics, random dive,</span><br><span class="line"> selectivity, unique constraint.</span><br></pre></td></tr></table></figure><p>​    </p><p>​    如何让sql强制使用索引</p><p>​    可以使用from表之后接条件语句：<code>force index(索引)</code> 的方式进行处理，使用强制索引的情况比较少，除非优化器真的选择了不符合预期的优化规则并且严重影响查询性能，使用强制索引的案例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> actor <span class="keyword">force</span> <span class="keyword">index</span>(idx_actor_last_name);</span><br></pre></td></tr></table></figure><h2 id="count-慢的原因是什么？"><a href="#count-慢的原因是什么？" class="headerlink" title="count()慢的原因是什么？"></a>count()慢的原因是什么？</h2><p>count函数不用多介绍，作用是查询结果的行数，但是需要注意优化器在处理过程中会<strong>比对并且排除掉结果为null的值</strong>的数据，这意味着在行数很大的时候如果使用不正确count会因为比对数据操作进而降低查询效率。</p><p>所以这里我们只要记住一个特定的规则，那就是只要是涉及行数的查询，那就使用<code>select(*)</code>，原因仅仅是mysql官方针对这个做了专门的优化，也不需要去纠结为什么官方要给<code>select(*)</code>做优化，只能说<strong>约定大于配置</strong>，下面是常见的查询性能之间的对比：</p><ul><li>count(非索引字段)：理论上是最慢的，因为对于每一行结果都要判断是否为null。</li><li>count(索引字段)：虽然走了索引，但是依然需要对每一行结果判断是否为null。</li><li>count(1)：虽然不涉及字段了，但是这种方式依然需要对1进行判断是否为null。</li><li><strong>count(*)：Mysql官方进行优化，查询效率最快，只需要记住这种方式即可</strong>。</li></ul><h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><p>索引下推实现版本为Mysql5.6以上。</p><p>作用：本质上是为了减少辅助索引（或者说二级索引）<strong>回表次数</strong>的一种优化手段。</p><p>案例：请看下面的建表语句，这里比较关键的是建立了<code>store_id</code>和<code>film_id</code>的联合索引 。</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202203211327993.png" alt=""></p><p>​    以下面的SQL语句为例，如果是5.6之前的版本虽然他是覆盖索引的查询方式但却是<strong>不能使用索引</strong>的，数据进过索引查找之后虽然store_id是顺序排序的但是film_id是乱序的，在索引检索的时候由于没有办法顺序扫描（如果不清楚索引组织结构可以多看几遍B+树索引构造） 它需要一行行使用主键回表进行查询，查询实际需要使用每一行的<code>inentory_id</code>回表4次去匹配film_id是否为3。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> inventory_3 <span class="keyword">where</span> store_id <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>) <span class="keyword">and</span> film_id = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204061303013.png" alt=""></p><p>​    按照人的思维看起来是很不合理的，因为我们可以发现按照正常的逻辑有一种搜索的方法是通过“跳跃“索引的方式进行扫描，当扫描到索引列如果不符合条件，则直接跳跃索引到下一个索引列，有点类似我们小时候”跳房子“方式来寻找自己需要的沙袋（索引数据）。</p><p>​    <strong>那么索引下推是如何处理上面这种情况的呢</strong>？虽然film_id是没有办法顺序扫描的也不符合索引的排列规则，但是发现可以根据遍历film_id汇总索引之后再回表查呀！比如根据查询条件搜索遍历找到film=3之后再根据二级索引列对应的主键去查主索引，这时候只需要一次回表就可以查到数据，此时原本应该根据每个二级索引的主键值进行回表变为遍历索引并找到索引值之后再回表，最终达到减少回表次数的效果，这也是前面为什么说索引下推是为了减少了回表的次数的答案。</p><p>​    索引下推的开启和关闭可以参考如下命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 索引下推变量值：</span></span><br><span class="line">mysql&gt; select @@optimizer_switch\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@optimizer_switch: index_merge=on,index_merge_union=on,index_merge_sort_union=on,index_merge_intersection=on,engine_condition_pushdown=on,index_condition_pushdown=on,mrr=on,mrr_cost_based=on,block_nested_loop=on,batched_key_access=off,materialization=on,semijoin=on,loosescan=on,firstmatch=on,duplicateweedout=on,subquery_materialization_cost_based=on,use_index_extensions=on,condition_fanout_filter=on,derived_merge=on</span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 关闭索引下推</span></span><br><span class="line"><span class="keyword">set</span> optimizer_switch=<span class="string">'index_condition_pushdown=off'</span>;</span><br><span class="line"><span class="comment">-- 开启索引下推</span></span><br><span class="line"><span class="keyword">set</span> optimizer_switch=<span class="string">'index_condition_pushdown=on'</span>;</span><br></pre></td></tr></table></figure><h2 id="松散索引和紧凑索引"><a href="#松散索引和紧凑索引" class="headerlink" title="松散索引和紧凑索引"></a><strong>松散索引和紧凑索引</strong></h2><p>​    关于松散索引和紧凑索引可以看下面两个文档对比参考阅读：</p><p>​    <span class="exturl" data-url="aHR0cHM6Ly93d3cuZG9jczRkZXYuY29tL2RvY3MvemgvbXlzcWwvNS43L3JlZmVyZW5jZS9ncm91cC1ieS1vcHRpbWl6YXRpb24uaHRtbA==" title="https://www.docs4dev.com/docs/zh/mysql/5.7/reference/group-by-optimization.html">MySql 中文文档 - 8.2.1.15 GROUP BY 最佳化 | Docs4dev<i class="fa fa-external-link"></i></span></p><p>​    <span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy9yZWZtYW4vOC4wL2VuL2dyb3VwLWJ5LW9wdGltaXphdGlvbi5odG1s" title="https://dev.mysql.com/doc/refman/8.0/en/group-by-optimization.html">MySQL :: MySQL 8.0 Reference Manual :: 8.2.1.17 GROUP BY Optimization<i class="fa fa-external-link"></i></span></p><p>​    松散索引和紧凑索引的概念不是特别好理解，松散索引和紧凑索引实际上就是当MySQL 利用索引扫描来实现<code>GROUP BY</code>的时候，<strong>并不需要扫描所有满足条件的索引键即可完成操作得出结果</strong>，仅仅处理的情况细节不同。</p><p>​    过去Mysql对于<code>group by</code>操作是构建临时表并且在临时表上操作，在使用索引的情况下，分组查询是可以走索引的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> last_name <span class="keyword">from</span> actor  <span class="keyword">GROUP</span> <span class="keyword">BY</span> last_name</span><br><span class="line"><span class="comment">-- 1SIMPLEactorindexidx_actor_last_nameidx_actor_last_name182200100.00Using index</span></span><br></pre></td></tr></table></figure><p>​    由于<code>group by</code> 操作和<code>order by</code>操作不走索引的时候可能会产生临时表，同时<code>group by</code> 操作拥有和<code>order by</code> 类似的排序操作，有时候我们分组查询不止一个字段，所以可能会出现多列索引情况，所以此时mysql对于多列联合索引分组查询进一步优化，提供了松散索引和紧凑索引多概念，</p><p>​    松散索引在官方有下面的定义：</p><ol><li>当彻底使用索引扫描实现<code>group by</code>操作的时候，只需要使用部分的索引列就可以完成操作</li><li>虽然Btree的二级索引内部是排序并且要求索引是顺序访问的，但是对于group by最大的优化是扫描这种顺序索引的时候<strong>where条件没必要完全贴合所有索引key</strong>，</li></ol><p>​    上面定义有两个个关键词：<strong>彻底</strong>和<strong>不完全</strong>，where条件没必要完全贴合索引键。为了更好理解我们这里使用了官方给的例子，假设在 table<code>t1(c1,c2,c3,c4)</code>上有一个索引<code>idx(c1,c2,c3)</code>。松散索引扫描访问方法可用于以下查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 可以不使用所有索引字段，可以走联合索引</span></span><br><span class="line"><span class="keyword">SELECT</span> c1, c2 <span class="keyword">FROM</span> t1 <span class="keyword">GROUP</span> <span class="keyword">BY</span> c1, c2;</span><br><span class="line"><span class="comment">-- 去重操作内部也会进行隐式的分组行为</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> c1, c2 <span class="keyword">FROM</span> t1;</span><br><span class="line"><span class="comment">-- 分组的极值查询可以使用松散索引，因为c2和c1依然有序</span></span><br><span class="line"><span class="keyword">SELECT</span> c1, <span class="keyword">MIN</span>(c2) <span class="keyword">FROM</span> t1 <span class="keyword">GROUP</span> <span class="keyword">BY</span> c1;</span><br><span class="line"><span class="comment">-- 分组前的where 条件</span></span><br><span class="line"><span class="keyword">SELECT</span> c1, c2 <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c1 &lt; const <span class="keyword">GROUP</span> <span class="keyword">BY</span> c1, c2;</span><br><span class="line"><span class="comment">-- 对于c3的极值操作依然和c1,c2构成索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(c3), <span class="keyword">MIN</span>(c3), c1, c2 <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c2 &gt; const <span class="keyword">GROUP</span> <span class="keyword">BY</span> c1, c2;</span><br><span class="line"><span class="comment">-- 支持范围查询的同时走松散索引</span></span><br><span class="line"><span class="keyword">SELECT</span> c2 <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c1 &lt; const <span class="keyword">GROUP</span> <span class="keyword">BY</span> c1, c2;</span><br><span class="line"><span class="comment">-- 最后一列等值查询依然可以视为松散索引</span></span><br><span class="line"><span class="keyword">SELECT</span> c1, c2 <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c3 = const <span class="keyword">GROUP</span> <span class="keyword">BY</span> c1, c2;</span><br><span class="line"><span class="comment">-- 松散索引可以作用于下面的查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> c1), <span class="keyword">SUM</span>(<span class="keyword">DISTINCT</span> c1) <span class="keyword">FROM</span> t1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> c1, c2), <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> c2, c1) <span class="keyword">FROM</span> t1;</span><br></pre></td></tr></table></figure><p>​    松散索引需要满足下面的条件：</p><ul><li>分组查询是单表查询</li><li><code>group by</code>的条件必须同一个索引顺序索引的连续位置。</li><li><code>group by</code>的同时只能使用max或者min两个聚合函数（但是在5.5之后，新增了更多函数支持）。</li><li>如果应用<code>group by</code>以外字段条件必须用<strong>常量形式</strong>存在。</li><li>必须使用完整的索引值，也就意味着like这样的前缀索引是不适用的。</li></ul><p>​    如果想要判定查询是否使用松散索引可以根据<code>explain</code>的<code>extra</code>内容是否为<code>Using index for group-by</code>确认。</p><p>​    下面我们用更实际SQL来介绍，假设在 table<code>t1(c1,c2,c3,c4)</code>上有一个索引<code>idx(c1,c2,c3)</code>。松散索引扫描访问方法可用于以下查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 自我实验：松散索引</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> film_id, store_id), <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> store_id, film_id) <span class="keyword">FROM</span> inventory_test;</span><br><span class="line"><span class="comment">-- 1  SIMPLE  inventory_test    range  idx_store_id_film_id  idx_store_id_film_id  3    4  100.00  Using index for group-by (scanning)</span></span><br><span class="line"><span class="comment">-- 自我实验：松散索引</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> store_id), <span class="keyword">SUM</span>(<span class="keyword">DISTINCT</span> store_id) <span class="keyword">FROM</span> inventory_test;</span><br><span class="line"><span class="comment">-- 1  SIMPLE  inventory_test    range  idx_store_id_film_id  idx_store_id_film_id  1    4  100.00  Using index for group-by (scanning)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 但是如果查询的不是同一个索引，不满足最左原则是不走松散索引的，而是走更快的索引扫描：</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> store_id), <span class="keyword">SUM</span>(<span class="keyword">DISTINCT</span> store_id) <span class="keyword">FROM</span> inventory_test;</span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> film_id), <span class="keyword">SUM</span>(<span class="keyword">DISTINCT</span> film_id) <span class="keyword">FROM</span> inventory_test;</span><br><span class="line"><span class="comment">-- 1SIMPLEinventory_testrangeidx_store_id_film_ididx_store_id_film_id14100.00Using index for group-by (scanning)</span></span><br><span class="line"><span class="comment">-- 1SIMPLEinventory_testindexidx_store_id_film_ididx_store_id_film_id33100.00Using index</span></span><br></pre></td></tr></table></figure><p><strong>紧凑索引</strong></p><p>​    和松散索引区别的是紧凑索引使用前提是必须是<strong>全索引扫描</strong>或者<strong>范围索引扫描</strong>，当松散索引没有生效时使得<code>group by</code> 依然有可能避免创建临时表，紧凑索引需要读取所有满足条件的索引键才会工作，然后根据读取的数据完成<code>group by</code> 操作。</p><p>​    为了使紧凑索引查询这种方法奏效在查询中的所有列都要有<strong>恒定的相等条件</strong>，比如必须<code>GROUP BY</code>键之前或之间的部分键。</p><p>​    在紧凑索引扫描方式下，先对索引执行<strong>范围扫描（range scan）</strong>，再对结果元组进行分组。为了更好的理解，可以看一下相关的案例：</p><p>​    在<code>GROUP BY</code>中存在一个缺口，但是它被条件<code>c2=&#39;a&#39;</code>所覆盖。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c1, c2, c3 <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c2 = <span class="string">'a'</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> c1, c3;</span><br></pre></td></tr></table></figure><p>​    <code>GROUP BY</code>没有以键的第一部分开始，但是有一个条件为这部分提供了一个常数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c1, c2, c3 <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c1 = <span class="string">'a'</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> c2, c3;</span><br></pre></td></tr></table></figure><p>​    我们按照官方给的案例实验一下，首先是表结构，我们在下面表中建立联合索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`inventory_test`</span> (</span><br><span class="line">  <span class="string">`inventory_id`</span> mediumint <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`film_id`</span> <span class="built_in">smallint</span> <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`store_id`</span> <span class="built_in">tinyint</span> <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`last_update`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`inventory_id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_store_id_film_id`</span> (<span class="string">`store_id`</span>,<span class="string">`film_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">4582</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COLLATE</span>=utf8mb4_0900_ai_ci;</span><br></pre></td></tr></table></figure><p>​    下面是个人使用紧凑索引的案例，当where条件是常量值并且是针对索引的常量值的时候，<code>group by</code>就可以走索引，但是如果where条件是非索引字段依然需要全表扫描，注意这里group的字段并不是按照联合索引的最左前缀处理的依然可以走索引，这就是mysql对于分组操作的一系列优化了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 紧凑索引</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> <span class="keyword">count</span>(*),<span class="keyword">max</span>(film_id),<span class="keyword">sum</span>(film_id), <span class="keyword">avg</span>(film_id) <span class="keyword">from</span> inventory_test <span class="keyword">where</span> store_id = <span class="number">1</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> film_id;</span><br><span class="line"><span class="comment">-- 1  SIMPLE  inventory_test    ref  idx_store_id_film_id  idx_store_id_film_id  1  const  1  100.00  Using index</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> <span class="keyword">count</span>(*),<span class="keyword">max</span>(film_id),<span class="keyword">sum</span>(film_id), <span class="keyword">avg</span>(film_id) <span class="keyword">from</span> inventory_test <span class="keyword">where</span> last_update &gt; <span class="string">'2022-02-02 23:20:45'</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> film_id;</span><br><span class="line"><span class="comment">-- 1  SIMPLE  inventory_test    ALL  idx_store_id_film_id        3  33.33  Using where; Using temporary</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> <span class="keyword">count</span>(*),<span class="keyword">max</span>(film_id),<span class="keyword">sum</span>(film_id), <span class="keyword">avg</span>(film_id) <span class="keyword">from</span> inventory_test <span class="keyword">where</span> last_update = <span class="string">'2022-02-02 23:20:45'</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> film_id;</span><br><span class="line"><span class="comment">-- 1  SIMPLE  inventory_test    ALL  idx_store_id_film_id        3  33.33  Using where; Using temporary</span></span><br></pre></td></tr></table></figure><p>​    建议读者多读一读官方文档加深这两个概念理解。</p><h2 id="order-by如何优化？"><a href="#order-by如何优化？" class="headerlink" title="order by如何优化？"></a>order by如何优化？</h2><p>什么是中间结果集？</p><p>​    对于常规的sort语句，由于需要对于搜索的结果按照某一字段进行大小排序，而为了让这个操作顺利完成，mysql会把这个操作放到硬盘或者内存完成。</p><p>排序的基本步骤和原理 </p><p>​    对于涉及排序的语句，它的大致工作原理如下：</p><ol><li>选取查询字段，根据<code>where</code>进行条件查询。</li><li>查询结果集生成<code>sort_buffer</code>，如果内存不够，需要在硬盘建立中间表进行排序。</li><li>将中间表根据<code>Order</code> 字段进行排序。</li><li>回表生成完整结果集，组装返回结果。</li></ol><p>中间结果集特点</p><p>​    如果中间表比较小则放到内存中，判定什么时候会存在于内存中Mysql提供了<code>sort_buffer_size</code>的参数，它负责控制中间结果集的大小，如果优化内存需要调整降低这个参数值，但是如果想要优化查询的时间，则需要调大这个参数。</p><p>回表生成完整结果集</p><p>​    回表生成完整结果集这个操作其实也不是总是执行的，会根据会话参数<code>max_length_for_sort_data</code>进行判断，如果当前查询小于这个数值，会生成一个<strong>全字段中间表</strong>结果可以直接从全字段中间表获取，但是如果大于这个数值那么就只会生成<strong>排序字段+主键中间表</strong>（类似二级索引），所以这时候显然查找一遍是无法找到的，需要回表才能完成操作。</p><blockquote><p>需要注意<strong>排序字段+主键中间表</strong>看起来像是二级索引但是实际上和二级索引完全没有关系，只是一个简单列表需要反复去主表获取数据。</p></blockquote><p>​    总结：全字段中间表&gt;<code>max_length_for_sort_data</code>&gt;排序字段+主键中间表，数值并不是越大越好越大越影响查询效率。</p><p>排序查询优化点</p><p>​    根本问题在于排序的结果是中间结果集，虽然结果集可以在内存中处理，但是他有最为本质的问题那就是<strong>中间表不存在索引</strong>并且导致索引失效，所以为了让中间表可以走索引我们可以使用<strong>索引覆盖</strong>的方式。</p><blockquote><p>优化手段：索引覆盖，也是最高效的处理方式。索引覆盖可以跳过生成生成中间结果集，直接输出查询结果。</p></blockquote><ol><li>order by的字段为索引（或者联合索引的最左边）。</li><li>其他字段（条件、输出）均在上述索引中。</li><li>索引覆盖可以跳过中间结果集，直接输出查询结果。 </li></ol><blockquote><p>什么是索引覆盖？</p><p>覆盖索引：覆盖索引是<strong>查询方式</strong>而不是一个索引，指的是一个sql语句中包括查询条件和返回结果均符合索引使用条件，当然在Mysql5.6之后增加索引下推，满足下推条件的也可以走覆盖索引。</p></blockquote><p>​    比如下面的语句并不会生成中间结果集并且可以有效利用索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> film_id, title <span class="keyword">from</span> film <span class="keyword">order</span> <span class="keyword">by</span> title;</span><br><span class="line"><span class="comment">-- 1SIMPLEfilmindexidx_title5141000100.00Using index</span></span><br></pre></td></tr></table></figure><p>总结：提升排序查询速度</p><ol><li>给<code>order by</code>字段增加索引，或者<code>where</code>字段使用索引，让查询可以走覆盖索引的方式。</li><li>调整<code>sort_buffer_size</code>大小，或者调整<code>max_length_for_sort_data</code>的大小，让排序尽量在内存完成。</li></ol><h2 id="函数操作索引失效的问题"><a href="#函数操作索引失效的问题" class="headerlink" title="函数操作索引失效的问题"></a>函数操作索引失效的问题</h2><p>通过下面的案例可以得知，如果我们对于索引的字段进行了类似函数的操作那么mysql会放弃使用索引，另外一种情况是日期函数比如month()函数也会使得索引失效。</p><blockquote><p>小贴士：很多人以为函数操作是那些sum()，count()函数，实际上对于字段的<strong>加减乘除</strong>操作都可以认为是函数操作，因为底层需要调用计算机的寄存器完成相关指令操作。另外这里需要和签名的索引下推和松散紧凑索引做区分，松散和紧凑索引针对分组操作索引优化，索引下推到了5.6才被正式引入。大多数旧版本的mysql系统是没法享受使用函数操作同时还能走索引的。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- sql1：对于索引字段进行函数操作</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span></span><br><span class="line">  title </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  film   </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  title + <span class="string">'22'</span> = <span class="string">'ACADEMY DINOSAUR'</span> </span><br><span class="line">  <span class="keyword">AND</span> <span class="keyword">length</span> + <span class="number">11</span> = <span class="number">86</span>;</span><br><span class="line">  <span class="comment">-- 1  SIMPLE  film    ALL          1000  100.00  Using where</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">-- sql2：如果对于其他字段使用函数操作，但是索引字段不进行 函数操作依然可以走索引</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span></span><br><span class="line">  title </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  film </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  title  = <span class="string">'ACADEMY DINOSAUR'</span> </span><br><span class="line">  <span class="keyword">AND</span> <span class="keyword">length</span> + <span class="number">11</span> = <span class="number">86</span>;</span><br><span class="line">  <span class="comment">-- 1  SIMPLE  film    ref  idx_title  idx_title  514  const  1  100.00  Using where</span></span><br></pre></td></tr></table></figure><p>时间函数如何优化：</p><p>​    我们要如何优化时间函数呢？有一种比较笨的方式是使用 <strong>between and 替代，</strong>比如要搜索5月份，就使用5月的第一天到5月的最后一天，具体的优化案例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> last_update <span class="keyword">from</span> payment <span class="keyword">where</span> <span class="keyword">month</span>(last_update) =<span class="number">2</span>;</span><br><span class="line"><span class="comment">-- last_update需要手动创建索引</span></span><br><span class="line"><span class="comment">-- 1  SIMPLE  payment    ALL          16086  100.00  Using where</span></span><br></pre></td></tr></table></figure><p>​    如果需要优化上面的结果，我们可以使用其他的方式替换写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain select * from payment where last_update between <span class="string">'2006-02-01'</span> and <span class="string">'2006-02-28'</span>;</span><br><span class="line">-- <span class="number">1</span>  SIMPLE  payment    ALL  idx_payment_lastupdate        <span class="number">16086</span>  <span class="number">50.00</span>  Using where</span><br></pre></td></tr></table></figure><p>​    这里很奇怪，咋和上面说的不一样呢？其实是因为<code>last_update</code>这个字段使用的数据类型是<strong>t</strong>imestamp，而timestamp在进行搜索的时候由于优化器的判断会放弃使用索引！所以解决办法也比较简单：<strong>使用force inde</strong>x 让SQL 强制使用索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span>  * <span class="keyword">from</span> payment <span class="keyword">force</span> <span class="keyword">index</span>(idx_payment_lastupdate) <span class="keyword">where</span> last_update <span class="keyword">between</span> <span class="string">'2006-02-01'</span> <span class="keyword">and</span> <span class="string">'2006-02-28'</span> ;</span><br><span class="line"><span class="comment">-- 1  SIMPLE  payment    range  idx_payment_lastupdate  idx_payment_lastupdate  5    8043  100.00  Using index condition</span></span><br></pre></td></tr></table></figure><blockquote><p>这里经过实验发现如果字段是datetime，就可以直接用Between and索引，对于时间戳类型并没有实验，仅从现有的表设计来看结果如下：</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 优化后</span></span><br><span class="line"><span class="comment">-- 1  SIMPLE  rental    range  rental_date  rental_date  5    182  100.00  Using index condition</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> rental <span class="keyword">where</span> rental_date <span class="keyword">between</span> <span class="string">'2006-02-01'</span> <span class="keyword">and</span> <span class="string">'2006-02-28'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1  SIMPLE  rental    ALL          16008  100.00  Using where</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> rental <span class="keyword">where</span>  <span class="keyword">month</span>(rental_date) =<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>字符和数字比较：</p><p>​    字符和数字比较也是会出现函数转化的同样会导致索引失效，所以在等式匹配的时候需要确保被比较的类型左右两边一致，另外如果无法修改查询可以使用cast函数进行补救，比如像下面这样处理。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> city <span class="keyword">where</span> <span class="keyword">cast</span>(city_id <span class="keyword">as</span> SIGNED <span class="built_in">int</span>) = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>隐式字符编码转化：</p><p>​    如果两个表字段的编码不一样，也会出现索引失效的问题，因为底层需要对于编码进行转化，解决方式也比较简单，在比较的时候， 同时<strong>尽量</strong>比较字符串保证编码一致。那么假设两张表比较的时候，那个表的字段需要转化呢，比如A表的utf8和B表utf8mb4，A表中字段需要和B表字段进行比较的时候，需要将<strong>A表的字段转为和 B表的字段一致</strong>。</p><blockquote><p>这个就偷懒不实验了，绝大多数情况下表的字符集编码格式只要跟随表级别基本不会出现不一致的问题……</p></blockquote><h2 id="order-by-rand-原理"><a href="#order-by-rand-原理" class="headerlink" title="order by rand()原理"></a>order by rand()原理</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> tilte, desciption <span class="keyword">from</span> film <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">rand</span>() <span class="keyword">limit</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- EXPLAIN select title, description from film order by rand() limit 1;</span></span><br><span class="line"><span class="comment">-- 1  SIMPLE  film    ALL          1000  100.00  Using temporary; Using filesort</span></span><br></pre></td></tr></table></figure><p>​    <code>rand()</code>函数是十分耗费数据库性能的函数，在日常使用过程中我们可能遇到需要临时获取一条数据的情况，这时候就有可能会使用<code>rand()</code>函数，下面是<code>rand()</code>函数的执行原理：</p><ul><li>创建一个临时表，临时表字段为<code>rand、title、description</code>。</li><li>从临时表中获取一行，调用rand()，把结果和数据放入临时表，以此类推。</li><li>针对临时表，把rand字段+行位置（主键）放入到<code>sort_buffer</code>。</li></ul><p>​    可以看到这里最大的问题是出现了<strong>两次中间结果集</strong>。</p><p>​    针对此问题可以使用下面的临时方案进行处理，这个临时方案可以看作是把rand()内部的工作拆开来进行处理，也是在不改动业务的情况下一种比较“笨”的解决方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(film_id),<span class="keyword">min</span>(film_id) <span class="keyword">into</span> @M,@N <span class="keyword">from</span> film;</span><br><span class="line"><span class="keyword">set</span> @x=<span class="keyword">FLOOR</span>((@M-@N+<span class="number">1</span>) * <span class="keyword">rand</span>() + @N);</span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> title,description <span class="keyword">from</span> film <span class="keyword">where</span> film_id &gt;= @X <span class="keyword">limit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>​    其他处理方式是使用业务和逻辑代码替代sql的内部处理，比如使用下面的方式进行处理：</p><ol><li>查询数据表总数 total。</li><li>total范围内，随机选取一个数字r。</li><li>执行下列的SQL：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> title,description <span class="keyword">from</span> film <span class="keyword">limit</span> r,<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>​    小结：</p><ol><li><p><code>order by rand() limit</code> 这个查询的效率极其低下，因为他需要生成两次中间表才能获取结果，谨慎使用此函数。</p></li><li><p>解决方案有两种：</p><ul><li><p>临时解决方案：在主键的最大值和最小值中选取一个。</p></li><li><p>好理解的方式处理：业务代码加limit处理</p></li></ul><p>优点：在不改变业务的情况下直接通过调整SQL                                                                                                                       </p><p>缺点：模板代码比较难以记忆，并且并不是万能的，因为可能不给你相关权限</p></li><li><p>建议使用业务逻辑代码处理不使用rand()函数。</p></li></ol><h2 id="分页查询慢怎么办？"><a href="#分页查询慢怎么办？" class="headerlink" title="分页查询慢怎么办？"></a>分页查询慢怎么办？</h2><p>​    再次注意这里实验的时候使用的数据库版本为<strong>8.0.26</strong>。</p><p>​    我们首先来看一下《高性能Mysql 第三版》 241-242页怎么说的，作者使用的也是sakila表，推荐的方式是使用<strong>延迟关联</strong>的方法，比如把下面的sql进行优化：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 优化前</span></span><br><span class="line"><span class="keyword">select</span> film_id,description <span class="keyword">from</span> film <span class="keyword">order</span> <span class="keyword">by</span> title <span class="keyword">limit</span> <span class="number">50</span>,<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 优化后</span></span><br><span class="line"><span class="keyword">select</span> film_id,description <span class="keyword">from</span> film <span class="keyword">inner</span> <span class="keyword">join</span> (<span class="keyword">select</span> film_id <span class="keyword">from</span> film <span class="keyword">order</span> <span class="keyword">by</span> title <span class="keyword">limit</span> <span class="number">50</span>, <span class="number">5</span>) <span class="keyword">as</span> lim <span class="keyword">using</span>(film_id)</span><br></pre></td></tr></table></figure><p>​    第二种方式是当id符合某种排序规则并且业务刚好符合的时候可以使用<code>between ...and</code>替代</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> film <span class="keyword">where</span> film_id <span class="keyword">between</span> <span class="number">46</span> <span class="keyword">and</span> <span class="number">50</span> <span class="keyword">order</span> <span class="keyword">position</span>;</span><br></pre></td></tr></table></figure><p>​    最后还有一种方式是利用排序的特性将数据排序之后获取前面的行即可：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> film <span class="keyword">where</span> film_id <span class="keyword">order</span> <span class="keyword">position</span> <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>​    以上是关于《高性能Mysql 第三版》 部分的介绍。下面来看下我们是否还有其他的办法？</p><p>​    深分页问题不管是面试还是日常开发中经常会遇到的问题，这和limit的语法特性有关，可以看下面的内容：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> film <span class="keyword">limit</span> x,y;</span><br></pre></td></tr></table></figure><p>​    limit的语句的执行顺序如下：</p><ol><li>先按照列查找出所有的语句，如果有where语句则根据where查找出数据</li><li>查找数据并且加入结果集直到查找到（x+y）条数据为止。</li><li>丢弃掉前面的x条，保留y条。</li><li>返回剩下的y条数据。</li></ol><p>​    针对limit我们有下面的优化和处理方案：</p><p>​    1. <strong>简单优化</strong>：</p><p>​    如果主键是int自增并且主键是逻辑符合业务自增的，那么我们可以使用下面的语句进行优化：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> film <span class="keyword">where</span> <span class="keyword">id</span> &gt;= <span class="number">10000</span> <span class="keyword">limit</span> y;</span><br></pre></td></tr></table></figure><p>​    </p><p>​    2. <strong>子查询优化</strong>：</p><p>​    自查询的优化方式是减少回表次数的一种方式，我们可以使用自查询的方式，由于不同业务之间存在不同的处理方式，这里给一个大致的处理模板：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> film <span class="keyword">where</span> <span class="keyword">ID</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> film <span class="keyword">where</span> title = <span class="string">'BANG KWAI'</span>) <span class="keyword">limit</span> <span class="number">10000</span>,<span class="number">10</span></span><br></pre></td></tr></table></figure><p>​    这样处理过后有两个优点：</p><ul><li>查询转为搜索索引列，并且不需要磁盘IO。</li><li>虽然使用的是子查询，但是因为搜索的是索引列，所以效率还是比较高的。</li></ul><p>​    3. <strong>延迟关联</strong></p><p>​    和《高性能Mysql》的方式一样，其实就是子查询方式的一种优化版本，优化的思路也是把过滤数据变为走索引之后在进行排除，由于上文已经介绍过这里就不再赘述了。</p><p>总结：</p><p>​    对于深分页的问题我们一般有下面的优化思路：</p><ul><li>如果主键符合自增或者符合业务排序，可以直接通过<code>id&gt;xxx</code> 然后limit搜索数据。</li><li>如果通过排序可以正确搜索相关数据，则可以直接排序之后取条数即可。</li><li>延迟关联，延迟关联有两种方式，第一种是使用in的子查询，第二种是使用inner join，本质都是通过索引列的方式避免大数据的查找，同时转变为查索引的方式。</li><li>如果可以确认范围，使用between and 替代。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​    本节内容针对了一些实战过程中可能经常遇到的一些问题处理进行阐述，其中稍微有些难度的部分在索引下推和紧凑索引部分，这些特性</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>​    <span class="exturl" data-url="aHR0cHM6Ly93d3cuZG9jczRkZXYuY29tL2RvY3MvemgvbXlzcWwvNS43L3JlZmVyZW5jZS9ncm91cC1ieS1vcHRpbWl6YXRpb24uaHRtbA==" title="https://www.docs4dev.com/docs/zh/mysql/5.7/reference/group-by-optimization.html">MySql 中文文档 - 8.2.1.15 GROUP BY 最佳化 | Docs4dev<i class="fa fa-external-link"></i></span></p><p>​    [MySQL :: MySQL 8.0 Reference Manual :: 8.2.1.17 GROUP BY Optimization](</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      Mysql索引和查询优化
    
    </summary>
    
    
      <category term="数据库-mysql" scheme="https://whitestore.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-mysql/"/>
    
    
      <category term="数据库" scheme="https://whitestore.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Mysql" scheme="https://whitestore.top/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>三高Mysql - Mysql索引和查询优化（偏理论部分）</title>
    <link href="https://whitestore.top/2022/04/06/suoyinlilun/"/>
    <id>https://whitestore.top/2022/04/06/suoyinlilun/</id>
    <published>2022-04-06T06:05:30.000Z</published>
    <updated>2022-06-02T10:09:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三高Mysql-Mysql索引和查询优化（偏理论部分）"><a href="#三高Mysql-Mysql索引和查询优化（偏理论部分）" class="headerlink" title="三高Mysql - Mysql索引和查询优化（偏理论部分）"></a>三高Mysql - Mysql索引和查询优化（偏理论部分）</h1><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>​    内容为慕课网的”高并发 高性能 高可用 MySQL 实战”视频的学习笔记内容和个人整理扩展之后的笔记，本节内容讲述的索引优化的内容，另外本部分内容涉及很多优化的内容，所以学习的时候建议翻开《高性能Mysql》第六章进行回顾和了解，对于Mysql数据的开发同学来说大致了解内部工作机制是有必要的。</p><p>​    由于文章内容过长，所以这里拆分为两部分，上下部分的内容均使用<strong>sakila-db</strong>，也就是mysql的官方案例。第一部分讲述优化的理论和Mysql过去的优化器设计的缺陷，同时会介绍更高的版本中如何修复完善这些问题的（但是从个人看来新版本那些优化根本算不上优化，甚至有的优化还是照抄的Mysql原作者的实现的，发展了这么多年才这么一点成绩还是要归功于Oracle这种极致商业化公司的功劳）。</p><blockquote><p>如果内容比较难，可以跟随《Mysql是怎么样运行》个人读书笔记专栏补补课，个人也在学习和同步更新中。</p><p>地址如下：<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vY29sdW1uLzcwMjQzNjM0NzY2NjM3MzAyMDfjgII=" title="https://juejin.cn/column/7024363476663730207。">https://juejin.cn/column/7024363476663730207。<i class="fa fa-external-link"></i></span></p></blockquote><a id="more"></a><h1 id="【知识点】"><a href="#【知识点】" class="headerlink" title="【知识点】"></a>【知识点】</h1><ul><li>Mysql索引内容的介绍</li><li>索引的使用策略和使用规则</li><li>查询优化排查，简单了解Mysql各个组件的职责</li></ul><h1 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h1><h2 id="sakila-db"><a href="#sakila-db" class="headerlink" title="sakila-db"></a>sakila-db</h2><p>​    sakila-db是什么？国外很火的一个概念，指的是国外的电影租赁市场使用租赁的方式进行电影的观看十分受外国的喜欢。这里介绍是因为后续的内容都用到了这个案例。所以我们需要提前把相关的环境准备好，从如下地址进行下载：</p><p>​    下载地址：<span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy9pbmRleC1vdGhlci5odG1s" title="https://dev.mysql.com/doc/index-other.html">https://dev.mysql.com/doc/index-other.html<i class="fa fa-external-link"></i></span></p><blockquote><p>《高性能Mysql》的SQL 案例也是使用官方的example</p></blockquote><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202203201510470.png" alt=""></p><h2 id="work-bench"><a href="#work-bench" class="headerlink" title="work-bench"></a>work-bench</h2><p>​    work-bench是官方开发的数据库关系图的可视化工具，使用官方案例的具体关系图展示效果如下，通过这些图可以看到Sakila-db之间的大致关系：</p><blockquote><p>work-bench也是开源免费软件，下载地址如下：</p><p><span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2Rvd25sb2Fkcy93b3JrYmVuY2gv" title="https://dev.mysql.com/downloads/workbench/">https://dev.mysql.com/downloads/workbench/<i class="fa fa-external-link"></i></span></p></blockquote><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202203201508589.png" alt="sakila-db示意图"></p><p>​    安装workbench和下载sakila-db的方式这里不做记录，在运行的时候需要注意先建立一个数据库运行sheme文件，然后执行data的sql文件，最终在navicat中查看数据：</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202203201521740.png" alt="数据库关系图"></p><h1 id="正文部分"><a href="#正文部分" class="headerlink" title="正文部分"></a>正文部分</h1><h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><p>​    首先是索引的特点以及作用：</p><ol><li><p>索引的目的是为了提升数据的效率。</p></li><li><p>对于ORM框架来说索引的使用至关重要，但是ORM的优化往往难以顾及所有业务情况，后续被逐渐废弃。</p></li><li><p>不同的索引类型适用于不同的场景。</p></li><li><p>索引关键在于减少数据需要扫描的量，同时避免服务器内部对内容排序和临时表（因为临时表会索引失效），随机IO转顺序IO等特点</p></li></ol><p>​    </p><p>​    下面介绍Mysql相关的索引类型：</p><ul><li>哈希索引：哈希索引适合全值匹配和精确查找，查询的速度非常快 在MySQL中只有memory存储引擎显式支持此索引，memory还支持非唯一哈希索引的，是哈希索引设计里面比较特殊的。</li><li>空间索引：空间索引是myisam表支持，主要用作地理数据存储，这里包含一个叫做GIS的玩意，但是GIS在Postgre中使用比MySQL要出色很多，所以mysql中空间索引是无关紧要的东西。</li><li>全文索引：全文索引也是myisam独有支持的一种索引类型。适合使用的场景为全值匹配的场景和关键字查询，对于大文本的关键字匹配可以有效处理。</li><li>聚簇索引：聚簇索引是innodb存储引擎的默认存储引擎。</li><li>前缀压缩索引：注意这个索引针对的是myisam存储引擎，目的是为了让索引放入内存中排序，，前缀压缩的方法是首先保存索引块的第一个值，然后在保存第二个值，存储第二个值类似（长度,索引值）的形式存放前缀索引。</li></ul><p>其他索引类型注意事项：</p><p>​    Archive 在5.1之后才支持单列自增索引。</p><p>​    MyISAM 支持压缩之后的前缀索引，使得数据结构占用更小。</p><p><strong>哈希索引</strong></p><p>​    在Mysql中唯一显式实现哈希索引的存储引擎为Memory，Memory是存在非唯一哈希索引，同时BTree也支持“自适应哈希索引的方式“兼容哈希索引。</p><p>下面是哈希索引特点：</p><ul><li>键存储的是索引哈希值，注意不是索引值本身，而值存储的是指向行的指针</li><li>注意此哈希索引无法避免行扫描，但是在内存中指针非常快通常可以忽略不计</li><li>注意只有哈希值按照顺序排序，但是行指针不是按照顺序排序</li><li>哈希不支持：部分索引覆盖，只支持全索引覆盖，因为使用全部的索引列计算哈希值</li><li>哈希索引支持等值匹配操作不支持范围查询，比如等于，in子查询，不全等。</li><li>如果出现哈希冲突，哈希索引将退化为链表顺序查询，同时维护索引的开销也会变大</li></ul><p><strong>聚簇索引</strong></p><p>​    聚簇表示数据行的值紧凑存储在一起。而innodb聚簇的值就是主键的值，所以通常使用都是主键上的索引，针对主键索引的选择十分重要。由于本部分着重索引优化，聚簇索引这里就不再讲述了。</p><p>​    MyISam和Innodb的主键索引区别是MyISam的索引很简单，因为数据行只包含行号，所以索引<strong>直接存储列值和行号</strong>，数据单独存放另一处，类似于一个唯一非空索引，索引和数据不在一处，MyISam的索引设计比InnoDB简单很多，这和MyIsam不需要支持事务也有直接关系，而innodb将索引和行数据放入一个数据结构，将列进行紧凑的存储。</p><p>​    </p><p>聚簇索引有下面优点</p><ul><li>紧凑存储数据行，所以可以只扫描少量磁盘就可以获取到数据</li><li>数据访问的速度非常快，索引和数据放在同一颗BTree中，比非聚簇索引查询快很多</li><li>覆盖索引可以直接<strong>减少回表</strong></li></ul><p>当然索引也有下面的缺点：</p><ul><li>对于非IO密集型应用，聚簇索引的优化无意义。</li><li>插入速度依赖于插入顺序，但是如果不是自增插入则需要optimize table重新组织表。</li><li>更新代价非常高，因为BTree要保证顺序排序需要挪动数据页位置和指针。</li><li>主键数据插入过满数据页存在页分裂问题，行溢出会导致存储压力加大。</li><li>聚簇索引导致全表扫描变慢，页分裂导致数据问题等。</li><li>二级索引需要回表查询聚簇索引才能查询数据。</li><li>二级索引由于需要存储主键开销会更大，至少在InnoDb中维护一个二级索引的开销是挺大的。</li></ul><p>压缩索引</p><p>​    压缩索引的特点是使用更少的空间存放尽可能多的内容，但是这样的处理方式仅仅适用于IO密集型的系统，压缩前缀存储形式最大的缺陷是无法使用二分法进行查找，同时如果使用的倒序索引的方式比如order by desc 的方式可能会因为压缩索引的问题存在卡顿的情况。</p><p>Bree索引的特点</p><ul><li><p>叶子结点存在逻辑页和索引页两种，通常非最底层叶子结点都是索引页，最底层索引页由链表串联。</p></li><li><p>Btree索引会根据<strong>建表顺序</strong>对于索引值进行排序，索引建表时候建议将经常查询的字段往前挪。</p></li><li><p>Btree索引适合的查询类型：<strong>前缀查询，范围查询，键值查询（哈希索引）</strong>。</p></li></ul><p>自适应哈希索引</p><p>​    当innodb发现某些索引列和值使用频繁的时候，BTree会在此基础上自动创建哈希索引辅助优化，但是这个行为是不受外部控制的，完全是内部的优化行为，如果不需要可以考虑关闭。</p><p>Btree查询类型</p><p>​    针对Innodb的Btree索引，有下面几种常见的查询方式：</p><ul><li>全值匹配：等值匹配的方式，全值匹配适合哈希索引进行查询</li><li>最左匹配原则：二级索引的查询条件放在where最左边</li><li>前缀匹配：只使用索引的第一列，并且like ‘xxx%’</li><li>范围匹配：范围匹配索引列到另一列之间的值</li><li>范围查询和精确匹配结合，一个全值匹配，一个范围匹配</li><li>覆盖索引查询：覆盖索引也是一种查询方式，</li></ul><h2 id="索引策略"><a href="#索引策略" class="headerlink" title="索引策略"></a>索引策略</h2><p>​    下面是关于建立索引的一些常见策略：</p><ol><li>第一件事情需要考虑的是预测那些数据为热点数据或者热点列，按照《高性能Mysql》介绍，对于热点列来说有时候要违背最大选择性的原则，通过建立时常搜索的索引作为最左前缀的默认的设置。同时优化查询需要考虑所有的列，如果一个查询的优化会破坏另一个查询，那么就需要优化索引的结构。</li><li>第二件事情是考虑where的条件组合，通过组合多种where条件，需要考虑的是尽可能让查询重用索引而不是大规模的建立新索引。</li><li>避免多个范围进行扫描，一方面是范围查询会导致，但是对于多个等值的条件查询，最好的办法是尽量控制搜索范围。</li></ol><p>​    </p><p>​    对于索引的策略我们还需要了解下面的细节</p><ul><li>单行访问很慢，特别是随机访问要比顺序访问要慢更多，一次性加载很多数据页会造成性能的浪费。</li><li>顺序访问范围数据很快，顺序IO的速度不需要多磁道查找，比随机的访问IO块很多，顺序访问也可以使用group by进行聚合计算。</li><li>索引覆盖速度很快，如果查询字段包含了索引列，就不需要回表。</li></ul><p>索引碎片优化</p><p>​    Innodb的数据结构和特性会导致索引存在数据碎片，对于任何存储结构来说顺序的存储结构是最合适的，并且索引顺序访问要比随机访问快更多，数据存储的碎片比索引本身复杂很多，索引碎片通常包含下面的情况：</p><ul><li>行碎片：数据行的数据被存储在多个数据页当中，碎片可能会导致性能的下降。</li><li>行间碎片：逻辑顺序上的页，行在磁盘上不顺序存储，行间数据碎片会导致全表扫描。</li><li>剩余空间碎片：数据页的间隙有大量的垃圾数据导致的浪费。</li></ul><p>​    对于上面几点，对于myisam 都有可能出现，但是innodb的行碎片不会出现，内部会移动碎片重写到一个片段。</p><p>​    索引碎片的处理方式：在Mysql中可以通过<code>optimize table</code>导入和导出的方式重新整理数据，防止数据碎片问题。</p><p>​    </p><p>索引规则</p><ul><li>索引必须按照索引顺序从左到右匹配</li><li>如果在查询中间出现范围，则范围查询之后的索引失效</li><li>不能跳过索引列的方式查询（和B+tree索引数据结构设计有关系）</li></ul><p>​    接着是索引顺序问题，由于BTree的结构特性，索引都是按照建立顺序进行查找的，通常不包含排序和分组的情况下，把选择性最高的索引放在最左列是一个普遍正确策略。</p><p>​    如何查看索引基数：<code>show index from sakila.actor</code>，还有一种方式是通过<code>information_schema.statistics</code> 表查询这些信息，可以编写为一个查询给出选择性较低的索引。</p><p>​    当innodb打开某些表的时候会触发索引信息的统计，比如打开<code>information_schema</code>表或者使用<code>show table status</code>和<code>show index</code>的时候，所以如果在系统要运行压力较大的业务时期尽量避开这些操作。</p><p><strong>冗余重复索引</strong></p><p>​    Mysql允许同一个列上创建多种类型的索引，有时候会因为建表的特性问题给字段重复建索引造成不必要的性能浪费。冗余索引和重复索引有什么区别？</p><p>​    冗余索引：是符合最左匹配法则的情况下重复对相同列建立索引。</p><p>​    重复索引：是对于不最做的方式创建的索引就有可能是重复创建索引。</p><p>​    比如联合索引：(A,B) 如果在创建 （A）或者（A，B）都是重复索引，但是创建（B）就不是重复索引而是冗余索引。另外某些十分特殊的情况下可能用到冗余索引，但是这会极大的增加索引维护的开销，最为直观的感受是插入、更新、删除的开销变得很大。</p><p><strong>多列索引</strong></p><p>​    首先多列索引不是意味着<code>where</code>字段出现的地方就需要加入，其次多列索引虽然在现在主流使用版本中（5.1版本之后）实现了索引内部合并，也就是使用<code>and or</code>或者<code>and</code>和<code>or</code>合并的方式相交使用索引，但是他存在下面几个缺点</p><ul><li>内部优化器的合并和计算十分耗费CPU的性能，索引反而增加数据查询复杂度，效率也不好</li><li>往往会存在优化过度的情况，导致运行效果还不如全表扫描</li><li>出现多列索引合并通常意味着建立索引的方式不对，存在反向优化的嫌疑</li></ul><p><strong>文件排序</strong></p><p>​    文件排序遵循Innodb的Btree索引的最基本原则：<strong>最左前缀原则</strong>，如果索引列的顺序和order by排序一致，并且查询列都和排序列都一样才会用索引替代排序，对于多表查询则排序字段<strong>全为第一个表</strong>才能进行索引排序。但是有一个特例那就是排序字段的前导列为<strong>常量</strong>的时候依然可以使用索引排序。</p><p>​    案例：rental 表的联合索引列进行排序</p><blockquote><p>Backward index scan 是 MySQL-8.0.x 针对上面场景的一个专用优化项，它可以从索引的后面往前面读，性能上比加索引提示要好的多</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> rental_id,staff_id <span class="keyword">from</span> rental <span class="keyword">where</span> rental_date = <span class="string">'2005-05-25'</span> <span class="keyword">order</span> <span class="keyword">by</span> inventory_id <span class="keyword">desc</span>, customer_id <span class="keyword">asc</span>;</span><br><span class="line"><span class="comment">-- 1 SIMPLE rental ref rental_date rental_date 5 const 1 100.00 Using filesort</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> rental_id,staff_id <span class="keyword">from</span> rental <span class="keyword">where</span> rental_date = <span class="string">'2005-05-25'</span> <span class="keyword">order</span> <span class="keyword">by</span> inventory_id <span class="keyword">desc</span>;</span><br><span class="line"><span class="comment">-- Backward-index-scan</span></span><br><span class="line"><span class="comment">-- Backward index scan 是 MySQL-8.0.x 针对上面场景的一个专用优化项，它可以从索引的后面往前面读，性能上比加索引提示要好的多</span></span><br><span class="line"><span class="comment">-- 1 SIMPLE rental ref rental_date rental_date 5 const 1 100.00 Backward index scan</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> rental_id,staff_id <span class="keyword">from</span> rental <span class="keyword">where</span> rental_date = <span class="string">'2005-05-25'</span> <span class="keyword">order</span> <span class="keyword">by</span> inventory_id, staff_id;</span><br><span class="line"><span class="comment">-- 1 SIMPLE rental ref rental_date rental_date 5 const 1 100.00 Using filesort</span></span><br><span class="line"><span class="comment">-- 无法使用索引</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> rental_id,staff_id <span class="keyword">from</span> rental <span class="keyword">where</span> rental_date &gt; <span class="string">'2005-05-25'</span> <span class="keyword">order</span> <span class="keyword">by</span> inventory_id, customer_id;</span><br><span class="line"><span class="comment">-- 1 SIMPLE rental ALL rental_date 16008 50.00 Using where; Using filesort</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> rental_id,staff_id <span class="keyword">from</span> rental <span class="keyword">where</span> rental_date = <span class="string">'2005-05-25'</span> <span class="keyword">and</span> inventory_id <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>) <span class="keyword">order</span> <span class="keyword">by</span> customer_id;</span><br><span class="line"><span class="comment">-- 1 SIMPLE rental range rental_date,idx_fk_inventory_id rental_date 8 2 100.00 Using index condition; Using filesort</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> actor_id, title <span class="keyword">from</span> film_actor <span class="keyword">inner</span> <span class="keyword">join</span> film <span class="keyword">using</span>(film_id) <span class="keyword">order</span> <span class="keyword">by</span> actor_id;</span><br><span class="line"><span class="comment">-- 1 SIMPLE film index PRIMARY idx_title 514 1000 100.00 Using index; Using temporary; Using filesort</span></span><br><span class="line"><span class="comment">-- 1 SIMPLE film_actor ref idx_fk_film_id idx_fk_film_id 2 sakila.film.film_id 5 100.00 Using index</span></span><br></pre></td></tr></table></figure><h2 id="查询优化排查"><a href="#查询优化排查" class="headerlink" title="查询优化排查"></a>查询优化排查</h2><p>​    查询优化的排查意味着我们需要先了解Mysql的各个组件在各步骤中做了哪些事情，下面这张图来自于《高性能Mysql》，对于一次客户端的请求，大致分为下面的流程：</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/202203212336431.png" alt=""></p><ol><li><p>客户端发送请求</p></li><li><p>服务器查询执行缓存</p><ul><li>不重要，8.0之后已经删除</li></ul></li><li><p>服务端进行SQL解析和预处理</p><ul><li>权限检查</li><li>词法解析</li><li>语法树</li></ul></li><li><p><strong>优化器生成执行计划</strong></p><ul><li><p>优化器存在的问题？</p></li><li><p>优化器如何工作？</p></li></ul></li><li><p>根据执行计划调用存储引擎的APi接口执行查询</p></li><li><p>结果返回客户端</p></li></ol><p>​    对于关系型的数据库来说，核心部分在于查询优化器和执行计划的部分，因为不管我们如何编写SQL语句，如果没有强大的优化器和执行计划那么一切都是空谈，所以本部分的重点也会围绕优化器进行讲解，在此之前我们先看看其他组件的工作：</p><p>​    首先查询缓存不需要过多解释，他的作用是当用户重复执行一个查询的时候会内部对于结果进行缓存，但是一旦用户修改查询条件，缓存就失效了，在早期的互联网环境中这种处理很不错，可以减少磁盘IO和CPU的压力，但是到了现在的环境下显然不适合，所以8.0删除也是可以理解的。</p><p>​    接着是解析器，解析器这部分主要工作是通过解析语法形成解析树对于语句进行预处理，预处理可以类看作我们编译器把我们写的编程语句“翻译”为机器代码的过程，让下一步的优化器可以认识这颗解析树去进行解析，</p><p>​    如果想要了解SQL解析优化的底层过程，可以从这篇文章入手：</p><p>​    <span class="exturl" data-url="aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMTgvMDUvMjAvc3FsLXBhcnNlci11c2VkLWluLW10ZHAuaHRtbA==" title="https://tech.meituan.com/2018/05/20/sql-parser-used-in-mtdp.html">SQL解析在美团的应用 - 美团技术团队 (meituan.com)<i class="fa fa-external-link"></i></span></p><p>​    在上面的博客中提到了一个DBA必须掌握的工具<strong>pt-query-digest</strong>，分析慢查询日志，下面这个文章中提供了一个实际的案例来排查和优化，案例较为简单适合刚接触这个工具的人进行学习和思考，这里一并列出来了。</p><p>​    <span class="exturl" data-url="aHR0cHM6Ly9hd3MuYW1hem9uLmNvbS9jbi9ibG9ncy9jaGluYS9wdC1xdWVyeS1kaWdlc3QtcmRzLW15c3FsLXNsb3ctc2VhcmNobmV3Lw==" title="https://aws.amazon.com/cn/blogs/china/pt-query-digest-rds-mysql-slow-searchnew/">使用 pt-query-digest 分析 RDS MySQL 慢查询日志 | 亚马逊AWS官方博客 (amazon.com)<i class="fa fa-external-link"></i></span></p><blockquote><p>SQL解析部分笔记：</p><p>词法分析：核心代码在sql/sql_lex.c文件中的，<code>MySQLLex→lex_one_Token</code></p><p><strong>MySQL语法分析树生成过程</strong>：全部的源码在<code>sql/sql_yacc.yy</code>中，在MySQL5.6中有17K行左右代码</p><p>最核心的结构是SELECT_LEX，其定义在<code>sql/sql_lex.h</code>中</p></blockquote><p>​    下面我们来深入看看优化器的部分工作内容以及Mysql优化历史：</p><p>​    由于讲述优化器的内容较少，这里直接总结《高性能Mysql》的内容，优化器也不需要研究和记忆，因为随着版本的迭代不断更新优化器会不断调整，一切要以真实实验为准：</p><p><strong>1. 子查询关联</strong>：</p><p>​    下面的查询在通常情况下我们会认为先进行子查询，然后通过for循环扫描film表进行匹配操作，然后从explain的结果中可以看到这里的查询线进行了全表扫描，然后通过关联索引进行第二层的for循环查询，这样的写法类似<code>exists</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> sakila.film <span class="keyword">where</span> film_id <span class="keyword">in</span> (<span class="keyword">select</span> film_id <span class="keyword">from</span> film_actor <span class="keyword">where</span> actor_id)</span><br><span class="line"><span class="comment">-- 1SIMPLEfilmALLPRIMARY1000100.00</span></span><br><span class="line"><span class="comment">-- 1SIMPLEfilm_actorrefidx_fk_film_ididx_fk_film_id2sakila.film.film_id590.00Using where; Using index; FirstMatch(film)</span></span><br></pre></td></tr></table></figure><p>​    优化这个子查询的方式使用关联查询替代子查询，但是需要注意这里存在where条件才会走索引，否则和上面的结果没有区别：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> film.* <span class="keyword">from</span> sakila.film film  <span class="keyword">join</span> film_actor actor <span class="keyword">using</span> (film_id) <span class="keyword">where</span> actor.actor_id = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>​    另一种是使用exists的方式进行关联匹配。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> film <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> * <span class="keyword">from</span> film_actor actor <span class="keyword">where</span> actor.film_id =  film.film_id <span class="keyword">and</span> actor.actor_id = <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>​    可以看到哪怕到了5.8的版本，Mysql的子查询优化既然没有特别大的改进，所以通常情况下如果不确定in查询的内容大小，建议用exists或者join进行查询，另外也不要相信什么in查询就一定慢点说法，在不同的mysql优化器版本中可能会有不同的效果。</p><p><strong>2. union查询</strong></p><p>​    虽然多数情况下我们会用union替换or，但是更多的情况是应该尽量避免使用union，因为union查询会产生临时表和中间结果集容易导致优化索引失效，需要注意的是 <strong>union</strong>会触发内部的排序动作，也就是说union会等价于<code>order by</code>的排序，如果数据不是强烈要求不能重复，那么更建议使用union all，对于优化器来说这样工作更加简单，直接把两个结果集凑在一起就行，也不会进行排序。</p><p>​    union查询能不用就不用，除非是用来代替or查询的时候酌情考虑是否有必要使用。</p><p>​    最后注意union的产生排序不受控制的，可能会出现意料之外的结果。</p><p><strong>3. 并行查询优化</strong></p><p>​    并行查询优化在8.0中终于有了实现，可以根据参数：<code>innodb_parallel_read_threads =并行数</code>来验证。</p><p>​    由于个人是M1的CPU，读者可以根据自己的实际情况进行实验。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">local</span> innodb_parallel_read_threads = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> payment;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">local</span> innodb_parallel_read_threads = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> payment;</span><br></pre></td></tr></table></figure><p>从执行结果可以看到仅仅是1万多条数据的count(*)查询就有明显直观的差距：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204051714387.png" alt=""></p><p><strong>4. 哈希关联</strong></p><p>​    官方文档的介绍地址：<span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy9yZWZtYW4vOC4wL2VuL2hhc2gtam9pbnMuaHRtbA==" title="https://dev.mysql.com/doc/refman/8.0/en/hash-joins.html">Mysql官方文档哈希关联<i class="fa fa-external-link"></i></span></p><p>​    在MySQL 8.0.18中Mysql终于增加了哈希关联的功能。在此之前的版本中，Mysql的优化器通常只支持for循环嵌套关联，曲线救国的方法是建立一个哈希索引或者使用Memory存储引擎，而新版本提供的哈希关联则提供了一种新的对关联方式，哈希关联的方式如下：</p><p>​    把一张小表数据存储到<strong>内存</strong>中的哈希表里，通过匹配大表中的数据计算<strong>哈希值</strong>，并把符合条件的数据从内存中返回客户端。    </p><p>​    对于Mysql的哈希关联，我们直接使用官方的例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (c1 <span class="built_in">INT</span>, c2 <span class="built_in">INT</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t2 (c1 <span class="built_in">INT</span>, c2 <span class="built_in">INT</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t3 (c1 <span class="built_in">INT</span>, c2 <span class="built_in">INT</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPLAIN</span></span><br><span class="line">     <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1</span><br><span class="line">         <span class="keyword">JOIN</span> t2 <span class="keyword">ON</span> t1.c1=t2.c1;</span><br><span class="line"><span class="comment">-- Using where; Using join buffer (hash join)</span></span><br></pre></td></tr></table></figure><p>​    除开等值查询以外，Mysql的8.0.20之后提供了更多的支持，比如在 MySQL 8.0.20 及更高版本中，连接不再需要包含至少一个等连接条件才能使用哈希连接，除此之外它还包括下面的内容：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 8.0.20 支持范围查询哈希关联</span></span><br><span class="line"><span class="keyword">EXPLAIN</span>  <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1 <span class="keyword">JOIN</span> t2 <span class="keyword">ON</span> t1.c1 &lt; t2.c1;</span><br><span class="line"><span class="comment">-- 8.0.20 支持 in关联</span></span><br><span class="line"><span class="keyword">EXPLAIN</span>  <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1 </span><br><span class="line">        <span class="keyword">WHERE</span> t1.c1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> t2.c2 <span class="keyword">FROM</span> t2);</span><br><span class="line"><span class="comment">-- 8.0.20 支持 not exists 关联</span></span><br><span class="line"><span class="keyword">EXPLAIN</span>  <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t2 </span><br><span class="line">         <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> t1.c1 = t2.c2);</span><br><span class="line"><span class="comment">-- 8.0.20 支持 左右外部连接</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> t2 <span class="keyword">ON</span> t1.c1 = t2.c1;</span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1 <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> t2 <span class="keyword">ON</span> t1.c1 = t2.c1;</span><br></pre></td></tr></table></figure><blockquote><p>注意8.0.18版本的哈希关联<strong>仅仅支持join查询</strong>，对于可能会带来笛卡尔积的左连和右连接查询是不支持的。但是在后续的版本中提供了更多查询条件支持</p><p>另外，8.0.20版本之前想要查看是否使用hash join，需要结合 <code>format=tree</code> 选项。</p></blockquote><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204051721828.png" alt="哈希关联"></p><p>​    最终Mysql在8.0.18版本中曾经提供过开关哈希索引和设置优化器提示<code>optimizer_switch</code>等参数来判定是否给予hash join的提示，真是闲的蛋疼（官方自己也这么认为）所以在8.0.19立马就把这些参数给废弃。</p><p>​    注意哈希连接不是没有限制的，了解哈希关联的流程就会发现如果哈希表过大，会导致整个哈希关联过程在磁盘中完成其速度可想而知，所以官方提供了下面的建议：</p><ul><li>增加<code>join_buffer_size</code>，也就是增加哈希关联的哈希表缓存大小，防止进入磁盘关联。</li><li>增加<code>open_files_limit</code>数量，这个参数什么意思这里就不介绍了，意义是增加这个参数可以增加关联的时候关联次数。</li></ul><blockquote><p>吐槽：说句心里话自Mysql被Oracle收购之后，越来越商业化的同时进步也越来越小，in查询优化这一点其实在很多开源库甚至Mysql的原作者给解决了，但是Mysql到了8.0依然和多年前的《高性能Mysql》结果没有差别。哎。。。。。</p><p>Mysql数据库的发展也告诉我们时刻保持开放的心态，吸取教训正视不足和改进，才不会被时代逐渐淘汰。</p></blockquote><p><strong>5. 松散索引</strong></p><p>​    松散索引在Mysql5.6之后已经支持，松散索引简单理解就是在进行多列索引扫描的时候，即使次索引不是有序的，但是跳过索引是有序的，也可以走索引来快速匹配数据。</p><pre><code>松散索引的优化细节放到了下半部分的文章，这里简单讲述一下大致的工作原理。</code></pre><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/202204051830883.png" alt=""></p><ol start="6"><li><strong>查询同时更新数据</strong></li></ol><p>​    在Postgresql中，支持下面的语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> tbl_info</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">name</span> = tmp.name</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> tbl_user <span class="keyword">where</span> <span class="keyword">name</span> =<span class="string">'xxx'</span>)</span><br><span class="line">tmp</span><br><span class="line">[<span class="keyword">where</span> ....]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 比如下面的写法：</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="string">`sakila`</span>.<span class="string">`actor`</span> <span class="keyword">SET</span> <span class="string">`first_name`</span> = <span class="string">'PENELOPE'</span></span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">(<span class="keyword">select</span> address,address_id <span class="keyword">from</span> address <span class="keyword">where</span> address_id = <span class="number">1</span>) tmp</span><br><span class="line"> <span class="keyword">WHERE</span> <span class="string">`actor_id`</span> = <span class="number">1</span> <span class="keyword">and</span> actor.actor_id = tmp.address_id;</span><br></pre></td></tr></table></figure><p>​    但是很可惜这种语法在Mysql是没有办法实现也是不支持的，哪怕到了8.0.26依然没有支持，这和Mysql的优化器设计有着本质的关系。</p><ol start="7"><li><strong>优化器提示设置</strong></li></ol><p>优化器提示没有多少意义，这里直接略过了。</p><ol start="8"><li><strong>最大值和最小值优化</strong></li></ol><p>​    从实际的情况来看Mysql最大值和最小值这两个函数使用并不是很多所以不再进行介绍了，另外无论什么样的数据库都不是很建议频繁使用函数，而是改用业务+简单SQL实现高效索引优化。</p><p>其他慢查询优化</p><p>​    对于慢查询的优化我们需要清楚优化是分为几种类别的，在Mysql中优化策略分为<strong>动态优化</strong>和<strong>静态优化</strong>：静态优化主要为优化更好的写法，比如常数的排序和一些固定的优化策略等，这些动作通常在一次优化过程中就可以完成。而动态优化策略要复杂很多，可能会在执行的过程中优化，有可能在执行过后重新评估执行计划。</p><p>​    静态优化是受优化器影响的，不同版本有不同情况，所以这里讲述动态优化的情况，而动态优化主要包含下面的内容：</p><ul><li>关联表顺序，有时候关联表顺序和查询顺序不一定相同。</li><li>重写外连接为内连接：如果一个外连接关联是没有必要的就优化掉外连接关联。</li><li>等价替换，比如 a&gt;5 and a= 5被优化为a &gt;= 5 ，类似数学的逻辑公式简化</li><li>优化count()、max()、min()等函数：有时候找最大和最小值只需要找最大和最小的索引记录，这时候由于不需要遍历，可以认为直接为哈希的获取记录的方式，所以在查询分析的 extra 里面进行体现（Select tables optimized away），比如：explain select max(actor_id) from actor;</li><li>预估和转化常数：以连接查询为例，如果在查询条件中可以实现预估关联的记录条数，那么对于一个关联查询来说就有可能被优化器作为常数进行优化，因为事先取出记录的条数被优化器知晓。所以优化起来十分简单。</li><li>子查询优化：子查询虽然有可能被索引优化但是需要尽量避免使用。</li><li>覆盖索引扫描：让索引和查询列一致，是非常高效的优化和执行方式</li><li>提前终止查询：提前终止查询指的是当遇到一些查询条件会让查询提前完成，优化器会提前判断加快数据的匹配和搜索速度</li><li>等值传递，如果范围查询可以根据关联表查询优化，那么无需 显式的提示则可以直接搜索数据。</li></ul><p>​    </p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>这里汇总了文章中出现的一些参考资料：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy9yZWZtYW4vOC4wL2VuL2hhc2gtam9pbnMuaHRtbA==" title="https://dev.mysql.com/doc/refman/8.0/en/hash-joins.html">Mysql官方文档哈希关联<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMTgvMDUvMjAvc3FsLXBhcnNlci11c2VkLWluLW10ZHAuaHRtbA==" title="https://tech.meituan.com/2018/05/20/sql-parser-used-in-mtdp.html">SQL解析在美团的应用 - 美团技术团队 (meituan.com)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9hd3MuYW1hem9uLmNvbS9jbi9ibG9ncy9jaGluYS9wdC1xdWVyeS1kaWdlc3QtcmRzLW15c3FsLXNsb3ctc2VhcmNobmV3Lw==" title="https://aws.amazon.com/cn/blogs/china/pt-query-digest-rds-mysql-slow-searchnew/">使用 pt-query-digest 分析 RDS MySQL 慢查询日志 | 亚马逊AWS官方博客 (amazon.com)<i class="fa fa-external-link"></i></span></li></ul><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>​    上半部分以理论为主，下半部分将会着重实战内容进行介绍。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      Mysql索引和查询优化
    
    </summary>
    
    
      <category term="数据库-mysql" scheme="https://whitestore.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-mysql/"/>
    
    
      <category term="数据库" scheme="https://whitestore.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Mysql" scheme="https://whitestore.top/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>《投资中最简单的事》读书笔记 - 寻找不变性</title>
    <link href="https://whitestore.top/2022/04/03/touzibubian/"/>
    <id>https://whitestore.top/2022/04/03/touzibubian/</id>
    <published>2022-04-03T04:47:59.000Z</published>
    <updated>2022-06-02T10:09:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《投资中最简单的事》读书笔记-寻找不变性"><a href="#《投资中最简单的事》读书笔记-寻找不变性" class="headerlink" title="《投资中最简单的事》读书笔记 - 寻找不变性"></a>《投资中最简单的事》读书笔记 - 寻找不变性</h1><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20220317220808.png" alt=""></p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>真正的价值投资应该乘着是越早用钱换经验，用尽可能少的钱换来“前瞻性”，而不是锻炼自己后视镜的眼光，用历史套用现在终究会血本无归，人人都可以事后诸葛亮，但是真正想要价值投资需要是<strong>培养向后看的眼光</strong>，培养寻找不变性的眼光。</p><h1 id="资源地址"><a href="#资源地址" class="headerlink" title="资源地址"></a>资源地址</h1><p>  《投资中最简单的事》pdf和mobi资源</p><p>链接: <span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMUhBVUQxTEFqckZQeHQ1cTNSUk9OSXc=" title="https://pan.baidu.com/s/1HAUD1LAjrFPxt5q3RRONIw">https://pan.baidu.com/s/1HAUD1LAjrFPxt5q3RRONIw<i class="fa fa-external-link"></i></span> 提取码: 2oii</p><h2 id="个人评价"><a href="#个人评价" class="headerlink" title="个人评价"></a>个人评价</h2><p>投资是不可能简单的，这本书的争议也十分大，原因是这本书非常散，很像是东拼西凑的书不成体系，不过确实如果股市有规律可循那么早就被资本周转运作消耗完了，所以投资最终学习的是学习<strong>不变性</strong>，而不是去分析市场的规律，规律是不可寻的，新冠和金融危机都是很好的启示，但是<strong>不变性</strong>是可寻的，比如<strong>瘦死的骆驼比马大</strong>，比如<strong>拥有定价权拥有一切</strong>，比如做“中间商”是一门好生意，因为现在所有的行业基本都离不开B2B，B2C，C2C这三个概念，再比如没有人除了战争可以炒的动黄金，所以在战争的前夕买黄金是稳赚不赔的生意，因为人类总是会在灾难的时候寻找最能保值的东西，再比如……等等。</p><p>寻找投资中的不变性是我读这本书的最大意义，所以我把这本书拆分为了三个部分：<strong>选赛道，选骑手（如果买的是基金）</strong>，<strong>稳心态</strong>。</p><a id="more"></a><h1 id="为什么我要看这本书"><a href="#为什么我要看这本书" class="headerlink" title="为什么我要看这本书"></a>为什么我要看这本书</h1><p>为什么我要看这本书呢？一方面作者作为重金投注基金的个人来说选对好的“骑师”是至关重要的，因为会发现在同样的赛道上如果骑师无法指挥好马是无法带来切实收益的，作为同一个行业的专业人士却有着天差地别的表现，这是很明显的圈子理论和效应，如果你投注一个烂圈子的懒经理，最好的方式是赶紧把钱取出来，你是什么样的人身边就会有什么样的人。另外坚持看完这本书的原因还有下面的几点，这几点包含了作者书中提到的前瞻性：</p><ul><li>预见了制造业往东南亚迁移。</li><li>汽车是一个好产业但是由于竞争压力过大很难有好的收益。</li><li>手游行业的爆发，并且和股市行情难以捉摸。</li></ul><p>·试想一下如果时间倒退十年能看到多少前瞻性的东西，有多少人能预测出这三个点？看到这些内容的时候第一反应并不是说自己能不能想到，而是发现自己从来就不会往后看或者往后猜，总是用历史去证明现在做的事情是对的，实际看来只有深入的了解国情才有可能在A股从券商手里偷钱。</p><h1 id="选赛道"><a href="#选赛道" class="headerlink" title="选赛道"></a>选赛道</h1><h2 id="投资依靠什么？"><a href="#投资依靠什么？" class="headerlink" title="投资依靠什么？"></a>投资依靠什么？</h2><p>如果我们不清楚自己所购买的企业是依靠什么赖以生存的那么是很难选对赛道的，选好赛道是价值投资的第一个步骤，下面是行之有效的几个参考点：</p><ul><li><p><strong>护城河</strong>是基石：如果总是需要深挖的护城河，那么这个行业就不能算是拥有护城河，在这样的行业里面求变是真理，所以高门槛和高标准是护城河，平台是护城河。 举例：手游市场竞争激烈，虽然因为缺乏理智被炒热，但是实际上真正的钱被平台赚走。但是后来实际证明手游这一块并不会被完全垄断，而是依然有很多其他力量介入。</p></li><li><p><strong>现金流</strong>决定抗风险能力，如果现金流受到各种条件制约，那么抗风险能力大幅度减弱，也难成大器，掌握现金流意味着定价权的掌握，谁拥有定价权就拥有先机。</p></li><li><p>行情：在熊市不要投资，行情不好的情况下几乎所有的赛道都不好走，行情和实际情况在不同国家有不同的反应，有的策略在这个国家有效，到了其他国家就不行了。这也是为什么我们看所有投资的好书却依然感觉学不到东西。</p><p>  举例：消费股总是周期往复，在美国消费股却常见杀猪盘，所以在低点买入是关键。</p></li><li><p>垄断：垄断行业总归是稳定增长的，但是垄断并不意味着稳定。在任何赛道里面买人人知道的股票是一件风险和代价很高的买卖。</p></li></ul><p>举例：电影为什么难以成为独立平台或者出现独立平台，因为电影总是没有平台或者大资本流入，拍电影不是一门好生意，但是当电影演员有可能是好生意。</p><h1 id="逆向投资"><a href="#逆向投资" class="headerlink" title="逆向投资"></a>逆向投资</h1><p>什么样的行业或人适合逆向投资？</p><ul><li>虽然可能容易受到时局影响但是本质不会变的行业。比如白酒虽然总是唱衰，但是实际上到了特定的时间段就是会上涨，因为消费是我国的生命线和安全线。</li><li>耐着住性子，只有耐心的人才能笑到最后，逆向投资是一种面向未来的投资方式，然而股市更多的是投机倒把者。</li><li>A股容易过度情绪化所以需要小心处理，因为逃的太快容易被踩死，跑的太前容易被挤死。</li><li>逆向投资并不是总是在暴跌的时候买入是对的，有可能出现更低的点，所以在大幅度下跌的时候不要轻易买入</li></ul><p>总结：不去人多地方并且不擅长在合适点出手的人适合逆向投资，人总是赚到大部分认知时候的钱，但是能接受可能部分收益不存在的人适合逆向投资，如果你没有及时止盈的能力或者投资的天赋，逆向投资和长期持有适合大部分普通人。</p><h2 id="投资的三个问题"><a href="#投资的三个问题" class="headerlink" title="投资的三个问题"></a>投资的三个问题</h2><p>做逆向投资，需要把控好三个问题：品质、估值、</p><ul><li>品质是否好？何谓品质，品质包含差异性，是不是一个好行业，同时需要小心是否是政策所管理的行业，最后胜而后求战才是值得购买的股票，而不是战而后求胜，因为拥有定价权或者垄断的公司才有东山再起的机会。</li><li>估值是否可以跑赢市场：其实也指上升空间，一年上升第二年疲软的股票不是好股票，很多人可能更加希望寻找一个平稳上涨的股票或者基金，但是平稳实际上意味着没有收益，今天上去明天下来。有一个特例是稳定增长的长期股票，这样的股票等到被发掘出来的时候往往上涨完成了。</li><li>时机，选股时机可能比选股本身更为重要，预见上涨的股票如果选择错误，很可能出现高点高仓位，低点低仓位。</li></ul><h2 id="何谓品质？"><a href="#何谓品质？" class="headerlink" title="何谓品质？"></a>何谓品质？</h2><p>如果用赌马的思路去思考投资，那么赛马最重要的是什么呢？是骑手还是马？我们总是想找到一匹好马，或者找一个好的骑手，但是我们忘了，找一个好的赛道才是关键，再好的马和骑手都不能在崎岖不堪的道路上跑出好成绩。</p><p>同样如果一个赛道上全是马或者骑手，我们很难分辨哪一匹马跑的快或者哪个骑手指挥的好，很多时候等我们看到跑完大半圈之后才看出端倪，但是这时候下注往往处于终点决赛阶段。</p><p>最后国家扶持的赛道其实需要特别小心的，为什么？因为市场会很容易有过激的反应，政策的加入会让各种投机取巧的分子进入抢占先机，最后赛道上全是马在跑，全是骑手在指挥，机构都不敢进入，更何况散户呢？另外国内政策对于行业的打击性也是毁灭的，因为我们的国家是公有制经济，经济的大头在国家手里，一旦想要打击某个小弟，所有人肯定只能避而远之。</p><h2 id="风险定义"><a href="#风险定义" class="headerlink" title="风险定义"></a>风险定义</h2><p>风险分为两种，一种是<strong>永久性丧失风险</strong>，这种风险是高风险低回报，一种是<strong>波动风险</strong>，这种风险是高风险高回报高收益，涨跌只是一时的表现，倒在黎明之前的人是大多数：</p><p>那么我们应该如何面对投资风险？</p><ul><li>投资风险分为价值投资和趋势投资，价值投资者的弱点是倒在黎明前，趋势投资者的弱点是没来得及卖出去，两者其实同样惨。</li><li>A股往往存在过激反应，常常会有超高估值的无价值公司爆发增长，于是追涨杀跌就会出现。</li><li>成长股不一定是稳妥的，经历过成长股之后的公司往往会出现疲软的局势。</li><li><strong>政策周期优于市场周期，市场周期优于经济周期</strong>。意味着经济周期往往在人们最不关注的地方以及最不关注的时候出现。</li><li>如果大街小巷都在讨论某个行业股票行情的时候，往往是最危险的时候，这时候需要做的事情是找准时机卖出高估值股票和重新寻找低估值股票。</li></ul><h2 id="市场与政策和估值的关系"><a href="#市场与政策和估值的关系" class="headerlink" title="市场与政策和估值的关系"></a>市场与政策和估值的关系</h2><p>我们可能认为政策会快速带动市场，然而政策干预的地方往往是最具有风险的，政策扶持可能会越管越乱，越管越破产。但是a股和政策对着干往往是死路一条，政策打压的行业需要小心，政策扶持的行业容易追涨杀跌。</p><p>股价永远是越低越好，高仓位高估值如同一叶扁舟，不仅容易被割韭菜，还容易追涨。</p><h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><p>上面的这几个问题的基本分析可以确定一支股票或者行业的好坏，其实选股和选马是一样的，首先需要找一条好的跑道，其次如果是基金选对骑师很重要，对于选股则选马和时机很重要，对于现在时代而言行业新赛道已经很难挖掘，更多需要对于选时机进行更多分析，研究周期性股票也是选股的关键。</p><p>最终我们会发现失败者往往是投机者，而成功者往往是选择价值投资和逆向投资的人，选择趋势投资还是长期投资取决于你有多少耐性。</p><h1 id="稳心态"><a href="#稳心态" class="headerlink" title="稳心态"></a>稳心态</h1><h2 id="投资心理学"><a href="#投资心理学" class="headerlink" title="投资心理学"></a>投资心理学</h2><p>投资是一种心理的博弈，了解自己的投资目的和建立自己的投资原则很重要，可能很多人认为投资心理学应该是自己选股或者选基之后出现下面的心理问题:</p><ul><li>关注其他行业，却永远不看自己股票价值。</li><li>总是在不到预期的时候追涨杀跌。</li><li>后视镜现象严重，总是把历史搬到今年来进行验证，总是在事后诸葛亮。</li><li>买股之后却不进行分析，无法坚定自己的判断。</li><li>短期趋势长期化，这样的做法可能就是被钓上来的鱼。</li><li><strong>赚了一块钱总想赚更多，亏一分钱都受不了</strong>，其实股价和你买了多少成本多少无关，不买照样无法影响股票估值上涨和下跌。</li></ul><h2 id="如何面对亏损？"><a href="#如何面对亏损？" class="headerlink" title="如何面对亏损？"></a>如何面对亏损？</h2><ul><li>忘记成本，你投入多少和股票的涨跌无关，所以不要在意你的亏损，投资需要的是比较，选对赛道和及时止损很重要。买的股票是在波动风险范围内。</li><li>你能撑多久：想象一下你的极限，比如是立马掉20个点也不打算买，那就是真的错误投资了，</li></ul><h2 id="不能触碰的赛道"><a href="#不能触碰的赛道" class="headerlink" title="不能触碰的赛道"></a>不能触碰的赛道</h2><ul><li>分散无定价权的夕阳产业，比如钢铁，基建。热度马上消退。</li><li>无显著竞争力的小公司，赢家通吃，依赖于平台吃饭。</li><li>技术进步淘汰的公司，比如传统线下被线上取代，物流是一个特点，地方物流最终被全国物流取代。</li></ul><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>说到容易做到难，投资需要的是时间和“价值”磨炼。</p><blockquote><p>高礼价值投资研究院推荐书单，感兴趣看看，《鞋狗》这本书还不错哦。 <span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC85ODkzMTg1Mw==" title="https://zhuanlan.zhihu.com/p/98931853">https://zhuanlan.zhihu.com/p/98931853<i class="fa fa-external-link"></i></span></p></blockquote><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      请输入描述信息
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://whitestore.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="书籍" scheme="https://whitestore.top/tags/%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
</feed>
