<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>爱看书的阿东</title>
  
  <subtitle>赐他一块白色石头，石头上写着新名</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://whitestore.top/"/>
  <updated>2023-10-21T14:26:20.053Z</updated>
  <id>https://whitestore.top/</id>
  
  <author>
    <name>阿东</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Mysql】Working with time zones, timestamps and datetimes in Laravel and MySQL</title>
    <link href="https://whitestore.top/2023/10/21/worktimestampmysql/"/>
    <id>https://whitestore.top/2023/10/21/worktimestampmysql/</id>
    <published>2023-10-21T14:24:58.000Z</published>
    <updated>2023-10-21T14:26:20.053Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h1><p><span class="exturl" data-url="aHR0cHM6Ly9laWRlYXN5LmNvbS93b3JraW5nLXdpdGgtdGltZS16b25lcy10aW1lc3RhbXBzLWFuZC1kYXRldGltZXMtaW4tbGFyYXZlbC1hbmQtbXlzcWwv" title="https://eideasy.com/working-with-time-zones-timestamps-and-datetimes-in-laravel-and-mysql/">Working with time zones, timestamps and datetimes in Laravel and MySQL - Advanced and Qualified electronic signature marketplace (eideasy.com)<i class="fa fa-external-link"></i></span></p><p>There seems to be quite a bit of confusion around how timestamps, datetimes and time zones really work. This article aims to demystify these concepts and give some recommendations and best practices on how to handle dates and time zones in a sane way in your Laravel app and MySQL.</p><a id="more"></a><p>关于时间戳、日期和时区的真正工作原理，似乎存在不少困惑。本文旨在揭开这些概念的神秘面纱，并就如何在 Laravel 应用程序和 MySQL 中以合理的方式处理日期和时区给出一些建议和最佳实践。</p><blockquote><p>补充：Laravel 是PHP生态的框架，Java 开发人员可以忽略</p></blockquote><h2 id="How-the-TIMESTAMP-type-works-in-MySQL"><a href="#How-the-TIMESTAMP-type-works-in-MySQL" class="headerlink" title="How the TIMESTAMP type works in MySQL"></a>How the TIMESTAMP type works in MySQL</h2><p><span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy9yZWZtYW4vOC4wL2VuL2RhdGV0aW1lLmh0bWw=" title="https://dev.mysql.com/doc/refman/8.0/en/datetime.html">The official documentation of MySQL<i class="fa fa-external-link"></i></span> explains it as follows:</p><blockquote><p> MySQL converts TIMESTAMP values from the current time zone to UTC for storage, and back from UTC to the current time zone for retrieval. </p><p>  MySQL 会将 TIMESTAMP 值从当前时区转换到 UTC 以进行存储，并在检索时从 UTC 转换回当前时区。</p><p> (This does not occur for other types such as DATETIME.) By default, the current time zone for each connection is the server’s time. </p><p>(默认情况下，每个连接的当前时区是服务器时间。</p><p> The time zone can be set on a per-connection basis. As long as the time zone setting remains constant, you get back the same value you store. </p><p>时区可根据每个连接进行设置。只要时区设置保持不变，就会返回存储的相同值。</p><p> If you store a TIMESTAMP value, and then change the time zone and retrieve the value, the retrieved value is different from the value you stored. </p><p> 如果存储了 <strong>TIMESTAMP</strong> 值，然后更改时区并检索该值，则检索到的值与存储的值不同。</p><p> This occurs because the same time zone was not used for conversion in both directions. </p><p>出现这种情况是因为在两个方向的转换中没有使用相同的时区。</p><p> The current time zone is available as the value of the <span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy9yZWZtYW4vOC4wL2VuL3NlcnZlci1zeXN0ZW0tdmFyaWFibGVzLmh0bWwjc3lzdmFyX3RpbWVfem9uZQ==" title="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_time_zone">time_zone<i class="fa fa-external-link"></i></span> system variable. </p><p> 当前时区可以通过 <span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy9yZWZtYW4vOC4wL2VuL3NlcnZlci1zeXN0ZW0tdmFyaWFibGVzLmh0bWwjc3lzdmFyX3RpbWVfem9uZQ==" title="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_time_zone">time_zone<i class="fa fa-external-link"></i></span> 系统变量的值获得。</p><p> For more information, see <span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy9yZWZtYW4vOC4wL2VuL3RpbWUtem9uZS1zdXBwb3J0Lmh0bWw=" title="https://dev.mysql.com/doc/refman/8.0/en/time-zone-support.html">Section 5.1.15, “MySQL Server Time Zone Support”<i class="fa fa-external-link"></i></span>.</p><p> 更多信息，请参阅 <span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy9yZWZtYW4vOC4wL2VuL3RpbWUtem9uZS1zdXBwb3J0Lmh0bWw=" title="https://dev.mysql.com/doc/refman/8.0/en/time-zone-support.html">第 5.1.15 节，”MySQL 服务器时区支持”<i class="fa fa-external-link"></i></span>。</p></blockquote><p>This explanation is perhaps a little bit abstract. So, let’s add some context and see what is really happening behind the scenes.</p><p>这种解释可能有点抽象。因此，让我们补充一些背景知识，看看幕后到底发生了什么。</p><h3 id="Current-time-zone"><a href="#Current-time-zone" class="headerlink" title="Current time zone"></a>Current time zone</h3><p>In order to understand how the timestamp conversions work we first need to know what’s meant by <strong>current time zone.</strong></p><p>要了解时间戳转换的工作原理，我们首先需要了解<strong>当前时区</strong>的含义。</p><p>In short, <strong>current time zone</strong> is the value of the SESSION time_zone. By default this is the SYSTEM time of the server that the database is running on. Let’s run some queries to illustrate this.</p><p>简而言之，<strong>当前时区</strong>就是 <code>Session</code> 时区的值。默认情况下，这是数据库所运行服务器的系统时间。让我们运行一些查询来说明这一点。</p><p>Running <code>SELECT @@SESSION.time_zone;</code> will return the current SESSSION time_zone like this:</p><p>运行 “<strong>SELECT @@SESSION.time_zone;</strong> “将返回当前的 SESSSION 时区，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+---------------------+</span><br><span class="line">| @@SESSION.time_zone |</span><br><span class="line">+---------------------+</span><br><span class="line">| SYSTEM              |</span><br><span class="line">+---------------------+</span><br></pre></td></tr></table></figure><p>Let’s change the SESSION time_zone to “+02:00” by running: <code>SET SESSION time_zone = &#39;+02:00&#39;;</code></p><p>运行 <code>SET SESSION time_zone = &#39;+02:00&#39;;</code> 将 SESSION 时区更改为 “<strong>+02:00</strong>“。</p><p><code>SELECT @@SESSION.time_zone;</code> will now return:</p><p>现在将返回 <code>SELECT @@SESSION.time_zone;</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+---------------------+</span><br><span class="line">| @@SESSION.time_zone |</span><br><span class="line">+---------------------+</span><br><span class="line">| +02:00              |</span><br><span class="line">+---------------------+</span><br></pre></td></tr></table></figure><h2 id="Practical-examples-of-how-timestamp-works-时间戳工作原理实例"><a href="#Practical-examples-of-how-timestamp-works-时间戳工作原理实例" class="headerlink" title="Practical examples of how timestamp works 时间戳工作原理实例"></a>Practical examples of how timestamp works 时间戳工作原理实例</h2><p>Let’s now go through some examples with specific dates and times to see how the timestamp storage and retrieval works in real life.</p><p>现在，让我们用具体的日期和时间举几个例子，看看时间戳的存储和检索在实际生活中是如何工作的。</p><p>We’ll start by creating a table with a TIMESTAMP column to store our test data.</p><p>首先，我们将创建一个带有 <code>TIMESTAMP</code> 列的表来存储测试数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE timestamp_test (</span><br><span class="line">    &#96;timestamp&#96; TIMESTAMP,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>We’ll now set our session time_zone to +02:00 and store some data</p><p>现在，我们要将 <code>Session</code> 时区设置为 <code>+02:00</code>，并存储一些数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET SESSION time_zone &#x3D; &#39;+02:00&#39;;</span><br><span class="line"></span><br><span class="line">INSERT INTO timestamp_test VALUES (&#39;1970-01-01 03:00:00&#39;);</span><br></pre></td></tr></table></figure><p>Check that the value got stored:</p><p>检查数值是否已存储：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> timestamp_test;</span><br></pre></td></tr></table></figure><p>We’ll see:</p><p>我们拭目以待：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+---------------------+</span><br><span class="line">| timestamp           |</span><br><span class="line">+---------------------+</span><br><span class="line">| 1970-01-01 03:00:00 |</span><br><span class="line">+---------------------+</span><br></pre></td></tr></table></figure><p>Schematic representation of the storage process:</p><p>下面是存储过程示意图：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20231020075820.png" alt="image.png"></p><p>So far so good. But what happens if we change the session time_zone?</p><p>到目前为止一切顺利。但如果我们更改会话时区，会发生什么呢？</p><p>Let’s set our session time_zone to <code>+00:00</code> and retrieve the data again.</p><p>让我们把会话时区设置为 “+00:00”，然后再次检索数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET SESSION time_zone &#x3D; &#39;+00:00&#39;;</span><br><span class="line">SELECT * FROM timestamp_test;</span><br></pre></td></tr></table></figure><p>We’ll see:</p><p>我们拭目以待：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+---------------------+</span><br><span class="line">| timestamp           |</span><br><span class="line">+---------------------+</span><br><span class="line">| 1970-01-01 01:00:00 |</span><br><span class="line">+---------------------+</span><br></pre></td></tr></table></figure><p>Schematic representation of the retrieval process:</p><p>检索过程示意图：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20231020075841.png" alt="image.png"></p><p><strong>Key takeaways:</strong></p><p><strong>主要收获：</strong></p><ol><li><p>MySQL stores the timestamp value as a <strong><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVW5peF90aW1l" title="https://en.wikipedia.org/wiki/Unix_time">Unix timestamp<i class="fa fa-external-link"></i></span></strong> in seconds.</p></li><li><p>MySQL does <strong>not</strong> store any information about the timezone.</p></li><li><p>Every time you store a value as a timestamp, it is converted to the Unix timestamp according to the current session time_zone.</p></li><li><p>Every time you retrieve a timestamp, it is converted to the datetime value according to the current session time_zone.</p></li><li><p>MySQL 将时间戳值存储为 <strong><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVW5peF90aW1l" title="https://en.wikipedia.org/wiki/Unix_time">Unix时间戳<i class="fa fa-external-link"></i></span></strong>，单位为秒。</p></li><li><p>MySQL <strong>不存储任何有关时区的信息</strong>。</p></li><li><p>每次以时间戳存储值时，都会根据当前会话时区将其转换为 Unix 时间戳。</p></li><li><p>每次检索时间戳时，都会根据当前会话时区将其转换为日期时间值。</p></li></ol><p><strong>Note</strong> A simple algorithm to convert dates to timestamps according to a specific timezone might look something like this (in case you’re interested how that’s actually done):</p><p><strong>注意</strong>，根据特定时区将日期转换为时间戳的简单算法可能是这样的（如果你对实际操作感兴趣的话）：</p><ol><li><p>Get the difference between the datetime and the Unix epoch (1970-01-01 00:00:00) in seconds.</p></li><li><p>Convert your current timezone offset to seconds</p></li><li><p>Subtract your current timezone offset from the value you got in step 1.</p></li><li><p>获取日期时间与 Unix 时间（1970-01-01 00:00:00）之间的差值（以秒为单位）。</p></li><li><p>将当前时区偏移转换为秒</p></li><li><p>用步骤 1 中得到的值减去当前时区偏移。</p></li></ol><p>For example, let’s say our time zone offset is +02:00 and we wish to convert 1970-01-01 03:00:00 to a Unix timestamp.</p><ol><li>1970-01-01 03:00:00 – 1970-01-01 00:00:00 = 3h = 3 * 60 * 60 = 10800</li><li>+02:00 in seconds is: 2 * 60 * 60 = 7200</li><li>10800 – 7200 = 3600</li></ol><p>例如，假设我们的时区偏移为 +02:00，我们希望将 1970-01-01 03:00:00 转换为 Unix 时间戳。</p><ol><li>1970-01-01 03:00:00 - 1970-01-01 00:00:00 = 3h = 3 * 60 * 60 = 10800</li><li>+02:00（秒）为： 2 * 60 * 60 = 7200 3.</li><li>10800 - 7200 = 3600</li></ol><p>Another example, let’s say our time zone offset is -03:00 and we wish to convert 1970-01-01 08:00:00 to a Unix timestamp.</p><ol><li>1970-01-01 08:00:00 – 1970-01-01 00:00:00 = 8h = 8 * 60 * 60 = 28800</li><li>-03:00 in seconds is: -3 * 60 * 60 = -10800</li><li>28800 – – 10800 = 39600 (note that we actually add the values as double minuses give a +)</li></ol><p>再比如，我们的时区偏移是 -03:00，我们希望将 1970-01-01 08:00:00 转换为 Unix 时间戳。</p><ol><li>1970-01-01 08:00:00 - 1970-01-01 00:00:00 = 8h = 8 * 60 * 60 = 28800</li><li>-03:00 的秒数为： -3 * 60 * 60 = -10800</li><li>28800 - - 10800 = 39600（注意，我们实际上是将这些值相加，因为双减得到的是 +）<h2 id="How-the-TIMESTAMP-type-differs-from-the-DATE-and-DATETIME-types-TIMESTAMP-类型与-DATE-和-DATETIME-类型的区别"><a href="#How-the-TIMESTAMP-type-differs-from-the-DATE-and-DATETIME-types-TIMESTAMP-类型与-DATE-和-DATETIME-类型的区别" class="headerlink" title="How the TIMESTAMP type differs from the DATE and DATETIME types TIMESTAMP 类型与 DATE 和 DATETIME 类型的区别"></a>How the TIMESTAMP type differs from the DATE and DATETIME types <strong>TIMESTAMP 类型与 DATE 和 DATETIME 类型的区别</strong></h2></li></ol><p>In case of TIMESTAMP, the actual value that is stored and retrieved depends on the session time_zone whereas DATE and DATETIME are always retrieved as the exact same values that were stored. </p><p>就 <code>TIMESTAMP</code> 而言，存储和检索的实际值取决于<strong>Session 时区</strong>，而 DATE 和 DATETIME 的检索值始终与存储值完全相同。</p><p>You can imagine the DATE and DATETIME values as static strings. </p><p>您可以将 DATE 和 DATETIME 值想象成<strong>静态字符串</strong>。</p><p>The string you store does not change upon retrieval. </p><p>您存储的字符串在检索时不会改变。</p><p>You’ll always get back the exact same value that you stored no matter the database’s or session’s time zone.</p><p>无论数据库或会话的时区如何，您都将返回所存储的<strong>完全相同的值</strong>。</p><p>TIMESTAMP can only store values from 1970-01-01 00:00:00 to 2038-01-19 03:14:17. The reason for this is how the Unix time is encoded: <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvWWVhcl8yMDM4X3Byb2JsZW0=" title="https://en.wikipedia.org/wiki/Year_2038_problem">https://en.wikipedia.org/wiki/Year_2038_problem<i class="fa fa-external-link"></i></span></p><p>TIMESTAMP 只能存储 1970-01-01 00:00:00 至 2038-01-19 03:14:17 的值。</p><p><strong>原因在于 Unix 时间的编码方式： <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvWWVhcl8yMDM4X3Byb2JsZW0=" title="https://en.wikipedia.org/wiki/Year_2038_problem">https://en.wikipedia.org/wiki/Year_2038_problem<i class="fa fa-external-link"></i></span></strong></p><p>DATETIME and DATE do not have such a limit.</p><p><code>DATETIME</code> 和 <code>DATE</code> 就没有这种限制。</p><h2 id="How-Laravel-handles-dates-and-times-Laravel-如何处理日期和时间"><a href="#How-Laravel-handles-dates-and-times-Laravel-如何处理日期和时间" class="headerlink" title="How Laravel handles dates and times Laravel 如何处理日期和时间"></a>How Laravel handles dates and times Laravel <strong>如何处理日期和时间</strong></h2><p>We’ve seen how the timestamp works on MySQL’s side. Let’s now see how dates and times are handled by Laravel.</p><p>我们已经了解了 MySQL 如何处理时间戳。现在让我们看看 Laravel 是如何处理日期和时间的。</p><p>Laravel uses <span class="exturl" data-url="aHR0cHM6Ly9jYXJib24ubmVzYm90LmNvbS9kb2NzLw==" title="https://carbon.nesbot.com/docs/">Carbon<i class="fa fa-external-link"></i></span> for generating dates (<span class="exturl" data-url="aHR0cHM6Ly9sYXJhdmVsLmNvbS9kb2NzLzEwLngvaGVscGVycyNkYXRlcw==" title="https://laravel.com/docs/10.x/helpers#dates">https://laravel.com/docs/10.x/helpers#dates<i class="fa fa-external-link"></i></span>). </p><p>Laravel 使用 <span class="exturl" data-url="aHR0cHM6Ly9jYXJib24ubmVzYm90LmNvbS9kb2NzLw==" title="https://carbon.nesbot.com/docs/">Carbon<i class="fa fa-external-link"></i></span> 生成日期（<span class="exturl" data-url="aHR0cHM6Ly9sYXJhdmVsLmNvbS9kb2NzLzEwLngvaGVscGVycyNkYXRlcw==" title="https://laravel.com/docs/10.x/helpers#dates">https://laravel.com/docs/10.x/helpers#dates<i class="fa fa-external-link"></i></span>）。</p><p>Carbon in turn uses PHPs Date/Time functions <span class="exturl" data-url="aHR0cHM6Ly93d3cucGhwLm5ldC9tYW51YWwvZW4vcmVmLmRhdGV0aW1lLnBocA==" title="https://www.php.net/manual/en/ref.datetime.php">https://www.php.net/manual/en/ref.datetime.php<i class="fa fa-external-link"></i></span>. </p><p>而 Carbon 又使用 PHP 的日期/时间函数 <span class="exturl" data-url="aHR0cHM6Ly93d3cucGhwLm5ldC9tYW51YWwvZW4vcmVmLmRhdGV0aW1lLnBocA==" title="https://www.php.net/manual/en/ref.datetime.php">https://www.php.net/manual/en/ref.datetime.php<i class="fa fa-external-link"></i></span>。</p><p>This means that when we generate a current date then that’s done according to PHP’s timezone. </p><p>这意味着当我们生成当前日期时，是根据 PHP 的时区来生成的。</p><p>But what determines PHP’s timezone? </p><p>但 PHP 的时区是由什么决定的呢？</p><p>Well, Laravel conveniently does that for you via the config/app.php timezone setting.</p><p>Laravel 可以通过配置/app.php 中的时区设置为您实现这一功能。</p><p>What kind of implications does the above have on how the dates are saved to our database? We can bring an example to illustrate this.</p><p>上述情况对如何将日期保存到数据库有什么影响？我们可以举例说明。</p><p>Let’s consider the following situation:</p><ul><li>timezone in our app’s config/app.php is set to <code>Europe/Berlin</code></li><li>our database session time_zone is <code>Europe/Tallinn</code> The mysql.timezone setting in config/database.php. If you do not specifically set it, then the database will probably use the system time of the server that it’s running on.</li></ul><ol><li>We generate a date in our Laravel app using the <code>now()</code> helper function which returns us the following date: “2023-10-13 16:00:00”. This is the current datetime in <code>Europe/Berlin</code></li><li>We then send “2023-10-13 16:00:00” to our MySQL database for storage in a timestamp column (for example by creating a Model and calling save() on it)</li><li>Our database takes “2023-10-13 16:00:00” and converts it to a Unix timestamp according to <code>Europe/Tallinn</code> timezone and then stores it. Notice what’s happening here? We generated the datetime according to <code>Europe/Berlin</code> but our database converted it to a timestamp according to <code>Europe/Tallinn</code></li><li>When we retrieve the timestamp, our database converts the timestamp back to datetime according to <code>Europe/Tallinn</code> (session time_zone). Which results in “2023-10-13 16:00:00” (the original datetime we generated) So, at a glance everything seems to be ok. However, what happens if we change our app’s timezone to also be <code>Europe/Tallinn</code> ?</li><li>On retrieval, nothing changes, we still get back 2023-10-13 16:00:00 as the conversion depends on the database session time_zone and not on our app timezone.</li><li>Real issues arise when we start doing date comparisons in our app. Let’s say the date we originally saved was the creation date of a token and 30 minutes have passed since we generated it. We now wish to see whether the token is expired. For that:<ol><li>we get our current time with <code>now()</code> (which now generates dates according to <code>Europe/Tallinn</code> timezone as we changed our app’s timezone), we get 2023-10-13 17:30:00</li><li>we get the token’s creation time from the database: 2023-10-13 16:00:00</li><li>token should be valid for 1h, so we subtract the creation date from the current time and get a difference of 1.5h which seems to indicate that the token has expired. However in reality, only 30 minutes have passed.</li></ol></li></ol><p>让我们考虑一下下面的情况：</p><ul><li>应用程序配置<code>/app.php</code> 中的时区设置为  <code>Europe/Berlin</code>。</li><li>我们的数据库会话时区是<code>欧洲/塔林</code> config/database.php 中的 mysql.timezone 设置。如果没有特别设置，数据库可能会使用运行服务器的系统时间。</li></ul><ol start="7"><li>我们在 <strong>Laravel</strong> 应用程序中使用 <code>now()</code> 辅助函数生成一个日期，返回如下日期：”<code>2023-10-13 16:00:00</code>“。这是当前在 <code>Europe/Berlin</code> 的日期时间。  </li><li>然后，我们将 “<code>2023-10-13 16:00:00</code> “发送到 MySQL 数据库的时间戳列中（例如，通过创建一个模型并调用 <code>save()</code> 函数）。  </li><li>我们的数据库接收 “<code>2023-10-13 16:00:00</code>“，并根据 <code>Europe/Berlin</code>  时区将其转换为 <strong>Unix</strong> 时间戳，然后将其存储起来。注意到这里发生了什么吗？我们根据 <code>Europe/Berlin</code> 生成了日期时间，但我们的数据库根据 <code>Europe/Berlin</code> 将其转换为时间戳。</li><li>当我们检索时间戳时，我们的数据库又将时间戳转换成了 “<code>Europe/Tallinn</code>“（会话时区）的日期时间。结果是 “<code>2023-10-13 16:00:00</code>“（我们生成的原始日期时间）。因此，乍一看一切似乎都没问题。但是，如果我们将应用程序的时区也改为 “<code>Europe/Tallinn</code>“，会发生什么情况呢？  </li><li>在检索时，没有任何变化，我们仍然得到 <code>2023-10-13 16:00:00</code>，因为转换取决于数据库会话的时区，而不是应用程序的时区。  </li><li>当我们开始在应用程序中进行日期比较时，真正的问题就出现了。假设我们最初保存的日期是令牌的创建日期，而生成令牌后已经过去了 30 分钟。我们现在希望查看令牌是否过期。</li></ol><p>为此：  </p><ol><li>我们使用 <code>now()</code> 获取当前时间（由于我们更改了应用程序的时区，因此现在根据 <code>Europe/Tallinn</code> 时区生成日期），得到 <code>2023-10-13 17:30:00</code></li><li>我们从数据库中得到令牌的创建时间：<code>2023-10-13 16:00:00</code></li><li>令牌的有效期应为 1 小时，因此我们将创建日期减去当前时间，得到 1.5 小时的差值，这似乎表明令牌已过期。但实际上只过了 30 分钟。<h2 id="Key-takeaways-and-best-practices-主要收获和最佳做法"><a href="#Key-takeaways-and-best-practices-主要收获和最佳做法" class="headerlink" title="Key takeaways and best practices 主要收获和最佳做法"></a>Key takeaways and best practices 主要收获和最佳做法</h2></li></ol><p>It might seem that running the database and the Laravel app in different timezones is pretty safe if you never change the timezone configs. However, this is a risky bet to make.</p><p>如果不更改时区配置，在不同时区运行数据库和 <code>Laravel</code> 应用程序似乎很安全。然而，这样做是有风险的。</p><p>Timezone changes might easily happen if you are running many instances of your apps and databases. The majority of cloud providers set their instance timezones to UTC by default so if you are running a different timezone you need to be extra careful to always set the instances to that sepcific timezone.</p><p>如果您正在运行多个应用程序和数据库实例，时区变化就很容易发生。大多数云提供商默认将实例时区设置为 UTC，因此如果您运行的是不同的时区，则需要格外小心，始终将实例设置为该特定时区。</p><p>You’ll also need to consider daylight saving times. For example if your database session time_zone is UTC and your app timezone is <code>Europe/Berlin</code> then you’ll end up with a plethora of issues on the last Sunday of October when the offset of <code>Europe/Berlin</code> changes due to daylight saving time change.</p><p>您还需要考虑夏令时。例如，如果您的<strong>数据库会话时区是 UTC，而应用程序时区是 <code>Europe/Tallinn</code></strong>，那么在十月的最后一个星期天，当 <code>Europe/Tallinn</code>的偏移量因夏令时变化而改变时，您就会遇到大量问题。</p><p>All this considered, the sanest way to handle dates in Laravel and MySQL is as follows:</p><ol><li>Always set the timezones of your apps and databases to UTC. This way you’ll not have to deal with any conversion and timezone issues.</li><li>If you wish to display dates according to your end-user’s timezone then convert the date to end-user’s timezone just before displaying it. Avoid storing it in a different timezone.</li></ol><p>综上所述，在 <code>Laravel</code> 和 <code>MySQL</code> 中处理日期的最合理方法如下：</p><ol><li>始终将应用程序和数据库的时区设置为 UTC。这样就不必处理任何转换和时区问题。</li><li>如果您希望<strong>根据最终用户的时区显示日期</strong>，那么<strong>在显示之前将日期转换为最终用户的时区</strong>。避免将日期存储在不同的时区。</li></ol><p>As for whether to use DATETIME or TIMESTAMP – that decision is up to you and is use case dependent.</p><p>至于是使用 DATETIME 还是 TIMESTAMP，这取决于您的使用情况。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      Mysql的日期工作机制
    
    </summary>
    
    
      <category term="Mysql" scheme="https://whitestore.top/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="https://whitestore.top/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】Linux Zero-Copy Using sendfile</title>
    <link href="https://whitestore.top/2023/09/13/zerocopy/"/>
    <id>https://whitestore.top/2023/09/13/zerocopy/</id>
    <published>2023-09-13T06:08:23.000Z</published>
    <updated>2023-10-21T14:26:31.032Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h1><p>Source：<span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL3N3bGgvbGludXgtemVyby1jb3B5LXVzaW5nLXNlbmRmaWxlLTc1ZDJlYjU2YjM5Yg==" title="https://medium.com/swlh/linux-zero-copy-using-sendfile-75d2eb56b39b">Linux Zero-Copy Using sendfile(). sendfile() has been gradually becoming… | by CocCoc Techblog | The Startup | Medium<i class="fa fa-external-link"></i></span></p><h1 id="Why-Zero-copy"><a href="#Why-Zero-copy" class="headerlink" title="Why Zero-copy?"></a>Why Zero-copy?</h1><p>What’s happening under the hood when the OS is copying a file / transfering a file to another host? </p><p>当操作系统将文件复制/传输到另一台主机时，在系统底层下发生了什么？</p><p>For our naked eyes the process can be simple, OS first reads content of the file, then writes it to another file, then it’s done! </p><p>我们<strong>肉眼</strong>看到的过程可能很简单：<strong>操作系统首先读取文件内容，然后将其写入另一个文件，接着就完成了！</strong></p><p>However, things become complicated when we look more closely and memory is taken into account.</p><p>然而，当我们仔细观察并将内存考虑在内时，事情就变得复杂了。</p><p>As depicted in the dataflow below, the file read from disk must go through kernel system cache — which resides in the kernel space, then the data is copied to userspace’s memory area before being written back to a new file — which then in turn goes to kernel memory buffer before really flushed out to disk. </p><p>如下面的数据流所示，从磁盘读取的文件必须经过内核系统缓存（位于内核空间），然后数据被复制到用户空间的内存区域，再写回一个新文件，然后再进入内核内存缓冲区，最后被刷新到磁盘。</p><p>The procedure takes quite many unnecessary operations of copying back and forth between kernel and userspace without actually doing anything, and the operations consume system resources and context switches as well. </p><p>这个过程需要在内核和用户空间之间进行大量不必要的来回复制操作，但实际上什么都没做，而且这些操作还会消耗系统资源和上下文切换。</p><p>There’re room for improvement.</p><p>当然这部分还有改进余地。</p><a id="more"></a><p>Zero-copy technique comes into play with the purpose of eliminating all the unnecessary copies. In the Linux world the system call for that kind of work is <strong><em>sendfile().</em></strong></p><p>零拷贝技术的目的是<strong>消除所有不必要的拷贝</strong>。在 Linux 世界中，这种工作的系统调用是 **_sendfile()。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230825130421.png" alt="image.png"></p><p>Differences between data transfer using read()+write() / sendfile()</p><p>使用 <code>read()+write() / sendfile()</code> 进行数据传输的区别</p><h1 id="What-is-Zero-copy"><a href="#What-is-Zero-copy" class="headerlink" title="What is Zero-copy"></a>What is Zero-copy</h1><p><em>sendfile()</em> claims to make data transfer happening under kernel space only — i.e data transferred from kernel system cache to NIC buffer (or traversed through kernel system cache if local copy), thus doesnt require context switches as in read+write combination. </p><p><em>sendfile()</em> 声称只在内核空间进行数据传输，即数据从内核系统缓存传输到网卡缓冲区（如果是本地拷贝，则穿过内核系统缓存），因此不需要像读写结合那样进行上下文切换。</p><p><em>sendfile()</em> has now been widely used as a supported data transfering technique especially under <strong><em>nginx</em></strong> <em>and</em> <strong><em>kafka.</em></strong></p><p>现在，<em>sendfile()</em> 已被广泛用作一种受支持的数据传输技术，尤其是在<strong><em>nginx</em></strong> _和**_kafka下。</p><p>For ease of understanding we demonstrate a simple local file copy rather than file transfer over networking, and all the code’s error checking procedures are left out for clarity as well.</p><p>为了便于理解，我们演示的是简单的本地文件复制，而不是通过网络进行文件传输，而且为了清楚起见，我们也省略了代码中所有的错误检查程序。</p><p><strong><em>readwrite.c</em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;#define BUF_SIZE 4096*1000</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE];  </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *fromfile = argv[<span class="number">1</span>];  </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *tofile = argv[<span class="number">2</span>];  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat_buf</span>;</span>  </span><br><span class="line">    <span class="keyword">int</span> fromfd = <span class="built_in">open</span>(fromfile, O_RDONLY);  </span><br><span class="line">    fstat(fromfd, &amp;stat_buf);  </span><br><span class="line">    <span class="keyword">int</span> tofd = <span class="built_in">open</span>(tofile, O_WRONLY | O_CREAT, stat_buf.st_mode);    <span class="keyword">int</span> n;  </span><br><span class="line">    <span class="keyword">while</span> ((n = <span class="built_in">read</span>(fromfd, &amp;buf, <span class="keyword">sizeof</span>(buf))) &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="built_in">write</span>(tofd, &amp;buf, n);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>buf[BUF_SIZE]</em></strong> is the <em>user-space buffer</em> that we’re talking about, as can be seen for every iteration, <em>read()</em> copies data from file (through system memory cache) to this buffer, and <em>write()</em> copies data from the buffer to another file (through system memory buffer)</p><p><strong><em>buf[BUF_SIZE]</em></strong> 就是我们所说的<strong>用户空间缓冲区</strong>，可以看到，每次迭代时，<em>read()</em> 都会将数据从文件（通过系统内存缓存）复制到该缓冲区，而 <em>write()</em> 则会将数据从缓冲区复制到另一个文件（通过系统内存缓冲区）。</p><p>In the process memory map, <em>buf[BUF_SIZE]</em> can be seen as a allocation of 4MB on stack area. Reducing the buffer size can help reduce the waste of memory, but it in turn increases number of read() and write() system calls, which is expensive as well.</p><p>在进程内存映射中，<em>buf[BUF_SIZE]</em> 可以看作是在堆栈区域分配的 4MB 内存。减小缓冲区大小有助于减少内存浪费，但这反过来又会增加 read() 和 write() 系统调用的次数，而且代价高昂。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00007f53e08f6000       4       4       4 rw---   [ anon ]  </span><br><span class="line">00007fff5a6b1000    4012    4008    4008 rw---   [ stack ]  </span><br><span class="line">00007fff5ab3e000      12       0       0 r----   [ anon ]  </span><br><span class="line">00007fff5ab41000       8       4       0 r-x--   [ anon ]</span><br></pre></td></tr></table></figure><p>In the example, we demonstrate only one file transfer, for many transfers the memory waste might be significantly noticable using this naive technique.</p><p>在示例中，我们只演示了一次文件传输，而对于多次传输，使用这种简单的技术可能会造成明显的内存浪费。</p><p><strong><em>sendfile.c</em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sendfile.h&gt;#define BUF_SIZE 4096*1000int main(int argc, char **argv) &#123;  </span></span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *fromfile = argv[<span class="number">1</span>];  </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *tofile = argv[<span class="number">2</span>];  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat_buf</span>;</span>  </span><br><span class="line">    <span class="keyword">int</span> fromfd = <span class="built_in">open</span>(fromfile, O_RDONLY);  </span><br><span class="line">    fstat(fromfd, &amp;stat_buf);  </span><br><span class="line">    <span class="keyword">int</span> tofd = <span class="built_in">open</span>(tofile, O_WRONLY | O_CREAT, stat_buf.st_mode);    <span class="keyword">int</span> n = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">        n = sendfile(tofd, fromfd, <span class="number">0</span>, BUF_SIZE);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>There’s no user-space buffer for <em>sendfile().</em> For that reason, sendfile can send all the data from file at once, which eliminates the need of BUF_SIZE and a while loop, however we still keep it for comparing with read/write technique.</p><p>因此，<code>sendfile</code> 可以一次性发送文件中的所有数据，这样就不需要 用户空间 BUF_SIZE 和 while 循环，但我们需要仍然保留它，以便与读/写技术进行比较。</p><h1 id="Performance-benchmark"><a href="#Performance-benchmark" class="headerlink" title="Performance benchmark"></a>Performance benchmark</h1><p>Copy of a ~1G file. BUF_SIZE = 4K.</p><p>案例，复制一个1G 文件。BUF_SIZE = 4K。</p><p><strong>readwrite</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">syscall            calls    total       <span class="built_in">min</span>       avg       <span class="built_in">max</span>       </span><br><span class="line">                               (msec)    (msec)    (msec)    (msec)  </span><br><span class="line">   --------------- -------- --------- --------- --------- ---------   </span><br><span class="line">   <span class="built_in">read</span>              <span class="number">244797</span> <span class="number">16974.624</span>     <span class="number">0.002</span>     <span class="number">0.069</span>   <span class="number">457.333</span>  </span><br><span class="line">   <span class="built_in">write</span>             <span class="number">245169</span>  <span class="number">2182.295</span>     <span class="number">0.004</span>     <span class="number">0.009</span>   <span class="number">268.689</span></span><br></pre></td></tr></table></figure><p>number of read / write is nearly the same, read() takes significanly more time because of major page faults.</p><p>读/写次数几乎相同，但 <code>read()</code> 要花费更多时间，因为会出现大的页面故障。</p><p><strong>sendfile</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">syscall            calls    total       <span class="built_in">min</span>       avg       <span class="built_in">max</span>     </span><br><span class="line">                               (msec)    (msec)    (msec)    (msec)     </span><br><span class="line">   --------------- -------- --------- --------- --------- ---------  </span><br><span class="line">   sendfile          <span class="number">245261</span> <span class="number">13559.231</span>     <span class="number">0.004</span>     <span class="number">0.055</span>   <span class="number">185.970</span></span><br></pre></td></tr></table></figure><p>number of sendfile() calls is by half of the total of read()+write(), which also helps reduce total execution time. For context switches, there’s lack of observation tool so it’s difficult to show the differences.</p><p><strong>sendfile()</strong> 调用次数是 <code>read()+write()</code> 调用次数的一半，这也有助于减少总执行时间。至于上下文切换，由于缺乏观察工具，很难显示出差异。</p><p>In conclusion, <em>sendfile()</em> brings to the table several benefits, including reduction of context switches, memory usage, number of system calls, and eventually faster operations. </p><p>总之，<em>sendfile()</em> 能带来多种好处，包括减少上下文切换、内存使用、系统调用次数，以及最终加快操作速度。</p><p>It is, however, not the silver bullet for everything, we once encountered the <span class="exturl" data-url="aHR0cHM6Ly90cmFjLm5naW54Lm9yZy9uZ2lueC90aWNrZXQvMTg3MA==" title="https://trac.nginx.org/nginx/ticket/1870">problem of large file download on nginx,<i class="fa fa-external-link"></i></span> therefore usage of <em>sendfile()</em> should be considered and tested carefully before production use.</p><p>然而，它并不是万能的，我们曾经遇到过<span class="exturl" data-url="aHR0cHM6Ly90cmFjLm5naW54Lm9yZy9uZ2lueC90aWNrZXQvMTg3MA==" title="https://trac.nginx.org/nginx/ticket/1870">nginx 上下载大文件的问题<i class="fa fa-external-link"></i></span>，因此在生产使用 <em>sendfile()</em> 之前，应仔细考虑和测试。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li>Chapter 61 — The Linux Programming Interface — Michael Kerrisk  </li><li>第 61 章 - Linux 编程接口 - Michael Kerrisk</li><li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuaWJtLmNvbS9hcnRpY2xlcy9qLXplcm9jb3B5Lw==" title="https://developer.ibm.com/articles/j-zerocopy/">https://developer.ibm.com/articles/j-zerocopy/<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL25naW54Lm9yZy9lbi9kb2NzL2h0dHAvbmd4X2h0dHBfY29yZV9tb2R1bGUuaHRtbCNzZW5kZmlsZQ==" title="http://nginx.org/en/docs/http/ngx_http_core_module.html#sendfile">http://nginx.org/en/docs/http/ngx_http_core_module.html#sendfile<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9rYWZrYS5hcGFjaGUub3JnLzA4L2RvY3VtZW50YXRpb24uaHRtbA==" title="https://kafka.apache.org/08/documentation.html">https://kafka.apache.org/08/documentation.html<i class="fa fa-external-link"></i></span></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      零拷贝
    
    </summary>
    
    
      <category term="Linux" scheme="https://whitestore.top/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://whitestore.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】Pass arguments into a function</title>
    <link href="https://whitestore.top/2023/09/13/passarguments/"/>
    <id>https://whitestore.top/2023/09/13/passarguments/</id>
    <published>2023-09-13T05:47:10.000Z</published>
    <updated>2023-10-21T14:26:31.032Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h1><p><span class="exturl" data-url="aHR0cHM6Ly9iYXNoLmN5YmVyY2l0aS5iaXovZ3VpZGUvUGFzc19hcmd1bWVudHNfaW50b19hX2Z1bmN0aW9u" title="https://bash.cyberciti.biz/guide/Pass_arguments_into_a_function">Pass arguments into a function - Linux Bash Shell Scripting Tutorial Wiki (cyberciti.biz)<i class="fa fa-external-link"></i></span></p><p>Let us see how to pass parameters to a Bash function.</p><p>让我们看看如何向 Bash 函数传递参数。</p><ul><li><p>A shell function is nothing but a set of one or more commands/statements that act as a complete routine.</p></li><li><p>Each function must have a unique name.</p></li><li><p>Shell functions have their own command line argument or parameters.</p></li><li><p>Use shell variable <span class="exturl" data-url="aHR0cHM6Ly9iYXNoLmN5YmVyY2l0aS5iaXovZ3VpZGUvJDE=" title="https://bash.cyberciti.biz/guide/$1">$1<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly9iYXNoLmN5YmVyY2l0aS5iaXovZ3VpZGUvJDI=" title="https://bash.cyberciti.biz/guide/$2">$2<i class="fa fa-external-link"></i></span>,..$n to access argument passed to the function.</p></li><li><p>shell 函数是由一条或多条命令/语句组成的一个完整例程。</p></li><li><p>每个函数都必须有一个唯一的名称。</p></li><li><p>shell 函数有自己的命令行参数。</p></li><li><p>使用 shell 变量 <span class="exturl" data-url="aHR0cHM6Ly9iYXNoLmN5YmVyY2l0aS5iaXovZ3VpZGUvJDE=" title="https://bash.cyberciti.biz/guide/$1">$1<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9iYXNoLmN5YmVyY2l0aS5iaXovZ3VpZGUvJDI=" title="https://bash.cyberciti.biz/guide/$2">$2<i class="fa fa-external-link"></i></span>…$n 访问传递给函数的参数。</p></li></ul><a id="more"></a><h1 id="Passing-parameters-to-a-Bash-function向-Bash-函数传递参数"><a href="#Passing-parameters-to-a-Bash-function向-Bash-函数传递参数" class="headerlink" title="Passing parameters to a Bash function向 Bash 函数传递参数"></a>Passing parameters to a Bash function向 Bash 函数传递参数</h1><ul><li>The syntax is as follows to create user-defined functions in a shell script:</li></ul><p>在 shell 脚本中创建用户定义函数的语法如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">function_name</span></span>()&#123;</span><br><span class="line">   command_block_here</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">## OR ##</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">function_name_here</span></span>()&#123;</span><br><span class="line">   command_line_block</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">## passing parameters to a Bash function ##</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">my_function_name</span></span>()&#123;</span><br><span class="line">  arg1=<span class="variable">$1</span></span><br><span class="line">  arg2=<span class="variable">$2</span></span><br><span class="line">  <span class="built_in">command</span> on <span class="variable">$arg1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Invoke-function"><a href="#Invoke-function" class="headerlink" title="Invoke function"></a>Invoke function</h1><ul><li>To invoke the the function use the following syntax:</li></ul><p>要调用该函数，请使用以下语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_function_name foo bar</span><br></pre></td></tr></table></figure><p>Where,</p><ol><li><p><strong>my_function_name</strong> = Your function name.</p></li><li><p><strong>foo</strong> = Argument # 1 passed to the function (positional parameter # 1).</p></li><li><p><strong>bar</strong> = Argument # 2 passed to the function.</p></li><li><p><strong>my_function_name</strong> = 您的函数名称。</p></li><li><p><strong>foo</strong> = 传递给函数的参数 # 1（位置参数 # 1）。</p></li><li><ol start="3"><li><strong>bar</strong> = 传递给函数的参数 # 2。</li></ol></li></ol><h1 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h1><p>Create a function called fresh.sh:</p><p>创建一个名为 fresh.sh 的函数：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># write a function</span></span><br><span class="line"><span class="function"><span class="title">fresh</span></span>()&#123;</span><br><span class="line">   <span class="comment"># t stores $1 argument passed to fresh()</span></span><br><span class="line">   t=<span class="variable">$1</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"fresh(): \$0 is <span class="variable">$0</span>"</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"fresh(): \$1 is <span class="variable">$1</span>"</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"fresh(): \$t is <span class="variable">$t</span>"</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"fresh(): total args passed to me <span class="variable">$#</span>"</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"fresh(): all args (\$@) passed to me -\"<span class="variable">$@</span>\""</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"fresh(): all args (\$*) passed to me -\"$*\""</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># invoke the function with "Tomato" argument</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"**** calling fresh() 1st time ****"</span></span><br><span class="line">fresh Tomato</span><br><span class="line"> </span><br><span class="line"><span class="comment"># invoke the function with total 3 arguments</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"**** calling fresh() 2nd time ****"</span></span><br><span class="line">fresh Tomato Onion Paneer</span><br></pre></td></tr></table></figure><p>Save and close the file. Run it as follows:</p><p>保存并关闭文件。按以下步骤运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x fresh.sh</span><br><span class="line">./fresh.sh</span><br></pre></td></tr></table></figure><p>Sample outputs:</p><p>样本输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">**** calling fresh() 1st time ****</span><br><span class="line">fresh(): <span class="variable">$0</span> is ./fresh.sh</span><br><span class="line">fresh(): <span class="variable">$1</span> is Tomato</span><br><span class="line">fresh(): <span class="variable">$t</span> is Tomato</span><br><span class="line">fresh(): total args passed to me 1</span><br><span class="line">fresh(): all args (<span class="variable">$@</span>) passed to me -<span class="string">"Tomato"</span></span><br><span class="line">fresh(): all args ($*) passed to me -<span class="string">"Tomato"</span></span><br><span class="line">**** calling fresh() 2nd time ****</span><br><span class="line">fresh(): <span class="variable">$0</span> is ./fresh.sh</span><br><span class="line">fresh(): <span class="variable">$1</span> is Tomato</span><br><span class="line">fresh(): <span class="variable">$t</span> is Tomato</span><br><span class="line">fresh(): total args passed to me 3</span><br><span class="line">fresh(): all args (<span class="variable">$@</span>) passed to me -<span class="string">"Tomato Onion Paneer"</span></span><br><span class="line">fresh(): all args ($*) passed to me -<span class="string">"Tomato Onion Paneer"</span></span><br></pre></td></tr></table></figure><p>Let us try one more example. Create a new shell script to determine if given name is file or directory (cmdargs.sh):</p><p>让我们再试一个例子。创建一个新的 shell 脚本来判断给定的名称是文件还是目录（cmdargs.sh）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Name - cmdargs.sh</span></span><br><span class="line"><span class="comment"># Purpose - Passing positional parameters to user defined function </span></span><br><span class="line"><span class="comment"># 目的 - 将位置参数传递给用户定义函数 </span></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------</span></span><br><span class="line">file=<span class="string">"<span class="variable">$1</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># User-defined function</span></span><br><span class="line"><span class="function"><span class="title">is_file_dir</span></span>()&#123;</span><br><span class="line">        <span class="comment"># $f is local variable</span></span><br><span class="line"><span class="built_in">local</span> f=<span class="string">"<span class="variable">$1</span>"</span></span><br><span class="line">        <span class="comment"># file attributes comparisons using test i.e. [ ... ]</span></span><br><span class="line">[ -f <span class="string">"<span class="variable">$f</span>"</span> ] &amp;&amp; &#123; <span class="built_in">echo</span> <span class="string">"<span class="variable">$f</span> is a regular file."</span>; <span class="built_in">exit</span> 0; &#125;</span><br><span class="line">[ -d <span class="string">"<span class="variable">$f</span>"</span> ] &amp;&amp; &#123; <span class="built_in">echo</span> <span class="string">"<span class="variable">$f</span> is a directory."</span>; <span class="built_in">exit</span> 0; &#125;</span><br><span class="line">[ -L <span class="string">"<span class="variable">$f</span>"</span> ] &amp;&amp; &#123; <span class="built_in">echo</span> <span class="string">"<span class="variable">$f</span> is a symbolic link."</span>; <span class="built_in">exit</span> 0; &#125;</span><br><span class="line">[ -x <span class="string">"<span class="variable">$f</span>"</span> ] &amp;&amp; &#123; <span class="built_in">echo</span> <span class="string">"<span class="variable">$f</span> is an executeble file."</span>; <span class="built_in">exit</span> 0; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># make sure filename supplied as command line arg else die</span></span><br><span class="line"><span class="comment"># 确保文件名作为命令行参数提供，否则 die</span></span><br><span class="line">[ <span class="variable">$#</span> -eq 0 ] &amp;&amp; &#123; <span class="built_in">echo</span> <span class="string">"Usage: <span class="variable">$0</span> filename"</span>; <span class="built_in">exit</span> 1; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># invoke the is_file_dir and pass $file as arg</span></span><br><span class="line"><span class="comment"># 调用 is_file_dir，并将 $file 作为参数传入</span></span><br><span class="line">is_file_dir <span class="string">"<span class="variable">$file</span></span></span><br></pre></td></tr></table></figure><p>Run it as follows:</p><p>运行方法如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./cmdargs.sh /etc/resolv.conf</span><br><span class="line">./cmdargs.sh /bin/date</span><br><span class="line">./cmdargs.sh <span class="variable">$HOME</span></span><br><span class="line">./cmdargs.sh /sbin</span><br></pre></td></tr></table></figure><p>Sample outputs:</p><p>样本输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/etc/resolv.conf is a regular file.</span><br><span class="line">/bin/date is a regular file.</span><br><span class="line">/home/vivek is a directory.</span><br><span class="line">/sbin is a directory.</span><br></pre></td></tr></table></figure><h1 id="Function-shell-variables"><a href="#Function-shell-variables" class="headerlink" title="Function shell variables"></a>Function shell variables</h1><ul><li><p>All function parameters or arguments can be accessed via $1, $2, $3,…, $N.</p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9iYXNoLmN5YmVyY2l0aS5iaXovZ3VpZGUvJDA=" title="https://bash.cyberciti.biz/guide/$0">$0<i class="fa fa-external-link"></i></span> always point to the shell script name.</p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9iYXNoLmN5YmVyY2l0aS5iaXovZ3VpZGUvJCo=" title="https://bash.cyberciti.biz/guide/$*">$*<i class="fa fa-external-link"></i></span> or <span class="exturl" data-url="aHR0cHM6Ly9iYXNoLmN5YmVyY2l0aS5iaXovZ3VpZGUvJEA=" title="https://bash.cyberciti.biz/guide/$@">$@<i class="fa fa-external-link"></i></span> holds all parameters or arguments passed to the function.</p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9iYXNoLmN5YmVyY2l0aS5iaXovZ3VpZGUvJA==" title="https://bash.cyberciti.biz/guide/$">$#<i class="fa fa-external-link"></i></span> holds the number of positional parameters passed to the function.</p></li><li><p>所有函数参数或参数都可以通过<code>$1, $2, $3,..., $N</code> 访问。</p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9iYXNoLmN5YmVyY2l0aS5iaXovZ3VpZGUvJDA=" title="https://bash.cyberciti.biz/guide/$0">$0<i class="fa fa-external-link"></i></span>总是指向 shell 脚本名。</p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9iYXNoLmN5YmVyY2l0aS5iaXovZ3VpZGUvJCo=" title="https://bash.cyberciti.biz/guide/$*">$* <i class="fa fa-external-link"></i></span>  或  <span class="exturl" data-url="aHR0cHM6Ly9iYXNoLmN5YmVyY2l0aS5iaXovZ3VpZGUvJEA=" title="https://bash.cyberciti.biz/guide/$@">$@<i class="fa fa-external-link"></i></span> 保存传递给函数的所有参数。</p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9iYXNoLmN5YmVyY2l0aS5iaXovZ3VpZGUvJA==" title="https://bash.cyberciti.biz/guide/$">$#<i class="fa fa-external-link"></i></span> 保存传递给函数的位置参数的个数。</p></li></ul><h2 id="How-do-I-display-function-name-如何显示功能名称？"><a href="#How-do-I-display-function-name-如何显示功能名称？" class="headerlink" title="How do I display function name? 如何显示功能名称？"></a>How do I display function name? 如何显示功能名称？</h2><p><span class="exturl" data-url="aHR0cHM6Ly9iYXNoLmN5YmVyY2l0aS5iaXovZ3VpZGUvJDA=" title="https://bash.cyberciti.biz/guide/$0">$0<i class="fa fa-external-link"></i></span> always point to the shell script name. However, you can use an array variable called <span class="exturl" data-url="aHR0cHM6Ly9iYXNoLmN5YmVyY2l0aS5iaXovd2lraS9pbmRleC5waHA/dGl0bGU9RlVOQ05BTUUmYWN0aW9uPWVkaXQmcmVkbGluaz0x" title="https://bash.cyberciti.biz/wiki/index.php?title=FUNCNAME&action=edit&redlink=1">FUNCNAME<i class="fa fa-external-link"></i></span> which contains the names of all shell functions currently in the execution call stack. The element with index 0 is the name any currently-executing shell function.This variable <em>exists only</em> when a shell function is executing.</p><p><span class="exturl" data-url="aHR0cHM6Ly9iYXNoLmN5YmVyY2l0aS5iaXovZ3VpZGUvJDA=" title="https://bash.cyberciti.biz/guide/$0">$0<i class="fa fa-external-link"></i></span>总是指向 shell 脚本名。不过，您可以使用一个名为 <span class="exturl" data-url="aHR0cHM6Ly9iYXNoLmN5YmVyY2l0aS5iaXovd2lraS9pbmRleC5waHA/dGl0bGU9RlVOQ05BTUUmYWN0aW9uPWVkaXQmcmVkbGluaz0x" title="https://bash.cyberciti.biz/wiki/index.php?title=FUNCNAME&action=edit&redlink=1">FUNCNAME<i class="fa fa-external-link"></i></span>的数组变量，它包含当前执行调用堆栈中所有 shell 函数的名称。索引为 0 的元素是当前正在执行的 shell 函数的名称。</p><p><strong>FUNCNAME in action</strong></p><p>Create a shell script called funcback.sh:</p><p>创建名为 funcback.sh 的 shell 脚本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#  funcback.sh : Use $FUNCNAME</span></span><br><span class="line"><span class="function"><span class="title">backup</span></span>()&#123;</span><br><span class="line"><span class="built_in">local</span> d=<span class="string">"<span class="variable">$1</span>"</span></span><br><span class="line">[[ -z <span class="variable">$d</span> ]] &amp;&amp; &#123; <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;FUNCNAME&#125;</span>(): directory name not specified"</span>; <span class="built_in">exit</span> 1; &#125;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Starting backup..."</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">backup <span class="variable">$1</span></span><br></pre></td></tr></table></figure><p>Save and close the file. Run it as follows:</p><p>保存并关闭文件。按以下步骤运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod +x funcback.sh</span><br><span class="line">funcback.sh /home</span><br><span class="line">funcback.sh</span><br></pre></td></tr></table></figure><p>Sample outputs:</p><p>样本输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">backup(): directory name not specified</span><br></pre></td></tr></table></figure><p>Return values</p><p>返回值</p><p>It is possible to pass a value from the function back to the bash using the <span class="exturl" data-url="aHR0cHM6Ly9iYXNoLmN5YmVyY2l0aS5iaXovZ3VpZGUvUmV0dXJuX2NvbW1hbmQ=" title="https://bash.cyberciti.biz/guide/Return_command">return command<i class="fa fa-external-link"></i></span>. The return statement terminates the function. The syntax is as follows:</p><p>可以使用 <span class="exturl" data-url="aHR0cHM6Ly9iYXNoLmN5YmVyY2l0aS5iaXovZ3VpZGUvUmV0dXJuX2NvbW1hbmQ=" title="https://bash.cyberciti.biz/guide/Return_command">return command<i class="fa fa-external-link"></i></span>将函数值传回 bash。return 语句终止函数。语法如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">return</span></span><br><span class="line"><span class="built_in">return</span> [value]</span><br></pre></td></tr></table></figure><p>One can force script to exit with the return value specified by [value]. If [value] is omitted, the return status is that of the last command executed within the function or script.</p><p>可以强制脚本以 [value] 指定的返回值退出。如果省略 [value]，返回状态将是函数或脚本中最后执行的命令的状态。</p><h2 id="Examples-1"><a href="#Examples-1" class="headerlink" title="Examples"></a>Examples</h2><p>Create a new file called math.sh:</p><p>新建一个名为 math.sh 的文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Name - math.sh</span></span><br><span class="line"><span class="comment"># Purpose - Demo return value </span></span><br><span class="line"><span class="comment"># ------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## user define function</span></span><br><span class="line"><span class="function"><span class="title">math</span></span>()&#123;</span><br><span class="line"><span class="built_in">local</span> a=<span class="variable">$1</span></span><br><span class="line"><span class="built_in">local</span> b=<span class="variable">$2</span></span><br><span class="line"><span class="built_in">local</span> sum=$(( a + b))</span><br><span class="line"><span class="built_in">return</span> <span class="variable">$sum</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">## call the math function with 5 and 10 as  arguments </span></span><br><span class="line">math 5 10</span><br><span class="line"></span><br><span class="line"><span class="comment">## display back result (returned value) using $?</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"5 + 10 = $?"</span></span><br></pre></td></tr></table></figure><p>Run it as follows:</p><p>运行方法如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x math.sh</span><br><span class="line">./math.sh</span><br></pre></td></tr></table></figure><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230830135648.png" alt="image.png"></p><p>The above example is straightforward. The <span class="exturl" data-url="aHR0cHM6Ly9iYXNoLmN5YmVyY2l0aS5iaXovZ3VpZGUvUmV0dXJuX2NvbW1hbmQ=" title="https://bash.cyberciti.biz/guide/Return_command">return command<i class="fa fa-external-link"></i></span> returns any given value between <strong>zero (0) and 255</strong>. By default, the value passed by the return statement is the current value of the <span class="exturl" data-url="aHR0cHM6Ly9iYXNoLmN5YmVyY2l0aS5iaXovZ3VpZGUvVGhlX2V4aXRfc3RhdHVzX29mX2FfY29tbWFuZA==" title="https://bash.cyberciti.biz/guide/The_exit_status_of_a_command">exit status<i class="fa fa-external-link"></i></span> variable. For example, the following code will return wrong values as it is not between <strong>zero (0) and 255</strong>.</p><p>上面的例子很简单。<span class="exturl" data-url="aHR0cHM6Ly9iYXNoLmN5YmVyY2l0aS5iaXovZ3VpZGUvUmV0dXJuX2NvbW1hbmQ=" title="https://bash.cyberciti.biz/guide/Return_command">return 命令<i class="fa fa-external-link"></i></span> 返回介于<strong>零 (0) 和 255</strong> 之间的任意给定值。默认情况下，return 语句传递的值是 <span class="exturl" data-url="aHR0cHM6Ly9iYXNoLmN5YmVyY2l0aS5iaXovZ3VpZGUvVGhlX2V4aXRfc3RhdHVzX29mX2FfY29tbWFuZA==" title="https://bash.cyberciti.biz/guide/The_exit_status_of_a_command">exit status<i class="fa fa-external-link"></i></span> 变量的当前值。例如，以下代码将返回错误的值，因为它不在<strong>零（0）和 255</strong> 之间。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">math 500 100</span><br></pre></td></tr></table></figure><p>Here is the proper use of <span class="exturl" data-url="aHR0cHM6Ly9iYXNoLmN5YmVyY2l0aS5iaXovZ3VpZGUvUmV0dXJuX2NvbW1hbmQ=" title="https://bash.cyberciti.biz/guide/Return_command">return command<i class="fa fa-external-link"></i></span> (bash-task.sh):</p><p>下面是 <span class="exturl" data-url="aHR0cHM6Ly9iYXNoLmN5YmVyY2l0aS5iaXovZ3VpZGUvUmV0dXJuX2NvbW1hbmQ=" title="https://bash.cyberciti.biz/guide/Return_command">return command<i class="fa fa-external-link"></i></span>的正确用法（bash-task.sh）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Name: bash-task.sh</span></span><br><span class="line"><span class="comment"># Purpose: Check if a file exists or not using custom bash function and return value</span></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># set values </span></span><br><span class="line"><span class="built_in">readonly</span> TRUE=0</span><br><span class="line"><span class="built_in">readonly</span> FALSE=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># get input from the CLI</span></span><br><span class="line">file=<span class="string">"<span class="variable">$1</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># return $TRUE (0) if file found </span></span><br><span class="line"><span class="comment"># return $FALSE (1) if file not found</span></span><br><span class="line"><span class="function"><span class="title">is_file_found</span></span>()&#123;</span><br><span class="line">[ -f <span class="string">"<span class="variable">$1</span>"</span> ] &amp;&amp; <span class="built_in">return</span> <span class="variable">$TRUE</span> || <span class="built_in">return</span> <span class="variable">$FALSE</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># show usage info if $1 not passed to our script</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -eq 0 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Usage: <span class="variable">$0</span> filename"</span></span><br><span class="line"><span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># let us call our function </span></span><br><span class="line">is_file_found <span class="string">"<span class="variable">$file</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># take action based upon return value</span></span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$file</span> added to backup task"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$file</span> not found."</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>Run it as follows:</p><p>运行方法如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chmod +x bash-task.sh</span><br><span class="line">./bash-task.sh</span><br><span class="line">./bash-task.sh /etc/passwd</span><br><span class="line">./bash-task.sh /foo/bar</span><br></pre></td></tr></table></figure><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230830140338.png" alt="image.png"></p><blockquote><p>Passing parameters to a Bash function and return true or false value<br>向 Bash 函数传递参数并返回 true 或 false 值</p></blockquote><h1 id="How-to-return-custom-value-from-a-user-defined-function"><a href="#How-to-return-custom-value-from-a-user-defined-function" class="headerlink" title="How to return custom value from a user-defined function?"></a>How to return custom value from a user-defined function?</h1><p>As I said earlier, you can’t use <span class="exturl" data-url="aHR0cHM6Ly9iYXNoLmN5YmVyY2l0aS5iaXovZ3VpZGUvUmV0dXJuX2NvbW1hbmQ=" title="https://bash.cyberciti.biz/guide/Return_command">return command<i class="fa fa-external-link"></i></span>. However, the workaround is as following using the <span class="exturl" data-url="aHR0cHM6Ly9iYXNoLmN5YmVyY2l0aS5iaXovZ3VpZGUvUHJpbnRmX2NvbW1hbmQ=" title="https://bash.cyberciti.biz/guide/Printf_command">printf command<i class="fa fa-external-link"></i></span>/<span class="exturl" data-url="aHR0cHM6Ly9iYXNoLmN5YmVyY2l0aS5iaXovZ3VpZGUvRWNob19jb21tYW5k" title="https://bash.cyberciti.biz/guide/Echo_command">echo command<i class="fa fa-external-link"></i></span>:</p><p>正如前面所说，不能使用 <span class="exturl" data-url="aHR0cHM6Ly9iYXNoLmN5YmVyY2l0aS5iaXovZ3VpZGUvUmV0dXJuX2NvbW1hbmQ=" title="https://bash.cyberciti.biz/guide/Return_command">return command<i class="fa fa-external-link"></i></span>。不过，变通方法如下：使用 <span class="exturl" data-url="aHR0cHM6Ly9iYXNoLmN5YmVyY2l0aS5iaXovZ3VpZGUvUHJpbnRmX2NvbW1hbmQ=" title="https://bash.cyberciti.biz/guide/Printf_command">printf 命令<i class="fa fa-external-link"></i></span>/<span class="exturl" data-url="aHR0cHM6Ly9iYXNoLmN5YmVyY2l0aS5iaXovZ3VpZGUvRWNob19jb21tYW5k" title="https://bash.cyberciti.biz/guide/Echo_command">echo命令<i class="fa fa-external-link"></i></span>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Name - math.sh</span></span><br><span class="line"><span class="comment"># Purpose - Demo how to return custom value </span></span><br><span class="line"><span class="comment"># -----------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## user define function that use echo/printf </span></span><br><span class="line"><span class="function"><span class="title">math</span></span>()&#123;</span><br><span class="line"><span class="built_in">local</span> a=<span class="variable">$1</span></span><br><span class="line"><span class="built_in">local</span> b=<span class="variable">$2</span></span><br><span class="line"><span class="built_in">local</span> sum=$(( a + b))</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$sum</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">## call the math function with 5 and 10 as  arguments </span></span><br><span class="line">total=$(math 500 42)</span><br><span class="line"></span><br><span class="line"><span class="comment">## display back result (returned value) using $?</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"500 + 42 = <span class="variable">$total</span>"</span></span><br></pre></td></tr></table></figure><h1 id="Listing-functions-列出函数"><a href="#Listing-functions-列出函数" class="headerlink" title="Listing functions 列出函数"></a>Listing functions 列出函数</h1><p>Use the <span class="exturl" data-url="aHR0cHM6Ly9iYXNoLmN5YmVyY2l0aS5iaXovd2lraS9pbmRleC5waHA/dGl0bGU9VHlwZXNldF9jb21tYW5kJmFjdGlvbj1lZGl0JnJlZGxpbms9MQ==" title="https://bash.cyberciti.biz/wiki/index.php?title=Typeset_command&action=edit&redlink=1">typeset command<i class="fa fa-external-link"></i></span> or <span class="exturl" data-url="aHR0cHM6Ly9iYXNoLmN5YmVyY2l0aS5iaXovZ3VpZGUvRGVjbGFyZV9jb21tYW5k" title="https://bash.cyberciti.biz/guide/Declare_command">declare command<i class="fa fa-external-link"></i></span>.</p><p>使用 <span class="exturl" data-url="aHR0cHM6Ly9iYXNoLmN5YmVyY2l0aS5iaXovd2lraS9pbmRleC5waHA/dGl0bGU9VHlwZXNldF9jb21tYW5kJmFjdGlvbj1lZGl0JnJlZGxpbms9MQ==" title="https://bash.cyberciti.biz/wiki/index.php?title=Typeset_command&action=edit&redlink=1">typeset command<i class="fa fa-external-link"></i></span>或 <span class="exturl" data-url="aHR0cHM6Ly9iYXNoLmN5YmVyY2l0aS5iaXovZ3VpZGUvRGVjbGFyZV9jb21tYW5k" title="https://bash.cyberciti.biz/guide/Declare_command">declare command<i class="fa fa-external-link"></i></span>。</p><h1 id="Show-the-known-functions-and-their-code-definitions显示已知函数及其代码-定义"><a href="#Show-the-known-functions-and-their-code-definitions显示已知函数及其代码-定义" class="headerlink" title="Show the known functions and their code/definitions显示已知函数及其代码/定义"></a>Show the known functions and their code/definitions显示已知函数及其代码/定义</h1><p>Open the terminal and then run:</p><p>打开终端，然后运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> -f</span><br><span class="line"><span class="built_in">declare</span> -f function_name_here</span><br><span class="line"><span class="comment">## or ##</span></span><br><span class="line"><span class="built_in">typeset</span> -f</span><br><span class="line"><span class="built_in">typeset</span> -f function_name_here</span><br></pre></td></tr></table></figure><h1 id="How-to-remove-or-unset-functions-如何删除或取消设置函数"><a href="#How-to-remove-or-unset-functions-如何删除或取消设置函数" class="headerlink" title="How to remove or unset functions 如何删除或取消设置函数"></a>How to remove or unset functions 如何删除或取消设置函数</h1><p>Use the <span class="exturl" data-url="aHR0cHM6Ly9iYXNoLmN5YmVyY2l0aS5iaXovd2lraS9pbmRleC5waHA/dGl0bGU9VW5zZXRfY29tbWFuZCZhY3Rpb249ZWRpdCZyZWRsaW5rPTE=" title="https://bash.cyberciti.biz/wiki/index.php?title=Unset_command&action=edit&redlink=1">unset command<i class="fa fa-external-link"></i></span> to unset values and attributes of <span class="exturl" data-url="aHR0cHM6Ly9iYXNoLmN5YmVyY2l0aS5iaXovZ3VpZGUvVmFyaWFibGVz" title="https://bash.cyberciti.biz/guide/Variables">shell variables<i class="fa fa-external-link"></i></span> and <span class="exturl" data-url="aHR0cHM6Ly9iYXNoLmN5YmVyY2l0aS5iaXovZ3VpZGUvRnVuY3Rpb25z" title="https://bash.cyberciti.biz/guide/Functions">functions<i class="fa fa-external-link"></i></span>:</p><p>使用 <span class="exturl" data-url="aHR0cHM6Ly9iYXNoLmN5YmVyY2l0aS5iaXovd2lraS9pbmRleC5waHA/dGl0bGU9VW5zZXRfY29tbWFuZCZhY3Rpb249ZWRpdCZyZWRsaW5rPTE=" title="https://bash.cyberciti.biz/wiki/index.php?title=Unset_command&action=edit&redlink=1">unset 命令<i class="fa fa-external-link"></i></span> 取消设置 <span class="exturl" data-url="aHR0cHM6Ly9iYXNoLmN5YmVyY2l0aS5iaXovZ3VpZGUvVmFyaWFibGVz" title="https://bash.cyberciti.biz/guide/Variables">shell 变量<i class="fa fa-external-link"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9iYXNoLmN5YmVyY2l0aS5iaXovZ3VpZGUvRnVuY3Rpb25z" title="https://bash.cyberciti.biz/guide/Functions">函数<i class="fa fa-external-link"></i></span> 的值和属性：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unset</span> -f function_name_here</span><br><span class="line"><span class="built_in">unset</span> -f foo</span><br><span class="line"><span class="built_in">unset</span> -f bar</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      Linux函数
    
    </summary>
    
    
      <category term="Linux" scheme="https://whitestore.top/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://whitestore.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【JVM】Garbage First Garbage Collector Tuning</title>
    <link href="https://whitestore.top/2023/09/11/adaptg1gc/"/>
    <id>https://whitestore.top/2023/09/11/adaptg1gc/</id>
    <published>2023-09-11T02:39:56.000Z</published>
    <updated>2023-10-21T14:26:31.032Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cub3JhY2xlLmNvbS90ZWNobmljYWwtcmVzb3VyY2VzL2FydGljbGVzL2phdmEvZzFnYy5odG1s" title="https://www.oracle.com/technical-resources/articles/java/g1gc.html">Garbage First Garbage Collector Tuning (oracle.com)<i class="fa fa-external-link"></i></span></p><h1 id="Learn-about-how-to-adapt-and-tune-the-G1-GC-for-evaluation-analysis-and-performance-了解如何适应和调整G1-GC的评估、分析和性能"><a href="#Learn-about-how-to-adapt-and-tune-the-G1-GC-for-evaluation-analysis-and-performance-了解如何适应和调整G1-GC的评估、分析和性能" class="headerlink" title="Learn about how to adapt and tune the G1 GC for evaluation, analysis and performance. 了解如何适应和调整G1 GC的评估、分析和性能"></a><strong>Learn about how to adapt and tune the G1 GC for evaluation, analysis and performance.</strong> 了解如何适应和调整G1 GC的评估、分析和性能</h1><p>The <span class="exturl" data-url="aHR0cHM6Ly93d3cub3JhY2xlLmNvbS9qYXZhL3RlY2hub2xvZ2llcy9qYXZhc2UvaG90c3BvdC1nYXJiYWdlLWNvbGxlY3Rpb24uaHRtbA==" title="https://www.oracle.com/java/technologies/javase/hotspot-garbage-collection.html">Garbage First Garbage Collector (G1 GC)<i class="fa fa-external-link"></i></span> is the low-pause, server-style generational garbage collector for Java HotSpot VM. The G1 GC uses concurrent and parallel phases to achieve its target pause time and to maintain good throughput. When G1 GC determines that a garbage collection is necessary, it collects the regions with the least live data first (garbage first).</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cub3JhY2xlLmNvbS9qYXZhL3RlY2hub2xvZ2llcy9qYXZhc2UvaG90c3BvdC1nYXJiYWdlLWNvbGxlY3Rpb24uaHRtbA==" title="https://www.oracle.com/java/technologies/javase/hotspot-garbage-collection.html">Garbage First Garbage Collector (G1 GC)<i class="fa fa-external-link"></i></span>是 Java HotSpot VM 的低等待、Server端垃圾收集器。G1 GC 使用并发和并行阶段来实现其目标暂停时间，并保持良好的吞吐量。当 G1 GC 确定有必要进行垃圾收集时，它会首先收集实时数据最少的区域（垃圾优先）。</p><p>A garbage collector (GC) is a memory management tool. The G1 GC achieves automatic memory management through the following operations:</p><p>垃圾收集器（GC）是一种内存管理工具。G1 GC 通过以下操作实现自动内存管理：</p><ul><li><p>Allocating objects to a young generation and promoting aged objects into an old generation.</p></li><li><p>Finding live objects in the old generation through a concurrent (parallel) marking phase. The Java HotSpot VM triggers the marking phase when the total Java heap occupancy exceeds the default threshold.</p></li><li><p>Recovering free memory by compacting live objects through parallel copying.</p></li><li><p>将对象分配到年轻一代，并将老化对象提升到老一代。</p></li><li><p>通过并发（并行）标记阶段，在旧一代中查找有效对象。Java HotSpot VM 会在 Java 堆总占用率超过默认阈值时触发标记阶段。</p></li><li><p>通过并行复制压缩活对象来恢复空闲内存。</p></li></ul><a id="more"></a><p>Here, we look at how to adapt and tune the G1 GC for evaluation, analysis and performance—we assume a basic understanding of Java garbage collection.</p><p>在此，我们将探讨如何调整 G1 GC 并使其满足评估、分析和性能要求–我们假设您对 Java 垃圾回收有基本的了解。</p><p>The G1 GC is a regionalized and generational garbage collector, which means that the Java object heap (heap) is divided into a number of equally sized regions. </p><p>G1 GC 是一种区域化和世代垃圾收集器，这意味着 Java 对象堆（heap）被划分为多个大小相等的区域。</p><p>Upon startup, the Java Virtual Machine (JVM) sets the region size. </p><p>启动时，Java 虚拟机（JVM）会设置区域大小。</p><p>The region sizes can vary from 1 MB to 32 MB depending on the heap size. </p><p>根据堆的大小，区域大小从 1 MB 到 32 MB 不等。</p><p>The goal is to have no more than 2048 regions. </p><p>目标是不超过 2048 个区域。</p><p>The eden, survivor, and old generations are logical sets of these regions and are not contiguous.</p><p>伊甸园”、”幸存者 “和 “旧世代 “是这些区域的逻辑集合，并不连续。</p><p>The G1 GC has a pause time-target that it tries to meet (soft real time).</p><p>G1 GC 有一个试图达到的暂停时间目标（软实时）。</p><p> During young collections, the G1 GC adjusts its young generation (eden and survivor sizes) to meet the soft real-time target. </p><p>在幼年期收集期间，G1 GC 会调整其幼年期生成（eden 和 survivor 大小），以满足软实时目标。</p><p>During mixed collections, the G1 GC adjusts the number of old regions that are collected based on a target number of mixed garbage collections, the percentage of live objects in each region of the heap, and the overall acceptable heap waste percentage.</p><p>在混合收集期间，G1 GC 会根据混合垃圾收集的目标数量、堆中每个区域中活对象的百分比以及可接受的总体堆浪费百分比，调整旧区域的收集数量。</p><p>The G1 GC reduces heap fragmentation by incremental parallel copying of live objects from one or more sets of regions (called Collection Set (CSet)) into different new region(s) to achieve compaction. </p><p>G1 GC 通过将实时对象从一组或多组区域（称为集合集（CSet））增量并行复制到不同的新区域来实现压缩，从而减少堆碎片。</p><p>The goal is to reclaim as much heap space as possible, starting with those regions that contain the most reclaimable space, while attempting to not exceed the pause time goal (garbage first).</p><p>其目标是尽可能多地回收堆空间，从包含最多可回收空间的区域开始，同时尽量不超过暂停时间目标（垃圾优先）。</p><p>The G1 GC uses independent Remembered Sets (RSets) to track references into regions. </p><p>G1 GC 使用独立的记忆集 (RSets) 来跟踪对区域的引用。</p><p>Independent RSets enable parallel and independent collection of regions because only a region’s RSet must be scanned for references into that region, instead of the whole heap. </p><p>独立 <code>RSet</code> 可实现并行和独立的区域收集，因为只需扫描区域的 <code>RSet</code> 以查找对该区域的引用，而无需扫描整个堆。</p><p>The G1 GC uses a post-write barrier to record changes to the heap and update the RSets.</p><p>G1 GC 使用写后屏障来记录堆的变化并更新 <code>RSets</code>。</p><h1 id="Garbage-Collection-Phases垃圾收集阶段"><a href="#Garbage-Collection-Phases垃圾收集阶段" class="headerlink" title="Garbage Collection Phases垃圾收集阶段"></a>Garbage Collection Phases垃圾收集阶段</h1><p>Apart from evacuation pauses (described below) that compose the stop-the-world (STW) young and mixed garbage collections, the G1 GC also has parallel, concurrent, and multiphase marking cycles. </p><p>除了构成 “Stop-World”（STW）年轻模式和混合垃圾收集的疏散暂停（如下所述）外，G1 GC 还具有并行、并发和多阶段标记周期。</p><p>G1 GC uses the Snapshot-At-The-Beginning (SATB) algorithm, which takes a snapshot of the set of live objects in the heap at the start of a marking cycle. </p><p>G1 GC 使用 “<strong>开始时快照</strong>“（SATB）算法，在标记周期开始时对堆中的实时对象集进行快照。</p><p>The set of live objects is composed of the live objects in the snapshot, and the objects allocated since the start of the marking cycle. </p><p>实时对象集由快照中的实时对象和标记周期开始后分配的对象组成。</p><p>The G1 GC marking algorithm uses a pre-write barrier to record and mark objects that are part of the logical snapshot.</p><p>G1 GC 标记算法使用预写屏障来记录和标记逻辑快照中的对象。</p><h1 id="Young-Garbage-Collections-年轻代垃圾手机"><a href="#Young-Garbage-Collections-年轻代垃圾手机" class="headerlink" title="Young Garbage Collections 年轻代垃圾手机"></a>Young Garbage Collections 年轻代垃圾手机</h1><p>The G1 GC satisfies most allocation requests from regions added to the eden set of regions. </p><p>G1 GC 可满足大部分来自添加到 Eden 区域集的区域的分配请求。</p><p>During a young garbage collection, the G1 GC collects both the eden regions and the survivor regions from the previous garbage collection. </p><p>在一次新的垃圾回收过程中，G1 GC 会同时回收上一次垃圾回收中的 eden 区域和 survivor 区域。</p><p>The live objects from the eden and survivor regions are copied, or evacuated, to a new set of regions. </p><p>来自 eden 和 survivor 区域的实时对象会被复制或疏散到一组新的区域中。</p><p>The destination region for a particular object depends upon the object’s age; an object that has aged sufficiently evacuates to an old generation region (that is, promoted); otherwise, the object evacuates to a survivor region and will be included in the CSet of the next young or mixed garbage collection.</p><p>特定对象的目标区域取决于该对象的年龄；年龄足够大的对象会被移动到老一代区域（即晋升）；否则，该对象会被移动到存活区域，并被纳入下一次年轻代或混合垃圾收集的 CSet 中。</p><h1 id="Mixed-Garbage-Collections"><a href="#Mixed-Garbage-Collections" class="headerlink" title="Mixed Garbage Collections"></a>Mixed Garbage Collections</h1><p>Upon successful completion of a concurrent marking cycle, the G1 GC switches from performing young garbage collections to performing mixed garbage collections. </p><p>成功完成并发标记周期后，G1 GC 会从执行年轻垃圾收集切换到执行混合垃圾收集。</p><p>In a mixed garbage collection, the G1 GC optionally adds some old regions to the set of eden and survivor regions that will be collected. </p><p>在混合垃圾收集中，G1 GC 会选择性地将一些old region添加到将被收集的 Eden 和 survivor 区域集合中。</p><p>The exact number of old regions added is controlled by a number of flags that will be discussed later (see “<span class="exturl" data-url="aHR0cHM6Ly93d3cub3JhY2xlLmNvbS90ZWNobmljYWwtcmVzb3VyY2VzL2FydGljbGVzL2phdmEvZzFnYy5odG1sI1RhbWluZw==" title="https://www.oracle.com/technical-resources/articles/java/g1gc.html#Taming">Taming Mixed GCs<i class="fa fa-external-link"></i></span>“). </p><p>添加old region的具体数量由一些标志控制，稍后将讨论这些标志（参见”<span class="exturl" data-url="aHR0cHM6Ly93d3cub3JhY2xlLmNvbS90ZWNobmljYWwtcmVzb3VyY2VzL2FydGljbGVzL2phdmEvZzFnYy5odG1sI1RhbWluZw==" title="https://www.oracle.com/technical-resources/articles/java/g1gc.html#Taming">驯服混合 GC<i class="fa fa-external-link"></i></span>“）。</p><p>After the G1 GC collects a sufficient number of old regions (over multiple mixed garbage collections), G1 reverts to performing young garbage collections until the next marking cycle completes.</p><p>在 G1 GC 收集到足够数量的旧区域后（经过多次混合垃圾收集），G1 将恢复执行年轻垃圾收集，直到下一个标记周期完成。</p><h1 id="Phases-of-the-Marking-Cycle"><a href="#Phases-of-the-Marking-Cycle" class="headerlink" title="Phases of the Marking Cycle"></a>Phases of the Marking Cycle</h1><p>The marking cycle has the following phases:</p><ul><li><strong>Initial mark phase</strong>: The G1 GC marks the roots during this phase. This phase is piggybacked on a normal (STW) young garbage collection.</li><li><strong>Root region scanning phase</strong>: The G1 GC scans survivor regions of the initial mark for references to the old generation and marks the referenced objects. This phase runs concurrently with the application (not STW) and must complete before the next STW young garbage collection can start.</li><li><strong>Concurrent marking phase</strong>: The G1 GC finds reachable (live) objects across the entire heap. This phase happens concurrently with the application, and can be interrupted by STW young garbage collections.</li><li><strong>Remark phase</strong>: This phase is STW collection and helps the completion of the marking cycle. G1 GC drains SATB buffers, traces unvisited live objects, and performs reference processing.</li><li><strong>Cleanup phase</strong>: In this final phase, the G1 GC performs the STW operations of accounting and RSet scrubbing. During accounting, the G1 GC identifies completely free regions and mixed garbage collection candidates. The cleanup phase is partly concurrent when it resets and returns the empty regions to the free list.</li></ul><p>垃圾回收的阶段如下：</p><ul><li><strong>初始标记阶段</strong>： G1 GC 在此阶段对root进行标记。该阶段是正常（STW）年轻垃圾回收的前置阶段。  </li><li><strong>根区域扫描阶段</strong>： G1 GC 会扫描初始标记的<code>survivor</code>区域，查找对旧一代的引用，并标记引用对象。该阶段与应用程序（非 STW）同时运行，必须在下一次 STW 年轻垃圾收集开始前完成。  </li><li><strong>并发标记阶段</strong>： G1 GC 会在整个堆中找到可触及的（活）对象。该阶段与应用程序同时进行，可能会被 STW 年轻垃圾收集中断。  </li><li><strong>标记阶段</strong>： 此阶段为 STW 收集，有助于完成标记周期。G1 GC 会耗尽 SATB 缓冲区，跟踪未访问的实时对象，并执行引用处理。  </li><li><strong>清理阶段</strong>： 在这一最后阶段，G1 GC 执行核算和 RSet 擦除的 STW 操作。在核算过程中，G1 GC 会识别完全空闲的区域和混合垃圾收集候选对象。清理阶段的部分并发操作是重置空区域并将其返回到空闲列表。  </li></ul><h1 id="Important-Defaults"><a href="#Important-Defaults" class="headerlink" title="Important Defaults"></a>Important Defaults</h1><p>The G1 GC is an adaptive garbage collector with defaults that enable it to work efficiently without modification. </p><p>G1 GC 是一种自适应垃圾回收器，其默认值使其无需修改即可高效工作。</p><p>Here is a list of important options and their default values. </p><p>下面列出了重要选项及其默认值。</p><p>This list applies to the latest Java HotSpot VM, build 24. </p><p>此列表适用于最新的 Java HotSpot VM 第 24 版。</p><p>You can adapt and tune the G1 GC to your application performance needs by entering the following options with changed settings on the JVM command line.</p><p>您可以通过在 JVM 命令行中输入以下已更改设置的选项，调整 G1 GC 以满足您的应用程序性能需求。</p><ul><li><p><code>-XX:G1HeapRegionSize=n</code>  </p><p>  Sets the size of a G1 region. The value will be a power of two and can range from 1MB to 32MB. The goal is to have around 2048 regions based on the minimum Java heap size.</p><p>  设置 G1 region 的大小。该值是 2 的幂次，范围从 1MB 到 32MB。我们的目标是根据 Java 堆的最小大小，设置大约 2048 个区域。</p></li><li><p><code>-XX:MaxGCPauseMillis=200</code>  </p><p>  Sets a target value for desired maximum pause time. The default value is 200 milliseconds. The specified value does not adapt to your heap size.<br>   设置所需<strong>最大暂停时间的目标值</strong>。默认值为 <strong>200</strong> 毫秒。指定值与堆大小无关。</p></li><li><p><code>-XX:G1NewSizePercent=5</code>  </p><p>  Sets the percentage of the heap to use as the minimum for the young generation size. The default value is 5 percent of your Java heap. This is an experimental flag. See “<span class="exturl" data-url="aHR0cHM6Ly93d3cub3JhY2xlLmNvbS90ZWNobmljYWwtcmVzb3VyY2VzL2FydGljbGVzL2phdmEvZzFnYy5odG1sI1VubG9jaw==" title="https://www.oracle.com/technical-resources/articles/java/g1gc.html#Unlock">How to unlock experimental VM flags<i class="fa fa-external-link"></i></span>“ for an example. This setting replaces the <code>-XX:DefaultMinNewGenPercent</code> setting. This setting is not available in Java HotSpot VM, build 23.</p></li><li><p><code>-XX:G1MaxNewSizePercent=60</code>  </p><p>  Sets the percentage of the heap size to use as the maximum for young generation size. The default value is 60 percent of your Java heap. This is an experimental flag. See “<span class="exturl" data-url="aHR0cHM6Ly93d3cub3JhY2xlLmNvbS90ZWNobmljYWwtcmVzb3VyY2VzL2FydGljbGVzL2phdmEvZzFnYy5odG1sI1VubG9jaw==" title="https://www.oracle.com/technical-resources/articles/java/g1gc.html#Unlock">How to unlock experimental VM flags<i class="fa fa-external-link"></i></span>“ for an example. This setting replaces the <code>-XX:DefaultMaxNewGenPercent</code> setting. This setting is not available in Java HotSpot VM, build 23.</p></li><li><p><code>-XX:ParallelGCThreads=n</code>  </p><p>  Sets the value of the STW worker threads. Sets the value of n to the number of logical processors. The value of <code>n</code> is the same as the number of logical processors up to a value of 8.</p><p>  If there are more than eight logical processors, sets the value of <code>n</code> to approximately 5/8 of the logical processors. This works in most cases except for larger SPARC systems where the value of <code>n</code> can be approximately 5/16 of the logical processors.</p></li><li><p><code>-XX:ConcGCThreads=n</code>  </p><p>  Sets the number of parallel marking threads. Sets <code>n</code> to approximately 1/4 of the number of parallel garbage collection threads (<code>ParallelGCThreads</code>).</p></li><li><p><code>-XX:InitiatingHeapOccupancyPercent=45</code>  </p><p>  Sets the Java heap occupancy threshold that triggers a marking cycle. The default occupancy is 45 percent of the entire Java heap.</p></li><li><p><code>-XX:G1MixedGCLiveThresholdPercent=65</code>  </p><p>  Sets the occupancy threshold for an old region to be included in a mixed garbage collection cycle. The default occupancy is 65 percent. This is an experimental flag. See “<span class="exturl" data-url="aHR0cHM6Ly93d3cub3JhY2xlLmNvbS90ZWNobmljYWwtcmVzb3VyY2VzL2FydGljbGVzL2phdmEvZzFnYy5odG1sI1VubG9jaw==" title="https://www.oracle.com/technical-resources/articles/java/g1gc.html#Unlock">How to unlock experimental VM flags<i class="fa fa-external-link"></i></span>“ for an example. This setting replaces the <code>-XX:G1OldCSetRegionLiveThresholdPercent</code> setting. This setting is not available in Java HotSpot VM, build 23.</p></li><li><p><code>-XX:G1HeapWastePercent=10</code>  </p><p>  Sets the percentage of heap that you are willing to waste. The Java HotSpot VM does not initiate the mixed garbage collection cycle when the reclaimable percentage is less than the heap waste percentage. The default is 10 percent. This setting is not available in Java HotSpot VM, build 23.</p><p>  设置触发垃圾回收之后剩余可被回收的百分比触发Mixed GC的百分比。如果当存活的垃圾对象百分比小于此设置的百分比时，Java HotSpot VM 不会启动Mixed GC。默认值为 10%。此设置在 Java HotSpot VM 第 23 版中不可用。</p></li><li><p><code>-XX:G1MixedGCCountTarget=8</code>  </p><p>  Sets the target number of mixed garbage collections after a marking cycle to collect old regions with at most <code>G1MixedGCLIveThresholdPercent</code> live data. The default is 8 mixed garbage collections. The goal for mixed collections is to be within this target number. This setting is not available in Java HotSpot VM, build 23.</p><p>  设置标记周期后混合垃圾收集的目标次数，以收集最多具有 <code>G1MixedGCLIveThresholdPercent</code> 实时数据的旧区域。默认为 8 次混合垃圾收集。混合收集的目标是在此目标次数范围内。此设置在 Java HotSpot VM 第 23 版中不可用。</p></li><li><p><code>-XX:G1OldCSetRegionThresholdPercent=10</code>  </p><p>  Sets an upper limit on the number of old regions to be collected during a mixed garbage collection cycle. The default is 10 percent of the Java heap. This setting is not available in Java HotSpot VM, build 23.</p><p>  <strong>设置在混合垃圾收集周期内收集的旧区域数量上限</strong>。默认值为 Java 堆的 10%。此设置在 Java HotSpot VM 第 23 版中不可用。</p></li><li><p><code>-XX:G1ReservePercent=10</code>  （保留内存百分比）</p><p>  Sets the percentage of reserve memory to keep free so as to reduce the risk of to-space overflows. The default is 10 percent. When you increase or decrease the percentage, make sure to adjust the total Java heap by the same amount. This setting is not available in Java HotSpot VM, build 23.</p><p>  <strong>设置保留空闲内存的百分比</strong>，以降低空间溢出的风险。默认值为 10%。增加或减少该百分比时，请确保<strong>以相同的数量调整 Java 堆总数</strong>。此设置在 <strong>Java HotSpot VM 第 23 版中不可用</strong>。</p></li></ul><h2 id="About-the-Author-关于作者"><a href="#About-the-Author-关于作者" class="headerlink" title="About the Author 关于作者"></a>About the Author 关于作者</h2><p>Monica Beckwith, Principal Member of Technical Staff at Oracle, is the performance lead for the Java HotSpot VM’s Garbage First Garbage Collector. </p><p>Monica Beckwith 是甲骨文公司的首席技术人员，是 Java HotSpot 虚拟机垃圾优先垃圾收集器的性能负责人。</p><p>She has worked in the performance and architecture industry for over 10 years. </p><p>她在性能和架构行业工作了 10 多年。</p><p>Prior to Oracle and Sun Microsystems, Monica lead the performance effort at Spansion Inc. </p><p>在加入 Oracle 和 Sun Microsystems 之前，Monica 在 Spansion Inc. </p><p>Monica has worked with many industry standard Java based benchmarks with a constant goal of finding opportunities for improvement in the Java HotSpot VM。</p><p>Monica 曾参与过许多基于行业标准 Java 的基准测试，始终致力于寻找 Java HotSpot VM 的改进机会。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      gc
    
    </summary>
    
    
      <category term="Java" scheme="https://whitestore.top/categories/Java/"/>
    
    
      <category term="Java" scheme="https://whitestore.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Zookeeper】Introduction to Apache Curator</title>
    <link href="https://whitestore.top/2023/09/11/zkapachcurator/"/>
    <id>https://whitestore.top/2023/09/11/zkapachcurator/</id>
    <published>2023-09-11T02:23:18.000Z</published>
    <updated>2023-10-21T14:26:31.033Z</updated>
    
    <content type="html"><![CDATA[<p>#zookeeper </p><h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFlbGR1bmcuY29tL2FwYWNoZS1jdXJhdG9y" title="https://www.baeldung.com/apache-curator">https://www.baeldung.com/apache-curator<i class="fa fa-external-link"></i></span></p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a><a href="https://www.baeldung.com/apache-curator#introduction" target="_blank" rel="noopener"><strong>1. Introduction</strong></a></h2><p><span class="exturl" data-url="aHR0cHM6Ly9jdXJhdG9yLmFwYWNoZS5vcmcv" title="https://curator.apache.org/">Apache Curator<i class="fa fa-external-link"></i></span> is a Java client for <span class="exturl" data-url="aHR0cHM6Ly96b29rZWVwZXIuYXBhY2hlLm9yZy8=" title="https://zookeeper.apache.org/">Apache Zookeeper<i class="fa fa-external-link"></i></span>, the popular coordination service for distributed applications.</p><p><span class="exturl" data-url="aHR0cHM6Ly9jdXJhdG9yLmFwYWNoZS5vcmcv" title="https://curator.apache.org/">Apache Curator<i class="fa fa-external-link"></i></span> 是 <span class="exturl" data-url="aHR0cHM6Ly96b29rZWVwZXIuYXBhY2hlLm9yZy8=" title="https://zookeeper.apache.org/">Apache Zookeeper<i class="fa fa-external-link"></i></span> 的 Java 客户端，后者是分布式应用程序的流行协调服务。</p><p>In this tutorial, we’ll introduce some of the most relevant features provided by Curator:</p><ul><li>Connection Management – managing connections and retry policies</li><li>Async – enhancing existing client by adding async capabilities and the use of Java 8 lambdas</li><li>Configuration Management – having a centralized configuration for the system</li><li>Strongly-Typed Models – working with typed models</li><li>Recipes – implementing leader election, distributed locks or counters</li></ul><p>在本文中，我们讲介绍一些Curator提供的最实用的功能实现：</p><ul><li>连接管理：管理连接和重试策略</li><li>异步：通过添加异步功能和使用 Java 8 lambda 来增强现有客户端</li><li>配置管理：系统集中配置。</li><li>强类型模型：作用于类型模型上</li><li>Recipes：实现领导选举，分布式锁或者计数器</li></ul><a id="more"></a><h2 id="2-Prerequisites"><a href="#2-Prerequisites" class="headerlink" title="2. Prerequisites"></a><a href="https://www.baeldung.com/apache-curator#prerequisites" target="_blank" rel="noopener"><strong>2. Prerequisites</strong></a></h2><p>To start with, it’s recommended to take a quick look at the <span class="exturl" data-url="aHR0cHM6Ly96b29rZWVwZXIuYXBhY2hlLm9yZy8=" title="https://zookeeper.apache.org/">Apache Zookeeper<i class="fa fa-external-link"></i></span> and its features.</p><p>首先，建议快速浏览一下 <span class="exturl" data-url="aHR0cHM6Ly96b29rZWVwZXIuYXBhY2hlLm9yZy8=" title="https://zookeeper.apache.org/">Apache Zookeeper<i class="fa fa-external-link"></i></span> 及其功能。</p><p>For this tutorial, we assume that there’s already a standalone Zookeeper instance running on <em>127.0.0.1:2181</em>; <span class="exturl" data-url="aHR0cHM6Ly96b29rZWVwZXIuYXBhY2hlLm9yZy9kb2MvY3VycmVudC96b29rZWVwZXJTdGFydGVkLmh0bWw=" title="https://zookeeper.apache.org/doc/current/zookeeperStarted.html">here are<i class="fa fa-external-link"></i></span> instructions on how to install and run it, if you’re just getting started.</p><p>对于本教程，我们假设已经有一个独立的 Zookeeper 实例在 <em>127.0.0.1:2181</em> 上运行；<span class="exturl" data-url="aHR0cHM6Ly96b29rZWVwZXIuYXBhY2hlLm9yZy9kb2MvY3VycmVudC96b29rZWVwZXJTdGFydGVkLmh0bWw=" title="https://zookeeper.apache.org/doc/current/zookeeperStarted.html">这里<i class="fa fa-external-link"></i></span> 会介绍如何安装并且运行</p><blockquote><p>[[【Zookeeper】基于3台linux虚拟机搭建zookeeper集群]]</p></blockquote><p>First, we’ll need to add the <span class="exturl" data-url="aHR0cHM6Ly9zZWFyY2gubWF2ZW4ub3JnL2NsYXNzaWMvI3NlYXJjaCU3Q2dhdiU3QzElN0NnJTNBJTIyb3JnLmFwYWNoZS5jdXJhdG9yJTIyJTIwQU5EJTIwYSUzQSUyMmN1cmF0b3IteC1hc3luYyUyMg==" title="https://search.maven.org/classic/#search%7Cgav%7C1%7Cg%3A%22org.apache.curator%22%20AND%20a%3A%22curator-x-async%22">curator-x-async<i class="fa fa-external-link"></i></span> dependency to our <em>pom.xml</em>:</p><p>首先，我们需要添加 [curator-x-async](<span class="exturl" data-url="aHR0cHM6Ly9zZWFyY2gubWF2ZW4ub3JnL2NsYXNzaWMvI3NlYXJjaCU3Q2dhdiU3QzElN0NnJTNBJTIyb3JnLmFwYWNoZS5jdXJhdG9yJTIyJTIwQU5EJQ==" title="https://search.maven.org/classic/#search%7Cgav%7C1%7Cg%3A%22org.apache.curator%22%20AND%">https://search.maven.org/classic/#search%7Cgav%7C1%7Cg%3A%22org.apache.curator%22%20AND%<i class="fa fa-external-link"></i></span> 20a%3A%22curator-x-async%22) 对我们的 <em>pom.xml</em> 的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-x-async<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>The latest version of Apache Curator 4.X.X has a hard dependency with Zookeeper 3.5.X</strong> which is still in beta right now.</p><p><strong>最新版本的 Apache Curator 4.X.X 与 Zookeeper 3.5.X 具有硬依赖性</strong>。</p><p>And so, in this article, we’re going to use the currently latest stable <span class="exturl" data-url="aHR0cHM6Ly96b29rZWVwZXIuYXBhY2hlLm9yZy9kb2MvcjMuNC4xMS9pbmRleC5odG1s" title="https://zookeeper.apache.org/doc/r3.4.11/index.html">Zookeeper 3.4.11<i class="fa fa-external-link"></i></span> instead.</p><p>在本文中会使用文章编写时候的最后一个稳定版本 <span class="exturl" data-url="aHR0cHM6Ly96b29rZWVwZXIuYXBhY2hlLm9yZy9kb2MvcjMuNC4xMS9pbmRleC5odG1s" title="https://zookeeper.apache.org/doc/r3.4.11/index.html">Zookeeper 3.4.11<i class="fa fa-external-link"></i></span> 替代</p><p>So we need to exclude the Zookeeper dependency and add <span class="exturl" data-url="aHR0cHM6Ly9zZWFyY2gubWF2ZW4ub3JnL2NsYXNzaWMvI3NlYXJjaCU3Q2dhdiU3QzElN0NnJTNBJTIyb3JnLmFwYWNoZS56b29rZWVwZXIlMjIlMjBBTkQlMjBhJTNBJTIyem9va2VlcGVyJTIy" title="https://search.maven.org/classic/#search%7Cgav%7C1%7Cg%3A%22org.apache.zookeeper%22%20AND%20a%3A%22zookeeper%22">the dependency for our Zookeeper version<i class="fa fa-external-link"></i></span> to our <em>pom.xml</em>:</p><p>因此，我们需要排除 Zookeeper 依赖项并添加[我们的 Zookeeper 版本的依赖项](<span class="exturl" data-url="aHR0cHM6Ly9zZWFyY2gubWF2ZW4ub3JnL2NsYXNzaWMvI3NlYXJjaCU3Q2dhdiU3QzElN0NnJTNBJTIyb3JnLmFwYWNoZS56b29rZWVwZXIlMjIl" title="https://search.maven.org/classic/#search%7Cgav%7C1%7Cg%3A%22org.apache.zookeeper%22%">https://search.maven.org/classic/#search%7Cgav%7C1%7Cg%3A%22org.apache.zookeeper%22%<i class="fa fa-external-link"></i></span> 20AND%20a%3A%22zookeeper%22) 到我们的 _pom.xml_：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>For more information about compatibility, please refer to <span class="exturl" data-url="aHR0cHM6Ly9jdXJhdG9yLmFwYWNoZS5vcmcvemstY29tcGF0aWJpbGl0eS0zNC5odG1s" title="https://curator.apache.org/zk-compatibility-34.html">this link<i class="fa fa-external-link"></i></span>.</p><p>更多信息可以查看： <span class="exturl" data-url="aHR0cHM6Ly9jdXJhdG9yLmFwYWNoZS5vcmcvemstY29tcGF0aWJpbGl0eS0zNC5odG1s" title="https://curator.apache.org/zk-compatibility-34.html">this link<i class="fa fa-external-link"></i></span></p><h2 id="3-Connection-Management"><a href="#3-Connection-Management" class="headerlink" title="3. Connection Management"></a><a href="https://www.baeldung.com/apache-curator#connection_management" target="_blank" rel="noopener"><strong>3. Connection Management</strong></a></h2><p><strong>The basic use case of Apache Curator is connecting to a running Apache Zookeeper instance</strong>.</p><p>最基础的使用案例，是使用Curator连接并且运行一个Apach Zk 实例。</p><p>The tool provides a factory to build connections to Zookeeper using retry policies:</p><p>工具提供了一个工厂构建ZK连接，并且需要手动指定重试器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sleepMsBetweenRetries = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> maxRetries = <span class="number">3</span>;</span><br><span class="line">RetryPolicy retryPolicy = <span class="keyword">new</span> RetryNTimes(</span><br><span class="line">  maxRetries, sleepMsBetweenRetries);</span><br><span class="line"></span><br><span class="line">CuratorFramework client = CuratorFrameworkFactory</span><br><span class="line">  .newClient(<span class="string">"127.0.0.1:2181"</span>, retryPolicy);</span><br><span class="line">client.start();</span><br><span class="line"> </span><br><span class="line">assertThat(client.checkExists().forPath(<span class="string">"/"</span>)).isNotNull();</span><br></pre></td></tr></table></figure><p>In this quick example, we’ll retry 3 times and will wait 100 ms between retries in case of connectivity issues.</p><p>在这个快速使用案例中，我们指定了重试三次，并且每次重试的间隔等待100ms。</p><p>Once connected to Zookeeper using the <em>CuratorFramework</em> client, we can now browse paths, get/set data and essentially interact with the server.</p><p>使用 <em>CuratorFramework</em> 客户端连接到 Zookeeper 后，我们现在可以浏览路径、获取/设置数据并与服务器进行交互。</p><h2 id="4-Async"><a href="#4-Async" class="headerlink" title="4. Async"></a><a href="https://www.baeldung.com/apache-curator#async" target="_blank" rel="noopener"><strong>4. Async</strong></a></h2><p><strong>The Curator Async module wraps the above <em>CuratorFramework</em> client to provide non-blocking capabilities</strong> using <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vZW4vamF2YS9qYXZhc2UvMTcvZG9jcy9hcGkvamF2YS5iYXNlL2phdmEvdXRpbC9jb25jdXJyZW50L0NvbXBsZXRpb25TdGFnZS5odG1s" title="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/CompletionStage.html">the CompletionStage Java 8 API<i class="fa fa-external-link"></i></span>.</p><p><strong>Curator Async 模块使用<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vZW4vamF2YS9qYXZhc2UvMTcvZG9jcy9hcGkvamF2YS5iYXNlL2phdmEvdXRpbC9jb25jdXJyZW50L0NvbXBsZXRpb25TdGFnZS5odG1s" title="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/CompletionStage.html">CompletionStage Java 8 API<i class="fa fa-external-link"></i></span> 对上述 <em>CuratorFramework</em> 客户端进行封装，以提供非阻塞功能</strong>。</p><p>Let’s see how the previous example looks like using the Async wrapper:</p><p>让我们看看使用 Async 封装器的前一个示例是怎样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sleepMsBetweenRetries = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> maxRetries = <span class="number">3</span>;</span><br><span class="line">RetryPolicy retryPolicy </span><br><span class="line">  = <span class="keyword">new</span> RetryNTimes(maxRetries, sleepMsBetweenRetries);</span><br><span class="line"></span><br><span class="line">CuratorFramework client = CuratorFrameworkFactory</span><br><span class="line">  .newClient(<span class="string">"127.0.0.1:2181"</span>, retryPolicy);</span><br><span class="line"></span><br><span class="line">client.start();</span><br><span class="line">AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);</span><br><span class="line"></span><br><span class="line">AtomicBoolean exists = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">async.checkExists()</span><br><span class="line">  .forPath(<span class="string">"/"</span>)</span><br><span class="line">  .thenAcceptAsync(s -&gt; exists.set(s != <span class="keyword">null</span>));</span><br><span class="line"></span><br><span class="line">await().until(() -&gt; assertThat(exists.get()).isTrue());</span><br></pre></td></tr></table></figure><p>Now, the <em>checkExists()</em> operation works in asynchronous mode, not blocking the main thread. We can also chain actions one after each other using the <em>thenAcceptAsync()</em> method instead, which uses the <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vZW4vamF2YS9qYXZhc2UvMTcvZG9jcy9hcGkvamF2YS5iYXNlL2phdmEvdXRpbC9jb25jdXJyZW50L0NvbXBsZXRpb25TdGFnZS5odG1s" title="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/CompletionStage.html">CompletionStage API<i class="fa fa-external-link"></i></span>.</p><p>现在，<em>checkExists()</em> 操作以异步模式运行，不会阻塞主线程。我们还可以使用_thenAcceptAsync()_方法（该方法使用 <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vZW4vamF2YS9qYXZhc2UvMTcvZG9jcy9hcGkvamF2YS5iYXNlL2phdmEvdXRpbC9jb25jdXJyZW50L0NvbXBsZXRpb25TdGFnZS5odG1s" title="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/CompletionStage.html">CompletionStage API<i class="fa fa-external-link"></i></span>）将操作一个接一个地串联起来。</p><h2 id="5-Configuration-Management"><a href="#5-Configuration-Management" class="headerlink" title="5. Configuration Management"></a><a href="https://www.baeldung.com/apache-curator#configuration_management" target="_blank" rel="noopener"><strong>5. Configuration Management</strong></a></h2><p>In a distributed environment, one of the most common challenges is to manage shared configuration among many applications. <strong>We can use Zookeeper as a data store where to keep our configuration.</strong></p><p>在分布式环境中，最常见的挑战之一就是管理多个应用程序之间的共享配置。 **我们可以使用 Zookeeper 作为保存配置的数据存储。</p><p>Let’s see an example using Apache Curator to get and set data:</p><p>让我们来看一个使用 Apache Curator 获取和设置数据的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CuratorFramework client = newClient();</span><br><span class="line">client.start();</span><br><span class="line">AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);</span><br><span class="line">String key = getKey();</span><br><span class="line">String expected = <span class="string">"my_value"</span>;</span><br><span class="line"></span><br><span class="line">client.create().forPath(key);</span><br><span class="line"></span><br><span class="line">async.setData()</span><br><span class="line">  .forPath(key, expected.getBytes());</span><br><span class="line"></span><br><span class="line">AtomicBoolean isEquals = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line">async.getData()</span><br><span class="line">  .forPath(key)</span><br><span class="line">  .thenAccept(data -&gt; isEquals.set(<span class="keyword">new</span> String(data).equals(expected)));</span><br><span class="line"></span><br><span class="line">await().until(() -&gt; assertThat(isEquals.get()).isTrue());</span><br></pre></td></tr></table></figure><p>In this example, we create the node path, set the data in Zookeeper, and then we recover it checking that the value is the same. The <em>key</em> field could be a node path like <em>/config/dev/my_key</em>.</p><p>在这个示例中，我们创建节点路径，在 Zookeeper 中设置数据，然后检查值是否相同，再恢复数据。<em>key</em> 字段可以是一个节点路径，如 _/config/dev/my_key_。</p><h3 id="5-1-Watchers"><a href="#5-1-Watchers" class="headerlink" title="5.1. Watchers"></a><strong>5.1. Watchers</strong><a href="https://www.baeldung.com/apache-curator#1-watchers" target="_blank" rel="noopener"></a></h3><p>Another interesting feature in Zookeeper is the ability to watch keys or nodes. <strong>It allows us to listen to changes in the configuration and update our applications without needing to redeploy</strong>.</p><p>Zookeeper 的另一个有趣功能是监视键或节点。 <strong>它允许我们监听配置中的变化并更新应用程序，而无需重新部署</strong>。</p><p>Let’s see how the above example looks like when using watchers:</p><p>让我们看看上面的示例在使用Watch时是什么样子的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">CuratorFramework client = newClient()</span><br><span class="line">client.start();</span><br><span class="line">AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);</span><br><span class="line">String key = getKey();</span><br><span class="line">String expected = <span class="string">"my_value"</span>;</span><br><span class="line"></span><br><span class="line">async.create().forPath(key);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; changes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">async.watched()</span><br><span class="line">  .getData()</span><br><span class="line">  .forPath(key)</span><br><span class="line">  .event()</span><br><span class="line">  .thenAccept(watchedEvent -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        changes.add(<span class="keyword">new</span> String(client.getData()</span><br><span class="line">          .forPath(watchedEvent.getPath())));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// fail ...</span></span><br><span class="line">    &#125;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set data value for our key</span></span><br><span class="line">async.setData()</span><br><span class="line">  .forPath(key, expected.getBytes());</span><br><span class="line"></span><br><span class="line">await()</span><br><span class="line">  .until(() -&gt; assertThat(changes.size()).isEqualTo(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>We configure the watcher, set the data, and then confirm the watched event was triggered. We can watch one node or a set of nodes at once.</p><p>我们配置监视器、设置数据，然后确认被监视事件已触发。我们可以同时观察一个节点或一组节点。</p><h2 id="6-Strongly-Typed-Models"><a href="#6-Strongly-Typed-Models" class="headerlink" title="6. Strongly Typed Models"></a><a href="https://www.baeldung.com/apache-curator#strongly_typed_models" target="_blank" rel="noopener"><strong>6. Strongly Typed Models</strong></a></h2><p>Zookeeper primarily works with byte arrays, so we need to serialize and deserialize our data. This allows us some flexibility to work with any serializable instance, but it can be hard to maintain.</p><p>Zookeeper 主要使用字节数组，因此我们需要对数据进行序列化和反序列化。这让我们可以灵活地使用任何可序列化的实例，但也很难维护。</p><p>To help here, Curator adds the concept of <span class="exturl" data-url="aHR0cHM6Ly9jdXJhdG9yLmFwYWNoZS5vcmcvY3VyYXRvci14LWFzeW5jL21vZGVsZWQuaHRtbA==" title="https://curator.apache.org/curator-x-async/modeled.html">typed models<i class="fa fa-external-link"></i></span> which <strong>delegates the serialization/deserialization and allows us to work with our types directly</strong>. Let’s see how that works.</p><p>为了在这方面提供帮助，Curator 添加了<span class="exturl" data-url="aHR0cHM6Ly9jdXJhdG9yLmFwYWNoZS5vcmcvY3VyYXRvci14LWFzeW5jL21vZGVsZWQuaHRtbA==" title="https://curator.apache.org/curator-x-async/modeled.html">类型化模型<i class="fa fa-external-link"></i></span>的概念，它<strong>了序列化/反序列化，并允许我们直接</strong>我们的类型。让我们看看它是如何工作的。</p><p>First, we need a serializer framework. Curator recommends using the Jackson implementation, so let’s add <span class="exturl" data-url="aHR0cHM6Ly9zZWFyY2gubWF2ZW4ub3JnL2NsYXNzaWMvI3NlYXJjaCU3Q2dhdiU3QzElN0NnJTNBJTIyY29tLmZhc3RlcnhtbC5qYWNrc29uLmNvcmUlMjIlMjBBTkQlMjBhJTNBJTIyamFja3Nvbi1kYXRhYmluZCUyMg==" title="https://search.maven.org/classic/#search%7Cgav%7C1%7Cg%3A%22com.fasterxml.jackson.core%22%20AND%20a%3A%22jackson-databind%22">the Jackson dependency<i class="fa fa-external-link"></i></span> to our <em>pom.xml</em>:</p><p>首先，我们需要一个序列化框架。Curator 推荐使用 Jackson 实现，因此让我们在 <em>pom.xml</em> 中添加<span class="exturl" data-url="aHR0cHM6Ly9zZWFyY2gubWF2ZW4ub3JnL2NsYXNzaWMvI3NlYXJjaCU3Q2dhdiU3QzElN0NnJTNBJTIyY29tLmZhc3RlcnhtbC5qYWNrc29uLmNvcmUlMjIlMjBBTkQlMjBhJTNBJTIyamFja3Nvbi1kYXRhYmluZCUyMg==" title="https://search.maven.org/classic/#search%7Cgav%7C1%7Cg%3A%22com.fasterxml.jackson.core%22%20AND%20a%3A%22jackson-databind%22">Jackson 依赖项<i class="fa fa-external-link"></i></span>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.13.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Now, let’s try to persist our custom class <em>HostConfig</em>:</p><p>现在，让我们尝试持久化自定义类 _HostConfig_：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HostConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String hostname;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We need to provide the model specification mapping from the <em>HostConfig</em> class to a path, and use the modeled framework wrapper provided by Apache Curator:</p><p>我们需要提供从 <em>HostConfig</em> 类到路径的模型规范映射，并使用 Apache Curator 提供的建模框架包装器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ModelSpec&lt;HostConfig&gt; mySpec = ModelSpec.builder(</span><br><span class="line">  ZPath.parseWithIds(<span class="string">"/config/dev"</span>), </span><br><span class="line">  JacksonModelSerializer.build(HostConfig<span class="class">.<span class="keyword">class</span>))</span></span><br><span class="line"><span class="class">  .<span class="title">build</span>()</span>;</span><br><span class="line"></span><br><span class="line">CuratorFramework client = newClient();</span><br><span class="line">client.start();</span><br><span class="line"></span><br><span class="line">AsyncCuratorFramework async </span><br><span class="line">  = AsyncCuratorFramework.wrap(client);</span><br><span class="line">ModeledFramework&lt;HostConfig&gt; modeledClient </span><br><span class="line">  = ModeledFramework.wrap(async, mySpec);</span><br><span class="line"></span><br><span class="line">modeledClient.set(<span class="keyword">new</span> HostConfig(<span class="string">"host-name"</span>, <span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">modeledClient.read()</span><br><span class="line">  .whenComplete((value, e) -&gt; &#123;</span><br><span class="line">     <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">          fail(<span class="string">"Cannot read host config"</span>, e);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          assertThat(value).isNotNull();</span><br><span class="line">          assertThat(value.getHostname()).isEqualTo(<span class="string">"host-name"</span>);</span><br><span class="line">          assertThat(value.getPort()).isEqualTo(<span class="number">8080</span>);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><p>The <em>whenComplete()</em> method when reading the path <em>/config/dev</em> will return the <em>HostConfig</em> instance in Zookeeper.</p><p>读取 <em>/config/dev</em> 路径时，<em>whenComplete()</em> 方法将返回 Zookeeper 中的 <em>HostConfig</em> 实例。</p><h2 id="7-Recipes"><a href="#7-Recipes" class="headerlink" title="7. Recipes"></a><a href="https://www.baeldung.com/apache-curator#recipes" target="_blank" rel="noopener"><strong>7. Recipes</strong></a></h2><p>Zookeeper provides <span class="exturl" data-url="aHR0cHM6Ly96b29rZWVwZXIuYXBhY2hlLm9yZy9kb2MvY3VycmVudC9yZWNpcGVzLmh0bWw=" title="https://zookeeper.apache.org/doc/current/recipes.html">this guideline<i class="fa fa-external-link"></i></span> to implement <strong>high-level solutions or recipes such as leader election, distributed locks or shared counters.</strong></p><p>Zookeeper 提供了<span class="exturl" data-url="aHR0cHM6Ly96b29rZWVwZXIuYXBhY2hlLm9yZy9kb2MvY3VycmVudC9yZWNpcGVzLmh0bWw=" title="https://zookeeper.apache.org/doc/current/recipes.html">本指南<i class="fa fa-external-link"></i></span>来实现<strong>高层次的解决方案或秘诀，如领导者选举、分布式锁或共享计数器。</strong></p><p>Apache Curator provides an implementation for most of these recipes. To see the full list, visit <span class="exturl" data-url="aHR0cHM6Ly9jdXJhdG9yLmFwYWNoZS5vcmcvY3VyYXRvci1yZWNpcGVzL2luZGV4Lmh0bWw=" title="https://curator.apache.org/curator-recipes/index.html">the Curator Recipes documentation<i class="fa fa-external-link"></i></span>.</p><p>Apache Curator 提供了其中大部分方案的实现方法。要查看完整列表，请访问<span class="exturl" data-url="aHR0cHM6Ly9jdXJhdG9yLmFwYWNoZS5vcmcvY3VyYXRvci1yZWNpcGVzL2luZGV4Lmh0bWw=" title="https://curator.apache.org/curator-recipes/index.html">Curator Recipes 文档<i class="fa fa-external-link"></i></span>。</p><p>All of these recipes are available in a separate module:</p><p>所有这些API都可以在单独的模块中找到：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Let’s jump right in and start understanding these with some simple examples.</p><p>让我们通过一些简单的例子，直接开始了解这些知识。</p><h3 id="7-1-Leader-Election"><a href="#7-1-Leader-Election" class="headerlink" title="7.1. Leader Election"></a><a href="https://www.baeldung.com/apache-curator#1-leader-election" target="_blank" rel="noopener"><strong>7.1. Leader Election</strong></a></h3><p>In a distributed environment, we may need one master or leader node to coordinate a complex job.</p><p>在分布式环境中，我们可能需要一个主节点或领导节点来协调复杂的工作。</p><p>This is how the usage of <span class="exturl" data-url="aHR0cHM6Ly9jdXJhdG9yLmFwYWNoZS5vcmcvY3VyYXRvci1yZWNpcGVzL2xlYWRlci1lbGVjdGlvbi5odG1s" title="https://curator.apache.org/curator-recipes/leader-election.html">the Leader Election recipe<i class="fa fa-external-link"></i></span> in Curator looks like:</p><p>这就是 <span class="exturl" data-url="aHR0cHM6Ly9jdXJhdG9yLmFwYWNoZS5vcmcvY3VyYXRvci1yZWNpcGVzL2xlYWRlci1lbGVjdGlvbi5odG1s" title="https://curator.apache.org/curator-recipes/leader-election.html">领导人选举配方<i class="fa fa-external-link"></i></span> 在 Curator 中的用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">CuratorFramework client = newClient();</span><br><span class="line">client.start();</span><br><span class="line">LeaderSelector leaderSelector = <span class="keyword">new</span> LeaderSelector(client, </span><br><span class="line">  <span class="string">"/mutex/select/leader/for/job/A"</span>, </span><br><span class="line">  <span class="keyword">new</span> LeaderSelectorListener() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        CuratorFramework client, </span></span></span><br><span class="line"><span class="function"><span class="params">        ConnectionState newState)</span> </span>&#123;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeLeadership</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        CuratorFramework client)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// join the members group</span></span><br><span class="line">leaderSelector.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// wait until the job A is done among all members</span></span><br><span class="line">leaderSelector.close();</span><br></pre></td></tr></table></figure><p>When we start the leader selector, our node joins a members group within the path <em>/mutex/select/leader/for/job/A</em>. Once our node becomes the leader, the <em>takeLeadership</em> method will be invoked, and we as leaders can resume the job.</p><p>当我们启动领导者选择器时，我们的节点会加入 <em>/mutex/select/leader/for/job/A</em> 路径下的成员组。一旦我们的节点成为领导者，<em>takeLeadership</em> 方法就会被调用，作为领导者的我们就可以继续执行任务。</p><h3 id="7-2-Shared-Locks"><a href="#7-2-Shared-Locks" class="headerlink" title="7.2. Shared Locks"></a><a href="https://www.baeldung.com/apache-curator#2-shared-locks" target="_blank" rel="noopener"><strong>7.2. Shared Locks</strong></a></h3><p><span class="exturl" data-url="aHR0cHM6Ly9jdXJhdG9yLmFwYWNoZS5vcmcvY3VyYXRvci1yZWNpcGVzL3NoYXJlZC1sb2NrLmh0bWw=" title="https://curator.apache.org/curator-recipes/shared-lock.html">The Shared Lock recipe<i class="fa fa-external-link"></i></span> is about having a fully distributed lock:</p><p><span class="exturl" data-url="aHR0cHM6Ly9jdXJhdG9yLmFwYWNoZS5vcmcvY3VyYXRvci1yZWNpcGVzL3NoYXJlZC1sb2NrLmh0bWw=" title="https://curator.apache.org/curator-recipes/shared-lock.html">共享锁配方<i class="fa fa-external-link"></i></span> 是关于完全分布式锁的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CuratorFramework client = newClient();</span><br><span class="line">client.start();</span><br><span class="line">InterProcessSemaphoreMutex sharedLock = <span class="keyword">new</span> InterProcessSemaphoreMutex(</span><br><span class="line">  client, <span class="string">"/mutex/process/A"</span>);</span><br><span class="line"></span><br><span class="line">sharedLock.acquire();</span><br><span class="line"></span><br><span class="line"><span class="comment">// do process A</span></span><br><span class="line"></span><br><span class="line">sharedLock.release();</span><br></pre></td></tr></table></figure><p>When we acquire the lock, Zookeeper ensures that there’s no other application acquiring the same lock at the same time.</p><p>当我们获取锁时，Zookeeper 会确保没有其他应用程序同时获取相同的锁。</p><h3 id="7-3-Counters"><a href="#7-3-Counters" class="headerlink" title="7.3. Counters"></a><a href="https://www.baeldung.com/apache-curator#3-counters" target="_blank" rel="noopener"><strong>7.3. Counters</strong></a></h3><p><span class="exturl" data-url="aHR0cHM6Ly9jdXJhdG9yLmFwYWNoZS5vcmcvY3VyYXRvci1yZWNpcGVzL3NoYXJlZC1jb3VudGVyLmh0bWw=" title="https://curator.apache.org/curator-recipes/shared-counter.html">The Counters recipe<i class="fa fa-external-link"></i></span> coordinates a shared <em>Integer</em> among all the clients:</p><p><span class="exturl" data-url="aHR0cHM6Ly9jdXJhdG9yLmFwYWNoZS5vcmcvY3VyYXRvci1yZWNpcGVzL3NoYXJlZC1jb3VudGVyLmh0bWw=" title="https://curator.apache.org/curator-recipes/shared-counter.html">计数器配方<i class="fa fa-external-link"></i></span> 协调所有客户端共享的_整数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CuratorFramework client = newClient();</span><br><span class="line">client.start();</span><br><span class="line"></span><br><span class="line">SharedCount counter = <span class="keyword">new</span> SharedCount(client, <span class="string">"/counters/A"</span>, <span class="number">0</span>);</span><br><span class="line">counter.start();</span><br><span class="line"></span><br><span class="line">counter.setCount(counter.getCount() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">assertThat(counter.getCount()).isEqualTo(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>In this example, Zookeeper stores the <em>Integer</em> value in the path <em>/counters/A</em> and initializes the value to <em>0</em> if the path has not been created yet.</p><p>在此示例中，Zookeeper 将 <em>Integer</em> 值存储在 <em>/counters/A</em> 路径中，如果路径尚未创建，则将该值初始化为 <em>0</em>。</p><h2 id="8-Conclusion"><a href="#8-Conclusion" class="headerlink" title="8. Conclusion"></a><strong>8. Conclusion</strong><a href="https://www.baeldung.com/apache-curator#conclusion" target="_blank" rel="noopener"></a></h2><p>In this article, we’ve seen how to use Apache Curator to connect to Apache Zookeeper and take benefit of its main features.</p><p>在这篇文章中，我们介绍了如何使用Apach Curator连接Apach Zookeeper，并利用其主要功能。</p><p>We’ve also introduced a few of the main recipes in Curator.</p><p>我们还介绍了 Curator 中的一些主要不见。</p><p>As usual, sources can be found <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2V1Z2VucC90dXRvcmlhbHMvdHJlZS9tYXN0ZXIvYXBhY2hlLWxpYnJhcmllcw==" title="https://github.com/eugenp/tutorials/tree/master/apache-libraries">over on GitHub<i class="fa fa-external-link"></i></span>.</p><p>与往常一样，您可以在 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2V1Z2VucC90dXRvcmlhbHMvdHJlZS9tYXN0ZXIvYXBhY2hlLWxpYnJhcmllcw==" title="https://github.com/eugenp/tutorials/tree/master/apache-libraries">GitHub<i class="fa fa-external-link"></i></span> 上找到源代码。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      Zookeeper使用
    
    </summary>
    
    
      <category term="Zookeeper" scheme="https://whitestore.top/categories/Zookeeper/"/>
    
    
      <category term="Zookeeper" scheme="https://whitestore.top/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>【读书笔记】《一本书读懂支付》读书笔记（一）</title>
    <link href="https://whitestore.top/2023/09/09/onebookpay/"/>
    <id>https://whitestore.top/2023/09/09/onebookpay/</id>
    <published>2023-09-09T01:33:10.000Z</published>
    <updated>2023-09-09T01:34:12.337Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-交易"><a href="#一-交易" class="headerlink" title="一. 交易"></a>一. 交易</h1><h2 id="1-1-什么是交易？"><a href="#1-1-什么是交易？" class="headerlink" title="1.1 什么是交易？"></a>1.1 什么是交易？</h2><p>按照历史趋势：贝壳交换 =&gt; 实体货币 =&gt; 数据化虚拟货币（轻量化和虚拟化）。</p><p>一句话：<strong>等价交换行为</strong>。</p><h2 id="1-2-交易定义"><a href="#1-2-交易定义" class="headerlink" title="1.2 交易定义"></a>1.2 交易定义</h2><p>买卖双方对有价值的物品与服务互通有无的行为。</p><blockquote><p>关键：双方、有价值、互通有无、物品和服务</p></blockquote><h2 id="1-3-交易流程"><a href="#1-3-交易流程" class="headerlink" title="1.3 交易流程"></a>1.3 交易流程</h2><p>古代：<strong>袖内拉手</strong> 和 <strong>袖内比价</strong>。</p><p>现代：某些交易场景下有专业的手势，比如交易所手心向内和手心向外代表买入和卖出。</p><h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><p>步骤：签约 =&gt; 认证 =&gt; 交付 =&gt; 记录</p><p><strong>签约</strong>：交易条件一致。</p><p><strong>认证</strong>：互验真伪。</p><p><strong>交付</strong>：卖方物品服务托付买方。</p><p><strong>记录</strong>：买方转账给卖方。</p><h3 id="产生问题"><a href="#产生问题" class="headerlink" title="产生问题"></a>产生问题</h3><ol><li>跨境交易</li><li>失信问题</li><li>诈骗</li><li>换汇等一系列问题</li></ol><a id="more"></a><h1 id="二、支付"><a href="#二、支付" class="headerlink" title="二、支付"></a>二、支付</h1><h2 id="2-1-什么是支付"><a href="#2-1-什么是支付" class="headerlink" title="2.1 什么是支付"></a>2.1 什么是支付</h2><p>定义：付款人向收款人转移<strong>可接受</strong>的<strong>货币债权</strong>。</p><blockquote><p>对应了交易流程的”交付“步骤。</p></blockquote><h2 id="2-2-支付过程"><a href="#2-2-支付过程" class="headerlink" title="2.2 支付过程"></a>2.2 支付过程</h2><ol><li>当面交付</li><li>周期交付</li><li>代理交付</li><li>授权承诺<h2 id="2-3-支付要素"><a href="#2-3-支付要素" class="headerlink" title="2.3 支付要素"></a>2.3 支付要素</h2></li></ol><p>关键点：付款人、收款人、可接受的货币债权</p><p><strong>付款人</strong>：买方。<br><strong>收款人</strong>：卖方。<br><strong>可接受的货币债权</strong>。</p><p>可接受的货币债权包含下面几个点：</p><p><strong>支付时间</strong>：合约规定时间。<br><strong>支付货币</strong>：合约规定币种。<br><strong>支付金额</strong>：合约规定货币数量。<br><strong>支付方式</strong>：支票、电子转账等等多种方式。</p><h2 id="2-4-支付复杂性"><a href="#2-4-支付复杂性" class="headerlink" title="2.4 支付复杂性"></a>2.4 支付复杂性</h2><p><strong>身份认证</strong>：付款人不验明正身，无法把资金交割给收款人。<br><strong>约定资金交割</strong>：跨境交易存在换汇和不同银行的交互问题。<br><strong>各国监管机构</strong>：关注反洗钱，反贪污，防止偷税漏税等。</p><h2 id="2-5-易混淆概念"><a href="#2-5-易混淆概念" class="headerlink" title="2.5 易混淆概念"></a>2.5 易混淆概念</h2><p><strong>支付指令</strong>：支付机构按照消费者授权，向银行发起具体的指令。<br><strong>支付请求</strong>：消费者向商户支付款项。</p><h1 id="三、交易与支付"><a href="#三、交易与支付" class="headerlink" title="三、交易与支付"></a>三、交易与支付</h1><h2 id="3-1-概念"><a href="#3-1-概念" class="headerlink" title="3.1 概念"></a>3.1 概念</h2><p>交易是支付的关键环节。</p><h2 id="3-2-交易与支付的差异"><a href="#3-2-交易与支付的差异" class="headerlink" title="3.2 交易与支付的差异"></a>3.2 交易与支付的差异</h2><ol><li>不存在有价值物品交换，不存在支付。</li></ol><ul><li>以物换物。</li></ul><ol start="2"><li>交易发生与支付这两者无直接关系。</li></ol><ul><li>少部分交易不需要支付</li><li>少部分支付无交易</li><li>多数交易有支付</li></ul><p>比如：</p><ul><li>朋友借钱和还钱（无交易的支付）</li><li>捐款（无交易支付）<h1 id="四、支付中的常用概念"><a href="#四、支付中的常用概念" class="headerlink" title="四、支付中的常用概念"></a>四、支付中的常用概念</h1></li></ul><h2 id="4-1-应收账款"><a href="#4-1-应收账款" class="headerlink" title="4.1 应收账款"></a>4.1 应收账款</h2><p>会计科目，指的是因出售商品或者服务，进而对顾客产生的债权。从卖方角度看，应收账款是指卖方提供了买方需要的服务，<strong>卖方应该收到的买方款项</strong>。</p><h2 id="4-2-保理"><a href="#4-2-保理" class="headerlink" title="4.2 保理"></a>4.2 保理</h2><p>金融术语：交易所产生的应收账款转让给保理机构管理，由保理机构完成金融服务。</p><p>保理服务商：主要提供资金融通，卖家资信评估，销售账户管理，信用风险担保，账款催收等一系列服务的综合金融服务方式。</p><h2 id="4-3-收单"><a href="#4-3-收单" class="headerlink" title="4.3 收单"></a>4.3 收单</h2><p>收单需要先了解”单“的概念：单就是消费者完成交易之后的单据。</p><p>常见的收单方式：</p><ul><li><strong>ATM 收单</strong>：多指持卡人在非开户行ATM取款。<ul><li>如果是跨行取款，会涉及银行和银行之间的清算，收取活动。</li></ul></li><li><strong>POS 机收单</strong>：国外使用较多，POS机由银行提供，直接和收单机构间接部署到各个商铺。<ul><li>产生双份收据，消费者方收据用于日后查询备用，商户收据则用于发生交易纠纷的时候找银行核算。</li></ul></li><li><strong>网络收单</strong>：在线支付产生的收据。</li></ul><p>交易链：三方支付 -&gt; 收单行 -&gt; 卡组织  -&gt; 公共/专用网络。</p><h2 id="4-4-结算"><a href="#4-4-结算" class="headerlink" title="4.4 结算"></a>4.4 结算</h2><p>支付机构和商户商定结算周期费率，周期内支付请求总结性计算，结算会在汇总的过程中抽取手续费并且扣除。</p><h2 id="4-5-备付金"><a href="#4-5-备付金" class="headerlink" title="4.5 备付金"></a>4.5 备付金</h2><p>指的是预收待支付货币资金（通常为银行）。</p><blockquote><p>比如我们在支付宝微信的”余额“或者说账户余额就是备付金的概念。</p></blockquote><h2 id="4-6-清算"><a href="#4-6-清算" class="headerlink" title="4.6 清算"></a>4.6 清算</h2><p>定义：对于不同的银行进行机构定期长短款<strong>割差</strong>过程。</p><p>目的：<strong>避免金融机构不必要的资金转移</strong>。</p><p>再比如这个例子：中行 =&gt; 建行转500，建行=&gt;中行700，通过清算机构割差，最终为 中行 =&gt; 建行200。</p><h2 id="4-7-对比清算和结算的概念"><a href="#4-7-对比清算和结算的概念" class="headerlink" title="4.7 对比清算和结算的概念"></a>4.7 对比清算和结算的概念</h2><p>清算：机构之间算清互相欠款，重点是机构和机构。<br>结算：仅限支付服务提供商和服务商户之间的活动。</p><h1 id="五、会计系统"><a href="#五、会计系统" class="headerlink" title="五、会计系统"></a>五、会计系统</h1><p>注意这部分介绍的内容都是以中国的会计系统为基础。</p><h2 id="5-1-账户"><a href="#5-1-账户" class="headerlink" title="5.1 账户"></a>5.1 账户</h2><p>基本结构为：名称（会计科目）、日期摘要，（增加/减少）方金额、余额。</p><h2 id="5-2-账务"><a href="#5-2-账务" class="headerlink" title="5.2 账务"></a>5.2 账务</h2><p>实现汇集处理的原始单据收集，整理，记载，计算等会计实事务处理。</p><h2 id="5-3-账户模型"><a href="#5-3-账户模型" class="headerlink" title="5.3 账户模型"></a>5.3 账户模型</h2><p><strong>账户编号</strong>：系统授权的开户账户唯一编号。<br><strong>账户余额</strong>：现存并且未使用的货币数量（包含了可用+冻结金额）。<br><strong>可用余额</strong>：表示此时此刻可以动用的金额。<br><strong>冻结金额</strong>：业务操作冻结，或者个人账户错误，付款停滞，充值按月返现等都会出现冻结金额。<br><strong>货币种类</strong>：余额 + 币种 = 实际的货币价值。<br><strong>借贷属性</strong>：会计行业术语，表示账户金额的增减。借出=&gt;资产增加，负债减少，贷入=&gt;负债增加、资产减少。</p><blockquote><p>会计的借贷概念：<br> 借：资产、费用成本增加，负债、收入，所有者权益减少。<br> 贷：负债、收入、所有者权益增加，资产、费用、成本的减少。</p></blockquote><p><strong>所属科目</strong>：指的是所从属会计科目。一般所属科目设置是按照资金划分的，按照经济内容对于资产、负债、所有者权益等会计要素进一步分类的类型名称。<br><strong>帐套</strong>：会计核算对象，会计业务数据文件总称。</p><h1 id="六、信用与信用支付"><a href="#六、信用与信用支付" class="headerlink" title=";六、信用与信用支付"></a>;六、信用与信用支付</h1><p>最早的信用支付在农耕时代，农民借钱耕种，庄稼收获卖出获利之后还钱。信用支付的本质就是超前消费，花未来的钱解决现在的问题，现代社会生活中，信用和信用支付随处可见。</p><h2 id="信用（redit）衍生信用支付"><a href="#信用（redit）衍生信用支付" class="headerlink" title="信用（redit）衍生信用支付"></a>信用（redit）衍生信用支付</h2><p>不用立刻付款就可以获得资金，物资，服务能力，本身建立在<strong>信任</strong>的基础上，获得这能力的条件是<strong>以约定的期限偿还</strong>。</p><p><strong>信用支付</strong>：其实就是支付过程当中，<strong>把付款人借到的资金转移给收款人的过程</strong>。</p><h2 id="美国信用评价体系"><a href="#美国信用评价体系" class="headerlink" title="美国信用评价体系"></a>美国信用评价体系</h2><p>这部分比较科普向，简单认识名字即可，感兴趣可以看看维基百科。</p><p>三大征信公司：</p><ul><li>全联公司（TransUnion）；</li><li>艾贵发公司（Equifax）；</li><li>益百利公司（Experian）;<h2 id="FICO-（FairIssac-Company）"><a href="#FICO-（FairIssac-Company）" class="headerlink" title="FICO （FairIssac Company）"></a>FICO （FairIssac Company）</h2></li></ul><p><strong>FICO （FairIssac Company）</strong> （消费者信用分数算法模型）最初是计算消费者信用分数的算法模型，这也是首家信贷咨询公司。</p><h3 id="评估依据"><a href="#评估依据" class="headerlink" title="评估依据"></a>评估依据</h3><p>消费者信用分数的评估依据有：信用记录长度、债务数额、新申请信贷、信用组合、支付历史。</p><h3 id="评估结果"><a href="#评估结果" class="headerlink" title="评估结果"></a>评估结果</h3><p>美国的消费者信用评估分为下面五个等级（由最差到最好）：</p><ul><li>Poor：信用分数350分以下</li><li>Fair：信用分数 351 - 590</li><li>OK：信用分数 591 - 610</li><li>Good：信用分数 611 - 680</li><li>Great：信用分数 681 以上<h2 id="次贷危机"><a href="#次贷危机" class="headerlink" title="次贷危机"></a>次贷危机</h2></li></ul><p>2007年的次贷危机，原因是贷款人的信用评估结果不好，但是这部分人依然要买房子，贷款公司和银行依然放贷，只不过条件变得更为严苛，此时作为贷款人只能接受“剥削”硬着头皮接受条件…..</p><p>美国的信用体系整体上是可靠的，次贷危机树因为银行没有按照征信机构指引作业。</p><h2 id="征信差的生意"><a href="#征信差的生意" class="headerlink" title="征信差的生意"></a>征信差的生意</h2><p>当然征信差的人并不一定完全没有任何出路，美国的 Capital One 公司会专门对于信用评分不太好的人挑选一部分继续做生意。</p><p>Capital One 公司是典型的用管理风险来赚钱的金融科技公司。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      读懂支付
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://whitestore.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://whitestore.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【摄影】通向另一个世界的窗口——摄影构图三步法</title>
    <link href="https://whitestore.top/2023/09/09/photo1/"/>
    <id>https://whitestore.top/2023/09/09/photo1/</id>
    <published>2023-09-09T00:56:17.000Z</published>
    <updated>2023-09-09T00:57:12.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="相关视频"><a href="#相关视频" class="headerlink" title="相关视频"></a>相关视频</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXZ2NDExODczUy8/c3BtX2lkX2Zyb209MzMzLjc4OC5yZWNvbW1lbmRfbW9yZV92aWRlby4wJnZkX3NvdXJjZT04MmI2ZjI0ZmM2OTljNDAwYzA5NzdjNjNkN2IzN2Y2NA==" title="https://www.bilibili.com/video/BV1vv411873S/?spm_id_from=333.788.recommend_more_video.0&vd_source=82b6f24fc699c400c0977c63d7b37f64">通向另一个世界的窗口——摄影构图三步法<i class="fa fa-external-link"></i></span></p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>传统的构图模式适合新手，比如三分法，对称法，对角线构图等等，遵循模式的构图会造成成片的千篇一律，这个过程这好似应试教育讲解例题，按照例题去不断练习完成考试。</p><p>应试教育的方式学习摄获取不到真正的知识，真正的知识是<strong>以原理为基础，构建有效方法</strong>。</p><h2 id="二维影像的基本构成"><a href="#二维影像的基本构成" class="headerlink" title="二维影像的基本构成"></a>二维影像的基本构成</h2><p>影响构成的基本原理是<strong>形态</strong>，形态分为点线面等基本要素，色彩是附加在形态之上的，在影像构成的时候可以忽略色彩观察形态，色彩是在影像结构上的视觉和心理影响。</p><a id="more"></a><h1 id="摄影镜头的成像"><a href="#摄影镜头的成像" class="headerlink" title="摄影镜头的成像"></a>摄影镜头的成像</h1><p>摄影镜头的成像遵循<strong>几何光学</strong>原理：宏观状态下光线是直线传播的，经过介质的时候会发生折射和反射。</p><p>镜头投射的影像和影像的位置有关，镜头所在的位置可以叫做观察点， 摄影镜头是通向另一个世界的窗口，和人眼的成像原理类似，镜头成像是把三维世界的物体形态压缩转为二维影像的过程。</p><p>压缩的过程发生了什么？观察点的改变造成压缩画面的改变，反之亦然，观察点的改变会<strong>产生形态关系的改变。</strong></p><p>压缩画面的改变本质是<strong>多个物体形态排列组合发生变化</strong>，物体的位置变化最终变为<strong>近大远小</strong>的形态对比，同样观察点的变化也会产生物体形态的相互叠加或者分离。</p><p><strong>影像构成基于透视原理，画面结构取决于观察点。</strong> </p><h1 id="构图三步法"><a href="#构图三步法" class="headerlink" title="构图三步法"></a>构图三步法</h1><p>从影像构成的角度认识摄影，才是通向摄影的另一个窗口。</p><h2 id="用形态观察"><a href="#用形态观察" class="headerlink" title="用形态观察"></a>用形态观察</h2><p>观察要有感知和感受，涉及到心态和感知变化，这个过程确定了选取那些形态放到照片里。</p><h2 id="选取观察点"><a href="#选取观察点" class="headerlink" title="选取观察点"></a>选取观察点</h2><p>把这些形态进行排列组合，让它们形成二维平面里的构成关系，这一步需要一定的训练。<strong>体会多个形态之间的排列组合，如何产生新的感知和感受</strong>。这就是摄影语言的基础，在平时的拍摄中多体会这一点，你会获得非凡的观察力。</p><h2 id="确定画面视觉元素"><a href="#确定画面视觉元素" class="headerlink" title="确定画面视觉元素"></a>确定画面视觉元素</h2><p>焦距和相机的取景框确定最终画面以及它们此时的空间关系位置，也确定了<strong>透视关系</strong>。</p><p>采用定焦镜头，需要前后移动改变拍摄范围，前后移动会带来透视关系改变，此时需要重新选取观察点和确定画面视觉元素，定焦镜头可以很好的训练影响构成。</p><h1 id="简化理解构图三步法"><a href="#简化理解构图三步法" class="headerlink" title="简化理解构图三步法"></a>简化理解构图三步法</h1><ol><li>拍什么 </li><li>从哪儿拍  </li><li>拍多少（镜头和焦距）<h1 id="影像的构成"><a href="#影像的构成" class="headerlink" title="影像的构成"></a>影像的构成</h1></li></ol><p>视觉元素的整理过程，整理的结果是让杂乱变得有序，让演奏音乐有旋律和节奏，而不是杂乱的噪音。</p><p>长焦镜头和广角镜头本质上是对于画面进行压缩或者容纳更多的元素，镜头并不会改变透视关系，只有位置的变化才会改变透视关系。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>用“心”的摄影才是真正的摄影。</p><h1 id="作品鉴赏"><a href="#作品鉴赏" class="headerlink" title="作品鉴赏"></a>作品鉴赏</h1><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909075248.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909075303.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909075319.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909075330.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909075600.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909075617.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909075645.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909075711.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909075721.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909075815.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909075839.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909075850.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909075907.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909075920.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909075939.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080002.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080017.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080027.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080037.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080045.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080059.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080111.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080122.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080137.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080155.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080209.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080221.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080234.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080247.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080303.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080317.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080331.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080342.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080352.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080406.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080436.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080450.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080502.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080517.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080534.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080546.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080557.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080612.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080627.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080638.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080648.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080659.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080713.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080724.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080738.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080747.png" alt=""></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230909080802.png" alt=""></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      摄影基础
    
    </summary>
    
    
      <category term="摄影" scheme="https://whitestore.top/categories/%E6%91%84%E5%BD%B1/"/>
    
    
      <category term="摄影" scheme="https://whitestore.top/tags/%E6%91%84%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>Jmeter压力测试学习</title>
    <link href="https://whitestore.top/2023/09/09/note20/"/>
    <id>https://whitestore.top/2023/09/09/note20/</id>
    <published>2023-09-09T00:55:00.446Z</published>
    <updated>2023-07-16T06:28:09.250Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>Jmeter 作为实操性的软件，更注重练习，理论作为参考掌握即可，不需要去具体的纠结</p><h1 id="1-目前用的常用测试工具对比"><a href="#1-目前用的常用测试工具对比" class="headerlink" title="1. 目前用的常用测试工具对比"></a>1. 目前用的常用测试工具对比</h1><h2 id="1、loadrunner"><a href="#1、loadrunner" class="headerlink" title="1、loadrunner"></a>1、loadrunner</h2><p>​    性能稳定，压测结果及细粒度大，可以自定义脚本进行压测，但是太过于重大，功能比较繁多</p><p>​    1、loadrunner</p><h2 id="2、apache-ab-单接口压测最方便"><a href="#2、apache-ab-单接口压测最方便" class="headerlink" title="2、apache ab(单接口压测最方便)"></a>2、apache ab(单接口压测最方便)</h2><p>​    模拟多线程并发请求,ab命令对发出负载的计算机要求很低，既不会占用很多CPU，也不会占用太多的内存，但却会给目标服务器造成巨大的负载, 简单DDOS攻击等</p><h2 id="3、webbench"><a href="#3、webbench" class="headerlink" title="3、webbench"></a>3、webbench</h2><p>​    webbench首先fork出多个子进程，每个子进程都循环做web访问测试。子进程把访问的结果通过pipe告诉父进程，父进程做最终的统计结果。</p><a id="more"></a><h1 id="2-Jmeter基本介绍和使用场景"><a href="#2-Jmeter基本介绍和使用场景" class="headerlink" title="2. Jmeter基本介绍和使用场景"></a>2. Jmeter基本介绍和使用场景</h1><h2 id="1、压测不同的协议和应用"><a href="#1、压测不同的协议和应用" class="headerlink" title="1、压测不同的协议和应用"></a>1、压测不同的协议和应用</h2><p>​    1) Web - HTTP, HTTPS (Java, NodeJS, PHP, <span class="exturl" data-url="aHR0cDovL0FTUC5ORVQ=" title="http://ASP.NET">ASP.NET<i class="fa fa-external-link"></i></span>, …)     2) SOAP / REST Webservices     3) FTP     4) Database via JDBC     5) LDAP 轻量目录访问协议     6) Message-oriented middleware (MOM) via JMS     7) Mail - SMTP(S), POP3(S) and IMAP(S)     8) TCP等等</p><h2 id="2、使用场景及优点"><a href="#2、使用场景及优点" class="headerlink" title="2、使用场景及优点"></a>2、使用场景及优点</h2><p>1）功能测试     </p><p>2）压力测试     </p><p>3）分布式压力测试     </p><p>4）纯java开发     </p><p>5）上手容易，高性能     </p><p>6）提供测试数据分析     </p><p>7）各种报表数据图形展示</p><h1 id="3-本地快速安装Jmeter4-x"><a href="#3-本地快速安装Jmeter4-x" class="headerlink" title="3. 本地快速安装Jmeter4.x"></a>3. 本地快速安装Jmeter4.x</h1><h2 id="1、需要安装JDK8。或者JDK9-JDK10-建议不要使用jre10"><a href="#1、需要安装JDK8。或者JDK9-JDK10-建议不要使用jre10" class="headerlink" title="1、需要安装JDK8。或者JDK9,JDK10 (建议不要使用jre10)"></a>1、需要安装JDK8。或者JDK9,JDK10 (建议不要使用jre10)</h2><h2 id="2、快速下载"><a href="#2、快速下载" class="headerlink" title="2、快速下载"></a>2、快速下载</h2><p>​    windows： <span class="exturl" data-url="aHR0cDovL21pcnJvcnMudHVuYS50c2luZ2h1YS5lZHUuY24vYXBhY2hlLy9qbWV0ZXIvYmluYXJpZXMvYXBhY2hlLWptZXRlci00LjAuemlw" title="http://mirrors.tuna.tsinghua.edu.cn/apache//jmeter/binaries/apache-jmeter-4.0.zip">http://mirrors.tuna.tsinghua.edu.cn/apache//jmeter/binaries/apache-jmeter-4.0.zip<i class="fa fa-external-link"></i></span>     </p><p>mac或者linux：<span class="exturl" data-url="aHR0cDovL21pcnJvcnMudHVuYS50c2luZ2h1YS5lZHUuY24vYXBhY2hlLy9qbWV0ZXIvYmluYXJpZXMvYXBhY2hlLWptZXRlci00LjAudGd6" title="http://mirrors.tuna.tsinghua.edu.cn/apache//jmeter/binaries/apache-jmeter-4.0.tgz">http://mirrors.tuna.tsinghua.edu.cn/apache//jmeter/binaries/apache-jmeter-4.0.tgz<i class="fa fa-external-link"></i></span></p><h2 id="3、文档地址：http-jmeter-apache-org-usermanual-get-started-html"><a href="#3、文档地址：http-jmeter-apache-org-usermanual-get-started-html" class="headerlink" title="3、文档地址：http://jmeter.apache.org/usermanual/get-started.html"></a>3、文档地址：<span class="exturl" data-url="aHR0cDovL2ptZXRlci5hcGFjaGUub3JnL3VzZXJtYW51YWwvZ2V0LXN0YXJ0ZWQuaHRtbA==" title="http://jmeter.apache.org/usermanual/get-started.html">http://jmeter.apache.org/usermanual/get-started.html<i class="fa fa-external-link"></i></span></h2><h2 id="4、建议安装JDK环境，虽然JRE也可以，但是压测https需要JDK里面的-keytool工具"><a href="#4、建议安装JDK环境，虽然JRE也可以，但是压测https需要JDK里面的-keytool工具" class="headerlink" title="4、建议安装JDK环境，虽然JRE也可以，但是压测https需要JDK里面的 keytool工具"></a>4、建议安装JDK环境，虽然JRE也可以，但是压测https需要JDK里面的 keytool工具</h2><h1 id="4-jemeter-目录结构"><a href="#4-jemeter-目录结构" class="headerlink" title="4. jemeter 目录结构"></a>4. jemeter 目录结构</h1><h2 id="bin-核心可执行文件，包含配置"><a href="#bin-核心可执行文件，包含配置" class="headerlink" title="bin:核心可执行文件，包含配置"></a>bin:核心可执行文件，包含配置</h2><p>jmeter.bat: windows启动文件：     </p><p>jmeter: mac或者linux启动文件：     </p><p>jmeter-server：mac或者Liunx分布式压测使用的启动文件  </p><p>jmeter-server.bat：mac或者Liunx分布式压测使用的启动文件     </p><p>jmeter.properties: 核心配置文件 </p><h2 id="extras：插件拓展的包"><a href="#extras：插件拓展的包" class="headerlink" title="extras：插件拓展的包"></a>extras：插件拓展的包</h2><p>lib:核心的依赖包     </p><p>ext:核心包     </p><p>junit:单元测试包</p><h1 id="5-改变jmeter的GUI界面语言版本"><a href="#5-改变jmeter的GUI界面语言版本" class="headerlink" title="5. 改变jmeter的GUI界面语言版本"></a>5. 改变jmeter的GUI界面语言版本</h1><h2 id="1、控制台修改"><a href="#1、控制台修改" class="headerlink" title="1、控制台修改"></a>1、控制台修改</h2><p>​    <code>menu -&gt; options -&gt; choose language</code></p><h2 id="2、配置文件修改"><a href="#2、配置文件修改" class="headerlink" title="2、配置文件修改"></a>2、配置文件修改</h2><p>​    <code>bin目录 -&gt; jmeter.properties     默认 #language=en     改为 language=zh_CN</code></p><h1 id="6-jemeter-菜单介绍"><a href="#6-jemeter-菜单介绍" class="headerlink" title="6. jemeter 菜单介绍"></a>6. jemeter 菜单介绍</h1><h2 id="1、添加-gt-threads-gt-线程组（控制总体并发）"><a href="#1、添加-gt-threads-gt-线程组（控制总体并发）" class="headerlink" title="1、添加-&gt;threads-&gt;线程组（控制总体并发）"></a>1、添加-&gt;threads-&gt;线程组（控制总体并发）</h2><ul><li>线程数：虚拟用户数。一个虚拟用户占用一个进程或线程</li><li>准备时长（Ramp-Up Period(in seconds)）：全部线程启动的时长，比如100个线程，20秒，则表示20秒内100个线程都要启动完成，每秒启动5个线程</li><li>循环次数：每个线程发送的次数，假如值为5，100个线程，则会发送500次请求，可以勾选永远循环</li></ul><h2 id="2、线程组-gt-添加-gt-Sampler-采样器-gt-Http-（一个线程组下面可以增加几个Sampler）"><a href="#2、线程组-gt-添加-gt-Sampler-采样器-gt-Http-（一个线程组下面可以增加几个Sampler）" class="headerlink" title="2、线程组-&gt;添加-&gt; Sampler(采样器) -&gt; Http （一个线程组下面可以增加几个Sampler）"></a>2、线程组-&gt;添加-&gt; Sampler(采样器) -&gt; Http （一个线程组下面可以增加几个Sampler）</h2><ul><li>名称：采样器名称</li><li>注释：对这个采样器的描述</li><li>web服务器：<ul><li>默认协议是http</li><li>默认端口是80</li><li>服务器名称或IP ：请求的目标服务器名称或IP地址</li></ul></li><li>路径：服务器URL</li><li><strong>Use multipart/from-data for HTTP POST</strong> ：当发送POST请求时，使用Use multipart/from-data方法发送，默认不选中。</li></ul><h2 id="3、查看测试结果"><a href="#3、查看测试结果" class="headerlink" title="3、查看测试结果"></a>3、查看测试结果</h2><h3 id="线程组-gt-添加-gt-监听器-gt-察看结果树"><a href="#线程组-gt-添加-gt-监听器-gt-察看结果树" class="headerlink" title="线程组-&gt;添加-&gt;监听器-&gt;察看结果树"></a>线程组-&gt;添加-&gt;监听器-&gt;察看结果树</h3><h1 id="7-断言的基本使用"><a href="#7-断言的基本使用" class="headerlink" title="7. 断言的基本使用"></a>7. 断言的基本使用</h1><h2 id="1-增加断言-线程组-gt-添加-gt-断言-gt-响应断言"><a href="#1-增加断言-线程组-gt-添加-gt-断言-gt-响应断言" class="headerlink" title="1. 增加断言: 线程组 -&gt; 添加 -&gt; 断言 -&gt; 响应断言"></a>1. 增加断言: 线程组 -&gt; 添加 -&gt; 断言 -&gt; 响应断言</h2><p>apply to(应用范围):     Main sample only: 仅当前父取样器 进行断言，一般一个请求，如果发一个请求会触发多个，则就有sub sample（比较少用）</p><h2 id="2-要测试的响应字段："><a href="#2-要测试的响应字段：" class="headerlink" title="2.要测试的响应字段："></a>2.要测试的响应字段：</h2><ul><li>响应文本：即响应的数据，比如json等文本</li><li>响应代码：http的响应状态码，比如200，302，404这些</li><li>响应信息：http响应代码对应的响应信息，例如：OK, Found</li><li>Response Header: 响应头</li></ul><h2 id="3-模式匹配规则："><a href="#3-模式匹配规则：" class="headerlink" title="3.模式匹配规则："></a>3.模式匹配规则：</h2><ul><li>包括：包含在里面就成功</li><li>匹配：响应内容完全匹配，不区分大小写</li><li>equals：完全匹配，区分大小写</li></ul><h2 id="4-断言结果监听器-线程组-gt-添加-gt-监听器-gt-断言结果"><a href="#4-断言结果监听器-线程组-gt-添加-gt-监听器-gt-断言结果" class="headerlink" title="4.断言结果监听器: 线程组-&gt; 添加 -&gt; 监听器 -&gt; 断言结果"></a>4.断言结果监听器: 线程组-&gt; 添加 -&gt; 监听器 -&gt; 断言结果</h2><p>里面的内容是sampler采样器的名称     断言失败，查看结果树任务结果颜色标红(通过结果数里面双击不通过的记录，可以看到错误信息)</p><h2 id="5-每个sample下面可以加单独的结果树，然后同时加多个断言，最外层可以加个结果树进行汇总"><a href="#5-每个sample下面可以加单独的结果树，然后同时加多个断言，最外层可以加个结果树进行汇总" class="headerlink" title="5.每个sample下面可以加单独的结果树，然后同时加多个断言，最外层可以加个结果树进行汇总"></a>5.每个sample下面可以加单独的结果树，然后同时加多个断言，最外层可以加个结果树进行汇总</h2><h1 id="8-Jmeter压测结果聚合报告分析"><a href="#8-Jmeter压测结果聚合报告分析" class="headerlink" title="8. Jmeter压测结果聚合报告分析"></a>8. Jmeter压测结果聚合报告分析</h1><h2 id="1-新增聚合报告：线程组-gt-添加-gt-监听器-gt-聚合报告（Aggregate-Report）"><a href="#1-新增聚合报告：线程组-gt-添加-gt-监听器-gt-聚合报告（Aggregate-Report）" class="headerlink" title="1.新增聚合报告：线程组-&gt;添加-&gt;监听器-&gt;聚合报告（Aggregate Report）"></a>1.新增聚合报告：线程组-&gt;添加-&gt;监听器-&gt;聚合报告（Aggregate Report）</h2><ul><li>lable: sampler的名称</li><li>Samples: 一共发出去多少请求,例如10个用户，循环10次，则是 100</li><li>Average: 平均响应时间</li><li>Median: 中位数，也就是 50％ 用户的响应时间</li><li>90% Line : 90％ 用户的响应不会超过该时间 （90% of the samples took no more than this time. The remaining samples at least as long as this）</li><li>95% Line : 95％ 用户的响应不会超过该时间</li><li>99% Line : 99％ 用户的响应不会超过该时间</li><li>min : 最小响应时间</li><li>max : 最大响应时间</li><li>Error%：错误的请求的数量/请求的总数</li><li><strong>Throughput： 吞吐量——默认情况下表示每秒完成的请求数（Request per Second) 可类比为qps     KB/Sec: 每秒接收数据量</strong></li></ul><h2 id="2-为什么使用：很多变量在全局中都有使用，或者测试数据更改，可以在一处定义，四处使用-比如服务器地址"><a href="#2-为什么使用：很多变量在全局中都有使用，或者测试数据更改，可以在一处定义，四处使用-比如服务器地址" class="headerlink" title="2.为什么使用：很多变量在全局中都有使用，或者测试数据更改，可以在一处定义，四处使用(比如服务器地址)"></a>2.为什么使用：很多变量在全局中都有使用，或者测试数据更改，可以在一处定义，四处使用(比如服务器地址)</h2><h3 id="1、线程组-gt-add-gt-Config-Element-配置原件-gt-User-Definde-Variable（用户定义的变量）"><a href="#1、线程组-gt-add-gt-Config-Element-配置原件-gt-User-Definde-Variable（用户定义的变量）" class="headerlink" title="1、线程组-&gt;add -&gt; Config Element(配置原件)-&gt; User Definde Variable（用户定义的变量）"></a>1、线程组-&gt;add -&gt; Config Element(配置原件)-&gt; User Definde Variable（用户定义的变量）</h3><h3 id="2、引用方式-XXX-，在接口中变量中使用"><a href="#2、引用方式-XXX-，在接口中变量中使用" class="headerlink" title="2、引用方式${XXX}，在接口中变量中使用"></a>2、引用方式${XXX}，在接口中变量中使用</h3><h3 id="3、原始查看结果树和非原生查看（基础按钮）"><a href="#3、原始查看结果树和非原生查看（基础按钮）" class="headerlink" title="3、原始查看结果树和非原生查看（基础按钮）"></a>3、原始查看结果树和非原生查看（基础按钮）</h3><h1 id="9-CSV可变参数压测（重要）"><a href="#9-CSV可变参数压测（重要）" class="headerlink" title="9. CSV可变参数压测（重要）"></a>9. CSV可变参数压测（重要）</h1><p><strong>实战操作jmeter读取CSV和Txt文本文件里面的参数进行压测</strong></p><h2 id="1、线程组-gt-add-gt-Config-Element-配置原件-gt-CSV-data-set-config-CSV数据文件设置"><a href="#1、线程组-gt-add-gt-Config-Element-配置原件-gt-CSV-data-set-config-CSV数据文件设置" class="headerlink" title="1、线程组-&gt;add -&gt; Config Element(配置原件)-&gt; CSV data set config (CSV数据文件设置)"></a>1、线程组-&gt;add -&gt; Config Element(配置原件)-&gt; CSV data set config (CSV数据文件设置)</h2><h2 id="2、在读取的配置文件里面，同时使用多个自定义参数"><a href="#2、在读取的配置文件里面，同时使用多个自定义参数" class="headerlink" title="2、在读取的配置文件里面，同时使用多个自定义参数"></a>2、在读取的配置文件里面，同时使用多个自定义参数</h2><p>如果是多个参数需要同时引用，则在CSV数据文件里面设置加多个字段 Variabled names(comma-delitited): csv_name,csv_pwd</p><h1 id="10、JDBC-request压测Mysql"><a href="#10、JDBC-request压测Mysql" class="headerlink" title="10、JDBC request压测Mysql"></a>10、JDBC request压测Mysql</h1><h2 id="1、Thread-Group-gt-add-gt-sampler-gt-jdbc-request"><a href="#1、Thread-Group-gt-add-gt-sampler-gt-jdbc-request" class="headerlink" title="1、Thread Group -&gt; add -&gt; sampler -&gt; jdbc request"></a>1、Thread Group -&gt; add -&gt; sampler -&gt; jdbc request</h2><h2 id="2、jar包添加-mysql-connector-java-5-1-30-jar"><a href="#2、jar包添加-mysql-connector-java-5-1-30-jar" class="headerlink" title="2、jar包添加 mysql-connector-java-5.1.30.jar"></a>2、jar包添加 mysql-connector-java-5.1.30.jar</h2><h2 id="3、JDBC-connection-Configuration-配置"><a href="#3、JDBC-connection-Configuration-配置" class="headerlink" title="3、JDBC connection Configuration 配置"></a>3、JDBC connection Configuration 配置</h2><p><strong>JDBC request-&gt;add -&gt; config element -&gt; JDBC connection configuration</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">核心配置</span><br><span class="line">Max Number of connections : 最大连接数</span><br><span class="line">MAX wait :最大等待时间</span><br><span class="line">Auto Commit: 是否自动提交事务</span><br><span class="line"></span><br><span class="line">DataBase URL : 数据库连接地址 jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;blog</span><br><span class="line">JDBC Driver Class : 数据库驱动，选择对应的mysql</span><br><span class="line">username:数据库用户名</span><br><span class="line">password:数据库密码</span><br></pre></td></tr></table></figure><h1 id="11-request压测Mysql-select语句"><a href="#11-request压测Mysql-select语句" class="headerlink" title="11. request压测Mysql, select语句"></a>11. request压测Mysql, select语句</h1><ul><li>个人测试1</li></ul><p>\</p><ul><li>个人测试2<ul><li>注意：需要添加一个全局的debug采集器采集查询结果</li><li>可以看到如图所示结果</li></ul></li></ul><h2 id="1-Debug-Sampler使用（结果树中查看）"><a href="#1-Debug-Sampler使用（结果树中查看）" class="headerlink" title="1. Debug Sampler使用（结果树中查看）"></a>1. Debug Sampler使用（结果树中查看）</h2><p>​    Thread Group -&gt; add -&gt; sampler -&gt; debug sampler</p><h2 id="2-参数讲解：-sql结尾不要加”-”"><a href="#2-参数讲解：-sql结尾不要加”-”" class="headerlink" title="2. 参数讲解：(sql结尾不要加”;”)"></a>2. 参数讲解：(sql结尾不要加”;”)</h2><ul><li>variable name of pool declared in JDBC connection configuration（和配置文件同名）</li><li>Query Type 查询类型</li><li>parameter values 参数值</li><li>parameter types 参数类型</li><li>variable names sql执行结果变量名</li><li>result variable names 所有结果当做一个对象存储</li><li>query timeouts 查询超时时间</li><li>handle results 处理结果集</li></ul><h1 id="12-分布式压测（学习重点）"><a href="#12-分布式压测（学习重点）" class="headerlink" title="12. 分布式压测（学习重点）"></a>12. 分布式压测（学习重点）</h1><p>官网教程： <span class="exturl" data-url="aHR0cDovL2ptZXRlci5hcGFjaGUub3JnL3VzZXJtYW51YWwvam1ldGVyX2Rpc3RyaWJ1dGVkX3Rlc3Rpbmdfc3RlcF9ieV9zdGVwLmh0bWw=" title="http://jmeter.apache.org/usermanual/jmeter_distributed_testing_step_by_step.html">http://jmeter.apache.org/usermanual/jmeter_distributed_testing_step_by_step.html<i class="fa fa-external-link"></i></span></p><ul><li>普通压测：单台机可以对目标机器产生的压力比较小，受限因素包括CPU，网络，IO等</li><li>分布式压测：利用多台机器向目标机器产生压力，模拟几万用户并发访问</li></ul><h1 id="13-Jmeter分布式压测原理-了解"><a href="#13-Jmeter分布式压测原理-了解" class="headerlink" title="13. Jmeter分布式压测原理(了解)"></a>13. Jmeter分布式压测原理(了解)</h1><p>1、总控机器的节点master，其他产生压力的机器叫“肉鸡” server</p><p>2、master会把压测脚本发送到 server上面</p><p>3、执行的时候，server上只需要把jmeter-server打开就可以了，不用启动jmeter</p><p>4、结束后，server会把压测数据回传给master,然后master汇总输出报告</p><p>5、配置详情</p><h1 id="14-阿里云安装jmeter-守护进程：nohup-java-jar-xxxxx-amp"><a href="#14-阿里云安装jmeter-守护进程：nohup-java-jar-xxxxx-amp" class="headerlink" title="14. 阿里云安装jmeter (守护进程：nohup java -jar xxxxx &amp;)"></a>14. 阿里云安装jmeter (守护进程：nohup java -jar xxxxx &amp;)</h1><h2 id="1-下载方式：wget-http-apache-osuosl-org-jmeter-binaries-apache-jmeter-4-0-tgz"><a href="#1-下载方式：wget-http-apache-osuosl-org-jmeter-binaries-apache-jmeter-4-0-tgz" class="headerlink" title="1. 下载方式：wget http://apache.osuosl.org//jmeter/binaries/apache-jmeter-4.0.tgz"></a>1. 下载方式：wget <span class="exturl" data-url="aHR0cDovL2FwYWNoZS5vc3Vvc2wub3JnLy9qbWV0ZXIvYmluYXJpZXMvYXBhY2hlLWptZXRlci00LjAudGd6" title="http://apache.osuosl.org//jmeter/binaries/apache-jmeter-4.0.tgz">http://apache.osuosl.org//jmeter/binaries/apache-jmeter-4.0.tgz<i class="fa fa-external-link"></i></span></h2><h2 id="2-直接到官网下载对应tag-gz包，并在服务器解压"><a href="#2-直接到官网下载对应tag-gz包，并在服务器解压" class="headerlink" title="2. 直接到官网下载对应tag.gz包，并在服务器解压"></a>2. 直接到官网下载对应tag.gz包，并在服务器解压</h2><h1 id="15-Jmeter非GUI界面-参数讲解-必须掌握"><a href="#15-Jmeter非GUI界面-参数讲解-必须掌握" class="headerlink" title="15. Jmeter非GUI界面 参数讲解(必须掌握)"></a>15. Jmeter非GUI界面 参数讲解(必须掌握)</h1><p>官方配置文件地址： <span class="exturl" data-url="aHR0cDovL2ptZXRlci5hcGFjaGUub3JnL3VzZXJtYW51YWwvZ2V0LXN0YXJ0ZWQuaHRtbA==" title="http://jmeter.apache.org/usermanual/get-started.html">http://jmeter.apache.org/usermanual/get-started.html<i class="fa fa-external-link"></i></span></p><ul><li><strong>-h</strong> 帮助</li><li><strong>-n</strong> 非GUI模式</li><li><strong>-t</strong> 指定要运行的 JMeter 测试脚本文件</li><li><strong>-l</strong> 记录结果的文件 每次运行之前，(要确保之前没有运行过,即xxx.jtl不存在，不然报错)</li><li><strong>-r</strong> Jmter.properties文件中指定的所有远程服务器</li><li><strong>-e</strong> 在脚本运行结束后生成html报告</li><li><strong>-o</strong> 用于存放html报告的目录（目录要为空，不然报错）</li></ul><p>jmeter -n -t linux_users_api.jmx -l result.jtl -e -o /usr/local/softwate/jmeter/temp/ResultReport</p><p>jmeter -n -t /Users/jack/Desktop/linux_users_api.jmx -l result.jtl -e -o /Users/jack/Desktop/person/jmeter/temp</p><p>个人： /usr/local/software/jmeter/project/temp 。。。。</p><h2 id="1-阿里云非GUI-jmeter-压测"><a href="#1-阿里云非GUI-jmeter-压测" class="headerlink" title="1.阿里云非GUI jmeter 压测"></a>1.阿里云非GUI jmeter 压测</h2><p>jmx目录：/usr/local/software/jmeter/temp</p><p>示例</p><p>jmeter -n -t /usr/local/software/jmeter/temp/linux_users_api.jmx -l /usr/local/software/jmeter/temp/jtl/result.jtl</p><p>利用软件从阿里云Centos服务器下载压测报告，讲解Jtl文件，并怎么查看文件 可以通过打开jmeter，新建线程组-&gt;summary report-&gt;浏览文件 进行查看</p><h2 id="2-讲解Jmeter压测减少资源使用的一些建议，即压测结果更准确"><a href="#2-讲解Jmeter压测减少资源使用的一些建议，即压测结果更准确" class="headerlink" title="2.讲解Jmeter压测减少资源使用的一些建议，即压测结果更准确"></a>2.讲解Jmeter压测减少资源使用的一些建议，即压测结果更准确</h2><p>1、使用非GUI模式：jmeter -n -t test.jmx -l result.jtl</p><p>2、少使用Listener， 如果使用-l参数，它们都可以被删除或禁用。</p><p>3、在加载测试期间不要使用“查看结果树”或“查看结果”表监听器，只能在脚本阶段使用它们来调试脚本。</p><p>4、包含控制器在这里没有帮助，因为它将文件中的所有测试元素添加到测试计划中。]</p><p>5、不要使用功能模式,使用CSV输出而不是XML</p><p>6、只保存你需要的数据,尽可能少地使用断言</p><p>7、如果测试需要大量数据，可以提前准备好测试数据放到数据文件中，以CSV Read方式读取。</p><p>8、用内网压测，减少其他带宽影响压测结果</p><p>9、如果压测大流量，尽量用多几个节点以非GUI模式向服务器施压</p><p>官方推荐 ：<span class="exturl" data-url="aHR0cDovL2pha2FydGEuYXBhY2hlLm9yZy9qbWV0ZXIvdXNlcm1hbnVhbC9iZXN0LXByYWN0aWNlcy5odG1sI2xlYW5fbWVhbg==" title="http://jakarta.apache.org/jmeter/usermanual/best-practices.html#lean_mean">http://jakarta.apache.org/jmeter/usermanual/best-practices.html#lean_mean<i class="fa fa-external-link"></i></span></p><h2 id="3-把Jmtere压测结果转换为Html"><a href="#3-把Jmtere压测结果转换为Html" class="headerlink" title="3. 把Jmtere压测结果转换为Html"></a>3. 把Jmtere压测结果转换为Html</h2><p>jmeter -n -t /usr/local/software/jmeter/temp/linux_users_api.jmx -l /usr/local/software/jmeter/temp/jtl/result.jtl -e -o /usr/local/software/jmeter/temp/result讲解压测报告 html里面Dashboard的核心指标</p><h3 id="1、dashboard讲解"><a href="#1、dashboard讲解" class="headerlink" title="1、dashboard讲解"></a>1、dashboard讲解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1）Test and Report informations</span><br><span class="line">Source file：jtl文件名</span><br><span class="line">Start Time ：压测开始时间</span><br><span class="line">End Time ：压测结束时间</span><br><span class="line">Filter for display：过滤器</span><br><span class="line">Lable:sampler采样器名称</span><br><span class="line"></span><br><span class="line">2）APDEX(Application performance Index)</span><br><span class="line">apdex:应用程序性能指标,范围在0~1之间，1表示达到所有用户均满意</span><br><span class="line">T(Toleration threshold)：可接受阀值</span><br><span class="line">F(Frustration threshold)：失败阀值</span><br><span class="line"></span><br><span class="line">3）Requests Summary</span><br><span class="line">OK:成功率</span><br><span class="line">KO:失败率</span><br><span class="line">4）Statistics 统计数据</span><br><span class="line">lable:sampler采样器名称</span><br><span class="line"></span><br><span class="line">samples:请求总数，并发数*循环次数</span><br><span class="line">KO:失败次数</span><br><span class="line">Error%:失败率</span><br><span class="line"></span><br><span class="line">Average:平均响应时间</span><br><span class="line">Min:最小响应时间</span><br><span class="line">Max:最大响应时间</span><br><span class="line">90th pct: 90%的用户响应时间不会超过这个值（关注这个就可以了）</span><br><span class="line">2ms,3ms,4,5,2,6,8,3,9</span><br><span class="line"></span><br><span class="line">95th pct: 95%的用户响应时间不会超过这个值</span><br><span class="line">99th pct: 99%的用户响应时间不会超过这个值 (存在极端值)</span><br><span class="line">throughtput:Request per Second吞吐量 qps</span><br><span class="line"></span><br><span class="line">received:每秒从服务器接收的数据量</span><br><span class="line">send：每秒发送的数据量</span><br></pre></td></tr></table></figure><h3 id="2、charts讲解"><a href="#2、charts讲解" class="headerlink" title="2、charts讲解"></a>2、charts讲解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1)Over Time（随着时间的变化）</span><br><span class="line">Response Times Over Time：响应时间变化趋势</span><br><span class="line">Response Time Percentiles Over Time (successful responses)：最大，最小，平均，用户响应时间分布</span><br><span class="line">Active Threads Over Time：并发用户数趋势</span><br><span class="line">Bytes Throughput Over Time：每秒接收和请求字节数变化，蓝色表示发送，黄色表示接受</span><br><span class="line">Latencies Over Time：平均响应延时趋势</span><br><span class="line">Connect Time Over Time：连接耗时趋势</span><br><span class="line"></span><br><span class="line">1)Throughput</span><br><span class="line">Hits Per Second (excluding embedded resources):每秒点击次数</span><br><span class="line">Codes Per Second (excluding embedded resources)：每秒状态码数量</span><br><span class="line">Transactions Per Second：即TPS，每秒事务数</span><br><span class="line">Response Time Vs Request：响应时间和请求数对比</span><br><span class="line">Latency Vs Request：延迟时间和请求数对比</span><br><span class="line"></span><br><span class="line">1)Response Times</span><br><span class="line">Response Time Percentiles：响应时间百分比</span><br><span class="line">Response Time Overview：响应时间概述</span><br><span class="line">Time Vs Threads：活跃线程数和响应时间</span><br><span class="line">Response Time Distribution：响应时间分布图</span><br></pre></td></tr></table></figure><h1 id="16、Linux服务器上jmeter进行分布式压测"><a href="#16、Linux服务器上jmeter进行分布式压测" class="headerlink" title="16、Linux服务器上jmeter进行分布式压测"></a>16、Linux服务器上jmeter进行分布式压测</h1><h2 id="1、压测注意事项"><a href="#1、压测注意事项" class="headerlink" title="1、压测注意事项"></a>1、压测注意事项</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">the firewalls on the systems are turned off or correct ports are opened.</span><br><span class="line">系统上的防火墙被关闭或正确的端口被打开。</span><br><span class="line"></span><br><span class="line">all the clients are on the same subnet.</span><br><span class="line">所有的客户端都在同一个子网上。</span><br><span class="line"></span><br><span class="line">the server is in the same subnet, if 192.x.x.x or 10.x.x.x IP addresses are used. If the server doesn&#39;t use 192.xx or 10.xx IP address, there shouldn&#39;t be any problems.</span><br><span class="line">如果使用192.x.x.x或10.x.x.x IP地址，则服务器位于同一子网中。 如果服务器不使用192.xx或10.xx IP地址，则不应该有任何问题。</span><br><span class="line"></span><br><span class="line">Make sure JMeter can access the server.</span><br><span class="line">确保JMeter可以访问服务器。</span><br><span class="line"></span><br><span class="line">Make sure you use the same version of JMeter and Java on all the systems. Mixing versions will not work correctly.</span><br><span class="line">确保在所有系统上使用相同版本的JMeter和Java。 混合版本将无法正常工作。</span><br><span class="line"></span><br><span class="line">You have setup SSL for RMI or disabled it.</span><br><span class="line">您已为RMI设置SSL或将其禁用。</span><br><span class="line"></span><br><span class="line">官网地址 http:&#x2F;&#x2F;jmeter.apache.org&#x2F;usermanual&#x2F;jmeter_distributed_testing_step_by_step.html</span><br><span class="line"></span><br><span class="line">压测注意事项：一定要用内网IP，不用用公网IP,用ping去检查</span><br></pre></td></tr></table></figure><h2 id="2、专业名字"><a href="#2、专业名字" class="headerlink" title="2、专业名字"></a>2、专业名字</h2><p>master:司令 slave：</p><p>奴隶 target：目标</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>地址：<span class="exturl" data-url="aHR0cDovL2ptZXRlci5hcGFjaGUub3JnL2ltYWdlcy9zY3JlZW5zaG90cy9kaXN0cmlidXRlZC1uYW1lcy5zdmc=" title="http://jmeter.apache.org/images/screenshots/distributed-names.svg">http://jmeter.apache.org/images/screenshots/distributed-names.svg<i class="fa fa-external-link"></i></span> </p><p>地址：<span class="exturl" data-url="aHR0cDovL2ptZXRlci5hcGFjaGUub3JnL2ltYWdlcy9zY3JlZW5zaG90cy9kaXN0cmlidXRlZC1qbWV0ZXIuc3Zn" title="http://jmeter.apache.org/images/screenshots/distributed-jmeter.svg">http://jmeter.apache.org/images/screenshots/distributed-jmeter.svg<i class="fa fa-external-link"></i></span></p><h2 id="3、远程拷贝-内网地址-："><a href="#3、远程拷贝-内网地址-：" class="headerlink" title="3、远程拷贝(内网地址)："></a>3、远程拷贝(内网地址)：</h2><p>scp -r /usr/local/software/jdk-8u141-linux-x64.tar.gz <span class="exturl" data-url="aHR0cDovL21haWx0bzpyb290QDE3Mi4xOC4yMzAuMjMz" title="http://mailto:root@172.18.230.233">root@172.18.230.233<i class="fa fa-external-link"></i></span>:/usr/local/software</p><p>scp -r /usr/local/software/jmeter/apache-jmeter-4.0.tgz <span class="exturl" data-url="aHR0cDovL21haWx0bzpyb290QDE3Mi4xOC4yMzAuMjMz" title="http://mailto:root@172.18.230.233">root@172.18.230.233<i class="fa fa-external-link"></i></span>:/usr/local/software/jmeter</p><h2 id="4、启动"><a href="#4、启动" class="headerlink" title="4、启动"></a>4、启动</h2><p>./jmeter-server 或者 nohup ./jmeter-server &amp;</p><h2 id="5、检查启动是否成功"><a href="#5、检查启动是否成功" class="headerlink" title="5、检查启动是否成功"></a>5、检查启动是否成功</h2><p>ps -ef|grep jmeter-server</p><p>ps aux|grep jmeter-server</p><h1 id="17、Jmeter分布式压测"><a href="#17、Jmeter分布式压测" class="headerlink" title="17、Jmeter分布式压测"></a>17、Jmeter分布式压测</h1><h2 id="本地非GUI分布式压测-r"><a href="#本地非GUI分布式压测-r" class="headerlink" title="本地非GUI分布式压测 -r"></a>本地非GUI分布式压测 -r</h2><p>jmeter -n -t /Users/jack/Desktop/remote.jmx -r -l /Users/jack/Desktop/jtl/result.jtl -e -o /Users/jack/Desktop/result</p><h2 id="压测结果"><a href="#压测结果" class="headerlink" title="压测结果"></a>压测结果</h2><p>./jmeter -n -t /Users/jack/Desktop/remote.jmx -r -l /Users/jack/Desktop/jtl/result.jtl -e -o /Users/jack/Desktop/result</p><h2 id="压测报告"><a href="#压测报告" class="headerlink" title="压测报告"></a>压测报告</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Creating summariser &lt;summary&gt;</span><br><span class="line">Created the tree successfully using &#x2F;Users&#x2F;jack&#x2F;Desktop&#x2F;remote.jmx</span><br><span class="line">Configuring remote engine: 172.20.10.3:8899</span><br><span class="line">Using local port: 8899</span><br><span class="line">Configuring remote engine: 172.20.10.11:8899</span><br><span class="line">Starting remote engines</span><br><span class="line">Starting the test @ Thu Mar 29 23:21:13 CST 2018 (1522336873931)</span><br><span class="line">Remote engines have been started</span><br><span class="line">Waiting for possible Shutdown&#x2F;StopTestNow&#x2F;Heapdump message on port 4445</span><br><span class="line">summary &#x3D;      4 in 00:00:22 &#x3D;    0.2&#x2F;s Avg:  5582 Min:    94 Max: 21006 Err:     1 (25.00%)</span><br><span class="line">Tidying up remote @ Thu Mar 29 23:21:36 CST 2018 (1522336896842)</span><br><span class="line">... end of run</span><br></pre></td></tr></table></figure><h2 id="压测修改master节点信息"><a href="#压测修改master节点信息" class="headerlink" title="压测修改master节点信息"></a>压测修改master节点信息</h2><p>jemeter.properties 值是slave机器的ip+端口号，如果有多个，用逗号分隔 remote_hosts=192.168.0.102:8899,192.168.0.101:8899 server.rmi.ssl.disable=true (前面有说到)</p><h2 id="启动slave机器，注意要同个网段，ip地址用内网ip"><a href="#启动slave机器，注意要同个网段，ip地址用内网ip" class="headerlink" title="启动slave机器，注意要同个网段，ip地址用内网ip"></a>启动slave机器，注意要同个网段，ip地址用内网ip</h2><p>./jmeter-server Using local port: 8899 Created remote object: UnicastServerRef2 [liveRef: [endpoint:<span class="exturl" data-url="aHR0cDovL2xvY2Fs" title="http://local">192.168.0.102:8899<i class="fa fa-external-link"></i></span>,objID:[3a585a4d:162724586ab:-7fff, 3963132813614033916]]]</p><h2 id="相关资料："><a href="#相关资料：" class="headerlink" title="相关资料："></a>相关资料：</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vRmluZS1DaGFuL3AvNjIzMzgyMy5odG1s" title="https://www.cnblogs.com/Fine-Chan/p/6233823.html">https://www.cnblogs.com/Fine-Chan/p/6233823.html<i class="fa fa-external-link"></i></span> <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdWppbmdxaXUvYXJ0aWNsZS9kZXRhaWxzLzUyNjM1Mjg5aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vcHVyZXNvdWwvcC80ODQ0NTM5Lmh0bWw=" title="https://blog.csdn.net/liujingqiu/article/details/52635289https://www.cnblogs.com/puresoul/p/4844539.html">https://blog.csdn.net/liujingqiu/article/details/52635289https://www.cnblogs.com/puresoul/p/4844539.html<i class="fa fa-external-link"></i></span></p><h1 id="18-、测试基本内容"><a href="#18-、测试基本内容" class="headerlink" title="18.、测试基本内容"></a>18.、测试基本内容</h1><p><strong>配置元件=》前置处理器=》定时器=》采样器=》后置处理器=》断言=》监听器</strong></p><h1 id="19、安装常见问题"><a href="#19、安装常见问题" class="headerlink" title="19、安装常见问题"></a>19、安装常见问题</h1><h2 id="1、问题：无法解析"><a href="#1、问题：无法解析" class="headerlink" title="1、问题：无法解析"></a>1、问题：无法解析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz95j86y235aroi85ht0Z bin]# .&#x2F;jmeter-server</span><br><span class="line">Created remote object: UnicastServerRef2 [liveRef: [endpoint:[:39308](local),objID:[24e78a63:16243c70661:-7fff, 7492480871343944173]]]</span><br><span class="line">Server failed to start: java.rmi.RemoteException: Cannot start. Unable to get local host IP address.; nested exception is:</span><br><span class="line">java.net.UnknownHostException: iZwz95j86y235aroi85ht0Z: iZwz95j86y235aroi85ht0Z: Name or service not known</span><br><span class="line">An error occurred: Cannot start. Unable to get local host IP address.; nested exception is:</span><br><span class="line">java.net.UnknownHostException: iZwz95j86y235aroi85ht0Z: iZwz95j86y235aroi85ht0Z: Name or service not known</span><br></pre></td></tr></table></figure><h3 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hostname  命令获取机器名称，追加一个映射  iZwz95j86y235aroi85ht0Z</span><br><span class="line">vim &#x2F;etc&#x2F;hosts</span><br><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line">120.79.160.143 iZwz95j86y235aroi85ht0Z</span><br><span class="line"></span><br><span class="line">windows用户 修改c:\windows\system32\drivers\etc\hosts文件，增加一条域名 与IP的映射</span><br></pre></td></tr></table></figure><h2 id="2-问题：禁用了SSL"><a href="#2-问题：禁用了SSL" class="headerlink" title="2.问题：禁用了SSL"></a>2.问题：禁用了SSL</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz95j86y235aroi85ht0Z bin]# .&#x2F;jmeter-server</span><br><span class="line">Server failed to start: java.rmi.server.ExportException: Listen failed on port: 0; nested exception is:</span><br><span class="line">java.io.FileNotFoundException: rmi_keystore.jks (No such file or directory)</span><br><span class="line">An error occurred: Listen failed on port: 0; nested exception is:</span><br><span class="line">java.io.FileNotFoundException: rmi_keystore.jks (No such file or directory)</span><br></pre></td></tr></table></figure><h3 id="解决：-1"><a href="#解决：-1" class="headerlink" title="解决："></a>解决：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">拥有RMI over SSL的有效密钥库，或者禁用了SSL。</span><br><span class="line">1、禁用SSL</span><br><span class="line">  jmeter.property里面 server.rmi.ssl.disable 改为 true，表示禁用</span><br></pre></td></tr></table></figure><h2 id="3、问题："><a href="#3、问题：" class="headerlink" title="3、问题："></a>3、问题：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ949uw2xehZ bin]# .&#x2F;jmeter</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: INFO: os::commit_memory(0x00000000c0000000, 1073741824, 0) failed; error&#x3D;&#39;Cannot allocate memory&#39; (errno&#x3D;12)</span><br><span class="line">#</span><br><span class="line"># There is insufficient memory for the Java Runtime Environment to continue.</span><br><span class="line"># Native memory allocation (mmap) failed to map 1073741824 bytes for committing reserved memory.</span><br><span class="line"># An error report file with more information is saved as:</span><br><span class="line"># &#x2F;usr&#x2F;local&#x2F;jmeter&#x2F;apache-jmeter-4.0&#x2F;bin&#x2F;hs_err_pid5855.log</span><br></pre></td></tr></table></figure><h3 id="解决：-2"><a href="#解决：-2" class="headerlink" title="解决："></a>解决：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">编辑jmeter</span><br><span class="line">搜索 : &quot;$&#123;HEAP:&#x3D;&quot;-Xms1g -Xmx1g -XX:MaxMetaspaceSize&#x3D;256m&quot;&#125;&quot;</span><br><span class="line">改变初始堆内存和最大堆内存</span><br></pre></td></tr></table></figure><h2 id="4、仅修改-server-port-即可-下面两者一样"><a href="#4、仅修改-server-port-即可-下面两者一样" class="headerlink" title="4、仅修改 server_port 即可,下面两者一样"></a>4、仅修改 server_port 即可,下面两者一样</h2><p>server.rmi.localport=8899 表示slave server启动显示的端口</p><p>server_port=8899 表示master机器要远程连接的端口 即 remote_hosts=xxxx:8899</p><h2 id="5、—–"><a href="#5、—–" class="headerlink" title="5、—–"></a>5、—–</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- jmeter 分布式性能测试（多网卡配置） --&gt;</span><br><span class="line">我们要在多网卡的服务器上开启RMI服务的话必须指定IP，使他们能够在同一个网段内。 </span><br><span class="line"></span><br><span class="line">需要以下几步（假定所有机器都在10.120.11.*网段,agent服务器为linux,controller服务器为windows）：</span><br><span class="line"></span><br><span class="line">1、 修改agent服务器，指定agent机器的IP</span><br><span class="line">修改jmeter-server文件</span><br><span class="line"># vi jmeter-server</span><br><span class="line">修改RMI_HOST_DEF&#x3D;-Djava.rmi.server.hostname&#x3D;xxx.xxx.xxx.xxx(需要连接的IP)</span><br><span class="line"></span><br><span class="line">2、修改server服务器，指定server机器的IP</span><br><span class="line"></span><br><span class="line">修改jmeter.bat文件 </span><br><span class="line"></span><br><span class="line">新增set rmi_host&#x3D;-Djava.rmi.server.hostname&#x3D;10.120.11.214</span><br><span class="line"></span><br><span class="line">修改set ARGS&#x3D;%DUMP% %HEAP% %NEW% %SURVIVOR% %TENURING% %PERM% %DDRAW% %rmi_host%</span><br></pre></td></tr></table></figure><h2 id="6、确定在controller机器上安装jdk-版本和jmeter一致，配置环境变量：Java-home等"><a href="#6、确定在controller机器上安装jdk-版本和jmeter一致，配置环境变量：Java-home等" class="headerlink" title="6、确定在controller机器上安装jdk,版本和jmeter一致，配置环境变量：Java_home等"></a>6、确定在controller机器上安装jdk,版本和jmeter一致，配置环境变量：Java_home等</h2><ul><li>在Agent机器上安装jdk，配置环境变量：Java_home和JMeter_home</li><li>安装目录不要带空格，最好都是简短的英文路径</li></ul><h2 id="7、master机器启动后会拷贝jmx文件到slave机器，所以不需要在每台slave机器上也上传一份jmx，只需要在master机器上上传一份jmx脚本即可。"><a href="#7、master机器启动后会拷贝jmx文件到slave机器，所以不需要在每台slave机器上也上传一份jmx，只需要在master机器上上传一份jmx脚本即可。" class="headerlink" title="7、master机器启动后会拷贝jmx文件到slave机器，所以不需要在每台slave机器上也上传一份jmx，只需要在master机器上上传一份jmx脚本即可。"></a>7、master机器启动后会拷贝jmx文件到slave机器，所以不需要在每台slave机器上也上传一份jmx，只需要在master机器上上传一份jmx脚本即可。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果使用csv进行参数化，则需要把参数文件在每台slave上拷一份且路径需要设置成一样的。</span><br><span class="line"></span><br><span class="line">总样本数 &#x3D; 线程数 * 循环次数 * 执行机总数</span><br></pre></td></tr></table></figure><h2 id="8、连接失败原因排查"><a href="#8、连接失败原因排查" class="headerlink" title="8、连接失败原因排查"></a>8、连接失败原因排查</h2><h4 id="以下步骤进行排查："><a href="#以下步骤进行排查：" class="headerlink" title="以下步骤进行排查："></a>以下步骤进行排查：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. jmeter-server是否启动；</span><br><span class="line">2. 是否联网</span><br><span class="line">3. ping 服务器IP是否畅通.</span><br><span class="line">4. telnet 端口 192.168.3.10 1099</span><br><span class="line">5. 检查服务器的防火墙是否关闭。</span><br><span class="line">6. 阿里云安全策略是否正常</span><br></pre></td></tr></table></figure><h2 id="9、”could-not-find-ApacheJmeter-core-jar”"><a href="#9、”could-not-find-ApacheJmeter-core-jar”" class="headerlink" title="9、”could not find ApacheJmeter_core.jar”"></a>9、”could not find ApacheJmeter_core.jar”</h2><p>​    <strong>解决：在Agent机器安装jdk，并设置环境变量</strong></p><h2 id="10、”Bad-call-to-remote-host”"><a href="#10、”Bad-call-to-remote-host”" class="headerlink" title="10、”Bad call to remote host”"></a>10、”Bad call to remote host”</h2><p>解决：检查被控制机器上的jmeter-server有没有启动，或者remote_hosts的配置是否正确。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      学习如何使用jmeter压力测试
    
    </summary>
    
    
      <category term="Java" scheme="https://whitestore.top/categories/Java/"/>
    
    
      <category term="Java" scheme="https://whitestore.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Java】Mastering Backend Development with Java</title>
    <link href="https://whitestore.top/2023/09/07/masteringjava/"/>
    <id>https://whitestore.top/2023/09/07/masteringjava/</id>
    <published>2023-09-07T06:03:14.000Z</published>
    <updated>2023-09-09T00:53:49.935Z</updated>
    
    <content type="html"><![CDATA[<p>#springboot</p><h1 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h1><p><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BpdHpuaWhhbC9tYXN0ZXJpbmctYmFja2VuZC1kZXZlbG9wbWVudC13aXRoLWphdmEtc3ByaW5nLWJvb3QtYmVzdC1wcmFjdGljZXMtYW5kLXByby10aXBzLTNmYzBmNTAxNDE4ZQ==" title="https://medium.com/@itznihal/mastering-backend-development-with-java-spring-boot-best-practices-and-pro-tips-3fc0f501418e">Mastering Backend Development with Java Spring Boot: Best Practices and Pro Tips | by Nihal Parmar | Medium<i class="fa fa-external-link"></i></span></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230907131707.png" alt="image.png"></p><p>Spring Boot is a widely used and very popular enterprise-level high-performance framework. </p><p>Spring Boot 是一种广泛使用且非常流行的企业级高性能框架。</p><p>Here are some best practices and a few tips you can use to improve your Spring Boot application and make it more efficient. </p><p>以下是一些最佳实践和技巧，您可以用来改进 Spring Boot 应用程序，使其更加高效。</p><p>This article will be a little longer, and it will take some time to completely read the article.</p><p>本文篇幅稍长，完整阅读需要耗费不少时间。</p><a id="more"></a><h1 id="Proper-packaging-style-适当的包装风格"><a href="#Proper-packaging-style-适当的包装风格" class="headerlink" title="Proper packaging style  适当的包装风格"></a>Proper packaging style  适当的包装风格</h1><ul><li><p>Proper packaging will help to understand the code and the flow of the application easily.</p></li><li><p>适当的包装有助于轻松理解代码和应用程序的流程。</p></li><li><p>You can structure your application with meaningful packaging.</p></li><li><p>您可以通过有意义的打包来构建应用程序。</p></li><li><p>You can include all your controllers into a separate package, services in a separate package, util classes into a separate package…etc. This style is very convenient in small-size microservices.</p></li><li><p>您可以将所有<code>controller</code>打包成一个单独的包，将服务打包成一个单独的包，将 <code>util</code> 类打包成一个单独的包……等等。这种风格在小型微服务中非常方便。</p></li><li><p>If you are working on a huge code base, a feature-based approach can be used. You can decide on your requirement.</p></li><li><p>如果您正在处理庞大的代码库，则可以使用基于功能的方法。您可以根据自己的需求来决定。</p></li></ul><p><strong>Based on type</strong></p><p><strong>基于类型</strong></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230907131717.png" alt="image.png"></p><p><strong>Based on feature</strong></p><p><strong>基于功能</strong></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230907131741.png" alt="image.png"></p><h1 id="Use-design-patterns-使用设计模式"><a href="#Use-design-patterns-使用设计模式" class="headerlink" title="Use design patterns 使用设计模式"></a>Use design patterns 使用设计模式</h1><ul><li><p>No complaints. Design patterns are already best practices.</p></li><li><p>But you must identify the place where you can use them.</p></li><li><p>Please check this article to understand “<a href="https://www.javastackflow.com/2022/09/how-to-use-builder-design-pattern-with.html" target="_blank" rel="noopener"><strong><em>how to use the Builder design pattern</em></strong></a>” in our Spring Boot applications.</p></li><li><p>不要埋怨。设计模式已经是最佳实践。</p></li><li><p>但您必须确定可以使用它们的地方。</p></li><li><p>请查看本文以了解：”<a href="https://www.javastackflow.com/2022/09/how-to-use-builder-design-pattern-with.html" target="_blank" rel="noopener"><strong><em>如何在 Spring Boot 应用程序中使用生成器设计模式</em></strong></a>“。</p></li></ul><h1 id="Use-Spring-Boot-starters-使用-Spring-Boot-启动器"><a href="#Use-Spring-Boot-starters-使用-Spring-Boot-启动器" class="headerlink" title="Use Spring Boot starters 使用 Spring Boot 启动器"></a>Use Spring Boot starters 使用 Spring Boot 启动器</h1><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230907131756.png" alt="image.png"></p><p>Image: <span class="exturl" data-url="aHR0cHM6Ly93d3cubWVycmlhbS13ZWJzdGVyLmNvbS93b3Jkcy1hdC1wbGF5L25hbWVzLW9mLWFwcGV0aXplcnM=" title="https://www.merriam-webster.com/words-at-play/names-of-appetizers">https://www.merriam-webster.com/words-at-play/names-of-appetizers<i class="fa fa-external-link"></i></span></p><ul><li><p>This is a cool feature of Spring Boot.</p></li><li><p>这是 Spring Boot 的一个很酷的功能。</p></li><li><p>We can very easily use starter dependencies without adding single dependencies one by one. These starter dependencies are already bundled with the required dependencies.</p></li><li><p>我们可以非常轻松地使用启动依赖，而无需逐个添加单个依赖。这些启动依赖已经与所需的依赖捆绑在一起。</p></li><li><p>For example, if we add <strong>spring-boot-starter-web</strong> dependency，by default,  it is bundled with <strong>jackson, spring-core, spring-mvc, and spring-boot-starter-tomcat dependencies</strong>.</p></li><li><p>例如，如果我们添加了<strong>spring-boot-starter-web</strong>依赖，默认情况下，它与 <strong>jackson、spring-core、spring-mvc 和 spring-boot-starter-tomcat 依赖</strong>捆绑在一起。</p></li><li><p>So we don’t need to care about adding dependencies separately.</p></li><li><p>因此，我们无需单独添加依赖。</p></li><li><p>And also it helps us to avoid version mismatches.</p></li><li><p>此外，它还能帮助我们避免版本不匹配。</p><h1 id="Use-proper-versions-of-the-dependencies-使用正确的依赖版本"><a href="#Use-proper-versions-of-the-dependencies-使用正确的依赖版本" class="headerlink" title="Use proper versions of the dependencies 使用正确的依赖版本"></a>Use proper versions of the dependencies 使用正确的依赖版本</h1></li><li><p>It is always recommended to use the latest stable <strong>GA</strong> versions.</p></li><li><p>建议始终使用最新的稳定<strong>GA</strong>版本。</p></li><li><p>Sometimes it may vary with the Java version, server versions, the type of the application…etc.</p></li><li><p>有时可能会因 Java 版本、服务器版本、应用程序类型……等而有所不同。</p></li><li><p>Do not use different versions of the same package and always use &lt; properties&gt; to specify the version if there are multiple dependencies.</p></li><li><p>不要使用同一软件包的不同版本，如果存在多个依赖关系，应始终使用 &lt; properties&gt; 来指定版本。</p></li></ul><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230907131843.png" alt="image.png"></p><h1 id="Use-Lombok-使用-Lombok"><a href="#Use-Lombok-使用-Lombok" class="headerlink" title="Use Lombok 使用 Lombok"></a>Use Lombok 使用 Lombok</h1><ul><li><p>As a Java developer, you have probably heard of the <strong>Lombok project</strong>.</p></li><li><p>Lombok is a Java library that can be used to reduce your codes and allow you to write clean code using its annotations.</p></li><li><p>For example, you may use plenty of lines for getters and setters in some classes like entities, request/response objects, dtos…etc.</p></li><li><p>But if you use Lombok, it is just one line, you can use <strong>@Data, @Getter</strong> or <strong>@Setter</strong> as per your requirement.</p></li><li><p>You can use <strong><em>Lombok</em></strong> logger annotations as well. <strong><em>@Slf4j</em></strong> is recommended.</p></li><li><p>Check this <a href="https://github.com/raviyasas/springboot-gcs-demo/blob/master/src/main/java/com/app/entity/InputFile.java" target="_blank" rel="noopener"><strong><em>file</em></strong></a> for your reference.</p></li><li><p>作为一名 Java 开发人员，您可能听说过<strong>Lombok 项目</strong>。</p></li><li><p><code>Lombok</code> 是一个 Java 库，可用于减少代码，并允许您使用其注解编写简洁的代码。</p></li><li><p>例如，在一些类（如实体、请求/响应对象、dtos……等）中，您可能会使用大量的行来表示 <code>getters</code> 和 <code>setters</code>。</p></li><li><p>但如果使用 <strong>Lombok</strong>，则只需一行，您可以根据需要使用 <strong>@Data</strong>、<strong>@Getter</strong> 或 <strong>@Setter</strong>。</p></li><li><p>您还可以使用 <strong><em>Lombok</em></strong> 日志注释。 建议使用 <strong><em>@Slf4j</em></strong>。</p></li><li><p>请查看此 <a href="https://github.com/raviyasas/springboot-gcs-demo/blob/master/src/main/java/com/app/entity/InputFile.java" target="_blank" rel="noopener"><strong><em>file</em></strong></a>，以供参考。</p><h1 id="Use-constructor-injection-with-Lombok-使用-Lombok-注入构造函数"><a href="#Use-constructor-injection-with-Lombok-使用-Lombok-注入构造函数" class="headerlink" title="Use constructor injection with Lombok 使用 Lombok 注入构造函数"></a>Use constructor injection with Lombok 使用 Lombok 注入构造函数</h1></li></ul><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230907131901.png" alt="image.png"></p><ul><li><p>When we talk about dependency injection, there are two types.</p></li><li><p>当我们谈论依赖注入时，有两种类型。</p></li><li><p>One is “<strong>constructor injection</strong>” and the other is “<strong>setter injection</strong>”. Apart from that, you can also use “<strong>field injection</strong>” using the very popular <strong>@Autowired</strong> annotation.</p></li><li><p>一种是 “<strong>构造器注入</strong>“，另一种是 “<strong>设置器注入</strong>“。除此之外，你还可以使用非常流行的<strong>@Autowired</strong>注解来进行 “ <strong>字段注入</strong> “。</p></li><li><p>But we highly recommend using <strong>Constructor injection</strong> over other types. Because it allows the application to initialize all required dependencies at the initialization time.</p></li><li><p>但我们强烈建议使用<strong>构造器注入</strong>，而不是其他类型。因为<strong>它允许应用程序在初始化时初始化所有需要的依赖关系</strong>。</p></li><li><p>This is very useful for unit testing.</p></li><li><p>这对<strong>单元测试</strong>非常有用。</p></li><li><p>The important thing is, that we can use the <strong>@RequiredArgsConstructor</strong> annotation by Lombok to use constructor injection.</p></li><li><p>重要的是，我们可以使用 Lombok 的 <strong>@RequiredArgsConstructor</strong> 注解来使用构造器注入。</p></li><li><p>Check this <a href="https://github.com/raviyasas/springboot-gcs-demo/blob/master/src/main/java/com/app/controller/FileController.java" target="_blank" rel="noopener"><em>sample controller</em></a> for your reference.</p></li><li><p>请查看 <a href="https://github.com/raviyasas/springboot-gcs-demo/blob/master/src/main/java/com/app/controller/FileController.java" target="_blank" rel="noopener"><em>sample controller</em></a> 以供参考。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.app.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.app.entity.InputFile;</span><br><span class="line"><span class="keyword">import</span> com.app.service.FileService;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/api/v1/files"</span>)</span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(FileController<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FileService fileService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(consumes = &#123;MediaType.MULTIPART_FORM_DATA_VALUE&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;InputFile&gt; <span class="title">addFile</span><span class="params">(@RequestParam(<span class="string">"files"</span>)</span>MultipartFile[] files)</span>&#123;</span><br><span class="line">        LOGGER.debug(<span class="string">"Call addFile API"</span>);</span><br><span class="line">        <span class="keyword">return</span> fileService.uploadFiles(files);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Use-slf4j-logging-使用-slf4j-日志"><a href="#Use-slf4j-logging-使用-slf4j-日志" class="headerlink" title="Use slf4j logging 使用 slf4j 日志"></a>Use slf4j logging 使用 slf4j 日志</h1><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230907131917.png" alt="image.png"></p><ul><li><p>Logging is very important.</p></li><li><p>If a problem occurs while your application is in production, logging is the only way to find out the root cause.</p></li><li><p>Therefore, you should think carefully before adding loggers, log message types, logger levels, and logger messages.</p></li><li><p>Do not use System.out.print()</p></li><li><p>Slf4j is recommended to use along with logback which is the default logging framework in Spring Boot.</p></li><li><p>Always use slf4j { } and avoid using String interpolation in logger messages. Because string interpolation consumes more memory.</p></li><li><p>Please check <a href="https://github.com/raviyasas/springboot-gcs-demo/blob/master/src/main/java/com/app/service/FileServiceImpl.java" target="_blank" rel="noopener"><em>this file</em></a> for your reference to get an idea about, implementing a logger.</p></li><li><p>==You can use Lombok== ==<strong><em>@Slf4j</em></strong>== ==<em>annotation to create a logger very easily.</em>==</p></li><li><p>If you are in a micro-services environment, you can use the ELK stack.</p></li><li><p>日志记录非常重要。  </p></li><li><p>如果应用程序在生产过程中出现问题，日志记录是找出根本原因的唯一途径。  </p></li><li><p>因此，在添加日志记录器、日志消息类型、日志记录器级别和日志记录器消息之前，应仔细考虑。  </p></li><li><p><strong>不要使用 System.out.print()</strong></p></li><li><p>建议使用 <code>Slf4j</code> 和 <code>logback</code>，后者是 <code>Spring Boot</code> 的默认日志框架。  </p></li><li><p>始终使用 slf4j { }，避免在日志记录器消息中使用字符串插值。因为字符串插值会消耗更多内存。  </p></li><li><p>请查看 <a href="https://github.com/raviyasas/springboot-gcs-demo/blob/master/src/main/java/com/app/service/FileServiceImpl.java" target="_blank" rel="noopener"><em>此文件</em></a> 以了解如何实现日志记录器，供您参考。  </p></li><li><p>===你可以使用 Lombok== ==<strong><em>@Slf4j</em></strong>== ==_annotation 来轻松创建日志记录器。  </p></li><li><p>如果你身处微服务环境，可以使用 ELK 栈。  </p></li></ul><h1 id="Use-Controllers-only-for-routing-仅在路由时使用控制器"><a href="#Use-Controllers-only-for-routing-仅在路由时使用控制器" class="headerlink" title="Use Controllers only for routing 仅在路由时使用控制器"></a>Use Controllers only for routing 仅在路由时使用控制器</h1><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230907133704.png" alt="image.png"></p><ul><li><p>Controllers are dedicated to routing.</p></li><li><p>It is <strong>stateless</strong> and <strong>singleton</strong>.</p></li><li><p>The DispatcherServlet will check the <em>@RequestMapping</em> on <em>Controllers</em></p></li><li><p>Controllers are the ultimate target of requests, then requests will be handed over to the service layer and processed by the service layer.</p></li><li><p>The business logic <strong>should not be</strong> in the controllers.</p></li><li><p>控制器专用于路由。</p></li><li><p>它是<strong>无状态</strong>和<strong>单例</strong>。</p></li><li><p>DispatcherServlet 会检查控制器上的 <em>@RequestMapping</em> 。</p></li><li><p>控制器是请求的最终目标，然后请求将被移交给服务层并由服务层处理。</p></li><li><p>业务逻辑<strong>不应该</strong>在控制器中。</p><h1 id="Use-Services-for-business-logic-业务逻辑使用服务"><a href="#Use-Services-for-business-logic-业务逻辑使用服务" class="headerlink" title="Use Services for business logic 业务逻辑使用服务"></a>Use Services for business logic 业务逻辑使用服务</h1></li><li><p>The <strong>complete business logic goes here</strong> with validations, caching…etc.</p></li><li><p>Services communicate with the persistence layer and receive the results.</p></li><li><p>Services are also singleton.</p></li><li><p>这里***完整的业务逻辑，包括验证、缓存……等。</p></li><li><p>服务与持久层通信并接收结果。</p></li><li><p>服务也是单例的。</p></li></ul><blockquote><p><em>Bonus article:</em> <a href="https://medium.com/@raviyasas/why-stress-and-how-to-manage-it-as-a-software-engineer-204b4e21ed9" target="_blank" rel="noopener"><em>Manage stress as a Software Engineer</em></a></p><p><em>Bonus article:</em> <a href="https://medium.com/@raviyasas/why-stress-and-how-to-manage-it-as-a-software-engineer-204b4e21ed9" target="_blank" rel="noopener"><em>Manage stress as a Software Engineer</em></a></p></blockquote><h1 id="Avoid-NullPointerException-避免-NullPointerException"><a href="#Avoid-NullPointerException-避免-NullPointerException" class="headerlink" title="Avoid NullPointerException 避免 NullPointerException"></a>Avoid NullPointerException 避免 NullPointerException</h1><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230907134658.png" alt="image.png"></p><ul><li><p>To avoid <strong>NullPointerException</strong> you can use <strong>Optional</strong> from java.util package.</p></li><li><p>You can also use null-safe libraries. Ex: <strong>Apache Commons StringUtils</strong></p></li><li><p>Call <strong>equals()</strong> and <strong>equalsIgnoreCase()</strong> methods on known objects.</p></li><li><p>Use <strong>valueOf()</strong> over <strong>toString()</strong></p></li><li><p>Use IDE-based <strong>@NotNull</strong> and <strong>@Nullable</strong> annotations.</p></li><li><p>避免<strong>NullPointerException</strong>，您可以使用 java.util 包中的<strong>Optional</strong>。</p></li><li><p>您还可以使用空安全库。例如：<strong>Apache Commons StringUtils</strong></p></li><li><p>在已知对象上调用 <strong>equals()</strong> 和 <strong>equalsIgnoreCase()</strong> 方法。</p></li><li><p>使用 <strong>valueOf()</strong> 而非 <strong>toString()</strong></p></li><li><p>使用基于 IDE 的 <strong>@NotNull</strong> 和 <strong>@Nullable</strong> 注解。</p><h1 id="Use-best-practices-for-the-Collection-framework-使用Collection框架的最佳实践"><a href="#Use-best-practices-for-the-Collection-framework-使用Collection框架的最佳实践" class="headerlink" title="Use best practices for the Collection framework 使用Collection框架的最佳实践"></a>Use best practices for the Collection framework 使用Collection框架的最佳实践</h1></li><li><p>Use appropriate collection for your data set.</p></li><li><p>Use <strong>forEach</strong> with Java 8 features and avoid using legacy for loops.</p></li><li><p>Use <strong>interface type</strong> instead of the implementation.</p></li><li><p>Use <strong>isEmpty()</strong> over <strong>size()</strong> for better readability.</p></li><li><p>Do not return null values, you can return an empty collection.</p></li><li><p>If you are using objects as data to be stored in a hash-based collection, you should override equals() and hashCode() methods. Please check this article “<a href="https://medium.com/@raviyasas/how-a-hashmap-internally-works-93e3887978f3" target="_blank" rel="noopener"><em>How does a HashMap internally work</em></a>”.</p></li><li><p>针对数据集使用适当的集合。</p></li><li><p>使用 Java 8 Lambda 的 <strong>forEach</strong>，避免使用传统的 for 循环。</p></li><li><p>使用 <strong>接口类型</strong> 而不是具体实现。</p></li><li><p>使用 <strong>isEmpty()</strong>，而不是 <strong>size()</strong>，以获得更好的可读性。</p></li><li><p>不要返回空值，可以返回空集合。</p></li><li><p>如果使用对象作为数据存储在基于Hash的集合中，则应覆盖 equals() 和 hashCode() 方法。请查看本文”<a href="https://medium.com/@raviyasas/how-a-hashmap-internally-works-93e3887978f3" target="_blank" rel="noopener"><em>HashMap 内部如何工作</em></a>“。</p></li></ul><h1 id="Use-pagination-使用分页"><a href="#Use-pagination-使用分页" class="headerlink" title="Use pagination 使用分页"></a>Use pagination 使用分页</h1><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230907134647.png" alt="image.png"></p><ul><li><p>This will improve the performance of the application.</p></li><li><p>If you’re using <strong>Spring Data JPA</strong>, the <strong><em>PagingAndSortingRepository</em></strong> makes using pagination very easy and with little effort.</p></li><li><p>这将提高应用程序的性能。</p></li><li><p>如果你使用的是<strong>Spring Data JPA</strong>，那么 <strong><em>PagingAndSortingRepository</em></strong> 会让分页功能的使用变得非常简单，而且几乎不费吹灰之力。</p><h1 id="Use-caching-使用缓存"><a href="#Use-caching-使用缓存" class="headerlink" title="Use caching 使用缓存"></a>Use caching 使用缓存</h1></li><li><p>Caching is another important factor when talking about application performance.</p></li><li><p>By default Spring Boot provides caching with <strong>ConcurrentHashMap</strong> and you can achieve this by <strong>@EnableCaching</strong> annotation.</p></li><li><p>If you are not satisfied with default caching, you can use <strong>Redis</strong>, <strong>Hazelcast,</strong> or any other distributed caching implementations.</p></li><li><p>Redis and Hazelcast are <strong>in-memory</strong> caching methods. You also can use database cache implementations as well.</p></li><li><p>缓存是影响应用程序性能的另一个重要因素。</p></li><li><p>默认情况下，Spring Boot 通过 <strong>ConcurrentHashMap</strong> 提供缓存，您可以通过 <strong>@EnableCaching</strong> 注解实现缓存。</p></li><li><p>如果对默认缓存不满意，可以使用 <strong>Redis</strong>、<strong>Hazelcast</strong> 或其他分布式缓存实现。</p></li><li><p><strong>Redis</strong> 和 <strong>Hazelcast</strong> 是<strong>内存</strong>缓存方法。您也可以使用数据库缓存实现。</p><h1 id="Use-custom-exception-handler-with-global-exception-handling-使用自定义异常处理程序和全局异常处理"><a href="#Use-custom-exception-handler-with-global-exception-handling-使用自定义异常处理程序和全局异常处理" class="headerlink" title="Use custom exception handler with global exception handling 使用自定义异常处理程序和全局异常处理"></a>Use custom exception handler with global exception handling 使用自定义异常处理程序和全局异常处理</h1></li></ul><p><img src="https://miro.medium.com/v2/resize:fit:875/0*ErfHekfADhtYb8e9.png" alt=""></p><ul><li><p>This is very important when working with large enterprise-level applications.</p></li><li><p>Apart from the general exceptions, we may have some scenarios to identify some specific error cases.</p></li><li><p>Exception adviser can be created with <strong>@ControllerAdvice</strong> and we can create separate exceptions with meaningful details.</p></li><li><p>It will make it much easier to identify and debug errors in the future.</p></li><li><p>Please check <a href="https://github.com/raviyasas/springboot-exceptions-demo/tree/master/src/main/java/com/app/exception" target="_blank" rel="noopener"><em>this</em></a> and <a href="https://github.com/raviyasas/springboot-gcs-demo/tree/master/src/main/java/com/app/exception" target="_blank" rel="noopener"><em>this</em></a> for your reference.</p></li><li><p>在处理大型企业级应用程序时，这一点非常重要。</p></li><li><p>除了一般的异常情况外，我们可能还需要在某些情况下识别一些特定的错误案例。</p></li><li><p>可以使用 <strong>@ControllerAdvice</strong> 创建异常切面，我们可以创建具有有意义细节的单独异常。</p></li><li><p>这将大大方便今后识别和调试错误。</p></li><li><p>请查看 <a href="https://github.com/raviyasas/springboot-exceptions-demo/tree/master/src/main/java/com/app/exception" target="_blank" rel="noopener"><em>this</em></a> 和 <a href="https://github.com/raviyasas/springboot-gcs-demo/tree/master/src/main/java/com/app/exception" target="_blank" rel="noopener"><em>this</em></a>，以供参考。</p></li></ul><blockquote><p><em>Bonus article:</em> <a href="https://www.javastackflow.com/2022/09/what-is-serverless-architecture.html" target="_blank" rel="noopener"><em>What is serverless Architecture?</em></a></p><p><em>Bonus article:</em> <a href="https://www.javastackflow.com/2022/09/what-is-serverless-architecture.html" target="_blank" rel="noopener"><em>什么是无服务架构？</em></a></p></blockquote><h1 id="Use-custom-response-object-使用自定义响应对象"><a href="#Use-custom-response-object-使用自定义响应对象" class="headerlink" title="Use custom response object 使用自定义响应对象"></a>Use custom response object 使用自定义响应对象</h1><p><img src="https://miro.medium.com/v2/resize:fit:875/0*HsR7UP64pwDENvq8.png" alt=""></p><ul><li><p>A custom response object can be used to return an object with some specific data with the requirements like HTTP status code, API code, message…etc.</p></li><li><p>We can use the <strong>builder design pattern</strong> to create a custom response object with custom attributes.</p></li><li><p>Please check <a href="https://www.javastackflow.com/2022/09/how-to-use-builder-design-pattern-with.html" target="_blank" rel="noopener"><strong><em>this article</em></strong></a> for your reference.</p></li><li><p>自定义响应对象可用于返回带有某些特定数据的对象，这些数据应符合 HTTP 状态代码、API 代码、消息等要求。</p></li><li><p>我们可以使用 ** 生成器设计模式** 来创建带有自定义属性的自定义响应对象。</p></li><li><p>请查阅<a href="https://www.javastackflow.com/2022/09/how-to-use-builder-design-pattern-with.html" target="_blank" rel="noopener"><strong><em>本文</em></strong></a>以供参考。</p><h1 id="Remove-unnecessary-codes-variables-methods-and-classes-删除不必要的代码、变量、方法和类"><a href="#Remove-unnecessary-codes-variables-methods-and-classes-删除不必要的代码、变量、方法和类" class="headerlink" title="Remove unnecessary codes, variables, methods, and classes.  删除不必要的代码、变量、方法和类"></a>Remove unnecessary codes, variables, methods, and classes.  删除不必要的代码、变量、方法和类</h1></li></ul><p><img src="https://miro.medium.com/v2/resize:fit:875/0*I1A3DYUGTcDRdIQ2.png" alt=""></p><p>commented code in the production</p><p>生产中的注释代码</p><ul><li><p><strong>Unused variable</strong> declarations will acquire some memory.</p></li><li><p>Remove unused methods, classes…etc because it will impact the performance of the application.</p></li><li><p>Try to avoid nested loops. You can use maps instead.</p></li><li><p>未使用的变量，**声明会占用一些内存。</p></li><li><p>删除未使用的方法、类……等，因为这将影响应用程序的性能。</p></li><li><p>尽量避免嵌套循环。可以使用映射来代替。</p><h1 id="Using-comments-使用注释"><a href="#Using-comments-使用注释" class="headerlink" title="Using comments 使用注释"></a>Using comments 使用注释</h1></li><li><p>Commenting is a good practice unless you abuse it.</p></li><li><p>DO NOT comment on everything. Instead, you can write descriptive code using meaningful words for classes, functions, methods, variables…etc.</p></li><li><p>Remove commented codes, misleading comments, and story-type comments.</p></li><li><p>You can use comments for warnings and explain something difficult to understand at first sight.</p></li><li><p>注释是一种很好的做法，除非你滥用它。</p></li><li><p><strong>切勿对所有内容进行注释</strong>。相反，您可以使用有意义的词来描述类、函数、方法、变量……等，编写描述性代码。</p></li><li><p>删除<strong>注释代码</strong>、<strong>误导性注释</strong>和<strong>故事型注释</strong>。</p></li><li><p>您可以使用注释来警告和解释一些<strong>乍一看难以理解</strong>的内容。</p><h1 id="Use-meaningful-words-for-classes-methods-functions-variables-and-other-attributes-对类、方法、函数、变量和其他属性使用有意义的词语。"><a href="#Use-meaningful-words-for-classes-methods-functions-variables-and-other-attributes-对类、方法、函数、变量和其他属性使用有意义的词语。" class="headerlink" title="Use meaningful words for classes, methods, functions, variables, and other attributes. 对类、方法、函数、变量和其他属性使用有意义的词语。"></a>Use meaningful words for classes, methods, functions, variables, and other attributes. 对类、方法、函数、变量和其他属性使用有意义的词语。</h1></li></ul><p><img src="https://miro.medium.com/v2/resize:fit:875/0*uJmiodAstz6j0-1j.png" alt=""></p><ul><li><p>This looks very simple, but the impact is huge.</p></li><li><p>Always use proper <strong>meaningful and searchable</strong> naming conventions with proper case.</p></li><li><p>Usually, we use <strong>nouns or short phrases</strong> when declaring <strong>classes</strong>, <strong>variables</strong>, and <strong>constants</strong>. Ex: String firstName, const isValid</p></li><li><p>You can use <strong>verbs and short phrases with adjectives</strong> for <strong>functions</strong> and <strong>methods</strong>. Ex: readFile(), sendData()</p></li><li><p>Avoid using <strong>abbreviating variable</strong> names and <strong>intention revealing</strong> names. Ex: int i; String getExUsr;</p></li><li><p>If you use this meaningfully, declaration comment lines can be reduced. Since it has meaningful names, a fresh developer can easily understand by reading the code.</p></li><li><p>这看起来很简单，但影响却很大。</p></li><li><p>始终使用<strong>有意义且可搜索的</strong>命名规则，并使用正确的大小写。</p></li><li><p>通常，我们在声明<strong>类</strong>、<strong>变量</strong>和<strong>常量</strong>时使用<strong>名词或短语</strong>。例如：字符串 firstName、常量 isValid</p></li><li><p>在声明<strong>函数</strong>和<strong>方法</strong>时，可以使用<strong>谚语和带有形容词的短语</strong>。例如：readFile()、sendData()</p></li><li><p>避免使用<strong>缩略变量</strong>名和<strong>暴露想法</strong>名。例如：int i; String getExUsr；</p></li><li><p>如果使用这些有意义的名称，就可以减少声明注释行。由于使用了有意义的名称，新开发人员在阅读代码时很容易理解。</p><h1 id="Use-proper-case-for-declarations-在声明中使用合适的大小写"><a href="#Use-proper-case-for-declarations-在声明中使用合适的大小写" class="headerlink" title="Use proper case for declarations 在声明中使用合适的大小写"></a>Use proper case for declarations 在声明中使用合适的大小写</h1></li></ul><p><img src="https://miro.medium.com/v2/resize:fit:875/0*LWJF3cRbzU4wU09A.png" alt=""></p><ul><li><p>There are many different cases like <strong>UPPERCASE, lowercase, camelCase, PascalCase, snake_case, SCREAMING_SNAKE_CASE, kebab-case</strong>…etc.</p></li><li><p>But we need to identify which case is dedicated to which variable.</p></li><li><p>Usually, I follow,</p></li><li><p>有许多不同的大小写，如 <strong>大写、小写、骆驼大写、帕斯卡大写、蛇大写、SCREAMING_SNAKE_CASE、kebab-case</strong>……等等。</p></li><li><p>但我们需要确定哪个大小写专用于哪个变量。</p></li><li><p>通常，我是这样做的。</p></li></ul><p>classes — <strong>PascalCase</strong></p><p>methods &amp; variables — <strong>camelCase</strong></p><p>方法和变量–<strong>camelCase</strong></p><p>constants — <strong>SCREAMING_SNAKE_CASE</strong></p><p>常量 - <strong>SCREAMING_SNAKE_CASE</strong></p><p>DB-related fields — <strong>snake_case</strong></p><p>与 DB 相关的字段 - <strong>snake_case</strong></p><ul><li><p>This is just an example. It can be different from the standard you follow in the company.</p></li><li><p>这只是一个示例。它可能与您在公司中遵循的标准不同。</p><h1 id="Be-simple-保持简单"><a href="#Be-simple-保持简单" class="headerlink" title="Be simple 保持简单"></a>Be simple 保持简单</h1></li></ul><p><img src="https://miro.medium.com/v2/resize:fit:875/0*am8Xo9e4ngoABycE.png" alt=""></p><ul><li><p>Always try to write simple, readable codes.</p></li><li><p>The same simple logic can be implemented using different ways, but it is difficult to understand if it is not readable or understandable.</p></li><li><p>Sometimes complex logic consumes more memory.</p></li><li><p>Try to use <strong>KISS</strong>, <strong>DRY</strong>, and <strong>SOLID</strong> principles when writing codes. I will explain this in a future article.</p></li><li><p>始终尽量编写简单、可读的代码。</p></li><li><p>同样简单的逻辑可以用不同的方法实现，但如果不可读性或不可懂性，就很难理解。</p></li><li><p>有时复杂的逻辑会消耗更多内存。</p></li><li><p>在编写代码时，尽量使用<strong>KISS</strong>、<strong>DRY</strong>和<strong>SOLID</strong>原则。我将在今后的文章中对此进行解释。</p></li></ul><blockquote><p>DRY stands for “Don’s Repeat Yourself</p></blockquote><p>如果代码可以公用就尽量公用，不要复制粘贴代码。</p><blockquote><p>kiss：KISS stands for “Keep It Simple, Stupid”.</p></blockquote><p>KISS就是保持简单，愚蠢。这个愚蠢指的是方法最好只知道干一件事情。这两点和Unix最初的设计的理念是一样的，简单好用即是美。</p><p><strong>SOLID</strong>原则：</p><p><strong>Single Responsibility Principle</strong> 单一职责：每个类和接口有明确目标。</p><p><strong>Open-Closed Principle</strong> 开闭原则：开放扩展，封闭修改。</p><p><strong>Liskov Substitution Principle</strong> 里式替代：尽可能让代码多态。</p><p><strong>Interface Segregation Principle</strong> 接口隔离：实现接口替代类继承。</p><p><strong>Dependency Inversion Principle</strong> 依赖倒转原则：依赖抽象而不是依赖实现。</p><h1 id="Use-a-common-code-formatting-style-使用通用的代码格式样式"><a href="#Use-a-common-code-formatting-style-使用通用的代码格式样式" class="headerlink" title="Use a common code formatting style 使用通用的代码格式样式"></a>Use a common code formatting style 使用通用的代码格式样式</h1><p><img src="https://miro.medium.com/v2/resize:fit:875/0*IW4rJbi2sMKKak9P.png" alt=""></p><ul><li><p>Formatting styles vary from developer to developer. Coding style changes are also considered a change and can make code merging very difficult.</p></li><li><p>To avoid this, the team can have a common coding format.</p></li><li><p>格式风格因开发人员而异。编码风格的改变也被认为是一种改变，会使代码合并变得非常困难。</p></li><li><p>为了避免这种情况，团队可以采用统一的编码格式。</p></li></ul><h1 id="Use-SonarLint-使用-SonarLint"><a href="#Use-SonarLint-使用-SonarLint" class="headerlink" title="Use SonarLint 使用 SonarLint"></a>Use SonarLint 使用 SonarLint</h1><p><img src="https://miro.medium.com/v2/resize:fit:240/0*ChADmyd-l_RX102d.png" alt=""></p><ul><li><p>This is very useful for identifying small bugs and best practices to avoid unnecessary bugs and code quality issues.</p></li><li><p>这对识别小错误和最佳实践非常有用，可避免不必要的错误和代码质量问题。</p></li><li><p>You can install the plugin into your favorite IDE.</p></li><li><p>您可以将该插件安装到自己喜欢的集成开发环境中。</p></li></ul><p>Follow me for <em>new tidbits</em> on the <strong>domain of tech.</strong></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      请输入描述信息
    
    </summary>
    
    
      <category term="Java" scheme="https://whitestore.top/categories/Java/"/>
    
    
      <category term="Java" scheme="https://whitestore.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Obsidian Day-Planner 插件新版本使用（0.7.X以上版本）</title>
    <link href="https://whitestore.top/2023/09/06/obsidiandayplan/"/>
    <id>https://whitestore.top/2023/09/06/obsidiandayplan/</id>
    <published>2023-09-06T03:10:21.000Z</published>
    <updated>2023-09-09T00:53:49.932Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>这几天把 <strong>Obsidian</strong> 和<strong>Day-Planner</strong>插件做了升级，突然发现原来的<strong>时间视图</strong>不见了。</p><p>起初个人认为是新版本的Obsidian和插件不兼容，于是选择换成旧版本，后来看了一眼<strong>Day-Planner</strong>更新日志，才发现原来作者基本把插件重做了。</p><p>更新之后的<strong>Day-Planner</strong>插件和旧版本差别挺大，个人花了不少时间熟悉新版本，本文将介绍如何快速使用和适应新版本的<strong>Day-Planner</strong>插件。</p><a id="more"></a><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2l2YW4tbGVkbmV2L29ic2lkaWFuLWRheS1wbGFubmVy" title="https://github.com/ivan-lednev/obsidian-day-planner">GitHub - ivan-lednev/obsidian-day-planner: An Obsidian plugin for day planning and managing pomodoro timers from a task list in a Markdown note.<i class="fa fa-external-link"></i></span></p><h2 id="简单说明"><a href="#简单说明" class="headerlink" title="简单说明"></a>简单说明</h2><blockquote><p>0.7.0 significantly changes what the plugin looks like and what it does. If you like to have some of the old behaviors back, <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2l2YW4tbGVkbmV2L29ic2lkaWFuLWRheS1wbGFubmVyL2lzc3Vlcw==" title="https://github.com/ivan-lednev/obsidian-day-planner/issues">consider creating an issue<i class="fa fa-external-link"></i></span>.</p><p>If for some reason you still want to use the old version, there are community forks, which you can use via <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1RmVEhhY2tlci9vYnNpZGlhbjQyLWJyYXQ=" title="https://github.com/TfTHacker/obsidian42-brat">BRAT<i class="fa fa-external-link"></i></span>. <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2VidWxsaWVudC9vYnNpZGlhbi1kYXktcGxhbm5lci1vZw==" title="https://github.com/ebullient/obsidian-day-planner-og">Here is one such fork<i class="fa fa-external-link"></i></span>.</p></blockquote><p>Github的README部分说的很清楚了，作者在 0.7.X 之后对于 Day-Planner 插件的功能和界面进行<strong>重做</strong>，基本可以当做一个新插件使用。</p><p>如果习惯老版本的使用方式，可以进入下面的网站下载之后进行手动安装。</p><blockquote><p>这也意味着旧版本做任何扩展和维护</p></blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2VidWxsaWVudC9vYnNpZGlhbi1kYXktcGxhbm5lci1vZw==" title="https://github.com/ebullient/obsidian-day-planner-og">GitHub - ebullient/obsidian-day-planner-og: An Obsidian plugin for day planning and managing pomodoro timers from a task list in a Markdown note.<i class="fa fa-external-link"></i></span></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230905105427.png" alt="image.png"></p><h1 id="新版本如何使用？"><a href="#新版本如何使用？" class="headerlink" title="新版本如何使用？"></a>新版本如何使用？</h1><p>下面来看下新版本插件的使用流程。</p><h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>新版本的Day-Planner通过左侧的菜单栏访问：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230905120656.png" alt="image.png"></p><p>点击进入，发现这是一个“周计划”视图：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230905120752.png" alt="image.png"></p><p>功能设计有点类似 IOS系统的 的日历视图，在任意的时间轴可以做自己的时间规划，比如我们选择在 “<strong>9月4日的8点设置出门</strong>”：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230905121029.png" alt="image.png"></p><p>点击对应的时间区间，插件会在选中的区间生成“item”。</p><blockquote><p>注意下面的界面“New Item”可以上下拖动。</p></blockquote><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230905121153.png" alt="image.png"></p><p>它的时间范围对应如下，作者的设计思路是：“<strong>一个Item为半小时</strong>”，在周计划界面拖动 Item 也是<strong>以固定半小时的间隔动态调整</strong>。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230905121231.png" alt="image.png"></p><p>注意，它并没有（个人期望的）通过拖动“一长段”时间设置1到两个小时或者更长时间的规划，希望作者后续更新可以加入这项功能。</p><p>以上就是对于新版本插件的简单快速上手，说实话半小时的设置操作不是很方便，个人做了一些直接可以复制粘贴的<strong>每日规划模板</strong>，只需要按照所需的日志一键粘贴就可以快速上手内容，个人习惯是一小时为“一段”，分割一天为24份，具体效果可以继续阅读下文。</p><h2 id="个人模板"><a href="#个人模板" class="headerlink" title="个人模板"></a>个人模板</h2><h3 id="旧版本"><a href="#旧版本" class="headerlink" title="旧版本"></a>旧版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#日记</span><br><span class="line"></span><br><span class="line">## 每日记录模板</span><br><span class="line"></span><br><span class="line">- [ ] 06:00 - 07:00 </span><br><span class="line">- [ ] 07:00 - 08:00</span><br><span class="line">- [ ] 08:00 - 09:00</span><br><span class="line">- [ ] 09:00 - 10:00</span><br><span class="line">- [ ] 10:00 - 11:00</span><br><span class="line">- [ ] 11:00 - 12:00</span><br><span class="line">- [ ] 12:00 - 13:00</span><br><span class="line">- [ ] 13:00 - 14:00</span><br><span class="line">- [ ] 14:00 - 15:00</span><br><span class="line">- [ ] 15:00 - 16:00</span><br><span class="line">- [ ] 16:00 - 17:00</span><br><span class="line">- [ ] 17:00 - 18:00</span><br><span class="line">- [ ] 18:00 - 19:00</span><br><span class="line">- [ ] 19:00 - 20:00</span><br><span class="line">- [ ] 20:00 - 21:00</span><br><span class="line">- [ ] 21:00 - 22:00</span><br><span class="line">- [ ] 22:00 - 23:00</span><br><span class="line"></span><br><span class="line"># 规划</span><br><span class="line"></span><br><span class="line"># 输入</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line"></span><br><span class="line"># 专注详情</span><br></pre></td></tr></table></figure><h3 id="新版本"><a href="#新版本" class="headerlink" title="新版本"></a>新版本</h3><p>新版本的出现导致旧模板也需要做更新，对应新版本的插件做了下面的微调：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#日记</span><br><span class="line"># Day planner</span><br><span class="line"></span><br><span class="line">-  06:00 - 07:00 </span><br><span class="line">-  07:00 - 08:00</span><br><span class="line">-  08:00 - 09:00</span><br><span class="line">-  09:00 - 10:00</span><br><span class="line">- 10:00 - 11:00</span><br><span class="line">-  11:00 - 12:00</span><br><span class="line">- 12:00 - 13:00</span><br><span class="line">-  13:00 - 14:00</span><br><span class="line">- 14:00 - 15:00</span><br><span class="line">- 15:00 - 16:00</span><br><span class="line">- 16:00 - 17:00</span><br><span class="line">- 17:00 - 18:00</span><br><span class="line">- 18:00 - 19:00</span><br><span class="line">- 19:00 - 20:00</span><br><span class="line">- 20:00 - 21:00</span><br><span class="line">- 21:00 - 22:00</span><br><span class="line">-  22:00 - 23:00</span><br><span class="line"></span><br><span class="line"># 规划</span><br><span class="line"></span><br><span class="line"># 输入</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line"></span><br><span class="line"># 专注详情</span><br></pre></td></tr></table></figure><p>上面的内容复制黏贴到对应日期文件，就可以在对应的日期指定一个“基础模板”，当然从截图看效果怪怪的，其实只要根据自己的需要填写内容即可正常显示：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230905120752.png" alt="image.png"></p><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>需要注意，如果读者想修改上面提供自定义模板内容，顶部的<code># Day planner</code>这样的一级标题是必须要保留的，<strong>不能做任何调整</strong>。</p><p>为了方便理解，直接看下面两张图对比：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230905115513.png" alt="image.png"></p><p><code># Day planner</code>可以修改为多级标题，但是<code># Day planner</code>这个“关键词”的本身的文本不能做任何变更，否则就变成下面这样“诡异”的情况：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230905115437.png" alt="image.png"></p><p>这样的设计也可以理解，顺着作者的设计规划自己的模板即可。</p><h2 id="Ctrl-P-变化"><a href="#Ctrl-P-变化" class="headerlink" title="Ctrl + P 变化"></a>Ctrl + P 变化</h2><p>如果使用过旧版本Day-Planner，我们可以在<code>Obsidian</code>中使用<code>ctrl + P</code>的快捷按钮做快捷操作，没错，新版本插件这里的功能按钮也完全不一样了。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230905111854.png" alt="image.png"></p><p>下面按照从上往下的顺序，介绍截图每一项快捷指令的作用。</p><h3 id="1-展示本周的时间视图规划。"><a href="#1-展示本周的时间视图规划。" class="headerlink" title="1. 展示本周的时间视图规划。"></a>1. 展示本周的时间视图规划。</h3><ul><li><p>优点：和点击左边的按钮效果相同，优点是不需要动用鼠标靠键盘就可以快速访问 =v=。</p></li><li><p>缺点：会覆盖当前<code>Tab</code>，个人更希望新开<code>Tab</code>展示。</p><h3 id="2-进入当天的Day-Planner"><a href="#2-进入当天的Day-Planner" class="headerlink" title="2. 进入当天的Day-Planner"></a>2. 进入当天的Day-Planner</h3></li><li><p>PS：旧版本是在 Day Planners 的文件夹下面每日自动创建。</p></li><li><p>新版本：如果发现对应日期的md文件不存在，默认会在<code>Obsidian</code>的仓库 <strong>根目录</strong> 创建一个新的文件，命名格式如下：</p></li></ul><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230905112419.png" alt="2. 进入当天的Dat-Planner"></p><h3 id="3-展示时间线"><a href="#3-展示时间线" class="headerlink" title="3. 展示时间线"></a>3. 展示时间线</h3><p>第三个选项是时间线展示，选择之后<code>Obsidian</code>右边的视窗多一个“选项”，这样就可以看到<strong>当天的时间线</strong>（新版本外观重做了）：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230905113547.png" alt="image.png"></p><p>左右箭头是切换当前日期的上一天和下一天，右上角的按钮可以选择：</p><ul><li><p><strong>调节当前时间线的间隔</strong>。比如个人设置了Zoom的等级为1，整个时间线的间隔会窄一些。</p></li><li><p><strong>是否自动滚动到当前的时间点</strong>，假设现在7点50，就会自动定位到7点-8点这个时间段。</p></li></ul><blockquote><p>选择自动滚动，时间线会随着当前时间自动滚动定位：</p></blockquote><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230905113723.png" alt="image.png"></p><h3 id="4-插入-Day-planner"><a href="#4-插入-Day-planner" class="headerlink" title="4. 插入 Day planner"></a>4. 插入 Day planner</h3><p>效果就是在<strong>当前的光标位置插入一个“Day planner” 的一级标题</strong>。</p><p>比如下面这样的效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#Day planner</span><br></pre></td></tr></table></figure><p>个人认为这个选项没什么用，模板赋值粘贴更为方便。</p><h3 id="5-进入当天的日期视图"><a href="#5-进入当天的日期视图" class="headerlink" title="5. 进入当天的日期视图"></a>5. 进入当天的日期视图</h3><p>最后一项就是进入到当天的日期视图，也是一个快捷操作。</p><h2 id="设置变化"><a href="#设置变化" class="headerlink" title="设置变化"></a>设置变化</h2><p>新版本插件的设置基本全默认即可，个人的调整为：变更 Zoom Level=1，把第一项做了选中，其他基本保持原样。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230905122240.png" alt="image.png"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>新版本的 Day-Planner 整体上比较容易上手，比起旧版本要实用不少，希望作者后续继续更新。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230905114923.png" alt="image.png"></p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>与时俱进，个人认为旧版本<strong>记录每一天的时间流</strong>不利于做个人规划，很容易变成流水账，个人还需要额外借助<strong>时间序</strong>或者<strong>滴答清单</strong>这样的软件，做一周或者更长时间的时间规划。</p><p>新版本把整个插件重做，贴合了目前大部分时间管理APP的风格，整个界面十分的简洁直观，当然目前的插件不是很完善，希望作者后续可以继续改进操作。</p><p>从个人角度来看，本次插件“换代”最大意义是，类似滴答清单这样需要付费高级会员才能体验“日历视图”，在 Day-Planner 是完全免费的，白嫖党表示非常Nice。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230905105639.png" alt="image.png"></p><p>总而言之，这次更新非常香。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      Obsidian 使用
    
    </summary>
    
    
      <category term="其他" scheme="https://whitestore.top/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="其他" scheme="https://whitestore.top/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>【Java】Garbage Collection Logging to a File in Java</title>
    <link href="https://whitestore.top/2023/09/04/engctojava/"/>
    <id>https://whitestore.top/2023/09/04/engctojava/</id>
    <published>2023-09-04T06:35:23.000Z</published>
    <updated>2023-09-09T00:53:49.934Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFlbGR1bmcuY29tL2phdmEtZ2MtbG9nZ2luZy10by1maWxl" title="https://www.baeldung.com/java-gc-logging-to-file">https://www.baeldung.com/java-gc-logging-to-file<i class="fa fa-external-link"></i></span></p><h2 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFlbGR1bmcuY29tL2phdmEtZ2MtbG9nZ2luZy10by1maWxlI292ZXJ2aWV3" title="https://www.baeldung.com/java-gc-logging-to-file#overview">1. Overview<i class="fa fa-external-link"></i></span></h2><p>Garbage collection is a marvel of the Java programming language providing us with automatic memory management. </p><p>垃圾回收是 Java 编程语言的一个奇迹，它为我们提供了自动内存管理功能。</p><p>Garbage collection hides the details of having to manually allocate and deallocate memory. </p><p>垃圾回收隐藏了手动分配和删除内存的细节。</p><p>While this mechanism is fantastic, sometimes it doesn’t work the way we want. </p><p>虽然这种机制非常好，但有时并不能如我们所愿。</p><p>In this tutorial, we’ll explore Java’s <strong>logging options for garbage collection statistics</strong> and discover how to <strong>redirect these statistics to a file</strong>.</p><p>在本教程中，我们将探索 Java 的<strong>垃圾收集统计日志选项</strong>，并了解如何<strong>将这些统计信息重定向到文件</strong>。</p><a id="more"></a><h2 id="2-GC-Logging-Flags-in-Java-8-and-Earlier"><a href="#2-GC-Logging-Flags-in-Java-8-and-Earlier" class="headerlink" title="2. GC Logging Flags in Java 8 and Earlier"></a>2. GC Logging Flags in Java 8 and Earlier<a href="https://www.baeldung.com/java-gc-logging-to-file#gc-logging-flags-in-java-8-and-earlier" target="_blank" rel="noopener"></a></h2><p>First, let’s explore the JVM flags relating to GC logging in Java versions prior to Java 9.</p><p>首先，让我们探讨 Java 9 之前的 Java 版本中与 GC 日志相关的 JVM 标志。</p><h3 id="2-1-XX-PrintGC"><a href="#2-1-XX-PrintGC" class="headerlink" title="2.1. -XX:+PrintGC"></a><a href="https://www.baeldung.com/java-gc-logging-to-file#1--xxprintgc" target="_blank" rel="noopener">2.1. <em>-XX:+PrintGC</em></a></h3><p>The <em>-XX:+PrintGC</em> flag is an alias for <em>-verbose:gc</em> and <strong>turns on basic GC logging</strong>. </p><p><em>-XX:+PrintGC</em> 标志是_-verbose:gc_的别名，作用是<strong>开启基本的 GC 日志</strong>。</p><p>In this mode, a single line is printed for every young-generation and every full-generation collection. </p><p>在这个模式中，每个年轻代和完整代的收集操作都会打印一行。</p><p>Let’s now turn our attention to providing detailed GC information.</p><p>现在，让我们把注意力转向提供详细的 GC 信息。</p><h3 id="2-2-XX-PrintGCDetails"><a href="#2-2-XX-PrintGCDetails" class="headerlink" title="2.2. -XX:+PrintGCDetails"></a><a href="https://www.baeldung.com/java-gc-logging-to-file#2--xxprintgcdetails" target="_blank" rel="noopener">2.2. <em>-XX:+PrintGCDetails</em></a></h3><p>Similarly, we have the flag <em>-XX:+PrintGCDetails</em> used to <strong>activate detailed GC logging</strong> instead of <em>-XX:+PrintGC</em>.</p><p>同样，我们使用标记 <em>-XX:+PrintGCDetails</em> 来<strong>激活详细的 GC 日志</strong>，而不是 _-XX:+PrintGC_。</p><p>Note that the output from <em>-XX:+PrintGCDetails</em> changes depending on the GC algorithm in use.</p><blockquote><p>请注意，<em>-XX:+PrintGCDetails</em> 的输出会根据使用的 GC 算法而改变。</p></blockquote><p>Next, we’ll look at annotating our logs with date and time information.</p><blockquote><p>接下来，我们将了解如何用日期和时间信息来注释日志。</p></blockquote><h3 id="2-3-XX-PrintGCDateStamps-and-XX-PrintGCTimeStamps"><a href="#2-3-XX-PrintGCDateStamps-and-XX-PrintGCTimeStamps" class="headerlink" title="2.3. -XX:+PrintGCDateStamps and -XX:+PrintGCTimeStamps"></a><a href="https://www.baeldung.com/java-gc-logging-to-file#3--xxprintgcdatestamps-and--xxprintgctimestamps" target="_blank" rel="noopener">2.3. <em>-XX:+PrintGCDateStamps</em> and <em>-XX:+PrintGCTimeStamps</em></a></h3><p>We can <strong>add dates and timing information to our GC logs</strong> by utilizing the flags <em>-XX:+PrintGCDateStamps</em> and <em>-XX:+PrintGCTimeStamps</em>, respectively.</p><p>我们可以分别利用标记 <em>-XX:+PrintGCDateStamps</em> 和 <em>-XX:+PrintGCTimeStamps</em> 在 GC 日志中**添加日期和时间信息。</p><p>First, <em>-XX:+PrintGCDateStamps</em> adds the date and time of the log entry to the beginning of each line.</p><p>首先，<em>-XX:+PrintGCDateStamps</em> 会在每行开头添加日志条目的日期和时间。</p><p>Second, <em>-XX:PrintGCTimeStamps</em> adds a timestamp to every line of the log detailing the time passed (in seconds) since the JVM was started.</p><p>其次，<em>-XX:PrintGCTimeStamps</em> 会在日志的每一行添加一个时间戳，详细记录 JVM 启动后的时间（以秒为单位）。</p><h3 id="2-4-Xloggc"><a href="#2-4-Xloggc" class="headerlink" title="2.4. -Xloggc"></a><a href="https://www.baeldung.com/java-gc-logging-to-file#4--xloggc" target="_blank" rel="noopener">2.4. <em>-Xloggc</em></a></h3><p>Finally, we come to <strong>redirecting the GC log to a file</strong>. </p><p>最后，我们来<strong>将 GC 日志重定向到文件</strong>。</p><p>This flag takes an optional filename as an argument using the syntax <em>-Xloggc:file</em> and without the presence of a file name the GC log is written to standard out.</p><p>该标志使用 <em>-Xloggc:file</em> 语法将一个可选的文件名作为参数，如果没有文件名，GC 日志将被写入标准输出。</p><p>Additionally, this flag also sets the <em>-XX:PrintGC</em> and <em>-XX:PrintGCTimestamps</em> flags for us. Let’s look at some examples:</p><p>此外，该标记还会为我们设置 <em>-XX:PrintGC</em> 和 <em>-XX:PrintGCTimestamps</em> 标记。让我们来看几个例子：</p><p>If we want to write the GC log to standard output, we can run:</p><p>如果我们想将 GC 日志写入标准输出，可以运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp <span class="variable">$CLASSPATH</span> -Xloggc mypackage.MainClass</span><br></pre></td></tr></table></figure><p>Or to write the GC log to a file, we would run:</p><p>如果要写入GC日志到一个文件，使用下面参数</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp <span class="variable">$CLASSPATH</span> -Xloggc:/tmp/gc.log mypackage.MainClass</span><br></pre></td></tr></table></figure><h2 id="3-GC-Logging-Flags-in-Java-9-and-Later"><a href="#3-GC-Logging-Flags-in-Java-9-and-Later" class="headerlink" title="3. GC Logging Flags in Java 9 and Later"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFlbGR1bmcuY29tL2phdmEtZ2MtbG9nZ2luZy10by1maWxlI2djLWxvZ2dpbmctZmxhZ3MtaW4tamF2YS05LWFuZC1sYXRlcg==" title="https://www.baeldung.com/java-gc-logging-to-file#gc-logging-flags-in-java-9-and-later">3. GC Logging Flags in Java 9 and Later<i class="fa fa-external-link"></i></span></h2><p>In Java 9+, <em>-XX:PrintGC</em>, the alias for <em>-verbose:gc</em>, has been deprecated in favor of the <strong>unified logging option, <em>-Xlog</em></strong>. </p><p>Java9+ 的版本，<em>-Xlog</em> 取代了  <em>-XX:PrintGC</em> 和别名 _-verbose:gc_，此前的两个参数均已经标记为“已弃用”</p><p>All other GC flags mentioned above are still valid in Java 9+. </p><p>当然，虽然被标记弃用，但是上述所有其他 GC 标志在 Java 9+ 中仍然有效。</p><p>This new logging option allows us to <strong>specify which messages should be shown, set the log level, and redirect the output</strong>.</p><p>这个新的日志选项允许我们<strong>指定应显示哪些信息、设置日志级别和重定向输出</strong>。</p><p>We can run the below command to see all the available options for log levels, log decorators, and tag sets:</p><p>我们可以使用下面的命令查看所有可用的参数，比如日志等级，日志装饰器和标记集：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xlog:logging=debug -version</span><br></pre></td></tr></table></figure><p>For example, if we wanted to log all GC messages to a file, we would run:</p><p>如果我们想要记录GC日志到一个外部文件，可以使用下面的启动参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp <span class="variable">$CLASSPATH</span> -Xlog:gc*=debug:file=/tmp/gc.log mypackage.MainClass</span><br></pre></td></tr></table></figure><p>Additionally, this new unified logging flag is repeatable, so you can, for example, <strong>log all GC messages to both standard out and a file</strong>:</p><p>此外，这一新的统一日志标记（-Xlog:gc）是可重复的，因此您可以<strong>将所有 GC 消息同时记录到标准输出和文件</strong>中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp <span class="variable">$CLASSPATH</span> -Xlog:gc*=debug:stdout -Xlog:gc*=debug:file=/tmp/gc.log mypackage.MainClass</span><br></pre></td></tr></table></figure><h2 id="4-Conclusion"><a href="#4-Conclusion" class="headerlink" title="4. Conclusion"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFlbGR1bmcuY29tL2phdmEtZ2MtbG9nZ2luZy10by1maWxlI2NvbmNsdXNpb24=" title="https://www.baeldung.com/java-gc-logging-to-file#conclusion">4. Conclusion<i class="fa fa-external-link"></i></span></h2><p>In this article, we’ve shown how to log garbage collection output in both Java 8 and Java 9+ including how to redirect that output to a file.</p><p>本节内容展示了开启收集打印日志在JDK8和JDK9+的区别，包括如何将输出重定向到文件等操作。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      gc
    
    </summary>
    
    
      <category term="Java" scheme="https://whitestore.top/categories/Java/"/>
    
    
      <category term="Java" scheme="https://whitestore.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Zookeeper】Apach Curator 框架源码分析：后台构造器和节点操作相关源码分析（二）【Ver 4.3.0】</title>
    <link href="https://whitestore.top/2023/08/10/curatorsource2/"/>
    <id>https://whitestore.top/2023/08/10/curatorsource2/</id>
    <published>2023-08-10T09:00:47.000Z</published>
    <updated>2023-09-09T00:53:49.937Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>本文介绍后台任务延迟队列的“元素” <strong>后台任务构造器</strong> 以及Curator 对于常见的ZK节点操作封装API。<strong>后台任务构造器</strong>对应了和ZK交互的常见”后台“操作，比如创建和销毁Watch，而ZK节点操作API涉及各种建造者模式的应用。可以说，Curator 整个框架各种地方都有建造者模式的身影。</p><p><code>Curator</code> 除了对于ZK本身交互和操作封装之外，还引入了<strong>Cache</strong>的概念来实现对ZooKeeper服务器端进行事件监听，本质上就是构建本地缓存，在远程节点出现”状态“变动的时候进行”联动“触发各种事件。</p><p>不过，<code>Cache</code> 的部分个人认为并不是很重要的内容，更多重心还是在分布式锁，再加上查询各种资料本身应用场景也比较少，因此放到了文章最后分析，读者可以按需阅读。</p><a id="more"></a><h1 id="相关应用场景和重要概念"><a href="#相关应用场景和重要概念" class="headerlink" title="相关应用场景和重要概念"></a>相关应用场景和重要概念</h1><p>本文的源码分析涉及到 ZK 的应用场景和重要概念，这里先补充相关概念，为后面的源码分析铺垫。</p><h2 id="相关应用场景"><a href="#相关应用场景" class="headerlink" title="相关应用场景"></a>相关应用场景</h2><p>ZK 中可以完成数据发布订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举，分布式锁和分布式队列。</p><p><strong>命名服务</strong>： 使用 ZooKeeper 的顺序节点生成全局唯一 ID。</p><p><strong>数据发布/订阅</strong>：通过 <strong>Watcher 机制</strong> 可以很方便地实现数据发布/订阅。</p><p><strong>分布式锁</strong>：通过创建唯一节点获得分布式锁，通常会使用临时节点的方式持有锁，特点是在节点宕机之后会自动释放。</p><h2 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h2><h3 id="ZNode-概念"><a href="#ZNode-概念" class="headerlink" title="ZNode 概念"></a>ZNode 概念</h3><p><code>Zookeeper</code> 的数据模型使用的是多叉树结构，每个节点上面可以存储任意类型的数据，比如数组、字符串、二进制序列，由于是树状节点，每个节点还可以有子节点。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230713133555.png" alt="image.png"></p><blockquote><p>注意 ZNode 通常用于临时创建，适合用于比较小体积的锁应用，不建议存储过大的业务数据，不要把过大的数据放到 ZNode上。</p></blockquote><h3 id="ZNode-数据节点"><a href="#ZNode-数据节点" class="headerlink" title="ZNode 数据节点"></a>ZNode 数据节点</h3><p>Zookeeper 的数据节点 ZNode 是最小组成单元，ZNode 是 ZK 实现分布式锁的重要基础，它主要有如下分类：</p><ul><li><strong>持久（PERSISTENT）节点</strong>：一旦创建就会一直存在，直到 ZK集群宕机才会删除。</li><li><strong>临时（EPHEMERAL）节点</strong>：临时节点的生命周期是与 <strong>客户端会话（session）</strong> 绑定，会话消失则节点消失，</li><li><strong>持久顺序（PERSISTENT_SEQUENTIAL）节点</strong>：在持久节点的特性上，子节点的名称依然有顺序性，比如 <code>/node1/app0000000001</code>、<code>/node1/app0000000002</code> 。</li><li><strong>临时顺序（EPHEMERAL_SEQUENTIAL）节点</strong>：除了具备临时（EPHEMERAL）节点的特性之外，子节点的名称还具有顺序性。</li></ul><h2 id="Watcher（事件监听器）"><a href="#Watcher（事件监听器）" class="headerlink" title="Watcher（事件监听器）"></a>Watcher（事件监听器）</h2><p><strong>Watcher</strong> 事件监听器是 Zookeeper 当中非常重要的特性，ZK 允许用户在指定的 Znode 上面注册监听器 Watcher，特定的事件触发时候，ZK服务端会把事件通知到注册Watcher的客户端,。事件监听器也是分布式协调服务的重要组成部分。</p><blockquote><p>在 Curator 中，Watcher 事件监听器是不同客户端监听分布式锁释放的重要应用组件。</p></blockquote><h1 id="ZK可视化客户端-PrettyZoo"><a href="#ZK可视化客户端-PrettyZoo" class="headerlink" title="ZK可视化客户端 PrettyZoo"></a>ZK可视化客户端 PrettyZoo</h1><p>为了方便我们调试源码的同时观察ZK节点变更，这里推荐使用 <strong>PrettyZoo</strong> 客户端。</p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3ZyYW4tZGV2L1ByZXR0eVpvbw==" title="https://github.com/vran-dev/PrettyZoo">PrettyZoo<i class="fa fa-external-link"></i></span> 是一个基于 Apache Curator 和 JavaFX 实现的 Zookeeper 图形化管理客户端。使用了 Java 的模块化（Jigsaw）技术，并基于 JPackage 打包了多平台的可运行文件（无需要额外安装 Java 运行时）。</p><p>目前已提供了 mac（dmg 文件）、Linux（deb 和 rpm 文件）、windows（msi 文件） 的安装包，<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3ZyYW4tZGV2L1ByZXR0eVpvby9yZWxlYXNlcw==" title="https://github.com/vran-dev/PrettyZoo/releases">下载地址<i class="fa fa-external-link"></i></span>。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230713143622.png" alt="image.png"></p><p>个人为Win系统，选择<code>win.msi</code> 的安装包，安装并启动并且就进入到主页面</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230713144539.png" alt="image.png"></p><p>完成配置之后进行连接，最终的连接效果如图：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230713144757.png" alt="image.png"></p><p>前面的铺垫已经完成，下面正式进入主题。</p><h1 id="后台任务构造器"><a href="#后台任务构造器" class="headerlink" title="后台任务构造器"></a>后台任务构造器</h1><p>在[[【Zookeeper】Apach Curator 框架源码分析：初始化过程（一）【Ver 4.3.0】]]当中，我们介绍了Curator实例化、Zookeeper连接以及各种组件初始化和启动过程，其中就有一个后台执行操作队列不断执行后台操作。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230720062506.png" alt="image.png"></p><p><strong>OperationAndData</strong>中的 <strong>BackgroundOperation</strong> ，封装各种常见ZK指令的构造器。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230703204542.png" alt="image.png"></p><p>下面以 <strong>BackgroundOperation</strong> 作为切入点，看看它的构造器是如何实现的？</p><h2 id="后台操作接口-BackgroundOperation-lt-T-gt"><a href="#后台操作接口-BackgroundOperation-lt-T-gt" class="headerlink" title="后台操作接口 BackgroundOperation&lt; T &gt;"></a>后台操作接口 BackgroundOperation&lt; T &gt;</h2><p><strong>BackgroundOperation</strong> 是后台操作接口的 <strong>顶级接口</strong>，其中只有一个方法，它接收 <strong>OperationAndData</strong> 作为请求参数。</p><p><strong>org.apache.curator.framework.imps.BackgroundOperation</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">BackgroundOperation</span>&lt;<span class="title">T</span>&gt;  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performBackgroundOperation</span><span class="params">(OperationAndData&lt;T&gt; data)</span> <span class="keyword">throws</span> Exception</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种设计让我联想到 Executor 的设计（略显牵强），Runnable 是线程的执行操作分离抽象，与之对应的<code>OperationAndData</code>是对于后台操作的抽象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;  </span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后台事件数据对象-OperationAndData"><a href="#后台事件数据对象-OperationAndData" class="headerlink" title="后台事件数据对象 OperationAndData"></a>后台事件数据对象 OperationAndData</h2><p><strong>org.apache.curator.framework.imps.OperationAndData</strong></p><p>OperationAndData 对象的代码略多，这里拆分介绍，首先来看下继承结构， <strong>OperationAndData</strong> 最终被存储在<strong>后台线程执行的操作队列backgroundOperations</strong>，backgroundOperations使用JDK原生并发延迟队列<strong>DelayQueue</strong>作为基础。</p><p>按照 <strong>DelayQueue</strong> 的设计存储要求，内部元素必须实现<code>Delayed</code>接口以支持延迟操作，除此之外， OperationAndData 还实现了 <strong>RetrySleeper</strong> 接口，从英文名称也可以大致猜出它是 <strong>对重试政策的抽象化</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OperationAndData</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Delayed</span>, <span class="title">RetrySleeper</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后台线程执行的操作队列</span></span><br><span class="line">backgroundOperations = <span class="keyword">new</span> DelayQueue&lt;OperationAndData&lt;?&gt;&gt;();</span><br></pre></td></tr></table></figure><p>下面来看下相关成员变量定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">初始化为0，每执行一次 reset() 重置，此计数器的值会+1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong nextOrdinal = <span class="keyword">new</span> AtomicLong();  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">BackgroundOperation 相关引用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BackgroundOperation&lt;T&gt; operation;  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">后台操作的相关对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> T data;  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">异步后台操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BackgroundCallback callback;  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">执行开始时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> startTimeMs = System.currentTimeMillis();  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">错误回调</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ErrorCallback&lt;T&gt; errorCallback;  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">重试次数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger retryCount = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">休眠时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicLong sleepUntilTimeMs = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">执行顺序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicLong ordinal = <span class="keyword">new</span> AtomicLong();  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">上下文</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object context;  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">需要连接</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> connectionRequired;</span><br></pre></td></tr></table></figure><p>重要的方法如下，执行后台操作就是调用<code>operation.performBackgroundOperation(this);</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callPerformBackgroundOperation</span><span class="params">()</span> <span class="keyword">throws</span> Exception  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    operation.performBackgroundOperation(<span class="keyword">this</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>BackgroundOperation</strong> 的实现类非常多。这里举几个例子。</p><p><strong>BackgroundSyncImpl</strong></p><p>从单词意思来看，这个实现是负责后台同步的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BackgroundSyncImpl</span> <span class="keyword">implements</span> <span class="title">BackgroundOperation</span>&lt;<span class="title">String</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CuratorFrameworkImpl client;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object context;</span><br><span class="line"></span><br><span class="line">    BackgroundSyncImpl(CuratorFrameworkImpl client, Object context)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performBackgroundOperation</span><span class="params">(<span class="keyword">final</span> OperationAndData&lt;String&gt; operationAndData)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> OperationTrace trace = client.getZookeeperClient().startAdvancedTracer(<span class="string">"BackgroundSyncImpl"</span>);</span><br><span class="line">        <span class="keyword">final</span> String data = operationAndData.getData();</span><br><span class="line">        client.getZooKeeper().sync</span><br><span class="line">        (</span><br><span class="line">            data,</span><br><span class="line">            <span class="keyword">new</span> AsyncCallback.VoidCallback()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx)</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                    trace.setReturnCode(rc).setRequestBytesLength(data).commit();</span><br><span class="line">                    CuratorEventImpl event = <span class="keyword">new</span> CuratorEventImpl(client, CuratorEventType.SYNC, rc, path, <span class="keyword">null</span>, ctx, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                    client.processBackgroundOperation(operationAndData, event);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            context</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过构造<code>CuratorEventImpl</code>实现类，把<code>operationAndData</code>和<code>event</code>事件传给<code>CuratorFrameworkImpl</code>。</p><p><strong>RemoveWatchesBuilderImpl</strong></p><p><strong>RemoveWatchesBuilderImpl</strong>定义了删除<code>Watcher</code>监听器的后台操作，简单看下相关代码实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoveWatchesBuilderImpl</span> <span class="keyword">implements</span> <span class="title">RemoveWatchesBuilder</span>, <span class="title">RemoveWatchesType</span>, <span class="title">RemoveWatchesLocal</span>, <span class="title">BackgroundOperation</span>&lt;<span class="title">String</span>&gt;, <span class="title">ErrorListenerPathable</span>&lt;<span class="title">Void</span>&gt;  </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> CuratorFrameworkImpl client;</span><br><span class="line">    <span class="keyword">private</span> Watcher watcher;</span><br><span class="line">    <span class="keyword">private</span> CuratorWatcher curatorWatcher;</span><br><span class="line">    <span class="keyword">private</span> WatcherType watcherType;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> guaranteed;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> local;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> quietly;    </span><br><span class="line">    <span class="keyword">private</span> Backgrounding backgrounding;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performBackgroundOperation</span><span class="params">(<span class="keyword">final</span> OperationAndData&lt;String&gt; operationAndData)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">final</span> TimeTrace   trace = client.getZookeeperClient().startTracer(<span class="string">"RemoteWatches-Background"</span>);</span><br><span class="line"></span><br><span class="line">            AsyncCallback.VoidCallback callback = <span class="keyword">new</span> AsyncCallback.VoidCallback()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx)</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                    trace.commit();</span><br><span class="line">                    CuratorEvent event = <span class="keyword">new</span> CuratorEventImpl(client, CuratorEventType.REMOVE_WATCHES, rc, path, <span class="keyword">null</span>, ctx, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                    client.processBackgroundOperation(operationAndData, event);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            ZooKeeper zkClient = client.getZooKeeper();</span><br><span class="line">            <span class="comment">// 命名空间 Watch </span></span><br><span class="line">            NamespaceWatcher namespaceWatcher = makeNamespaceWatcher(operationAndData.getData());</span><br><span class="line">            <span class="keyword">if</span>(namespaceWatcher == <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="comment">// ZK 客户端移除 Watch </span></span><br><span class="line">                zkClient.removeAllWatches(operationAndData.getData(), watcherType, local, callback, operationAndData.getContext());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                zkClient.removeWatches(operationAndData.getData(), namespaceWatcher, watcherType, local, callback, operationAndData.getContext());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> ( Throwable e )</span><br><span class="line">        &#123;</span><br><span class="line">            backgrounding.checkError(e, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="执行后台事件-CuratorFrameworkImpl-processBackgroundOperation"><a href="#执行后台事件-CuratorFrameworkImpl-processBackgroundOperation" class="headerlink" title="执行后台事件 CuratorFrameworkImpl#processBackgroundOperation"></a>执行后台事件 CuratorFrameworkImpl#processBackgroundOperation</h2><p>所有的后台任务操作都会回调Curator 实例<strong>CuratorFrameworkImpl</strong>的 <code>processBackgroundOperation</code>方法，下面简单分析相关方法细节。</p><p><strong>org.apache.curator.framework.imps.CuratorFrameworkImpl#processBackgroundOperation</strong></p><p>主要的逻辑如下：</p><ol><li>判断是否初次执行，初次执行会进行连接状态检查呵护后续的重试判断处理。</li><li>校验是否需要重试。</li><li>检查是否发送回调。</li><li>监听器事件回调通知（这里会进行事件通知回调）。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;DATA_TYPE&gt; <span class="function"><span class="keyword">void</span> <span class="title">processBackgroundOperation</span><span class="params">(OperationAndData&lt;DATA_TYPE&gt; operationAndData, CuratorEvent event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> isInitialExecution = (event == <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 如果是初次执行</span></span><br><span class="line"><span class="keyword">if</span> ( isInitialExecution )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 初次执行会进行连接状态检查呵护后续的重试判断处理</span></span><br><span class="line">performBackgroundOperation(operationAndData);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> doQueueOperation = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">do</span>                                                                                          </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 校验是否需要重试</span></span><br><span class="line"><span class="keyword">if</span> ( RetryLoop.shouldRetry(event.getResultCode()) )</span><br><span class="line">&#123;</span><br><span class="line">doQueueOperation = checkBackgroundRetry(operationAndData, event);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查是否发送回调</span></span><br><span class="line"><span class="keyword">if</span> ( operationAndData.getCallback() != <span class="keyword">null</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 发送后台回调</span></span><br><span class="line">sendToBackgroundCallback(operationAndData, event);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 监听器事件回调通知</span></span><br><span class="line">processEvent(event);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ( <span class="keyword">false</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( doQueueOperation )</span><br><span class="line">&#123;</span><br><span class="line">queueOperation(operationAndData);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>真心看不懂 while ( false );  这的写法=-=。</p></blockquote><p>以上简单分析了后台任务构造器以及如何执行，设计比较好懂，这里就不做过多分析了。</p><h1 id="Curator-节点操作"><a href="#Curator-节点操作" class="headerlink" title="Curator 节点操作"></a>Curator 节点操作</h1><h2 id="创建节点API"><a href="#创建节点API" class="headerlink" title="创建节点API"></a>创建节点API</h2><p>这里以个人阅读的 Curator 4.3.0 版本为例，创建节点的 API 涉及下面几个组件：</p><ul><li><strong>CuratorFramework</strong>：<ul><li><code>public CreateBuilder create();</code></li></ul></li><li><strong>CreateBuilder</strong>：<ul><li><code>public ProtectACLCreateModePathAndBytesable&lt;String&gt; createParentsIfNeeded();</code></li></ul></li><li><strong>CreateModable</strong>：<ul><li><code>public T withMode(CreateMode mode);</code></li></ul></li><li><strong>PathAndBytesable&lt; T&gt;</strong>：<ul><li><code>public T forPath(String path, byte[] data) throws Exception;</code></li><li><code>public T forPath(String path) throws Exception;</code></li></ul></li></ul><p>下面是几个常见的API使用Demo：</p><p><strong>创建一个节点，初始内容为空</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.create().forPath(path);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个节点，初始内容为空  </span></span><br><span class="line">client.create().forPath(<span class="string">"/tmp"</span>);</span><br></pre></td></tr></table></figure><p>从结果可以看到，<strong>如果没有设置节点属性，那么Curator默认创建的是持久节点</strong>。</p><p><strong>创建一个节点，附带初始内容</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个节点，附带初始内容  </span></span><br><span class="line">client.create().forPath(<span class="string">"/tmp"</span>, <span class="string">"init"</span>.getBytes());;</span><br></pre></td></tr></table></figure><p>和上面的区别就是在对应的节点写入内容，注意 Curator 使用了 Zookeeper 的原始API风格。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  KeeperErrorCode = NodeExists for /tmp</span></span><br></pre></td></tr></table></figure><p>由于上面已经创建过节点，这里创建节点出现报错，我们在Pretty客户端中执行删除节点操作。删除之后重新执行，”/tmp”节点被正确创建。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230713145410.png" alt="image.png"></p><p><strong>创建一个临时节点，初始内容为空</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.create().withMode(CreateMode.EPHEMERAL).forPath(path);</span><br></pre></td></tr></table></figure><p>临时节点属于会话级别，我们在编写Demo代码的时候，如果没有手动 close 客户端，那么服务端会判断客户端会在<strong>会话超时之后自动释放临时节点</strong>。</p><p>临时节点的好处是即使ZK集群宕机，也可以保证及时释放，防止锁长期占用，适合作为分布式锁设计使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个临时节点，初始内容为空  </span></span><br><span class="line">client.create().withMode(CreateMode.EPHEMERAL).forPath(<span class="string">"/temp"</span>);  </span><br><span class="line"><span class="comment">// 如果立即Close，那么临时节点会立即释放</span></span><br><span class="line">client.close();</span><br></pre></td></tr></table></figure><p>如果我们 close 客户端，那么临时节点的创建和销毁会立即触发，在 <strong>prettyZoo</strong> 看来就是“什么也没发送过”。</p><p><strong>创建一个临时节点，并自动递归创建父节点</strong></p><p>使用ZooKeeper的过程中，开发人员经常会碰到<strong>NoNodeException</strong>异常，其中一个可能的原因就是试图对一个不存在的父节点创建子节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 试图对一个不存在的父节点创建子节点  </span></span><br><span class="line">client.create().withMode(CreateMode.EPHEMERAL).forPath(<span class="string">"/temp/childNode"</span>);  </span><br><span class="line"><span class="comment">// 报错KeeperErrorCode = NoNode for /temp/childNode</span></span><br></pre></td></tr></table></figure><p>在使用Curator之后，通过调用<code>creatingParentsIfNeeded</code>接口，Curator就能够自动递归创建所有需要的父节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lient.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(path);</span><br></pre></td></tr></table></figure><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230713151258.png" alt="image.png"></p><h2 id="创建节点源码分析"><a href="#创建节点源码分析" class="headerlink" title="创建节点源码分析"></a>创建节点源码分析</h2><p>节点API的涉及都比较简单，<strong>CreateBuilder</strong> 的继承结构图如下：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230713142916.png" alt="image.png"></p><p><strong>CreateBuilder</strong> 的对应实现类为 <strong>CreateBuilderImpl</strong>，我们通过一串API调用Demo来简单分析构建过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(<span class="string">"/temp/childNode"</span>, <span class="string">"init"</span>.getBytes());</span><br></pre></td></tr></table></figure><p><strong>org.apache.curator.framework.imps.CuratorFrameworkImpl#create</strong></p><ol><li>检查ZK的连接状态。</li><li>new CreateBuilderImpl,，这里的 this 为 <strong>CuratorFrameworkImpl</strong> ，也就是client 客户端实例。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CreateBuilder <span class="title">create</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"><span class="comment">// 检查ZK的连接状态</span></span><br><span class="line">    checkState();  </span><br><span class="line">    <span class="comment">// new构造器, this 为 CuratorFrameworkImpl 也就是client 客户端实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CreateBuilderImpl(<span class="keyword">this</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>org.apache.curator.framework.imps.CreateBuilderImpl#creatingParentsIfNeeded</strong></p><p>下面代码的关键是<code>createParentsIfNeeded = true;</code>这一行，其他代码可以忽略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> ProtectACLCreateModeStatPathAndBytesable&lt;String&gt; <span class="title">creatingParentsIfNeeded</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    createParentsIfNeeded = <span class="keyword">true</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ProtectACLCreateModeStatPathAndBytesable&lt;String&gt;()  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>withMode(CreateMode.EPHEMERAL)</strong></p><p>这一部分属于ZK的客户端提供的，<strong>CreateMode</strong> 一般用的比较多的是<strong>临时节点</strong>。</p><p>具体使用这里不一一介绍，简单看下源码中的英文注释很容易理解不同模式的作用。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230713152956.png" alt="image.png"></p><blockquote><p>默认为 <strong>PERSISTENT</strong> 持久节点。</p></blockquote><p><strong>org.apache.curator.framework.imps.CreateBuilderImpl#forPath(java.lang.String, byte[])</strong></p><p><strong>forPath</strong> 对应了创建节点的最终操作，这里大致逻辑如下：</p><ol><li>判断是否需要压缩。</li><li>acl 权限检查。</li><li>判断是否执行回调。</li><li>核心：使用 ZooKeeper 的顺序节点生成全局唯一 ID。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">forPath</span><span class="params">(<span class="keyword">final</span> String givenPath, <span class="keyword">byte</span>[] data)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 判断是否需要压缩</span></span><br><span class="line"><span class="keyword">if</span> ( compress )</span><br><span class="line">&#123;</span><br><span class="line">data = client.getCompressionProvider().compress(givenPath, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> String adjustedPath = adjustPath(client.fixForNamespace(givenPath, createMode.isSequential()));</span><br><span class="line">List&lt;ACL&gt; aclList = acling.getAclList(adjustedPath);</span><br><span class="line">client.getSchemaSet().getSchema(givenPath).validateCreate(createMode, givenPath, data, aclList);</span><br><span class="line"></span><br><span class="line">String returnPath = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 后台回调</span></span><br><span class="line"><span class="keyword">if</span> ( backgrounding.inBackground() )</span><br><span class="line">&#123;</span><br><span class="line">pathInBackground(adjustedPath, data, givenPath);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// forpath 会走这一段逻辑</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">String path = protectedPathInForeground(adjustedPath, data, aclList);</span><br><span class="line"></span><br><span class="line">returnPath = client.unfixForNamespace(path);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> returnPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺着<code>String path = protectedPathInForeground(adjustedPath, data, aclList);</code>这一段代码一路往下探，找到对应截图部分的代码：</p><p><strong>org.apache.curator.framework.imps.CreateBuilderImpl#pathInForeground</strong></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230713155631.png" alt="image.png"></p><p>这里使用<code>RetryLoop.callWithRetry</code>嵌套了一个 <code>Callable</code>操作，但是这个操作并没有做任何多线程操作，而是进行了<code>result = proc.call();</code>调用？？？不太理解这一段封装处理的含义，于是看了下JavaDoc解释：</p><blockquote><p>在Zookeeper上执行操作的机制，可安全防止断开连接和 “可恢复 “错误。如果在操作过程中出现异常，RetryLoop将处理该异常，检查当前重试策略，并尝试重新连接或重新抛出异常。</p></blockquote><p>典型用法如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RetryLoop retryLoop = client.newRetryLoop();</span><br><span class="line"><span class="keyword">while</span> ( retryLoop.shouldContinue() )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// do your work</span></span><br><span class="line">        ZooKeeper zk = client.getZooKeeper();    <span class="comment">// it's important to re-get the ZK instance in case there was an error and the instance was re-created</span></span><br><span class="line"> </span><br><span class="line">        retryLoop.markComplete();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> ( Exception e )</span><br><span class="line">    &#123;</span><br><span class="line">        retryLoop.takeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说白了，它主要封装了类似下面这样的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">while</span> (count &lt; <span class="number">3</span>)&#123;  </span><br><span class="line"><span class="keyword">try</span>&#123;  </span><br><span class="line"><span class="comment">//                ZooKeeper zk = client.getZooKeeper();  </span></span><br><span class="line"><span class="comment">//                zk.create(final String path, byte data[], List&lt;ACL &gt; acl,  </span></span><br><span class="line"><span class="comment">//                        CreateMode createMode)  </span></span><br><span class="line"><span class="keyword">break</span>;  </span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;  </span><br><span class="line">count++;  </span><br><span class="line"><span class="keyword">continue</span>;            </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果就是把重试的重复代码做了一个封装，其中<code>call()</code>方法则是具体委托ZK的客户端进行节点的创建操作了，这里的<code>ttl</code>为 <strong>-1</strong>。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230713160928.png" alt="image.png"></p><p>截图对应代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createdPath = client.getZooKeeper().create(path, data, aclList, createMode, storingStat, ttl);</span><br></pre></td></tr></table></figure><p>此外，个人在阅读代码过程中，发现在进行path的字符串拼接操作的时候，这里有一个小小的  <strong>StringBuilder</strong> 优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Avoid internal StringBuilder's buffer reallocation by specifying the max path length  </span></span><br><span class="line">StringBuilder path = <span class="keyword">new</span> StringBuilder(maxPathLength);</span><br></pre></td></tr></table></figure><p>至此，创建节点的相关操作源码已经了解，下面我们来过一下删除的相关API操作和源码。</p><h2 id="删除节点API"><a href="#删除节点API" class="headerlink" title="删除节点API"></a>删除节点API</h2><ul><li><strong>CuratorFramework</strong>：<ul><li><code>public CreateBuilder create();</code></li></ul></li><li><strong>DeleteBuilder</strong></li><li><strong>ChildrenDeletable</strong><ul><li><code>public BackgroundVersionable deletingChildrenIfNeeded();</code></li></ul></li><li><strong>PathAndBytesable&lt; T&gt;</strong>：<ul><li><code>public T forPath(String path, byte[] data) throws Exception;</code></li><li>`public T forPath(String path) throws Exception;</li></ul></li></ul><p><strong>DeleteBuilder</strong> 的继承结构图如下：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230713163524.png" alt="image.png"></p><p>删除节点的API较为简单，这里直接贴出相关的Demo代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先创建一个持久节点  </span></span><br><span class="line">client.create().forPath(<span class="string">"/create"</span>);  </span><br><span class="line"><span class="comment">// 删除节点  </span></span><br><span class="line">client.delete().forPath(<span class="string">"/create"</span>);  </span><br><span class="line"><span class="comment">// 如果节点不存在：KeeperErrorCode = NoNode for /create</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先创建一个持久节点  </span></span><br><span class="line">client.create().creatingParentsIfNeeded().forPath(<span class="string">"/create/child0"</span>);  </span><br><span class="line">client.create().creatingParentsIfNeeded().forPath(<span class="string">"/create/child1"</span>);  </span><br><span class="line"><span class="comment">// 删除并且判断是否需要同时删除子节点，如果有子节点并且确定一并删除需要添加 </span></span><br><span class="line">deletingChildrenIfNeededclient.delete().deletingChildrenIfNeeded().forPath(<span class="string">"/create"</span>);</span><br></pre></td></tr></table></figure><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230713164006.png" alt="image.png"></p><h2 id="删除节点源码分析"><a href="#删除节点源码分析" class="headerlink" title="删除节点源码分析"></a>删除节点源码分析</h2><p>由于基本的CRUDE操作逻辑实现比较类似，这里主要介绍下<code>deletingChildrenIfNeeded</code>是如何作用的，处理思路是在访问ZK出现<strong>NotEmptyException</strong>异常之后，这里在异常中判断是否设置删除子节点的操作并且重新发起请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> ( KeeperException.NotEmptyException e )  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span> ( deletingChildrenIfNeeded )  </span><br><span class="line">    &#123;  </span><br><span class="line">        ZKPaths.deleteChildren(client.getZooKeeper(), path, <span class="keyword">true</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">throw</span> e;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ZKPaths.deleteChildren(client.getZooKeeper(), path, true);</code>这个工具方法具体操作是利用<strong>递归</strong>的方式遍历所有子ZNode，然后挨个执行<code>delete</code>方法删除。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230713164635.png" alt="image.png"></p><h2 id="获取节点API"><a href="#获取节点API" class="headerlink" title="获取节点API"></a>获取节点API</h2><ul><li><strong>CuratorFramework</strong>：<ul><li><code>public GetDataBuilder getData();</code></li></ul></li><li><strong>GetDataBuilder</strong></li><li><strong>GetChildrenBuilder</strong><ul><li><code>public GetChildrenBuilder getChildren();</code></li></ul></li><li><strong>PathAndBytesable&lt; T&gt;</strong>：<ul><li>`public T forPath(String path) throws Exception;</li></ul></li></ul><p><strong>GetDataBuilder</strong> 的类继承结构图如下：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230715152747.png" alt="image.png"></p><p>下面是简单的API使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">client.create().creatingParentsIfNeeded().withMode(CreateMode.CONTAINER).forPath(<span class="string">"/app2"</span>, <span class="string">"Test"</span>.getBytes());</span><br><span class="line"><span class="comment">//1、查询数据：get</span></span><br><span class="line"><span class="keyword">byte</span>[] data = client.getData().forPath(<span class="string">"/app2"</span>);</span><br><span class="line"><span class="comment">// KeeperErrorCode = NoNode for /app1</span></span><br><span class="line">log.info(<span class="string">"查询数据 &#123;&#125;"</span>, <span class="keyword">new</span> String(data));</span><br><span class="line"><span class="comment">// 运行结果：查询数据 Test</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、查询子节点：ls</span></span><br><span class="line">List&lt;String&gt; list = client.getChildren().forPath(<span class="string">"/app2"</span>);</span><br><span class="line">log.info(<span class="string">"查询子节点 &#123;&#125;"</span>, list);</span><br><span class="line"><span class="comment">//运行结果：查询子节点 []</span></span><br><span class="line">client.close();</span><br><span class="line"><span class="comment">//3、查询节点状态信息：ls -s</span></span><br><span class="line">Stat stat = <span class="keyword">new</span> Stat();</span><br><span class="line">client.getData().storingStatIn(stat).forPath(<span class="string">"/app2"</span>);</span><br></pre></td></tr></table></figure><h2 id="获取节点源码分析"><a href="#获取节点源码分析" class="headerlink" title="获取节点源码分析"></a>获取节点源码分析</h2><p>获取节点的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] forPath(String path) <span class="keyword">throws</span> Exception</span><br><span class="line">   &#123;</span><br><span class="line">       client.getSchemaSet().getSchema(path).validateWatch(path, watching.isWatched() || watching.hasWatcher());</span><br><span class="line"></span><br><span class="line">       path = client.fixForNamespace(path);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">byte</span>[]      responseData = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">if</span> ( backgrounding.inBackground() )</span><br><span class="line">       &#123;</span><br><span class="line">           client.processBackgroundOperation(<span class="keyword">new</span> OperationAndData&lt;String&gt;(<span class="keyword">this</span>, path, backgrounding.getCallback(), <span class="keyword">null</span>, backgrounding.getContext(), watching), <span class="keyword">null</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           responseData = pathInForeground(path);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> responseData;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>前台调用方法操作如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] pathInForeground(<span class="keyword">final</span> String path) <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        OperationTrace   trace = client.getZookeeperClient().startAdvancedTracer(<span class="string">"GetDataBuilderImpl-Foreground"</span>);</span><br><span class="line">        <span class="keyword">byte</span>[]      responseData = RetryLoop.callWithRetry</span><br><span class="line">        (</span><br><span class="line">            client.getZookeeperClient(),</span><br><span class="line">            <span class="keyword">new</span> Callable&lt;<span class="keyword">byte</span>[]&gt;()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">byte</span>[] call() <span class="keyword">throws</span> Exception</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">byte</span>[]      responseData;</span><br><span class="line">                    <span class="keyword">if</span> ( watching.isWatched() )</span><br><span class="line">                    &#123;</span><br><span class="line">                        responseData = client.getZooKeeper().getData(path, <span class="keyword">true</span>, responseStat);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        responseData = client.getZooKeeper().getData(path, watching.getWatcher(path), responseStat);</span><br><span class="line">                        watching.commitWatcher(KeeperException.NoNodeException.Code.OK.intValue(), <span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> responseData;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">        trace.setResponseBytesLength(responseData).setPath(path).setWithWatcher(watching.hasWatcher()).setStat(responseStat).commit();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> decompress ? client.getCompressionProvider().decompress(path, responseData) : responseData;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="修改节点API"><a href="#修改节点API" class="headerlink" title="修改节点API"></a>修改节点API</h2><ul><li><strong>CuratorFramework</strong>：<ul><li><code>public SetDataBuilder setData();</code></li></ul></li><li><strong>SetDataBuilder</strong><ul><li><code>SetDataBuilder setData()</code></li></ul></li><li><strong>PathAndBytesable&lt; T&gt;</strong>：<ul><li>`public T forPath(String path) throws Exception;</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、修改节点数据（基本修改）</span></span><br><span class="line">curatorFramework.setData().forPath(<span class="string">"/app1"</span>, <span class="string">"333"</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、根据版本号修改</span></span><br><span class="line">Stat stat1 = <span class="keyword">new</span> Stat();</span><br><span class="line">curatorFramework.getData().storingStatIn(stat1).forPath(<span class="string">"/app1"</span>);</span><br><span class="line">curatorFramework.setData().withVersion(stat1.getVersion()).forPath(<span class="string">"/app1"</span>, <span class="string">"itcast"</span>.getBytes(StandardCharsets.UTF_8));</span><br></pre></td></tr></table></figure><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230715154642.png" alt="image.png"></p><h2 id="修改节点源码分析"><a href="#修改节点源码分析" class="headerlink" title="修改节点源码分析"></a>修改节点源码分析</h2><p>设计思路都是类似的，这里挑选<code>forPath</code>的相关代码进行展示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> Stat <span class="title">forPath</span><span class="params">(String path, <span class="keyword">byte</span>[] data)</span> <span class="keyword">throws</span> Exception  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    client.getSchemaSet().getSchema(path).validateGeneral(path, data, <span class="keyword">null</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> ( compress )  </span><br><span class="line">    &#123;  </span><br><span class="line">        data = client.getCompressionProvider().compress(path, data);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    path = client.fixForNamespace(path);  </span><br><span class="line">  </span><br><span class="line">    Stat        resultStat = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="keyword">if</span> ( backgrounding.inBackground()  )  </span><br><span class="line">    &#123;  </span><br><span class="line">        client.processBackgroundOperation(<span class="keyword">new</span> OperationAndData&lt;&gt;(<span class="keyword">this</span>, <span class="keyword">new</span> PathAndBytes(path, data), backgrounding.getCallback(), <span class="keyword">null</span>, backgrounding.getContext(), <span class="keyword">null</span>), <span class="keyword">null</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        resultStat = pathInForeground(path, data);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> resultStat;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="监听节点"><a href="#监听节点" class="headerlink" title="监听节点"></a>监听节点</h2><p>在使用原生的ZooKeeper的时候，是可以使用Watcher对节点进行监听的，但是唯一不方便的是一个Watcher只能生效一次，也就是说每次进行监听回调之后我们需要自己重新的设置监听才能达到永久监听的效果。</p><p>Curator在这方面做了优化，Curator引入了Cache的概念用来实现对ZooKeeper服务器端进行事件监听。<strong>Cache是Curator对事件监听的包装</strong>，其对事件的监听可以近似看做是<strong>本地缓存视图和远程ZooKeeper视图的对比过程</strong>。而且Curator会<strong>自动再次监听</strong>，我们就不需要自己手动的重复监听了。</p><p>Curator支持的cache种类有3种Path Cache，Node Cache，Tree Cache。</p><p><strong>1）Path Cache</strong></p><p>Path Cache用来观察ZNode的子节点并缓存状态，如果ZNode的子节点被创建，更新或者删除，那么Path Cache会更新缓存，并且触发事件给注册的监听器。</p><p>Path Cache是通过PathChildrenCache类来实现的，监听器注册是通过PathChildrenCacheListener。</p><p><strong>2）Node Cache</strong></p><p>Node Cache用来观察ZNode自身，如果ZNode节点本身被创建，更新或者删除，那么Node Cache会更新缓存，并触发事件给注册的监听器。</p><p>Node Cache是通过NodeCache类来实现的，监听器对应的接口为NodeCacheListener。</p><p><strong>3）Tree Cache</strong></p><p>可以看做是上两种的合体，Tree Cache观察的是所有节点的所有数据。</p><p>Curator 拥有一套在节点上进行监听的API，具体操作是利用<strong>节点缓存</strong>上的监听器监听节点的数据变化。监听节点主要分为下面几个操作：</p><ul><li>监听单个节点</li><li>监听所有子节点</li><li>监听节点树</li></ul><h3 id="监听单个节点API"><a href="#监听单个节点API" class="headerlink" title="监听单个节点API"></a>监听单个节点API</h3><p>监听单个节点的案例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//----------------- 监听单个节点 -----------------------------------</span></span><br><span class="line"><span class="comment">//1. 创建NodeCache对象</span></span><br><span class="line"><span class="keyword">final</span> NodeCache nodeCache = <span class="keyword">new</span> NodeCache(client,<span class="string">"/app1"</span>);</span><br><span class="line"><span class="comment">//2. 注册监听</span></span><br><span class="line">nodeCache.getListenable().addListener(<span class="keyword">new</span> NodeCacheListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nodeChanged</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"节点变化了~"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取修改节点后的数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] data = nodeCache.getCurrentData().getData();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(data));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//3. 开启监听.如果设置为true，则开启监听是，加载缓冲数据</span></span><br><span class="line">nodeCache.start(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h3 id="监听子节点API"><a href="#监听子节点API" class="headerlink" title="监听子节点API"></a>监听子节点API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//----------------- 监听子节点 -----------------------------------</span></span><br><span class="line"><span class="comment">//1.创建监听对象</span></span><br><span class="line">PathChildrenCache pathChildrenCache = <span class="keyword">new</span> PathChildrenCache(client,<span class="string">"/app2"</span>,<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//2. 绑定监听器</span></span><br><span class="line">pathChildrenCache.getListenable().addListener(<span class="keyword">new</span> PathChildrenCacheListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">childEvent</span><span class="params">(CuratorFramework client, PathChildrenCacheEvent event)</span>  </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"子节点变化了~"</span>);</span><br><span class="line">System.out.println(event);</span><br><span class="line"><span class="comment">//监听子节点的数据变更，并且拿到变更后的数据</span></span><br><span class="line"><span class="comment">//1.获取类型</span></span><br><span class="line">PathChildrenCacheEvent.Type type = event.getType();</span><br><span class="line"><span class="comment">//2.判断类型是否是update</span></span><br><span class="line"><span class="keyword">if</span>(type.equals(PathChildrenCacheEvent.Type.CHILD_UPDATED))&#123;</span><br><span class="line">System.out.println(<span class="string">"数据变了！！！"</span>);</span><br><span class="line"><span class="keyword">byte</span>[] data = event.getData().getData();</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(data));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//3. 开启</span></span><br><span class="line">pathChildrenCache.start();</span><br></pre></td></tr></table></figure><h3 id="监听节点树"><a href="#监听节点树" class="headerlink" title="监听节点树"></a>监听节点树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//----------------- 监听节点树 -----------------------------------</span></span><br><span class="line"><span class="comment">//1. 创建监听器</span></span><br><span class="line">TreeCache treeCache = <span class="keyword">new</span> TreeCache(client,<span class="string">"/app2"</span>);</span><br><span class="line"><span class="comment">//2. 注册监听</span></span><br><span class="line">treeCache.getListenable().addListener(<span class="keyword">new</span> TreeCacheListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">childEvent</span><span class="params">(CuratorFramework client, TreeCacheEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"节点变化了"</span>);</span><br><span class="line">        System.out.println(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//3. 开启</span></span><br><span class="line">treeCache.start();</span><br></pre></td></tr></table></figure><h2 id="NodeCache-源码解析"><a href="#NodeCache-源码解析" class="headerlink" title="NodeCache 源码解析"></a>NodeCache 源码解析</h2><p>有关节点监听机制，和ZK 的 watch 机制也有关，下面来简单解析 NodeCache 相关源码实现。</p><h3 id="初始化部分"><a href="#初始化部分" class="headerlink" title="初始化部分"></a>初始化部分</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NodeCache</span><span class="params">(CuratorFramework client, String path, <span class="keyword">boolean</span> dataIsCompressed)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.client = client.newWatcherRemoveCuratorFramework();  </span><br><span class="line">    <span class="keyword">this</span>.path = PathUtils.validatePath(path);  </span><br><span class="line">    <span class="keyword">this</span>.dataIsCompressed = dataIsCompressed;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键部分是构建了<code>WatcherRemovalFacade</code>监听器的门面对象，在Cache 发生变化之后会触发事件监听回调通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> WatcherRemovalFacade(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><h3 id="start-启动"><a href="#start-启动" class="headerlink" title="start() 启动"></a>start() 启动</h3><p><strong>NodeCache</strong> 使用必须要结合 <code>xxx.start();</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>     <span class="title">start</span><span class="params">(<span class="keyword">boolean</span> buildInitial)</span> <span class="keyword">throws</span> Exception  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"><span class="comment">// 检查启动状态</span></span><br><span class="line">    Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), <span class="string">"Cannot be started more than once"</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加连接状态监听器</span></span><br><span class="line">    client.getConnectionStateListenable().addListener(connectionStateListener);  </span><br><span class="line"><span class="comment">// 初始化处理</span></span><br><span class="line">    <span class="keyword">if</span> ( buildInitial )  </span><br><span class="line">    &#123;  </span><br><span class="line">        client.checkExists().creatingParentContainersIfNeeded().forPath(path);  </span><br><span class="line">        internalRebuild();  </span><br><span class="line">    &#125;  </span><br><span class="line">    reset();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要注意<code>client.getConnectionStateListenable().addListener(connectionStateListener);</code>这一串代码实际上是注册到 <strong>CuratorFrameworkImpl</strong>内部的连接状态管理器 <strong>ConnectionStateManager</strong>。</p><p>连接状态监听器的实现如下，主要是解决了原生客户端Watch只能使用一次的问题，这里通过监听状态变化并且结合CAS操作完成更新。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ConnectionStateListener connectionStateListener = <span class="keyword">new</span> ConnectionStateListener()  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(CuratorFramework client, ConnectionState newState)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> ( (newState == ConnectionState.CONNECTED) || (newState == ConnectionState.RECONNECTED) )  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span> ( isConnected.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>) )  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">try</span>  </span><br><span class="line">                &#123;  </span><br><span class="line">                    reset();  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">catch</span> ( Exception e )  </span><br><span class="line">                &#123;  </span><br><span class="line">                    ThreadUtils.checkInterrupted(e);  </span><br><span class="line">                    log.error(<span class="string">"Trying to reset after reconnection"</span>, e);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            isConnected.set(<span class="keyword">false</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上下两部分代码都调用了<code>reset()</code>方法，它在内部传递了两个对象 <strong>监听对象watcher</strong> 以及 <strong>回调对象backgroundCallback(异步回调)</strong>，前者在一开始启动就会注册进来，而后者则需要返回数据的时候执行回调函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reset() 方法内部实现</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span>  <span class="title">reset</span><span class="params">()</span> <span class="keyword">throws</span> Exception  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> ( (state.get() == State.STARTED) &amp;&amp; isConnected.get() )  </span><br><span class="line">    &#123;  </span><br><span class="line">        </span><br><span class="line">        client.checkExists().creatingParentContainersIfNeeded().usingWatcher(watcher).inBackground(backgroundCallback).forPath(path);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>监听对象watcher</strong> 所干的事情就是不断重新执行<code>reset</code>方法，把监听器重新注册到对应的节点上面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Watcher watcher = <span class="keyword">new</span> Watcher()  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">try</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            reset();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">catch</span>(Exception e)  </span><br><span class="line">        &#123;  </span><br><span class="line">            ThreadUtils.checkInterrupted(e);  </span><br><span class="line">            handleException(e);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="异步回调逻辑"><a href="#异步回调逻辑" class="headerlink" title="异步回调逻辑"></a>异步回调逻辑</h3><p>异步回调的任务是判断当前事件是获取数据还是检查是否存在，之后进行本地缓存数据的变更，以及刷新本地缓存数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BackgroundCallback backgroundCallback = <span class="keyword">new</span> BackgroundCallback()  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(CuratorFramework client, CuratorEvent event)</span> <span class="keyword">throws</span> Exception  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        processBackgroundResult(event);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processBackgroundResult</span><span class="params">(CuratorEvent event)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="comment">// 当发生获取数据或者是判断节点是否存在时候进行监听</span></span><br><span class="line">        <span class="keyword">switch</span> ( event.getType() )</span><br><span class="line">        &#123;</span><br><span class="line">         <span class="comment">// 响应状态为ok时，将刷新本地缓存的数据</span></span><br><span class="line">            <span class="keyword">case</span> GET_DATA:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ( event.getResultCode() == KeeperException.Code.OK.intValue() )</span><br><span class="line">                &#123;</span><br><span class="line">                 <span class="comment">// 获取监听到的数据变动集合</span></span><br><span class="line">                    ChildData childData = <span class="keyword">new</span> ChildData(path, event.getStat(), event.getData());</span><br><span class="line">                <span class="comment">// 刷新本地缓存数据</span></span><br><span class="line">                    setNewData(childData);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> EXISTS:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )</span><br><span class="line">                &#123;</span><br><span class="line">                    setNewData(<span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ( event.getResultCode() == KeeperException.Code.OK.intValue() )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( dataIsCompressed )</span><br><span class="line">                    &#123;</span><br><span class="line">                        client.getData().decompressed().usingWatcher(watcher).inBackground(backgroundCallback).forPath(path);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        client.getData().usingWatcher(watcher).inBackground(backgroundCallback).forPath(path);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 调用<strong>setNewData(childData);</strong> 之后会刷新本地缓存数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setNewData</span><span class="params">(ChildData newData)</span> <span class="keyword">throws</span> InterruptedException  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"><span class="comment">// 比较最新数据和变更前的数据，查看是否有变更</span></span><br><span class="line">    ChildData   previousData = data.getAndSet(newData);  </span><br><span class="line">    <span class="keyword">if</span> ( !Objects.equal(previousData, newData) )  </span><br><span class="line">    &#123;  </span><br><span class="line">        listeners.forEach  </span><br><span class="line">        (  </span><br><span class="line">        <span class="comment">// 用节点监听容器内部的监听器处理目录变更事件</span></span><br><span class="line">            <span class="keyword">new</span> Function&lt;NodeCacheListener, Void&gt;()  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="meta">@Override</span>  </span><br><span class="line">                <span class="function"><span class="keyword">public</span> Void <span class="title">apply</span><span class="params">(NodeCacheListener listener)</span>  </span></span><br><span class="line"><span class="function">                </span>&#123;  </span><br><span class="line">                    <span class="keyword">try</span>  </span><br><span class="line">                    &#123;  </span><br><span class="line">                        listener.nodeChanged();  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    <span class="keyword">catch</span> ( Exception e )  </span><br><span class="line">                    &#123;  </span><br><span class="line">                        ThreadUtils.checkInterrupted(e);  </span><br><span class="line">                        log.error(<span class="string">"Calling listener"</span>, e);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        );  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> ( rebuildTestExchanger != <span class="keyword">null</span> )  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">try</span>  </span><br><span class="line">            &#123;  </span><br><span class="line">                rebuildTestExchanger.exchange(<span class="keyword">new</span> Object());  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">catch</span> ( InterruptedException e )  </span><br><span class="line">            &#123;  </span><br><span class="line">                Thread.currentThread().interrupt();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何触发注册的监听器？"><a href="#如何触发注册的监听器？" class="headerlink" title="如何触发注册的监听器？"></a>如何触发注册的监听器？</h3><p>我们回到 <code>start()</code> 启动这部分代码，来看下如何触发监听器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加连接状态监听器</span></span><br><span class="line">client.getConnectionStateListenable().addListener(connectionStateListener);</span><br></pre></td></tr></table></figure><p>这里注册到 <strong>CuratorFrameworkImpl</strong>内部的连接状态管理器 <strong>ConnectionStateManager</strong>，具体的注册过程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Listenable&lt;ConnectionStateListener&gt; <span class="title">getListenable</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> listeners;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 <code>listeners</code> 成员变量定义如下，可以看到它是一个监听器的管理容器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> UnaryListenerManager&lt;ConnectionStateListener&gt; listeners;</span><br></pre></td></tr></table></figure><p>这个容器什么时候会通知注册在其中的监听器？</p><p>答案是在出现状态变更的时候：</p><p><strong>org.apache.curator.framework.state.ConnectionStateManager#processEvents</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listeners.forEach(listener -&gt; listener.stateChanged(client, newState));</span><br></pre></td></tr></table></figure><p>这部分内容在[[【Zookeeper】Apach Curator 框架源码分析：初始化过程（一）【Ver 4.3.0】]] 的通知机制中有详细介绍【参考：注册 ConnectionStateListener 通知部分】。</p><p>这里节省读者时间，我们直接看一个草图：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230717111550.png" alt="image.png"></p><p><code>ConnectionStateManager</code> 调用<code>start</code> 启动之后，会开启一个单线程线程池异步的轮询，并且在状态变更的时候回调<strong>UnaryListenerManager</strong>容器中注册的监听器。</p><p>以上就是关于如何触发注册的监听器的问题解答。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>节点监听缓存 NodeCache，内部关联Curator框架客户端CuratorFramework，通过节点内部的监听器容器 listeners（ListenerContainer）存放节点监听器。</p><p>添加节点监听器，实际上是注册到节点缓存的节点监听器容器<strong>ListenerContainer</strong>（CuratorFrameworkImpl内部的成员添加节点监听器，注册到节点缓存的节点监听器容器ListenerContainer）中。 </p><p>启动节点监听器，注册节点监听器到CuratorFramework实现的连接状态管理器中<strong>ConnectionStateManager</strong>，如果需要则重新构建节点数据，同时重新注册节点监听器 <strong>CuratorWatcher</strong>，如果连接状态有变更， 重新注册节点监听器CuratorWatcher。</p><p>以上内容需要区分添加和启动过程，两者分别存储在两个不同的容器当中，这个添加过程类似先把鸡蛋放自己的篮子，启动之后再把自己篮子的鸡蛋倒入”机器“中运作。</p><p>当然上面的API没有分析PathChildrenCache，这里进行简单描述大致了解即可。</p><p>子目录监听器PathChildrenCache，主要成员变量为客户端框架实现CuratorFramework，子路径监听器容器 ListenerContainer（ListenerAble），及事件执行器CloseableExecutorService，事件操作集Set。</p><p>一级目录监听器PathChildrenCache，启动过程主要是注册连接状态监听器ConnectionStateListener，连接状态监听器根据连接状态来添加事件EventOperation和RefreshOperation操作到操作集。 </p><p><strong>事件操作EventOperation</strong>：主要是触发监听器的子目录事件操作；</p><p><strong>事件刷新操作 RefreshOperation</strong>：主要是完成子目录的添加和刷新事件，并重新注册子目录监听器。 然后根据启动模式来决定是重添加事件操作，刷新、事件操作，或者重新构建，即刷新缓存路径数据，并注册刷新操作。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>这里还是吐槽Curator 这代码设计挺绕的，还有很多贴合设计模式的古怪代码。</p><h1 id="上一篇"><a href="#上一篇" class="headerlink" title="上一篇"></a>上一篇</h1><p>[[【Zookeeper】Apach Curator 框架源码分析：初始化过程（一）【Ver 4.3.0】]]</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VuX2pva2VyL2FydGljbGUvZGV0YWlscy83ODc4MTc1MA==" title="https://blog.csdn.net/en_joker/article/details/78781750">(3条消息) Curator之创建节点_curator创建节点_孤芳不自賞的博客-CSDN博客<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9qYXZhZ3VpZGUuY24vZGlzdHJpYnV0ZWQtc3lzdGVtL2Rpc3RyaWJ1dGVkLXByb2Nlc3MtY29vcmRpbmF0aW9uL3pvb2tlZXBlci96b29rZWVwZXItaW50cm8uaHRtbCN6bm9kZS0lRTYlOTUlQjAlRTYlOEQlQUUlRTglOEElODIlRTclODIlQjk=" title="https://javaguide.cn/distributed-system/distributed-process-coordination/zookeeper/zookeeper-intro.html#znode-%E6%95%B0%E6%8D%AE%E8%8A%82%E7%82%B9">ZooKeeper相关概念总结(入门) | JavaGuide(Java面试 + 学习指南)<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9hODY0YmY4YTZjM2M=" title="https://www.jianshu.com/p/a864bf8a6c3c">https://www.jianshu.com/p/a864bf8a6c3c<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9kb25hbGRoYW4uZ2l0aHViLmlvL3pvb2tlZXBlci8yMDE4LzA2LzI5L2N1cmF0b3IlRTclOUIlQUUlRTUlQkQlOTUlRTclOUIlOTElRTUlOTAlQUMuaHRtbCMlRTglOEElODIlRTclODIlQjklRTclOUIlOTElRTUlOTAlQUMlRTUlOTklQThub2RlY2FjaGU=" title="https://donaldhan.github.io/zookeeper/2018/06/29/curator%E7%9B%AE%E5%BD%95%E7%9B%91%E5%90%AC.html#%E8%8A%82%E7%82%B9%E7%9B%91%E5%90%AC%E5%99%A8nodecache">https://donaldhan.github.io/zookeeper/2018/06/29/curator%E7%9B%AE%E5%BD%95%E7%9B%91%E5%90%AC.html#%E8%8A%82%E7%82%B9%E7%9B%91%E5%90%AC%E5%99%A8nodecache<i class="fa fa-external-link"></i></span></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      源码分析Curator的使用
    
    </summary>
    
    
      <category term="Zookeeper" scheme="https://whitestore.top/categories/Zookeeper/"/>
    
    
      <category term="Zookeeper" scheme="https://whitestore.top/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>【Zookeeper】Apach Curator 框架源码分析：初始化过程（一）【Ver 4.3.0】</title>
    <link href="https://whitestore.top/2023/08/10/curatorsource1/"/>
    <id>https://whitestore.top/2023/08/10/curatorsource1/</id>
    <published>2023-08-10T08:57:00.000Z</published>
    <updated>2023-09-09T00:53:49.936Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Curator是netflix公司开源的一套zookeeper客户端，目前是Apache的顶级项目。</p><p>和ZK的原生客户端相比，Curator的抽象层次要更高，同时简化了ZK的常用功能开发量，比如Curator自带连接重试、反复注册Watcher、NodeExistsException 异常处理等等。</p><p>根据官方的介绍，我们可以了解到它是一个用于分布式的Java客户端API工具。它基于<code>high-level API</code>，拥有它可以更简单易懂的指挥Zookeeper实现分布式安全应用程序开发。</p><p>Curator由一系列的模块构成，对于一般开发者而言，常用的是<strong>curator-framework</strong>和<strong>curator-recipes</strong>，以及广为熟知的 <strong>分布式锁</strong>。</p><p>Curator 当然也包括许多扩展，比如<strong>服务发现</strong>和<strong>基于Java 8异步DSL</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Apache Curator is a Java&#x2F;JVM client library for [Apache ZooKeeper](https:&#x2F;&#x2F;zookeeper.apache.org&#x2F;), a distributed coordination service.</span><br><span class="line"></span><br><span class="line">Apache Curator includes a high-level API framework and utilities to make using Apache ZooKeeper much easier and more reliable. It also includes recipes for common use cases and extensions such as service discovery and a Java 8 asynchronous DSL.</span><br></pre></td></tr></table></figure><blockquote><p>用官方的介绍来说就是：guava之于java就像curator之于zookeeper </p></blockquote><a id="more"></a><h1 id="ZK-版本支持"><a href="#ZK-版本支持" class="headerlink" title="ZK 版本支持"></a>ZK 版本支持</h1><p>Curator 目前最新的版本为 5.X 的版本，已经不支持 ZK 的 3.4.X 以及之前的版本，阅读源码之前经过认真考虑，最终选择了 ZK的 <strong>3.5.10</strong> 版本。</p><blockquote><p>5.X 对于 Curator 做了不少破坏性的改动，不兼容的原因如下：</p><ul><li>旧的ListenerContainer类已经被移除，以避免Guava类泄漏。</li><li>ConnectionHandlingPolicy和相关类已被删除</li><li>Reaper和ChildReaper类/recipes已被删除。您应该改用 ZooKeeper 容器节点。</li><li>newPersistentEphemeralNode()和newPathChildrenCache()已从GroupMember中移除。</li><li>ServiceCacheBuilder&lt; T&gt; executorService(CloseableExecutorService executorService)已从ServiceCacheBuilder中移除。</li><li>ServiceProviderBuilder&lt; T&gt; executorService(CloseableExecutorService executorService)已从ServiceProviderBuilder中移除。</li><li>static boolean shouldRetry(int rc)已从RetryLoop中移除。</li><li>static boolean isRetryException(Throwable exception)已从RetryLoop中移除。</li></ul></blockquote><h1 id="官网地址"><a href="#官网地址" class="headerlink" title="官网地址"></a>官网地址</h1><p><span class="exturl" data-url="aHR0cHM6Ly9jdXJhdG9yLmFwYWNoZS5vcmcv" title="https://curator.apache.org/">Apache Curator<i class="fa fa-external-link"></i></span></p><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><p>Curator Maven 相关地址：<span class="exturl" data-url="aHR0cHM6Ly9tdm5yZXBvc2l0b3J5LmNvbS9hcnRpZmFjdC9vcmcuYXBhY2hlLmN1cmF0b3I=" title="https://mvnrepository.com/artifact/org.apache.curator">https://mvnrepository.com/artifact/org.apache.curator<i class="fa fa-external-link"></i></span></p><p>Curator jar包下载地址：<span class="exturl" data-url="aHR0cHM6Ly9jd2lraS5hcGFjaGUub3JnL2NvbmZsdWVuY2UvZGlzcGxheS9DVVJBVE9SL1JlbGVhc2Vz" title="https://cwiki.apache.org/confluence/display/CURATOR/Releases">https://cwiki.apache.org/confluence/display/CURATOR/Releases<i class="fa fa-external-link"></i></span></p><h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><h2 id="ZK-集群部署"><a href="#ZK-集群部署" class="headerlink" title="ZK 集群部署"></a>ZK 集群部署</h2><p>学习之前需要使用ZK搭建集群环境，方便Debug的时候调试代码。这部分搭建过程放到另一篇文章：</p><p>[[【Zookeeper】基于3台linux虚拟机搭建zookeeper集群]]</p><h2 id="Maven依赖引入"><a href="#Maven依赖引入" class="headerlink" title="Maven依赖引入"></a>Maven依赖引入</h2><p>下面是对应的Zookeeper和Curator的版本选择。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">curator.version</span>&gt;</span>4.3.0<span class="tag">&lt;/<span class="name">curator.version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">zookeeper.version</span>&gt;</span>3.5.10<span class="tag">&lt;/<span class="name">zookeeper.version</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;curator.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;curator.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;zookeeper.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="构建入门实例"><a href="#构建入门实例" class="headerlink" title="构建入门实例"></a>构建入门实例</h2><p>Curator 最为核心和强大并且常用功能是分布式锁。</p><p>在入门demo中可以看到整个 Curator 依靠 <strong>CuratorFrameworkFactory</strong> 构建，使用 Curator 进行分布式加锁解锁操作，只需要为所连接的ZooKeeper集群提供一个CuratorFramework对象即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CuratorFrameworkFactory.newClient(zookeeperConnectionString, retryPolicy)</span><br></pre></td></tr></table></figure><p>上面的方法将会使用默认值创建与ZooKeeper集群的连接，调用放只需要关注使用到的重试策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>)</span><br><span class="line">CuratorFramework client = CuratorFrameworkFactory.newClient(zookeeperConnectionString, retryPolicy);</span><br><span class="line">client.start();</span><br></pre></td></tr></table></figure><p>从参数值可以大致了解到，这里使用的策略是指数递增间隔的方式尝试重试时间，并且指定重试三次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>);  </span><br><span class="line">CuratorFramework client =  </span><br><span class="line">        CuratorFrameworkFactory.newClient(<span class="string">"192.168.0.1;192.168.0.2;192.168.0.3"</span>, retryPolicy);  </span><br><span class="line">client.start();  </span><br><span class="line"><span class="comment">// 此处就获取到 zk的一个连接实例。  </span></span><br><span class="line"><span class="comment">//.....</span></span><br></pre></td></tr></table></figure><p>拥有了 <strong>CuratorFramework</strong> 实例之后，就可以直接通过 API 调用操作ZK。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.create().forPath(<span class="string">"/my/path"</span>, myData)</span><br></pre></td></tr></table></figure><blockquote><p>这样的直接调用还有个好处是client实例如果碰到网络抖动等情况会自动重试，重试过程不需要开发者自己实现。</p></blockquote><h2 id="可重入锁（公平锁）案例代码"><a href="#可重入锁（公平锁）案例代码" class="headerlink" title="可重入锁（公平锁）案例代码"></a>可重入锁（公平锁）案例代码</h2><p>下面是官网可重入锁的Demo使用代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">InterProcessMutex lock = <span class="keyword">new</span> InterProcessMutex(client, lockPath);</span><br><span class="line"><span class="keyword">if</span> ( lock.acquire(maxWait, waitUnit) ) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// do some work inside of the critical section here</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        lock.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里改造一下即可简单使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>);  </span><br><span class="line">CuratorFramework client =  </span><br><span class="line">        CuratorFrameworkFactory.newClient(<span class="string">"192.168.0.1,192.168.0.2,192.168.0.3"</span>, retryPolicy);  </span><br><span class="line">client.start();  </span><br><span class="line"><span class="comment">// 此处就获取到 zk的一个连接实例。  </span></span><br><span class="line"><span class="comment">//.....  </span></span><br><span class="line">client.create().forPath(<span class="string">"/my/path"</span>, <span class="string">"Test"</span>.getBytes());  </span><br><span class="line">InterProcessMutex lock = <span class="keyword">new</span> InterProcessMutex(client, <span class="string">"/test/myLock"</span>);  </span><br><span class="line">lock.acquire();  </span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">    <span class="comment">// do some work inside of the critical section here  </span></span><br><span class="line">    Thread.sleep(<span class="number">3000</span>);  </span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">    lock.release();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个Demo案例代码比较简单，下面直接开始介绍初始化过程。</p><p>本文主要介绍和<strong>Curator初始化</strong>、内部的<strong>通知机制</strong>以及<strong>会话管理</strong>部分。</p><h1 id="初始化过程流程图"><a href="#初始化过程流程图" class="headerlink" title="初始化过程流程图"></a>初始化过程流程图</h1><p>初始化过程流程图全图如下。下面将会一步步拆解这幅图是如何拼凑的。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/Curator%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.drawio.png" alt="Curator 源码分析.drawio.png"></p><blockquote><p>Drawio 源文件和图片地址如下：<br>链接：<span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMThQb01qa3AxMUx6dG1OQjNYZ1owcXc/cHdkPTRidWc=" title="https://pan.baidu.com/s/18PoMjkp11LztmNB3XgZ0qw?pwd=4bug">https://pan.baidu.com/s/18PoMjkp11LztmNB3XgZ0qw?pwd=4bug<i class="fa fa-external-link"></i></span><br>    提取码：4bug </p></blockquote><h1 id="初始化源码分析"><a href="#初始化源码分析" class="headerlink" title="初始化源码分析"></a>初始化源码分析</h1><h2 id="CuratorFramework-初始化过程"><a href="#CuratorFramework-初始化过程" class="headerlink" title="CuratorFramework 初始化过程"></a>CuratorFramework 初始化过程</h2><h3 id="初始化过程流程图-1"><a href="#初始化过程流程图-1" class="headerlink" title="初始化过程流程图"></a>初始化过程流程图</h3><p>CuratorFramework 初始化过程为下面截图这一部分，红色部分为个人认为相对比较重要的对象和变量。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230708120150.png" alt="image.png"></p><h3 id="CuratorFrameworkFactory-newClient-代码分析"><a href="#CuratorFrameworkFactory-newClient-代码分析" class="headerlink" title="CuratorFrameworkFactory.newClient() 代码分析"></a>CuratorFrameworkFactory.newClient() 代码分析</h3><p>下面通过<code>CuratorFrameworkFactory.newClient()</code>一步步探究整个初始化过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>);  </span><br><span class="line">CuratorFramework client =  </span><br><span class="line">        CuratorFrameworkFactory.newClient(<span class="string">"192.168.19.100:2181,192.168.19.101:2181,192.168.19.102:2181"</span>, retryPolicy);</span><br></pre></td></tr></table></figure><p>在获取分布式锁之前，我们需要先连接ZK集群，整个过程通过两行代码完成。</p><p>首先，我们需要确定连接ZK的重试策略，接着通过<code>CuratorFrameworkFactory</code>构建<code>Curator</code> 实例，<code>Curator</code>内部根据ZK原生客户端做了一层封装，开发者使用过程中不需要关注。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>);  </span><br><span class="line">CuratorFramework client =  CuratorFrameworkFactory.newClient(<span class="string">"192.168.0.1,192.168.0.2,192.168.0.3"</span>, retryPolicy);</span><br></pre></td></tr></table></figure><p>上面是简单的模板代码。<strong>ExponentialBackoffRetry</strong> 构建重试策略为按照指数增长重试时间，比如第一次1秒，第二次2秒，第三次4秒，第四次8秒….. </p><p>接着是利用<code>CuratorFrameworkFactory</code>构建实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> newClient(connectString, DEFAULT_SESSION_TIMEOUT_MS, DEFAULT_CONNECTION_TIMEOUT_MS, retryPolicy);</span><br></pre></td></tr></table></figure><p>这里强调一下两个常量 <strong>DEFAULT_SESSION_TIMEOUT_MS</strong> （默认的会话超时时间）、<strong>DEFAULT_CONNECTION_TIMEOUT_MS</strong>（默认的连接超时时间），作用是传入重试策略时候填写默认参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_SESSION_TIMEOUT_MS</span><br><span class="line">    = Integer.getInteger(<span class="string">"curator-default-session-timeout"</span>, <span class="number">60</span> * <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONNECTION_TIMEOUT_MS = Integer.getInteger(<span class="string">"curator-default-connection-timeout"</span>, <span class="number">15</span> * <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>我们进一步进入构造方法，这里用了建造者模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> builder().  </span><br><span class="line">    connectString(connectString).  </span><br><span class="line">    sessionTimeoutMs(sessionTimeoutMs).  </span><br><span class="line">    connectionTimeoutMs(connectionTimeoutMs).  </span><br><span class="line">    retryPolicy(retryPolicy).  </span><br><span class="line">    build();</span><br></pre></td></tr></table></figure><p><code>build()</code>工作完成之后，后续的调用实际上调用的是<strong>CuratorFrameworkImpl</strong>实例，注意这里把<strong>CuratorFrameworkFactory</strong>的<strong>this</strong>引用逸出给<strong>CuratorFrameworkImpl</strong>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> CuratorFrameworkImpl(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p><code>CuratorFrameworkImpl</code> 构造方法的内容比较多，这里在源码对于相对重要的组件进行标注，这里的<strong>CuratorZookeeperClient</strong>这个对象，相当于ZK原生客户端的封装对象，Curator的很多质量都是由它来完成调用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CuratorFrameworkImpl</span><span class="params">(CuratorFrameworkFactory.Builder builder)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    ZookeeperFactory localZookeeperFactory = makeZookeeperFactory(builder.getZookeeperFactory());  </span><br><span class="line">    <span class="keyword">this</span>.client = <span class="keyword">new</span> CuratorZookeeperClient  </span><br><span class="line">        (  </span><br><span class="line">            localZookeeperFactory,  </span><br><span class="line">            builder.getEnsembleProvider(),  </span><br><span class="line">            builder.getSessionTimeoutMs(),  </span><br><span class="line">            builder.getConnectionTimeoutMs(),  </span><br><span class="line">            builder.getWaitForShutdownTimeoutMs(),  </span><br><span class="line">            <span class="keyword">new</span> Watcher()  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="meta">@Override</span>  </span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span>  </span></span><br><span class="line"><span class="function">                </span>&#123;  </span><br><span class="line">                    CuratorEvent event = <span class="keyword">new</span> CuratorEventImpl(CuratorFrameworkImpl.<span class="keyword">this</span>, CuratorEventType.WATCHED, watchedEvent.getState().getIntValue(), unfixForNamespace(watchedEvent.getPath()), <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, watchedEvent, <span class="keyword">null</span>, <span class="keyword">null</span>);  </span><br><span class="line">                    processEvent(event);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;,  </span><br><span class="line">            builder.getRetryPolicy(),  </span><br><span class="line">            builder.canBeReadOnly(),  </span><br><span class="line">            builder.getConnectionHandlingPolicy()  </span><br><span class="line">        );  </span><br><span class="line">  <span class="comment">//用于判断连接断开和连接超时的状态，设置curator的连接状态，并通过connectionStateManager触发连接事件状态通知</span></span><br><span class="line">    internalConnectionHandler = <span class="keyword">new</span> StandardInternalConnectionHandler();</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//接收事件的通知。后台线程操作事件和连接状态事件会触发 </span></span><br><span class="line">    listeners = <span class="keyword">new</span> ListenerContainer&lt;CuratorListener&gt;();  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当后台线程发生异常或者handler发生异常的时候会触发</span></span><br><span class="line">    unhandledErrorListeners = <span class="keyword">new</span> ListenerContainer&lt;UnhandledErrorListener&gt;();  </span><br><span class="line">    <span class="comment">//后台线程执行的操作队列</span></span><br><span class="line">    backgroundOperations = <span class="keyword">new</span> DelayQueue&lt;OperationAndData&lt;?&gt;&gt;();  </span><br><span class="line">    forcedSleepOperations = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();  </span><br><span class="line">    <span class="comment">//命名空间</span></span><br><span class="line">    namespace = <span class="keyword">new</span> NamespaceImpl(<span class="keyword">this</span>, builder.getNamespace());  </span><br><span class="line"></span><br><span class="line"><span class="comment">//线程工厂方法，初始化后台线程池时会使用</span></span><br><span class="line">    threadFactory = getThreadFactory(builder);  </span><br><span class="line"></span><br><span class="line">maxCloseWaitMs = builder.getMaxCloseWaitMs();  </span><br><span class="line"></span><br><span class="line"><span class="comment">//负责连接状态变化时的通知</span></span><br><span class="line">    connectionStateManager = <span class="keyword">new</span> ConnectionStateManager(<span class="keyword">this</span>, builder.getThreadFactory(), builder.getSessionTimeoutMs(), builder.getConnectionHandlingPolicy().getSimulatedSessionExpirationPercent(), builder.getConnectionStateListenerDecorator());  </span><br><span class="line">    compressionProvider = builder.getCompressionProvider();  </span><br><span class="line">    aclProvider = builder.getAclProvider();  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//CuratorFrameworkImpl的状态，调用start方法之前为 LATENT，调用start方法之后为 STARTED ,调用close()方法之后为STOPPEDstate = new AtomicReference&lt;CuratorFrameworkState&gt;(CuratorFrameworkState.LATENT);  </span></span><br><span class="line">    useContainerParentsIfAvailable = builder.useContainerParentsIfAvailable(); </span><br><span class="line">    <span class="comment">//错误连接策略 </span></span><br><span class="line">    connectionStateErrorPolicy = Preconditions.checkNotNull(builder.getConnectionStateErrorPolicy(), <span class="string">"errorPolicy cannot be null"</span>);  </span><br><span class="line">    schemaSet = Preconditions.checkNotNull(builder.getSchemaSet(), <span class="string">"schemaSet cannot be null"</span>);  </span><br><span class="line">    zk34CompatibilityMode = builder.isZk34CompatibilityMode();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">byte</span>[] builderDefaultData = builder.getDefaultData();  </span><br><span class="line">    defaultData = (builderDefaultData != <span class="keyword">null</span>) ? Arrays.copyOf(builderDefaultData, builderDefaultData.length) : <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];  </span><br><span class="line">    authInfos = buildAuths(builder);  </span><br><span class="line">    </span><br><span class="line">  <span class="comment">//有保障的执行删除操作，其实是不断尝试直到删除成功，通过递归调用实现</span></span><br><span class="line">    failedDeleteManager = <span class="keyword">new</span> FailedDeleteManager(<span class="keyword">this</span>);  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//有保障的执行删除watch操作</span></span><br><span class="line">    failedRemoveWatcherManager = <span class="keyword">new</span> FailedRemoveWatchManager(<span class="keyword">this</span>);  </span><br><span class="line">    </span><br><span class="line">    namespaceFacadeCache = <span class="keyword">new</span> NamespaceFacadeCache(<span class="keyword">this</span>);  </span><br><span class="line">    </span><br><span class="line">  <span class="comment">//服务端可用节点的检测器，第一次连接和重连成功之后都会触发重新获取服务端列表</span></span><br><span class="line">    ensembleTracker = zk34CompatibilityMode ? <span class="keyword">null</span> : <span class="keyword">new</span> EnsembleTracker(<span class="keyword">this</span>, builder.getEnsembleProvider());  </span><br><span class="line">  </span><br><span class="line">    runSafeService = makeRunSafeService(builder);</span><br></pre></td></tr></table></figure><p><code>newClient</code>的目的是构建ZK连接实例，包括一系列附加核心组件：后台操作、连接事件、异常监控、容器，命名空间、负载均衡等等。</p><h2 id="CuratorZookeeperClient-初始化过程"><a href="#CuratorZookeeperClient-初始化过程" class="headerlink" title="CuratorZookeeperClient 初始化过程"></a>CuratorZookeeperClient 初始化过程</h2><h3 id="CuratorZookeeperClient-初始化过程流程图"><a href="#CuratorZookeeperClient-初始化过程流程图" class="headerlink" title="CuratorZookeeperClient 初始化过程流程图"></a>CuratorZookeeperClient 初始化过程流程图</h3><p>CuratorZookeeperClient 初始化过程图如下：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230708120426.png" alt="image.png"></p><h3 id="CuratorZookeeperClient-初始化代码分析"><a href="#CuratorZookeeperClient-初始化代码分析" class="headerlink" title="CuratorZookeeperClient 初始化代码分析"></a>CuratorZookeeperClient 初始化代码分析</h3><p>上面提到，<code>CuratorFrameworkImp</code>l的初始化过程中，有一段比较重要的<code>CuratorZookeeperClient</code>客户端初始化过程，下面就来看看这个初始化过程干了啥。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CuratorZookeeperClient</span><span class="params">(ZookeeperFactory zookeeperFactory, EnsembleProvider ensembleProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> sessionTimeoutMs, <span class="keyword">int</span> connectionTimeoutMs, <span class="keyword">int</span> waitForShutdownTimeoutMs, Watcher watcher,</span></span></span><br><span class="line"><span class="function"><span class="params">            RetryPolicy retryPolicy, <span class="keyword">boolean</span> canBeReadOnly, ConnectionHandlingPolicy connectionHandlingPolicy)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StandardConnectionHandler当收到Disconnect事件后，如果在规定时间内没有重连到服务器，则会主动触发Expired事件</span></span><br><span class="line">        <span class="keyword">this</span>.connectionHandlingPolicy = connectionHandlingPolicy;</span><br><span class="line">        <span class="keyword">if</span> ( sessionTimeoutMs &lt; connectionTimeoutMs )</span><br><span class="line">        &#123;</span><br><span class="line">            log.warn(String.format(<span class="string">"session timeout [%d] is less than connection timeout [%d]"</span>, sessionTimeoutMs, connectionTimeoutMs));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 重连策略</span></span><br><span class="line">        retryPolicy = Preconditions.checkNotNull(retryPolicy, <span class="string">"retryPolicy cannot be null"</span>);</span><br><span class="line">        ensembleProvider = Preconditions.checkNotNull(ensembleProvider, <span class="string">"ensembleProvider cannot be null"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.connectionTimeoutMs = connectionTimeoutMs;</span><br><span class="line">        <span class="keyword">this</span>.waitForShutdownTimeoutMs = waitForShutdownTimeoutMs;</span><br><span class="line">        <span class="comment">// //curator注册到原生客户端上的defaultWatcher,会收到和连接状态有关的事件通知等，负责超时重连</span></span><br><span class="line">        state = <span class="keyword">new</span> ConnectionState(zookeeperFactory, ensembleProvider, sessionTimeoutMs, connectionTimeoutMs, watcher, tracer, canBeReadOnly, connectionHandlingPolicy);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  重试策略设置</span></span><br><span class="line">        setRetryPolicy(retryPolicy);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>ConnectionState</strong>是<code>Curator</code>注册到原生客户端上的<strong>defaultWatcher</strong>，它会收到和连接状态有关的事件通知等，负责超时重连操作等。</p><p>再来看下<code>ConnectionState</code>的构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ConnectionState(ZookeeperFactory zookeeperFactory, EnsembleProvider ensembleProvider, <span class="keyword">int</span> sessionTimeoutMs, <span class="keyword">int</span> connectionTimeoutMs, Watcher parentWatcher, AtomicReference&lt;TracerDriver&gt; tracer, <span class="keyword">boolean</span> canBeReadOnly, ConnectionHandlingPolicy connectionHandlingPolicy)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">this</span>.ensembleProvider = ensembleProvider;  </span><br><span class="line">    <span class="keyword">this</span>.sessionTimeoutMs = sessionTimeoutMs;  </span><br><span class="line">    <span class="keyword">this</span>.connectionTimeoutMs = connectionTimeoutMs;  </span><br><span class="line">    <span class="keyword">this</span>.tracer = tracer;  </span><br><span class="line">    <span class="keyword">this</span>.connectionHandlingPolicy = connectionHandlingPolicy;  </span><br><span class="line">    <span class="keyword">if</span> ( parentWatcher != <span class="keyword">null</span> )  </span><br><span class="line">    &#123;  </span><br><span class="line">    <span class="comment">// 因为defaultWatcher只能有一个，通过parentWatchers可实现defaultWatcher接到事件通知时parentWatchers的回调</span></span><br><span class="line">        parentWatchers.offer(parentWatcher);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    handleHolder = <span class="keyword">new</span> HandleHolder(zookeeperFactory, <span class="keyword">this</span>, ensembleProvider, sessionTimeoutMs, canBeReadOnly);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>parentWatchers</strong> 使用了并发安全队列 <strong>ConcurrentLinkedQueue</strong>，这部分属于JDK并发编程的基础内容，这个队列的作用如下：</p><blockquote><p><strong>ConcurrentLinkedQueue</strong>：一个基于链接节点的<strong>无界线程安全队列</strong>。此队列按照 FIFO（<strong>先进先出</strong>）原则对元素进行排序。队列的<strong>头部</strong> 是队列中<strong>时间最长的元素</strong>。队列的尾部 是队列中时间最短的元素。<strong>新的元素插入到队列的尾部</strong>，队列获取操作从队列头部获得元素。当多个线程共享访问一个公共 collection 时，ConcurrentLinkedQueue 是一个恰当的选择。此队列不允许使用 null 元素。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Watcher&gt; parentWatchers = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;Watcher&gt;();</span><br></pre></td></tr></table></figure><h2 id="ConnectionStateManager-初始化过程"><a href="#ConnectionStateManager-初始化过程" class="headerlink" title="ConnectionStateManager 初始化过程"></a>ConnectionStateManager 初始化过程</h2><h3 id="ConnectionStateManager-初始化过程流程图"><a href="#ConnectionStateManager-初始化过程流程图" class="headerlink" title="ConnectionStateManager 初始化过程流程图"></a>ConnectionStateManager 初始化过程流程图</h3><p><strong>ConnectionStateManager</strong> 主要是持有<code>Client</code>引用，通过连接状态管理工程创建构建监听器，以及构建只允许一个线程执行的线程池。</p><blockquote><p>Curator 的设计记录是一个客户端永远只有一个线程负责工作。</p></blockquote><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230704210542.png" alt="image.png"></p><h3 id="ConnectionStateManager-初始化代码分析"><a href="#ConnectionStateManager-初始化代码分析" class="headerlink" title="ConnectionStateManager 初始化代码分析"></a>ConnectionStateManager 初始化代码分析</h3><p>在<code>Curator</code>框架初始化代码中包含了 <strong>ConnectionStateManager</strong> 初始化，它主要负责状态维护和连接状态变更通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//负责连接状态变化时的通知</span></span><br><span class="line">connectionStateManager = <span class="keyword">new</span> ConnectionStateManager(<span class="keyword">this</span>, builder.getThreadFactory(), builder.getSessionTimeoutMs(), builder.getConnectionHandlingPolicy().getSimulatedSessionExpirationPercent(), builder.getConnectionStateListenerManagerFactory());</span><br></pre></td></tr></table></figure><p>可以看到，如果要监听状态改变，需要注册一个监听器。相关的注册方式在“”部分进行详细介绍，这里先看下相关的成员变量以及初始化方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//连接状态事件通知队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;ConnectionState&gt; eventQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;ConnectionState&gt;(QUEUE_SIZE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要通知的listeners </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> UnaryListenerManager&lt;ConnectionStateListener&gt; listeners;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ConnectionStateManager的运行状态 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;State&gt; state = <span class="keyword">new</span> AtomicReference&lt;State&gt;(State.LATENT);</span><br></pre></td></tr></table></figure><p><strong>ConnectionStateManager#ConnectionStateManager</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Params:</span></span><br><span class="line"><span class="comment">client – the client </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">threadFactory – thread factory to use or null for a default </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">sessionTimeoutMs – the ZK session timeout in milliseconds </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">sessionExpirationPercent – percentage of negotiated session timeout to use when simulating a session timeout. 0 means don't simulate at all </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">managerFactory – manager factory to use</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConnectionStateManager</span><span class="params">(CuratorFramework client, ThreadFactory threadFactory, <span class="keyword">int</span> sessionTimeoutMs, <span class="keyword">int</span> sessionExpirationPercent, ConnectionStateListenerManagerFactory managerFactory)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.client = client;  </span><br><span class="line">    <span class="keyword">this</span>.sessionTimeoutMs = sessionTimeoutMs;  </span><br><span class="line">    <span class="keyword">this</span>.sessionExpirationPercent = sessionExpirationPercent;  </span><br><span class="line">    <span class="keyword">if</span> ( threadFactory == <span class="keyword">null</span> )  </span><br><span class="line">    &#123;  </span><br><span class="line">        threadFactory = ThreadUtils.newThreadFactory(<span class="string">"ConnectionStateManager"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//事件队列处理线程池</span></span><br><span class="line">    service = Executors.newSingleThreadExecutor(threadFactory);  </span><br><span class="line">    <span class="comment">// 构建监听器队列</span></span><br><span class="line">    listeners = managerFactory.newManager(client);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CuratorFrameworkImpl-启动过程"><a href="#CuratorFrameworkImpl-启动过程" class="headerlink" title="CuratorFrameworkImpl 启动过程"></a>CuratorFrameworkImpl 启动过程</h2><p><code>CuratorFrameworkImpl</code>启动过程的主要工作如下：</p><ol><li>启动 <strong>ConnectionStateManager</strong>，同时负责连接事件的通知准备。</li><li>启动 <strong>CuratorZookeeperClient</strong> ，建立服务端会话连接。</li><li>启动一个单线程线程池，这个线程负责监听执行后台任务队列，不断从任务队列取出元素并且执行。</li></ol><h3 id="CuratorFrameworkImpl-启动过程流程图"><a href="#CuratorFrameworkImpl-启动过程流程图" class="headerlink" title="CuratorFrameworkImpl 启动过程流程图"></a>CuratorFrameworkImpl 启动过程流程图</h3><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230705073357.png" alt="image.png"></p><h3 id="客户端连接-client-start"><a href="#客户端连接-client-start" class="headerlink" title="客户端连接 client.start();"></a>客户端连接 client.start();</h3><p>调用<code>start</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.start();</span><br></pre></td></tr></table></figure><p><code>client.start();</code>内部逻辑如下，这个方法的代码都比较简单，具体可以参考注释理解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    log.info(<span class="string">"Starting"</span>);  </span><br><span class="line">    <span class="comment">// 使用CAS把当前的运行状态切换为 STARTED，状态切换之后不可逆</span></span><br><span class="line">    <span class="comment">// LATENT:CuratorFramework.start() has not yet been called</span></span><br><span class="line">    <span class="comment">// STARTED: CuratorFramework.start() has been called</span></span><br><span class="line">    <span class="keyword">if</span> ( !state.compareAndSet(CuratorFrameworkState.LATENT, CuratorFrameworkState.STARTED) )  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot be started more than once"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">try</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">    <span class="comment">// ordering dependency - must be called before client.start()  </span></span><br><span class="line">    <span class="comment">// 顺序依赖 - 必须在 client.start()之前调用。 </span></span><br><span class="line">        connectionStateManager.start(); </span><br><span class="line"><span class="comment">// 构建连接监听器，监听异常连接状态</span></span><br><span class="line">        <span class="keyword">final</span> ConnectionStateListener listener = <span class="keyword">new</span> ConnectionStateListener()  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(CuratorFramework client, ConnectionState newState)</span>  </span></span><br><span class="line"><span class="function">            </span>&#123;  </span><br><span class="line">            <span class="comment">// CONNECTED：为第一次成功连接到服务器而发送。注意：对于任何一个CuratorFramework实例只会收到其中一条信息。</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// RECONNECTED：一个暂停的、丢失的或只读的连接已被重新建立</span></span><br><span class="line">            <span class="comment">// RECONNECTED：A suspended, lost, or read-only connection has been re-established</span></span><br><span class="line">            <span class="comment">// 如果已经连接或者正在重连</span></span><br><span class="line">                <span class="keyword">if</span> ( ConnectionState.CONNECTED == newState || ConnectionState.RECONNECTED == newState )  </span><br><span class="line">                &#123;  </span><br><span class="line">                    logAsErrorConnectionErrors.set(<span class="keyword">true</span>);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doNotDecorate</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">            </span>&#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;;  </span><br><span class="line"><span class="comment">// 注册监听器</span></span><br><span class="line">        <span class="keyword">this</span>.getConnectionStateListenable().addListener(listener);  </span><br><span class="line"><span class="comment">// 全局启动开发设置为true，ConnectionState 状态更新</span></span><br><span class="line">        client.start();  </span><br><span class="line"><span class="comment">// 构建线程池</span></span><br><span class="line">        executorService = Executors.newSingleThreadScheduledExecutor(threadFactory);         <span class="comment">// 执行具备返回值的Callable 任务</span></span><br><span class="line">        executorService.submit(<span class="keyword">new</span> Callable&lt;Object&gt;()  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception  </span></span><br><span class="line"><span class="function">            </span>&#123;  </span><br><span class="line">            <span class="comment">// 关键部分：挂起后台操作</span></span><br><span class="line">                backgroundOperationsLoop();  </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;            </span><br><span class="line">&#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> ( ensembleTracker != <span class="keyword">null</span> )  </span><br><span class="line">        &#123;  </span><br><span class="line">            ensembleTracker.start();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        log.info(schemaSet.toDocumentation());  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">catch</span> ( Exception e )  </span><br><span class="line">    &#123;  </span><br><span class="line">        ThreadUtils.checkInterrupted(e);  </span><br><span class="line">        handleBackgroundOperationException(<span class="keyword">null</span>, e);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过CAS操作将当前状态更新为 <strong>STARTED</strong>，同时根据<code>if</code>逻辑可以得知<code>start()</code>方法不允许重复调用，这和 JDK的 Thread 设计思路比较相似，Thread 同样只允许执行一次<code>start()</code>方法。</p><p>CAS 操作成功则构建连接监听器监听异常连接状态，监听器中会判断当前客户端是否已经连接或者正在重连，如果是则设置<strong>logAsErrorConnectionErrors=true</strong>。</p><p>我们继续看关键部分<code>backgroundOperationsLoop();</code>。</p><h3 id="后台轮询操作指令-backgroundOperationsLoop"><a href="#后台轮询操作指令-backgroundOperationsLoop" class="headerlink" title="后台轮询操作指令 backgroundOperationsLoop()"></a>后台轮询操作指令 <code>backgroundOperationsLoop()</code></h3><p><code>backgroundOperationsLoop()</code>方法，根据名称得知这是一个后台循环，后台任务的整体流程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backgroundOperationsLoop</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">try</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">while</span> ( state.get() == CuratorFrameworkState.STARTED )  </span><br><span class="line">        &#123;  </span><br><span class="line">            OperationAndData&lt;?&gt; operationAndData;  </span><br><span class="line">            <span class="keyword">try</span>            </span><br><span class="line">            &#123;  </span><br><span class="line">                operationAndData = backgroundOperations.take();  </span><br><span class="line">                <span class="keyword">if</span> ( debugListener != <span class="keyword">null</span> )  </span><br><span class="line">                &#123;  </span><br><span class="line">                    debugListener.listen(operationAndData);  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="comment">// 执行后台操作</span></span><br><span class="line">                performBackgroundOperation(operationAndData);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">catch</span> ( InterruptedException e )  </span><br><span class="line">            &#123;  </span><br><span class="line">            <span class="comment">// 在这里中断异常会被吞掉。</span></span><br><span class="line">                <span class="comment">// swallow the interrupt as it's only possible from either a background  </span></span><br><span class="line">                <span class="comment">// operation and, thus, doesn't apply to this loop or the instance                // is being closed in which case the while test will get it            &#125;  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">finally</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        log.info(<span class="string">"backgroundOperationsLoop exiting"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>OperationAndData</code> 实现了 Delayed 接口用于实现阻塞队列延迟重试。</p></blockquote><p>上面的处理逻辑如下：</p><ol><li>判断当前是否为<code>STARTED</code>状态，一直循环。</li><li>从阻塞队列<strong>BlockingQueue</strong>当中弹出操作指令对象，在初始化代码中可以得知是一个<code>DelayQueue</code> 延迟并发安全阻塞队列，<code>OperationAndData</code> 对象毫无疑问实现了<code>Delayed</code>接口。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">backgroundOperations = <span class="keyword">new</span> DelayQueue&lt;OperationAndData&lt;?&gt;&gt;();</span><br></pre></td></tr></table></figure><ol start="3"><li>判断Debug 监听器是否存在，如果存在则监听<code>OperationAndData</code>。</li><li>执行后台操作<code>performBackgroundOperation</code>，它的工作是从阻塞队列不断获取数据操作<code>OperationAndData</code> 对象调用<code>callPerformBackgroundOperation</code>方法执行。</li><li>如果无法正常连接ZK集群，此时会走else分支并且进入重连判断逻辑。如果符合条件，则添加到阻塞队列的当中等待下一次重试。（注意这里是<strong>主动重试，同步操作</strong>）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performBackgroundOperation</span><span class="params">(OperationAndData&lt;?&gt; operationAndData)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( !operationAndData.isConnectionRequired() || client.isConnected() )</span><br><span class="line">            &#123;</span><br><span class="line">                operationAndData.callPerformBackgroundOperation();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">            <span class="comment">// 允许重连或者超时这样的情况发生</span></span><br><span class="line">                client.getZooKeeper();  <span class="comment">// important - allow connection resets, timeouts, etc. to occur</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果连接超时，则跑出 CuratorConnectionLossException 异常</span></span><br><span class="line">                <span class="keyword">if</span> ( operationAndData.getElapsedTimeMs() &gt;= client.getConnectionTimeoutMs() )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> CuratorConnectionLossException();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果没有超时，则推入到 forcedSleepOperations 强制睡眠后等待重连</span></span><br><span class="line">                sleepAndQueueOperation(operationAndData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> ( Throwable e )</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">// 检查线程中断</span></span><br><span class="line">            ThreadUtils.checkInterrupted(e);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * Fix edge case reported as CURATOR-52. ConnectionState.checkTimeouts() throws KeeperException.ConnectionLossException</span></span><br><span class="line"><span class="comment">             * when the initial (or previously failed) connection cannot be re-established. This needs to be run through the retry policy</span></span><br><span class="line"><span class="comment">             * and callbacks need to get invoked, etc.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">             <span class="comment">/*</span></span><br><span class="line"><span class="comment">             修复报告为CURATOR-52的边缘案例。当初始（或之前失败的）连接无法重新建立时，ConnectionState.checkTimeouts()会抛出KeeperException.ConnectionLossException。这需要通过重试策略运行，回调需要被调用，等等。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">             <span class="comment">// 连接丢失异常处理</span></span><br><span class="line">            <span class="keyword">if</span> ( e <span class="keyword">instanceof</span> CuratorConnectionLossException )</span><br><span class="line">            &#123;</span><br><span class="line">                WatchedEvent watchedEvent = <span class="keyword">new</span> WatchedEvent(Watcher.Event.EventType.None, Watcher.Event.KeeperState.Disconnected, <span class="keyword">null</span>);</span><br><span class="line">                CuratorEvent event = <span class="keyword">new</span> CuratorEventImpl(<span class="keyword">this</span>, CuratorEventType.WATCHED, KeeperException.Code.CONNECTIONLOSS.intValue(), <span class="keyword">null</span>, <span class="keyword">null</span>, operationAndData.getContext(), <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, watchedEvent, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">// 如果重连次数</span></span><br><span class="line">                <span class="keyword">if</span> ( checkBackgroundRetry(operationAndData, event) )</span><br><span class="line">                &#123;</span><br><span class="line">                <span class="comment">// 推送到backgroundOperations队列尝试重连</span></span><br><span class="line">                    queueOperation(operationAndData);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                <span class="comment">// 放弃重连</span></span><br><span class="line">                    logError(<span class="string">"Background retry gave up"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">            <span class="comment">// 否则需要处理后台操作异常</span></span><br><span class="line">                handleBackgroundOperationException(operationAndData, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里顺带介绍下后台决定是否重试的判断逻辑，主要是根据用户传输的重试策略执行对应的重试逻辑判断，比较经典的<strong>策略模式</strong>实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.getRetryPolicy().allowRetry(operationAndData.getThenIncrementRetryCount(), operationAndData.getElapsedTimeMs(), operationAndData)</span><br></pre></td></tr></table></figure><h3 id="operationAndData-callPerformBackgroundOperation-后台任务执行"><a href="#operationAndData-callPerformBackgroundOperation-后台任务执行" class="headerlink" title="operationAndData.callPerformBackgroundOperation() 后台任务执行"></a>operationAndData.callPerformBackgroundOperation() 后台任务执行</h3><p><strong>operationAndData</strong> 继承了<strong>DelayQueue</strong>，运用多态特性拥有不同实现，内部只有一行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callPerformBackgroundOperation</span><span class="params">()</span> <span class="keyword">throws</span> Exception  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    operation.performBackgroundOperation(<span class="keyword">this</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>operation.performBackgroundOperation(this);  对应 <strong>BackgroundOperation#performBackgroundOperation</strong></p></blockquote><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230708125752.png" alt="image.png"></p><p><strong>BackgroundOperation</strong> 后台操作有很多具体的实现，对应了ZK常见操作。传递的<code>this</code>就是 <code>operationAndData</code> 对象。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230703204542.png" alt="image.png"></p><h2 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h2><ol><li>Client 连接状态都是通过 <strong>ConnectionState</strong> 进行管理的，它会负责尝试超时重连的操作。</li><li><strong>ConnectionStateManager</strong> 会负责连接状态的改变和通知。</li><li><strong>ConnectionHandlingPolicy</strong>  则对应了连接超时策略的触发。</li></ol><p>在后台轮询队列操作指令对象过程中会在状态改变的时候尝试重连，客户端重连必然要通知到对应的监听器，那么 <strong>Curator</strong> 是如何进行客户端 <strong>会话状态通知</strong>以及<strong>会话超时重连</strong>的？</p><h3 id="连接事件监听和状态变更-ConnectionState-process"><a href="#连接事件监听和状态变更-ConnectionState-process" class="headerlink" title="连接事件监听和状态变更 ConnectionState#process"></a>连接事件监听和状态变更 ConnectionState#process</h3><p>从<code>ConnectionState#process</code>的代码可以得知，连接状态相关的事件类型为<code>Watcher.Event.EventType.None</code>，会通知到所有的Wathcer。</p><p>其中<code>ConnectionState</code>作为 <strong>defaultWatcher</strong> ，它的事件回调如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> ( LOG_EVENTS )  </span><br><span class="line">    &#123;  </span><br><span class="line">        log.debug(<span class="string">"ConnectState watcher: "</span> + event);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> ( event.getType() == Watcher.Event.EventType.None )  </span><br><span class="line">    &#123;  </span><br><span class="line">    <span class="comment">//isConnected：客户当前的连接状态，true表示已连接（SyncConnected 和 ConnectedReadOnly 状态）</span></span><br><span class="line">        <span class="keyword">boolean</span> wasConnected = isConnected.get(); </span><br><span class="line">        <span class="comment">// 根据 org.apache.zookeeper.Watcher.Event.KeeperState 进行状态判断。 </span></span><br><span class="line">        <span class="keyword">boolean</span> newIsConnected = checkState(event.getState(), wasConnected);  </span><br><span class="line">        <span class="keyword">if</span> ( newIsConnected != wasConnected )  </span><br><span class="line">        &#123;  </span><br><span class="line">        <span class="comment">// /如果连接状态发生改变，则更新</span></span><br><span class="line">            isConnected.set(newIsConnected);  </span><br><span class="line">            connectionStartMs = System.currentTimeMillis();  </span><br><span class="line">            <span class="keyword">if</span> ( newIsConnected )  </span><br><span class="line">            &#123;  </span><br><span class="line">                </span><br><span class="line"><span class="comment">//重连，更新会话超时协商时间</span></span><br><span class="line"><span class="comment">// NegotiatedSessionTimeoutMs（协商会话超时）。</span></span><br><span class="line">                lastNegotiatedSessionTimeoutMs.set(handleHolder.getNegotiatedSessionTimeoutMs());  </span><br><span class="line">                log.debug(<span class="string">"Negotiated session timeout: "</span> + lastNegotiatedSessionTimeoutMs.get());  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知parentWatchers, 注意初始化的时候其实传入了一个parentWatcher,会调用CuratorFrameworkImpl.processEvent</span></span><br><span class="line">    <span class="keyword">for</span> ( Watcher parentWatcher : parentWatchers )  </span><br><span class="line">    &#123;  </span><br><span class="line">        OperationTrace trace = <span class="keyword">new</span> OperationTrace(<span class="string">"connection-state-parent-process"</span>, tracer.get(), getSessionId());  </span><br><span class="line">        parentWatcher.process(event);  </span><br><span class="line">        trace.commit();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一段注释提到可以看到遍历<code>parentWatchers</code>并且调用<code>process</code>方法。这里实际上默认会有个Watcher，那就是在初始化的时候默认会注册一个Watch作为parentWatcher传入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.client = <span class="keyword">new</span> CuratorZookeeperClient  </span><br><span class="line">      (  </span><br><span class="line">          localZookeeperFactory,  </span><br><span class="line">          builder.getEnsembleProvider(),  </span><br><span class="line">          builder.getSessionTimeoutMs(),  </span><br><span class="line">          builder.getConnectionTimeoutMs(),  </span><br><span class="line">          builder.getWaitForShutdownTimeoutMs(),  </span><br><span class="line">          <span class="keyword">new</span> Watcher()  </span><br><span class="line">          &#123;  </span><br><span class="line">              <span class="meta">@Override</span>  </span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span>  </span></span><br><span class="line"><span class="function">              </span>&#123;  </span><br><span class="line">                  CuratorEvent event = <span class="keyword">new</span> CuratorEventImpl(CuratorFrameworkImpl.<span class="keyword">this</span>, CuratorEventType.WATCHED, watchedEvent.getState().getIntValue(), unfixForNamespace(watchedEvent.getPath()), <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, watchedEvent, <span class="keyword">null</span>, <span class="keyword">null</span>);  </span><br><span class="line">                  <span class="comment">// 注意初始化的时候其实传入了一个parentWatcher,会调用CuratorFrameworkImpl.processEvent</span></span><br><span class="line">                  processEvent(event);  </span><br><span class="line">              &#125;  </span><br><span class="line">          &#125;,  </span><br><span class="line">          builder.getRetryPolicy(),  </span><br><span class="line">          builder.canBeReadOnly(),  </span><br><span class="line">          builder.getConnectionHandlingPolicy()  </span><br><span class="line">      );</span><br></pre></td></tr></table></figure><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230706215011.png" alt="image.png"></p><p>这部分通知事件回调在下文会再次提到，这里简单有关印象即可。</p><h3 id="连接状态检查和处理-ConnectionState-checkState"><a href="#连接状态检查和处理-ConnectionState-checkState" class="headerlink" title="连接状态检查和处理 ConnectionState#checkState"></a>连接状态检查和处理 ConnectionState#checkState</h3><p>连接状态检查和处理在<code>ConnectionState#checkState</code>方法中进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> newIsConnected = checkState(event.getState(), wasConnected);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkState</span><span class="params">(Event.KeeperState state, <span class="keyword">boolean</span> wasConnected)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">boolean</span> isConnected = wasConnected;  </span><br><span class="line">    <span class="keyword">boolean</span> checkNewConnectionString = <span class="keyword">true</span>;  </span><br><span class="line">    <span class="keyword">switch</span> ( state )  </span><br><span class="line">    &#123;  </span><br><span class="line">    <span class="keyword">default</span>:  </span><br><span class="line">    <span class="keyword">case</span> Disconnected:  </span><br><span class="line">    &#123;  </span><br><span class="line">        isConnected = <span class="keyword">false</span>;  </span><br><span class="line">        <span class="keyword">break</span>;    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">case</span> SyncConnected:  </span><br><span class="line">    <span class="keyword">case</span> ConnectedReadOnly:  </span><br><span class="line">    &#123;  </span><br><span class="line">        isConnected = <span class="keyword">true</span>;  </span><br><span class="line">        <span class="keyword">break</span>;    &#125;  </span><br><span class="line"><span class="comment">// 访问权限异常</span></span><br><span class="line">    <span class="keyword">case</span> AuthFailed:  </span><br><span class="line">    &#123;  </span><br><span class="line">        isConnected = <span class="keyword">false</span>;  </span><br><span class="line">        log.error(<span class="string">"Authentication failed"</span>);  </span><br><span class="line">        <span class="keyword">break</span>;    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">case</span> Expired:  </span><br><span class="line">    &#123;  </span><br><span class="line">        isConnected = <span class="keyword">false</span>;  </span><br><span class="line">        checkNewConnectionString = <span class="keyword">false</span>;  </span><br><span class="line">        handleExpiredSession();  </span><br><span class="line">        <span class="keyword">break</span>;    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">case</span> SaslAuthenticated:  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">// NOP  </span></span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// the session expired is logged in handleExpiredSession, so not log here  </span></span><br><span class="line">    <span class="comment">// 会话过期被记录在handleExpiredSession中，所以不记录在这里。 </span></span><br><span class="line">    <span class="keyword">if</span> (state != Event.KeeperState.Expired) &#123;  </span><br><span class="line">        <span class="keyword">new</span> EventTrace(state.toString(), tracer.get(), getSessionId()).commit();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> ( checkNewConnectionString )  </span><br><span class="line">    &#123;  </span><br><span class="line">    <span class="comment">//如果服务端列表发生变化，则更新</span></span><br><span class="line">        String newConnectionString = handleHolder.getNewConnectionString();  </span><br><span class="line">        <span class="keyword">if</span> ( newConnectionString != <span class="keyword">null</span> )  </span><br><span class="line">        &#123;  </span><br><span class="line">            handleNewConnectionString(newConnectionString);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> isConnected;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面根据不同连接状态判断连接是否异常， 返回结果为<strong>true</strong>则表示连接是正常的，当会话超时过期<code>Expired</code>时，会调用<code>handleExpiredSession</code>进行<code>reset</code>操作（会话<strong>被动重连</strong>），这里对于非连接超时的状态进行时间追踪。</p><blockquote><p>注意重连策略 <strong>RetryPolicy</strong>这个策略在主动和被动重连中均会调用。</p></blockquote><h3 id="parentWatchers-注册和回调"><a href="#parentWatchers-注册和回调" class="headerlink" title="parentWatchers 注册和回调"></a>parentWatchers 注册和回调</h3><p>发生状态变更的方法最后部分是通知所有的parentWatchers，下面来看看这个循环干了什么事情。</p><p>再次强调初始化的时候传入了一个 <strong>parentWatcher</strong>，会调用<code>CuratorFrameworkImpl.processEvent</code> 方法，现在来看看这部分是如何注册和回调的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通知parentWatchers,注意初始化的时候其实传入了一个parentWatcher,会调用CuratorFrameworkImpl.processEvent</span></span><br><span class="line">    <span class="keyword">for</span> ( Watcher parentWatcher : parentWatchers )  </span><br><span class="line">    &#123;  </span><br><span class="line">        OperationTrace trace = <span class="keyword">new</span> OperationTrace(<span class="string">"connection-state-parent-process"</span>, tracer.get(), getSessionId());  </span><br><span class="line">        parentWatcher.process(event);  </span><br><span class="line">        trace.commit();  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们直接看看这个默认的Watcher回调<code>CuratorFrameworkImpl#processEvent(event)</code> 相关代码逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Watcher()  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        CuratorEvent event = <span class="keyword">new</span> CuratorEventImpl(CuratorFrameworkImpl.<span class="keyword">this</span>, CuratorEventType.WATCHED, watchedEvent.getState().getIntValue(), unfixForNamespace(watchedEvent.getPath()), <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, watchedEvent, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 处理事件  </span></span><br><span class="line">        processEvent(event);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><code>processEvent(event)</code>相关逻辑如下，首先对于状态变更判断，状态如果出现变更则通知到所有注册在 <strong>CuratorListener</strong> 上的监听器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processEvent</span><span class="params">(<span class="keyword">final</span> CuratorEvent curatorEvent)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> ( curatorEvent.getType() == CuratorEventType.WATCHED )  </span><br><span class="line">    &#123;  </span><br><span class="line">    <span class="comment">//状态转换</span></span><br><span class="line">        validateConnection(curatorEvent.getWatchedEvent().getState());  </span><br><span class="line">    &#125;  </span><br><span class="line">  <span class="comment">//通知所有注册的CuratorListener</span></span><br><span class="line">    listeners.forEach(<span class="keyword">new</span> Function&lt;CuratorListener, Void&gt;()  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">apply</span><span class="params">(CuratorListener listener)</span>  </span></span><br><span class="line"><span class="function">        </span>&#123;  </span><br><span class="line">            <span class="keyword">try</span>  </span><br><span class="line">            &#123;  </span><br><span class="line">                OperationTrace trace = client.startAdvancedTracer(<span class="string">"EventListener"</span>);  </span><br><span class="line">                <span class="comment">// 接收回调事件</span></span><br><span class="line">                listener.eventReceived(CuratorFrameworkImpl.<span class="keyword">this</span>, curatorEvent);  </span><br><span class="line">                trace.commit();  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">catch</span> ( Exception e )  </span><br><span class="line">            &#123;  </span><br><span class="line">                ThreadUtils.checkInterrupted(e);  </span><br><span class="line">                logError(<span class="string">"Event listener threw exception"</span>, e);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>validateConnection</code> 负责连接状态的转换代码。</p><p><strong>CuratorFrameworkImpl#validateConnection</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">validateConnection</span><span class="params">(Watcher.Event.KeeperState state)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> ( state == Watcher.Event.KeeperState.Disconnected )  </span><br><span class="line">    &#123;  </span><br><span class="line">        internalConnectionHandler.suspendConnection(<span class="keyword">this</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( state == Watcher.Event.KeeperState.Expired )  </span><br><span class="line">    &#123;  </span><br><span class="line">        connectionStateManager.addStateChange(ConnectionState.LOST);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( state == Watcher.Event.KeeperState.SyncConnected )  </span><br><span class="line">    &#123;  </span><br><span class="line">        internalConnectionHandler.checkNewConnection(<span class="keyword">this</span>);  </span><br><span class="line">        connectionStateManager.addStateChange(ConnectionState.RECONNECTED);  </span><br><span class="line">        unSleepBackgroundOperations();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( state == Watcher.Event.KeeperState.ConnectedReadOnly )  </span><br><span class="line">    &#123;  </span><br><span class="line">        internalConnectionHandler.checkNewConnection(<span class="keyword">this</span>);  </span><br><span class="line">        connectionStateManager.addStateChange(ConnectionState.READ_ONLY);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到实际的状态变更是依靠 <strong>ConnectionStateManager</strong> 组件负责的，<strong>ZK的原生客户端状态和Curator包装的状态对应</strong>表如下：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230706220450.png" alt="image.png"></p><p>此外还需要注意每一个 <code>if</code> 判断的最后一行代码中有一个添加 <strong>ConnectionState</strong> 的操作，这个操作的意义是通知所有注册到 <code>listeners</code>的<code>ConnectionStateListener</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connectionStateManager.addStateChange(ConnectionState.READ_ONLY);</span><br></pre></td></tr></table></figure><blockquote><p>至于怎么通知的会在下文介绍。</p></blockquote><h2 id="通知机制"><a href="#通知机制" class="headerlink" title="通知机制"></a>通知机制</h2><p>通知是干什么？其实就是在事件发生的时候，及时回调注册的<strong>Listenrner监听器</strong>对应的回调函数。Curator 针对不同组件设计了不同的监听器注册和回调。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义监听器 CuratorListener</span></span><br><span class="line">client.getCuratorListenable().addListener((_fk, e) -&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (e.getType().equals(CuratorEventType.WATCHED)) &#123;</span><br><span class="line">log.info(<span class="string">"测试"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">ConnectionStateListener connectionStateListener = (client1, newState) -&gt; &#123;</span><br><span class="line"><span class="comment">//Some details</span></span><br><span class="line">log.info(<span class="string">"newState =&gt; "</span>+ newState);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以注册的监听器方式如下：</p><ul><li>一次性 Watch 通知</li><li>注册 CuratorListener 通知</li><li>注册 ConnectionStateListener 通知</li><li>注册 UnhandledErrorListener 通知</li><li>后台线程操作完成时的回调通知</li><li>缓存机制，多次注册</li></ul><h3 id="一次性-Watch-通知"><a href="#一次性-Watch-通知" class="headerlink" title="一次性 Watch 通知"></a>一次性 Watch 通知</h3><p>每次都需要反复通过下面的方法重新注册。这里涉及到 NodeCache 的相关组件，由于目前并没有介绍相关的前置代码，这里暂时跳过介绍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.checkExists().creatingParentContainersIfNeeded().usingWatcher(watcher).inBackground(backgroundCallback).forPath(path);</span><br></pre></td></tr></table></figure><h3 id="注册-CuratorListener-通知"><a href="#注册-CuratorListener-通知" class="headerlink" title="注册 CuratorListener 通知"></a>注册 CuratorListener 通知</h3><p>实现方式很简单，就是把监听器注册到<code>CuratorFrameworkImpl.listeners</code>这个容器当中，后台线程完成操作通知该监听器容器的所有监听器。</p><p>比如异步的方式在ZK上面创建路径会触发<strong>CuratorEventType.CREATE</strong>事件，还有就是连接状态事件触发的时候<strong>parentWatcher</strong>也会回调这些listeners，比如下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * connect ZK, register watchers</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CuratorFramework <span class="title">mkClient</span><span class="params">(Map conf, List&lt;String&gt; servers, Object port,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String root, <span class="keyword">final</span> WatcherCallBack watcher)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    CuratorFramework fk = Utils.newCurator(conf, servers, port, root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义监听器 CuratorListener</span></span><br><span class="line">    fk.getCuratorListenable().addListener(<span class="keyword">new</span> CuratorListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eventReceived</span><span class="params">(CuratorFramework _fk, CuratorEvent e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (e.getType().equals(CuratorEventType.WATCHED)) &#123;</span><br><span class="line">                WatchedEvent event = e.getWatchedEvent();</span><br><span class="line"></span><br><span class="line">                watcher.execute(event.getState(), event.getType(), event.getPath());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    fk.start();</span><br><span class="line">    <span class="keyword">return</span> fk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CuratorFrameworkImpl#processEvent</strong></p><p><code>processEvent</code> 方法总会进行注册的 <strong>CuratorListener</strong> 回调操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processEvent</span><span class="params">(<span class="keyword">final</span> CuratorEvent curatorEvent)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( curatorEvent.getType() == CuratorEventType.WATCHED )</span><br><span class="line">        &#123;</span><br><span class="line">            validateConnection(curatorEvent.getWatchedEvent().getState());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        listeners.forEach(<span class="keyword">new</span> Function&lt;CuratorListener, Void&gt;()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Void <span class="title">apply</span><span class="params">(CuratorListener listener)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    OperationTrace trace = client.startAdvancedTracer(<span class="string">"EventListener"</span>);</span><br><span class="line">                    listener.eventReceived(CuratorFrameworkImpl.<span class="keyword">this</span>, curatorEvent);</span><br><span class="line">                    trace.commit();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> ( Exception e )</span><br><span class="line">                &#123;</span><br><span class="line">                    ThreadUtils.checkInterrupted(e);</span><br><span class="line">                    logError(<span class="string">"Event listener threw exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>具体回调则是有各种执行构建实现器完成的，这一块深究比较复杂，这里有个概念后续有需要查看相关实现即可。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230708111456.png" alt="image.png"></p><h3 id="注册-ConnectionStateListener-通知"><a href="#注册-ConnectionStateListener-通知" class="headerlink" title="注册 ConnectionStateListener 通知"></a>注册 ConnectionStateListener 通知</h3><p>如果添加 <strong>ConnectionStateListener</strong> 监听器，则在连接状态发生改变时，会收到通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ConnectionStateListener connectionStateListener = <span class="keyword">new</span> ConnectionStateListener()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(CuratorFramework client, ConnectionState newState)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">          <span class="comment">//Some details</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">client.getConnectionStateListenable().addListener(connectionStateListener);</span><br></pre></td></tr></table></figure><p>ConnectionStateListener 监听器的事件回调发生在<strong>ConnectionStateManager</strong>当中，但是前面我们只介绍了如何初始化，下面扩展介绍回调<code>ConnectionStateListener</code>的部分</p><h4 id="ConnectionStateManager-如何回调-ConnectionStateListener？"><a href="#ConnectionStateManager-如何回调-ConnectionStateListener？" class="headerlink" title="ConnectionStateManager 如何回调 ConnectionStateListener？"></a>ConnectionStateManager 如何回调 ConnectionStateListener？</h4><p><strong>CuratorFrameworkImpl#validateConnection</strong></p><p>上面讲解<strong>会话机制</strong>的时候，提到了最后有一个添加 <strong>ConnectionState</strong> 的操作，这里将介绍收到 <strong>ConnectionState</strong> 变更之后如何回调注册在自己身上的监听器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">validateConnection</span><span class="params">(Watcher.Event.KeeperState state)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( state == Watcher.Event.KeeperState.Expired )  </span><br><span class="line">    &#123;  </span><br><span class="line">        connectionStateManager.addStateChange(ConnectionState.LOST);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( state == Watcher.Event.KeeperState.SyncConnected )  </span><br><span class="line">    &#123;  </span><br><span class="line">        unSleepBackgroundOperations();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( state == Watcher.Event.KeeperState.ConnectedReadOnly )  </span><br><span class="line">    &#123;  </span><br><span class="line">        connectionStateManager.addStateChange(ConnectionState.READ_ONLY);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体处理在下面这个方法中完成。</p><p><strong>ConnectionStateManager#processEvents</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processEvents</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> ( state.get() == State.STARTED )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> useSessionTimeoutMs = getUseSessionTimeoutMs();</span><br><span class="line">                <span class="keyword">long</span> elapsedMs = startOfSuspendedEpoch == <span class="number">0</span> ? useSessionTimeoutMs / <span class="number">2</span> : System.currentTimeMillis() - startOfSuspendedEpoch;</span><br><span class="line">                <span class="keyword">long</span> pollMaxMs = useSessionTimeoutMs - elapsedMs;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> ConnectionState newState = eventQueue.poll(pollMaxMs, TimeUnit.MILLISECONDS);</span><br><span class="line">                <span class="keyword">if</span> ( newState != <span class="keyword">null</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( listeners.isEmpty() )</span><br><span class="line">                    &#123;</span><br><span class="line">                        log.warn(<span class="string">"There are no ConnectionStateListeners registered."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="comment">// 关键部分，当出现状态变更进行回调监听器通知</span></span><br><span class="line">                    listeners.forEach(listener -&gt; listener.stateChanged(client, newState));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ( sessionExpirationPercent &gt; <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span>(<span class="keyword">this</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        checkSessionExpiration();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> ( InterruptedException e )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// swallow the interrupt as it's only possible from either a background</span></span><br><span class="line">                <span class="comment">//  吞下中断，因为它只可能来自后台操作</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// operation and, thus, doesn't apply to this loop or the instance</span></span><br><span class="line">                <span class="comment">// is being closed in which case the while test will get it</span></span><br><span class="line">                <span class="comment">// 如果实例在关闭有可能走到这一块代码</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面内容重要的其实就一行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listeners.forEach(listener -&gt; listener.stateChanged(client, newState));</span><br></pre></td></tr></table></figure><p>这个<strong>processEvents</strong>是怎么回调的？其实在之前画的 <strong>CuratorFrameworkImpl</strong> 启动过程流程图中就有展示。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230706222022.png" alt="image.png"></p><p><strong>ConnectionStateManager</strong> 当中有一个 <strong>ExecutorService</strong> 线程池，翻看代码可以得知他的实现是 <strong>SingleThreadScheduledExecutor</strong>，这里含义明显就是单独开启一个线程轮询这一段代码检查 <strong>listener</strong>，状态变更通知注册在 <strong>ConnectionStateManager</strong> 上的监听器。</p><h3 id="注册-UnhandledErrorListener-通知"><a href="#注册-UnhandledErrorListener-通知" class="headerlink" title="注册 UnhandledErrorListener 通知"></a>注册 UnhandledErrorListener 通知</h3><p>同理注册到<code>CuratorFrameworkImpl.unhandledErrorListeners</code>当中，当后台线程操作发生异常或者handler发生异常的时候会触发。</p><p><strong>注册方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * connect ZK, register watchers</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CuratorFramework <span class="title">mkClient</span><span class="params">(Map conf, List&lt;String&gt; servers, Object port,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String root, <span class="keyword">final</span> WatcherCallBack watcher)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    CuratorFramework fk = Utils.newCurator(conf, servers, port, root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义监听器 UnhandledErrorListener</span></span><br><span class="line">   fk.getUnhandledErrorListenable().addListener(<span class="keyword">new</span> UnhandledErrorListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unhandledError</span><span class="params">(String msg, Throwable error)</span> </span>&#123;</span><br><span class="line">            String errmsg = <span class="string">"Unrecoverable zookeeper error, halting process: "</span> + msg;</span><br><span class="line">            LOG.error(errmsg, error);</span><br><span class="line">            JStormUtils.halt_process(<span class="number">1</span>, <span class="string">"Unrecoverable zookeeper error"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    fk.start();</span><br><span class="line">    <span class="keyword">return</span> fk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如何触发？</strong></p><p>触发的相关代码在<code>CuratorFrameworkImpl#logError</code>方法中，注意这里的<code>apply</code>方法处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logError</span><span class="params">(String reason, <span class="keyword">final</span> Throwable e)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"><span class="comment">// 省略其他无关代码</span></span><br><span class="line">    unhandledErrorListeners.forEach(<span class="keyword">new</span> Function&lt;UnhandledErrorListener, Void&gt;()  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">apply</span><span class="params">(UnhandledErrorListener listener)</span>  </span></span><br><span class="line"><span class="function">        </span>&#123;  </span><br><span class="line">            listener.unhandledError(localReason, e);  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;        </span><br><span class="line">            &#125;  </span><br><span class="line">    &#125;);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略无关代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后台线程操作完成时的回调通知"><a href="#后台线程操作完成时的回调通知" class="headerlink" title="后台线程操作完成时的回调通知"></a>后台线程操作完成时的回调通知</h3><p>对于不同操作比如 <code>setData</code>，可以通过链式调用的方式传入回调函数 callback，操作完成之后会执行回调函数完成回调操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDataAsyncWithCallback</span><span class="params">(CuratorFramework client, BackgroundCallback callback, String path, <span class="keyword">byte</span>[] payload)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">// this is another method of getting notification of an async completion</span></span><br><span class="line">       client.setData().inBackground(callback).forPath(path, payload);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="缓存机制，多次注册"><a href="#缓存机制，多次注册" class="headerlink" title="缓存机制，多次注册"></a>缓存机制，多次注册</h3><p>Curator的缓存机制是一块比较大的部头，Curator 的缓存方式包括：</p><ul><li>Path Cache</li><li>Node Cache </li><li>Tree Cache</li></ul><p>缓存在使用之前会和服务端的节点数据进行对比，当数据不一致时，会通过watch机制触发回调刷新本地缓存，同时再次注册Watch，每次重连会注册新的 Watcher，保证 Watcher永远不丢失。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过通知机制和会话管理两个部分，我们了解到：</p><ul><li><strong>客户端通知</strong>是同步完成。</li><li><code>connectionStateManager.listeners</code>是由<strong>内部的线程池</strong>做异步通知</li><li><code>CuratorFrameworkImpl.listeners</code> 对于连接状态的通知，与watcher通知线程为<strong>同步</strong>，由后台线程通知时为<strong>异步</strong>。</li><li>watcher注册过多可能导致重连之后watcher丢失。</li></ul><h2 id="回顾初始化过程"><a href="#回顾初始化过程" class="headerlink" title="回顾初始化过程"></a>回顾初始化过程</h2><p>Curator框架实现CuratorFrameworkImpl启动时，首先启动连接状态管理器<strong>ConnectionStateManager</strong>， 然后再启动客户端<strong>CuratorZookeeperClient</strong>。</p><p>构造Curator框架实现CuratorFrameworkImpl初始化动客户端CuratorZookeeperClient，注意在这里会默认传入一个Watcher，用于处理CuratorEvent。)。 </p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230717113221.png" alt="image.png"></p><p>CuratorZookeeperClient启动过程，关键点是在启动连接状态ConnectionState（在构造CuratorZookeeperClient，初始化连接状态，并将内部Watcher传给连接状态）。 </p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230717112918.png" alt="image.png"></p><p>连接状态实现了观察者Watcher，在连接状态建立时，调用客户端CuratorZookeeperClient传入的Watcher，处理相关事件。而这个Watcher是在现CuratorFrameworkImpl初始化动客户端CuratorZookeeperClient时 传入的。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230717113503.png" alt="image.png"></p><p><strong>客户端观察者的实际处理业务逻辑在CuratorFrameworkImpl实现</strong>，也就是<code>processEvent</code>方法，processEvent主要处理逻辑为，遍历CuratorFrameworkImpl内部的监听器容器内的监听器处理相关CuratorEvent 事件。这个CuratorEvent事件，是由原生WatchedEvent事件包装而来。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230717113536.png" alt="image.png"></p><p>启动连接状态管理器<strong>ConnectionStateManager</strong>，主要是使用连接状态监听器容器（UnaryListenerManager&lt; ConnectionStateListener&gt;）<strong>Listenabler</strong>（之前版本叫 <strong>ListenerContainer</strong>）中的监听器。</p><p><strong>ConnectionStateManager</strong>中监听器触发具体工作是消费连接状态事件队列<strong>BlockingQueue</strong>中事件。这里<strong>BlockingQueue</strong>里面存放的是ConnectionState状态变更之后【offer】的节点。</p><p>这部分又回到【注册 ConnectionStateListener 通知】部分，状态变更之后最后一段有一个<code>connectionStateManager.addStateChange(XXXX);</code>的小动作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">validateConnection</span><span class="params">(Watcher.Event.KeeperState state)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( state == Watcher.Event.KeeperState.Expired )  </span><br><span class="line">    &#123;  </span><br><span class="line">        connectionStateManager.addStateChange(ConnectionState.LOST);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( state == Watcher.Event.KeeperState.SyncConnected )  </span><br><span class="line">    &#123;  </span><br><span class="line">        unSleepBackgroundOperations();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( state == Watcher.Event.KeeperState.ConnectedReadOnly )  </span><br><span class="line">    &#123;  </span><br><span class="line">        connectionStateManager.addStateChange(ConnectionState.READ_ONLY);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过代码下探，最终回到下面的部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postState</span><span class="params">(ConnectionState state)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       log.info(<span class="string">"State change: "</span> + state);</span><br><span class="line"></span><br><span class="line">       notifyAll();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> ( !eventQueue.offer(state) )</span><br><span class="line">       &#123;</span><br><span class="line">           eventQueue.poll();</span><br><span class="line">           log.warn(<span class="string">"ConnectionStateManager queue full - dropping events to make room"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>@since 4.2.0 return type has changed from ListenerContainer to Listenable</p></blockquote><h1 id="写到最后"><a href="#写到最后" class="headerlink" title="写到最后"></a>写到最后</h1><p>本节介绍了Curator的基础使用，从源码角度分析了Curator 组件的初始化过程，并且简单分析会话管理和通知机制的相关源码调用。</p><p>下面是本文涉及到的源码讲解汇总的一副总图。个人源码分析过程如果有存在错误或者疑问欢迎反馈和讨论。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/Curator%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.drawio.png" alt="Curator 源码分析.drawio.png"></p><p>最后是整个demo代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorTestExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>);</span><br><span class="line">        CuratorFramework client =</span><br><span class="line">                CuratorFrameworkFactory.newClient(<span class="string">"192.168.19.100:2181,192.168.19.101:2181,192.168.19.102:2181"</span>, retryPolicy);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接ZK,开启连接</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自定义监听器 CuratorListener</span></span><br><span class="line">        client.getCuratorListenable().addListener((_fk, e) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.getType().equals(CuratorEventType.WATCHED)) &#123;</span><br><span class="line">                log.info(<span class="string">"测试"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">        ConnectionStateListener connectionStateListener = (client1, newState) -&gt; &#123;</span><br><span class="line">            <span class="comment">//Some details</span></span><br><span class="line">            log.info(<span class="string">"newState =&gt; "</span>+ newState);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 11:31:17.026 [Curator-ConnectionStateManager-0] INFO com.zxd.interview.zkcurator.CuratorTestExample - newState =&gt; CONNECTED</span></span><br><span class="line">        client.getConnectionStateListenable().addListener(connectionStateListener);</span><br><span class="line">        client.start();</span><br><span class="line">        <span class="comment">// 此处就获取到 zk的一个连接实例。</span></span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">        <span class="comment">// 创建znode，如果有必要需要创建父目录</span></span><br><span class="line">        client.create().creatingParentsIfNeeded().withProtection().forPath(<span class="string">"/my/path"</span>, <span class="string">"Test"</span>.getBytes());</span><br><span class="line">        InterProcessMutex lock = <span class="keyword">new</span> InterProcessMutex(client, <span class="string">"/my/path"</span>);</span><br><span class="line">        lock.acquire();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// do some work inside of the critical section here</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.release();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMzUzMzQ3NjA=" title="https://zhuanlan.zhihu.com/p/135334760">ZK客户端Curator使用详解 - 知乎 (zhihu.com)<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xNjQ4OTc2P2FyZWFTb3VyY2U9MTA2MDA1LjE0" title="https://cloud.tencent.com/developer/article/1648976?areaSource=106005.14">https://cloud.tencent.com/developer/article/1648976?areaSource=106005.14<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9kb25hbGRoYW4uZ2l0aHViLmlvL3pvb2tlZXBlci8yMDE4LzA2LzI5L2N1cmF0b3IlRTclOUIlQUUlRTUlQkQlOTUlRTclOUIlOTElRTUlOTAlQUMuaHRtbA==" title="https://donaldhan.github.io/zookeeper/2018/06/29/curator%E7%9B%AE%E5%BD%95%E7%9B%91%E5%90%AC.html">Curator目录监听 | Ravitn Blog (donaldhan.github.io)<i class="fa fa-external-link"></i></span></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      Zookeeper的客户端Curator使用
    
    </summary>
    
    
      <category term="Zookeeper" scheme="https://whitestore.top/categories/Zookeeper/"/>
    
    
      <category term="Zookeeper" scheme="https://whitestore.top/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>【Java】Effective Lambda Expressions in Java</title>
    <link href="https://whitestore.top/2023/08/10/effectivelambda/"/>
    <id>https://whitestore.top/2023/08/10/effectivelambda/</id>
    <published>2023-08-10T08:53:42.000Z</published>
    <updated>2023-09-09T00:53:49.934Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><p><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BidWJ1LnRyaXBhdGh5L2VmZmVjdGl2ZS1sYW1iZGEtZXhwcmVzc2lvbnMtaW4tamF2YS0yZDQwNjFkZGU3N2E=" title="https://medium.com/@bubu.tripathy/effective-lambda-expressions-in-java-2d4061dde77a">Effective Lambda Expressions in Java | by Bubu Tripathy | Medium<i class="fa fa-external-link"></i></span></p><h2 id="Introductory"><a href="#Introductory" class="headerlink" title="Introductory"></a>Introductory</h2><p>Lambda expressions were introduced in Java 8 to allow functional programming in Java. They are a concise way to express functions that can be used as data and provide a more functional approach to programming. Lambda expressions can be used in a variety of ways, from simple expressions to complex functions. In this article, we will discuss 20 best practices of using lambda expressions in Java with examples for each.</p><a id="more"></a><p>Lambda 表达式在 Java 8 中引入，允许在 Java 中进行函数式编程。Lambda表达式是表达可用作数据的函数的一种简洁方式，并为编程提供了一种功能性更强的方法。Lambda表达式的使用方式多种多样，从简单的表达式到复杂的函数。在本文中，我们将讨论在Java中使用lambda表达式的20个最佳实践，并分别举例说明。</p><h2 id="Use-Lambda-expressions-to-create-functional-Interfaces-使用Lambda表达式创建功能接口"><a href="#Use-Lambda-expressions-to-create-functional-Interfaces-使用Lambda表达式创建功能接口" class="headerlink" title="Use Lambda expressions to create functional Interfaces 使用Lambda表达式创建功能接口"></a>Use Lambda expressions to create functional Interfaces 使用Lambda表达式创建功能接口</h2><p>A functional interface is an interface that contains a single abstract method. Functional interfaces are used extensively in Java to represent functions and Lambdas.</p><p>功能接口是一个包含单个抽象方法的接口。<strong>功能接口</strong>在Java中广泛用于表示函数和Lambdas。</p><blockquote><p>When using Lambda expressions to create functional interfaces, the Lambda expression is used to define the implementation of the abstract method. The Lambda expression takes the same parameters as the abstract method, and returns a value that represents the result of the method.</p><p>当时用Lambda 表达式创建功能接口的时候，Lambda 表达式用于定义抽象方法实现。Lambda 表达式接受和抽象方法相同的参数，并且返回代表方法结果的值。</p></blockquote><p>Here is an example of using Lambda expressions to create a functional interface for a calculator:</p><p>下面是使用Lambda 表达式来创建功能接口计算器的案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span>  </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Calculator</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaDemo</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Calculator add = (a, b) -&gt; a + b;  </span><br><span class="line">        Calculator subtract = (a, b) -&gt; a - b;  </span><br><span class="line">  </span><br><span class="line">        System.out.println(<span class="string">"10 + 5 = "</span> + add.calculate(<span class="number">10</span>, <span class="number">5</span>));  </span><br><span class="line">        System.out.println(<span class="string">"10 - 5 = "</span> + subtract.calculate(<span class="number">10</span>, <span class="number">5</span>));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In this example, we are using a Lambda expression to define the implementation of the <code>calculate()</code> method of the Calculator interface. The <code>calculate()</code> method takes two integer values as input (a and b), and returns an integer value representing the result of the calculation.</p><p>在这个例子中，我们使用Lambda 表达式定义Calculator 接口的 <code>calculate()</code> 方法的实现。<code>calculate()</code> 方法接收两个整型参数作为输入（a 和 b），并且返回一个整型结果代表计算结果</p><p>Note that in this example, we are using the <em>@FunctionalInterface</em> annotation to indicate that the Calculator interface is a functional interface. This annotation is not strictly necessary, but it can help to clarify the intent of the interface.</p><p>注意在这个例子中我们使用了 <strong>@FunctionalInterface</strong>  注解指定在 Calculator 接口的接口方法上面。这个注解严格上来来说是<strong>非必要</strong>的， 但它有助于明确界面的意图。</p><h2 id="Use-the-right-syntax-for-Lambda-Expressions-为Lambda表达式使用正确的语法"><a href="#Use-the-right-syntax-for-Lambda-Expressions-为Lambda表达式使用正确的语法" class="headerlink" title="Use the right syntax for Lambda Expressions 为Lambda表达式使用正确的语法"></a>Use the right syntax for Lambda Expressions 为Lambda表达式使用正确的语法</h2><p>When using Lambda expressions in Java, it is important to use the correct syntax for defining and using them. The syntax of a Lambda expression consists of three parts: the parameter list, the arrow operator, and the body.</p><p>在Java中使用Lambda表达式， 使用正确的语法定义和使用它们非常重要的。Lambda表达式的语法由三部分组成：<strong>参数列表</strong>、<strong>箭头操作符</strong>和<strong>主体</strong>。</p><p>The parameter list [specifies] the input parameters that the Lambda expression will take. If there are no parameters, an empty parameter list must still be specified, as shown here:</p><p>参数列表指定了Lambda表达式将使用的输入参数，如果没有任何参数，一个空的参数化列表依然必须被指定，它的表现形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; System.out.println(<span class="string">"Hello, world!"</span>);</span><br></pre></td></tr></table></figure><p>The arrow operator separates the parameter list from the body of the Lambda expression. The arrow operator can be either a hyphen and greater-than symbol (-&gt;), or the word “goes to” written as an equals sign followed by a greater-than symbol (=&gt;).</p><p>箭头操作符将参数列表与Lambda表达式的主体分开，箭头运算符可以是<code>-</code>字符和大于号组合(-&gt;)，也可以是等号和大于号组合(=&gt;)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hyphen and greater-than symbol  </span></span><br><span class="line">x -&gt; x * x</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// equals sign followed by a greater-than symbol  </span></span><br><span class="line">(x, y) =&gt; x + y</span><br></pre></td></tr></table></figure><p>The body of the Lambda expression specifies the behavior of the expression. The body can be a single expression, or a block of statements enclosed in braces. If the body is a single expression, the braces are optional.</p><p>Lambda 表达式的主体指定表达式的行为，主题可以是一个单独的表达式，也可以是用大括号括起来的语句块，如果主体是单个表达式，则大括号是可选的。</p><p>函数表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// single expression  </span></span><br><span class="line">x -&gt; x * x</span><br></pre></td></tr></table></figure><p>语句块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// block of statements  </span></span><br><span class="line">(x, y) -&gt; &#123;  </span><br><span class="line">    <span class="keyword">int</span> sum = x + y;  </span><br><span class="line">    System.out.println(<span class="string">"The sum is: "</span> + sum);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>It is also important to use the correct type for Lambda expressions when they are assigned to variables or parameters. When a Lambda expression is assigned to a variable or parameter, the type of the variable or parameter must be a functional interface that is compatible with the Lambda expression.</p><p>当Lambda表达式设置变量或者参数的时候，使用正确的类型也是十分重要。当一个Lambda 表达式设置了变量或者参数，变量或参数必须是与<strong>Lambda表达式兼容的功能接口</strong>。</p><p>For example, the following Lambda expression:</p><p>比如下面这个函数表达式的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x, y) -&gt; x + y</span><br></pre></td></tr></table></figure><p>can be assigned to a variable of type <em>IntBinaryOperator</em>:</p><p>这里只能够设置变量类型为 <em>IntBinaryOperator</em> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntBinaryOperator add = (x, y) -&gt; x + y;</span><br></pre></td></tr></table></figure><h2 id="Use-Lambda-expressions-to-implement-Functional-Programming-使用-Lambda-表达式实现函数式编程"><a href="#Use-Lambda-expressions-to-implement-Functional-Programming-使用-Lambda-表达式实现函数式编程" class="headerlink" title="Use Lambda expressions to implement Functional Programming 使用 Lambda 表达式实现函数式编程"></a>Use Lambda expressions to implement Functional Programming 使用 Lambda 表达式实现函数式编程</h2><p>Functional programming is a programming paradigm that emphasizes the use of functions and functional composition to solve problems. In Java, Lambda expressions can be used to implement functional programming by creating and using functions as first-class objects.</p><p>函数式编程是一种编程范式，强调使用函数和函数组合来解决问题。在Java中，可以使用Lambda表达式来实现函数式编程，将函数作为头等对象来创建和使用。</p><blockquote><p>Functions in functional programming are defined by their behavior, rather than their implementation. This means that a function can be treated as an object, and passed around as a parameter or returned as a result. This is where Lambda expressions come in — they allow us to define functions as expressions, and pass them around as objects.</p><p>函数式编程当中行为是通过具体行为而不是实现定义的，也就是说函数可以是对象，并且把参数传递作为结果返回。Lambda表达式的强大之处就在于此，可以把函数作为表达式，并且把对应的对象进行传递。</p></blockquote><p>Here is an example of using Lambda expressions to implement functional programming in Java:</p><p>下面是使用Lambda表达式使Java实现函数式编程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionalProgrammingDemo</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);  </span><br><span class="line">        numbers.stream()  </span><br><span class="line">            .filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>)  </span><br><span class="line">            .map(n -&gt; n * n)  </span><br><span class="line">            .forEach(System.out::println);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In this example, we are using Lambda expressions to implement functional programming in Java. The code first creates a list of integers, and then uses a stream to process the list using functional operations.</p><p>在本示例中，我们使用Lambda表达式在Java中实现函数式编程。代码首先创建一个整数列表，然后使用<code>stream</code>的函数式操作来处理该列表。</p><p>The filter() operation uses a Lambda expression to define a predicate that filters out all odd numbers from the list. The map() operation uses another Lambda expression to define a function that squares each even number in the list. Finally, the <em>forEach()</em> operation uses a method reference to print each squared even number to the console.</p><p><code>filter()</code> 操作使用 Lambda 表达式定义一个<code>predicate</code>，<code>predicate</code>中定义了过滤列表所有奇数的操作，<code>map()</code>操作使用另一个Lambda表达式定义一个函数，该函数将列表中的每个元素求平方，最后使用 forEach 的方式，把每个处理之后的数据打印出来。</p><p>By using Lambda expressions to implement functional programming, you can create more expressive and modular code, and solve problems in a more concise and efficient way. Lambda expressions provide a powerful and flexible way to implement functional programming in Java and are a key feature of the Stream API in Java 8 and later versions.</p><p>使用函数表达式实现函数式编程，你可以创建更多更具表现力和模块化的代码，解决问你也会更加的简单高效，Lambda表达his提供一个强大并且流畅的方法在Java中实现函数式编程，这是Java 8及更高版本中流API的关键特性。</p><h2 id="Use-Lambda-expressions-to-create-Anonymous-Classes-使用-Lambda-表达式创建匿名类"><a href="#Use-Lambda-expressions-to-create-Anonymous-Classes-使用-Lambda-表达式创建匿名类" class="headerlink" title="Use Lambda expressions to create Anonymous Classes 使用 Lambda 表达式创建匿名类"></a>Use Lambda expressions to create Anonymous Classes 使用 Lambda 表达式创建匿名类</h2><p>Anonymous classes are often used in Java to create objects with a specific behavior, such as event listeners or runnable tasks.</p><p>在Java中，匿名类通常用于创建具有特定行为的对象，如事件监听器或可运行任务。</p><p>Lambda expressions can be used to create anonymous classes in Java. When using Lambda expressions to create anonymous classes, the Lambda expression is used to define the behavior of the anonymous class.</p><p>Lambda表达式可用于在Java中创建匿名类。使用Lambda表达式创建匿名类时，Lambda表达式用于定义匿名类的行为。</p><p>Here is an example of using Lambda expressions to create an anonymous class that implements the Runnable interface:</p><p>下面是一个使用Lambda表达式创建一个实现Runnable接口的匿名类的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousClassDemo</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Runnable runnable = () -&gt; &#123;  </span><br><span class="line">            System.out.println(<span class="string">"Hello from anonymous class!"</span>);  </span><br><span class="line">        &#125;;  </span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(runnable);  </span><br><span class="line">        thread.start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In this example, we are using a Lambda expression to create an anonymous class that implements the Runnable interface. The code first defines a Lambda expression that simply prints a message to the console. This Lambda expression is then used to create an anonymous class that implements the Runnable interface. Finally, the anonymous class is passed to a Thread object and started.</p><p>在这个案例中，我们通过Lambda表达式创建Runnable的匿名类，代码首先定义了一个Lambda表达式，该表达式简单地向控制台打印一条消息。然后使用该Lambda表达式创建一个实现Runnable接口的匿名类。最后，匿名类被传递给Thread对象并启动。</p><p>Note that in this example, we are using a Lambda expression with a block of statements enclosed in braces. This is because the Runnable interface has a single abstract method, run(), that takes no arguments and returns no value. Therefore, the Lambda expression must define the behavior of the run() method using a block of statements.</p><p>请注意，在本示例中，我们使用的是一个Lambda表达式，其中的语句块用大括号括起来。这是因为<strong>Runnable接口只有一个抽象方法run()</strong>，它不需要参数也不返回值。因此，Lambda表达式必须使用语句块来定义run()方法的行为。</p><h2 id="Use-Lambda-expressions-to-create-Event-Listeners-使用-Lambda-表达式创建事件监听器"><a href="#Use-Lambda-expressions-to-create-Event-Listeners-使用-Lambda-表达式创建事件监听器" class="headerlink" title="Use Lambda expressions to create Event Listeners 使用 Lambda 表达式创建事件监听器"></a>Use Lambda expressions to create Event Listeners 使用 Lambda 表达式创建事件监听器</h2><p>Event listeners are used in Java to handle events that occur in a user interface or other system. Events can include things like button clicks, mouse movements, and keyboard inputs.</p><p>Java中的事件监听器用于处理用户界面或其他系统中发生的事件。</p><p>事件包括按钮点击、鼠标移动和键盘输入等。</p><blockquote><p>When using Lambda expressions to implement event listeners, the Lambda expression is used to define the behavior that should be executed when the event occurs. The Lambda expression takes an event object as input, and performs some action based on the event.</p><p>当我们使用Lambda表达式实现事件监听器，通常需要用于定义事件发生时应执行的行为。Lambda表达式接收一个事件对象作为输入，并且根据事件的执行某些操作。</p></blockquote><p>Here is an example of using Lambda expressions to implement an event listener for a button click:</p><p>下面是一个使用 Lambda 表达式实现按钮点击事件监听器的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ButtonDemo</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        JButton button = <span class="keyword">new</span> JButton(<span class="string">"Click me!"</span>);  </span><br><span class="line">        button.addActionListener(event -&gt; System.out.println(<span class="string">"Button clicked!"</span>));  </span><br><span class="line">        JFrame frame = <span class="keyword">new</span> JFrame();  </span><br><span class="line">        frame.add(button);  </span><br><span class="line">        frame.pack();  </span><br><span class="line">        frame.setVisible(<span class="keyword">true</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In this example, we are using a Lambda expression to define the behavior that should be executed when the button is clicked. The addActionListener() method of the JButton class takes a ActionListener object as input, which is implemented as a Lambda expression in this case. The Lambda expression simply prints a message to the console when the button is clicked.</p><p>在本示例中，我们使用Lambda表达式来定义点击按钮时应执行的行为。JButton类的addActionListener()方法将ActionListener对象作为输入，在本例中以Lambda表达式的形式实现。当按钮被点击时，Lambda表达式简单地向控制台打印一条消息。</p><p>Note that in this example, we are using the “arrow” notation (-&gt;) to separate the parameter list from the body of the Lambda expression. The parameter list consists of a single event object, which represents the button click event. The body of the Lambda expression simply prints a message to the console.</p><p>请注意，在本例中，我们使用了 “箭头 “符号 (-&gt;) 来分隔参数列表和 Lambda 表达式的主体。参数列表由单个字符串值组成，代表列表中的每个字符串。Lambda 表达式的主体只是将字符串打印到控制台。</p><h2 id="Use-Lambda-expressions-to-Iterate-over-Collections-使用-Lambda-表达式遍历集合"><a href="#Use-Lambda-expressions-to-Iterate-over-Collections-使用-Lambda-表达式遍历集合" class="headerlink" title="Use Lambda expressions to Iterate over Collections 使用 Lambda 表达式遍历集合"></a>Use Lambda expressions to Iterate over Collections 使用 Lambda 表达式遍历集合</h2><p>Iterating over collections is a common operation in Java, and Lambda expressions can be used to simplify and streamline this process. When using Lambda expressions to iterate over collections, the Lambda expression is used to define the behavior that should be executed for each element in the collection.</p><p>在 Java 中，遍历集合是一种常见操作，而 Lambda 表达式可用于简化和精简这一过程。使用 Lambda 表达式遍历集合时，Lambda 表达式用于定义应针对集合中的每个元素执行的行为。</p><p>Here is an example of using Lambda expressions to iterate over a list of strings and print each string to the console:</p><p>下面是一个使用 Lambda 表达式遍历字符串列表并将每个字符串打印到控制台的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"cherry"</span>);  </span><br><span class="line">strings.forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure><p>In this example, we are using the forEach() method of the List interface to iterate over a list of strings. The forEach() method takes a Consumer object as input, which is implemented as a Lambda expression in this case. The Lambda expression simply prints each string to the console.</p><p>在本示例中，我们使用 List 接口的 forEach() 方法遍历字符串列表。forEach()方法将Consumer对象作为输入，在本例中以Lambda表达式的形式实现。Lambda 表达式简单地将每个字符串打印到控制台。</p><p>Note that in this example, we are using the “arrow” notation (-&gt;) to separate the parameter list from the body of the Lambda expression. The parameter list consists of a single string value, which represents each string in the list. The body of the Lambda expression simply prints the string to the console.</p><p>请注意，在本例中，我们使用了 “箭头 “符号 (-&gt;) 来分隔参数列表和 Lambda 表达式的主体。参数列表由单个字符串值组成，代表列表中的每个字符串。Lambda 表达式的主体只是将字符串打印到控制台。</p><p>Here is another example of using Lambda expressions to iterate over a map of key-value pairs and print each pair to the console:</p><p>下面是另一个使用 Lambda 表达式遍历键值对映射并将每一对键值对打印到控制台的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();  </span><br><span class="line">map.put(<span class="string">"apple"</span>, <span class="number">1</span>);  </span><br><span class="line">map.put(<span class="string">"banana"</span>, <span class="number">2</span>);  </span><br><span class="line">map.put(<span class="string">"cherry"</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.forEach((k, v) -&gt; System.out.println(k + <span class="string">" -&gt; "</span> + v));</span><br></pre></td></tr></table></figure><p>In this example, we are using the <em>forEach()</em> method of the Map interface to iterate over a map of key-value pairs. The forEach() method takes a <em>BiConsumer</em> object as input, which is implemented as a Lambda expression in this case. The Lambda expression takes two parameters, a key and a value, and simply prints each key-value pair to the console.</p><p>在本例中，我们使用 <code>Map</code> 接口的 <em>forEach()</em> 方法遍历键值对映射。forEach()方法将 <em>BiConsumer</em> 对象作为输入，在本例中是以 Lambda 表达式的形式实现的。</p><p>Lambda 表达式接收两个参数，一个键和一个值，并简单地将每个键值对打印到控制台。</p><p>Note that in this example, we are using the “arrow” notation (-&gt;) to separate the parameter list from the body of the Lambda expression. The parameter list consists of two values, a key and a value, which represent each key-value pair in the map. The body of the Lambda expression simply prints the key-value pair to the console.</p><p>请注意，在这个示例中，我们使用了 “箭头 “符号 (-&gt;) 来分隔参数列表和 Lambda 表达式的主体。参数列表由两个值（一个 key 和一个 value）组成，分别代表 map 中的每个键值对。Lambda 表达式的主体只是将键值对打印到控制台。</p><h2 id="Use-Lambda-expressions-to-Filter-Collections-使用-Lambda-表达式过滤集合"><a href="#Use-Lambda-expressions-to-Filter-Collections-使用-Lambda-表达式过滤集合" class="headerlink" title="Use Lambda expressions to Filter Collections 使用 Lambda 表达式过滤集合"></a>Use Lambda expressions to Filter Collections 使用 Lambda 表达式过滤集合</h2><p>Filtering collections is a common operation in Java, and Lambda expressions can be used to simplify and streamline this process. When using Lambda expressions to filter collections, the Lambda expression is used to define a predicate that selects which elements in the collection should be included or excluded.</p><p>过滤集合是 Java 中的一种常见操作，而 Lambda 表达式可用于简化和精简这一过程。使用 Lambda 表达式过滤集合时，Lambda 表达式用于定义一个谓词，该谓词用于选择应包含或排除集合中的哪些元素。</p><p>Here is an example of using Lambda expressions to filter a list of integers and create a new list that contains only the even numbers:</p><p>下面是一个使用 Lambda 表达式过滤整数列表并创建一个只包含偶数的新列表的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);  </span><br><span class="line">List&lt;Integer&gt; evenNumbers = numbers.stream()  </span><br><span class="line">                                    .filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>)  </span><br><span class="line">                                    .collect(Collectors.toList());  </span><br><span class="line">System.out.println(evenNumbers);</span><br></pre></td></tr></table></figure><p>In this example, we are using the filter() method of the Stream interface to filter a list of integers. The filter() method takes a predicate as input, which is implemented as a Lambda expression in this case. The Lambda expression defines a predicate that tests whether a number is even or not by checking if its remainder is zero when divided by two.</p><p>在本例中，我们使用流接口的 filter() 方法过滤整数列表。filter() 方法将一个谓词作为输入，在本例中以 Lambda 表达式的形式实现。Lambda 表达式定义了一个谓词，该谓词通过检查一个数字除以 2 后的余数是否为零来检验该数字是否为偶数。</p><p>Note that in this example, we are using the “arrow” notation (-&gt;) to separate the parameter list from the body of the Lambda expression. The parameter list consists of a single integer value, which represents each element in the stream. The body of the Lambda expression is a boolean expression that defines the predicate.</p><p>请注意，在这个示例中，我们使用了 “箭头 “符号 (-&gt;) 来分隔参数列表和 Lambda 表达式的主体。参数列表由单个整数值组成，代表流中的每个元素。Lambda 表达式的主体是定义谓词的布尔表达式。</p><p>The filtered elements are then collected into a new list using the collect() method of the Stream interface, which takes a Collector object as input. The Collector object in this case is the toList() method of the Collectors class, which creates a new list of the filtered elements.</p><p>然后，使用流接口的 collect() 方法将过滤后的元素收集到一个新的列表中，该方法将收集器对象作为输入。本例中的收集器对象是收集器类的 toList() 方法，它将创建一个包含过滤元素的新列表。</p><h2 id="Use-Lambda-expressions-to-Sort-Collections-使用-Lambda-表达式对集合进行排序"><a href="#Use-Lambda-expressions-to-Sort-Collections-使用-Lambda-表达式对集合进行排序" class="headerlink" title="Use Lambda expressions to Sort Collections 使用 Lambda 表达式对集合进行排序"></a>Use Lambda expressions to Sort Collections 使用 Lambda 表达式对集合进行排序</h2><p>Sorting is the process of arranging the elements of a collection in a specific order. In Java, collections can be sorted using the <em>sorted()</em> method of the Stream API.</p><p>排序是将集合中的元素按特定顺序排列的过程。在Java中，可以使用流API的 <em>sorted()</em> 方法对集合进行排序。 </p><blockquote><p>When using Lambda expressions to sort collections, the Lambda expression is used to define the <em>order</em> in which the elements should be sorted. </p><p>使用 Lambda 表达式对集合进行排序时，Lambda 表达式用于定义元素的排序顺序。</p><p>The Lambda expression takes two elements from the collection as input, and returns an integer value indicating their relative order. </p><p>Lambda 表达式将集合中的两个元素作为输入，并返回一个整数值，表示它们的相对顺序。</p><p>If the first element should come before the second element in the sorted collection, the Lambda expression returns a negative integer. </p><p>如果在排序集合中，第一个元素应在第二个元素之前，则 Lambda 表达式会返回一个负整数。</p><p>If the first element should come after the second element, the Lambda expression returns a positive integer. If the two elements are equal, the Lambda expression returns zero.</p><p>如果第一个元素位于第二个元素之后，则 Lambda 表达式返回一个正整数。如果两个元素相等，则 Lambda 表达式返回 0。</p></blockquote><p>Here is an example of using Lambda expressions to sort a list of integers:</p><p>下面是一个使用 Lambda 表达式对整数列表进行排序的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">5</span>);  </span><br><span class="line">List&lt;Integer&gt; sortedNumbers = numbers.stream().sorted().collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>In this example, we are using a Lambda expression to sort the list of integers in ascending order. The sorted() method uses this Lambda expression to create a new stream that contains the elements of the original list in sorted order.</p><p>在这个示例中，我们使用 Lambda 表达式按升序对整数列表进行排序。</p><p>sorted()方法使用该Lambda表达式创建一个新的流，其中包含按排序顺序排列的原始列表元素。</p><p>Note that in this example, we are not explicitly defining a Lambda expression for the sorted() method. This is because the default behavior of the sorted() method is to sort the elements in natural order. However, you can also provide a custom Lambda expression to the sorted() method to define a custom sort order.</p><p>请注意，在这个示例中，我们没有为 sorted() 方法明确定义一个 Lambda 表达式。这是因为 sorted() 方法的默认行为是按自然顺序对元素进行排序。</p><p>不过，您也可以为 sorted() 方法提供自定义 Lambda 表达式，以定义自定义排序顺序。</p><p>Here is an example of using a Lambda expression to sort a list of strings in descending order:</p><p>下面是一个使用 Lambda 表达式对字符串列表进行降序排序的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; words = Arrays.asList(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"cherry"</span>, <span class="string">"date"</span>, <span class="string">"elderberry"</span>);  </span><br><span class="line">List&lt;String&gt; sortedWords = words.stream().sorted((a, b) -&gt; b.compareTo(a)).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>In this example, we are using a Lambda expression to sort the list of strings in descending order. The Lambda expression takes two strings as input, and returns the result of comparing the second string to the first string using the <em>compareTo()</em> method of the String class.</p><p>在本例中，我们使用 Lambda 表达式对字符串列表进行降序排序。Lambda 表达式将两个字符串作为输入，并使用 String 类的 <em>compareTo()</em> 方法返回第二个字符串与第一个字符串的比较结果。</p><h2 id="Use-Lambda-expressions-to-Map-Collections"><a href="#Use-Lambda-expressions-to-Map-Collections" class="headerlink" title="Use Lambda expressions to Map Collections"></a>Use Lambda expressions to Map Collections</h2><p>Mapping is the process of transforming one collection into another. In Java, collections can be mapped using the map() method of the Stream API.</p><p>Map是将一个集合转换成另一个集合的过程。在 Java 中，可以使用流 API 的 map() 方法对集合进行映射。</p><blockquote><p>When using Lambda expressions to map collections, the Lambda expression is used to define the transformation that should be applied to each element in the collection. The Lambda expression takes an element from the collection as input and returns a new value that represents the transformed element.</p><p>使用 Lambda 表达式映射集合时，Lambda 表达式用于定义应用于集合中每个元素的转换。Lambda 表达式将集合中的元素作为输入，并返回一个代表转换后元素的新值。</p></blockquote><p>Here is an example of using Lambda expressions to map a list of strings to a list of integers:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>);  </span><br><span class="line">List&lt;Integer&gt; integers = strings.stream().map(Integer::parseInt).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>In this example, we are using a Lambda expression to map the list of strings to a list of integers. The Lambda expression applies the parseInt() method of the Integer class to each string in the list, converting it to an integer value. The map() method then uses this Lambda expression to create a new stream that contains the transformed elements.</p><p>在本例中，我们使用 Lambda 表达式将字符串列表映射为整数列表。Lambda 表达式对列表中的每个字符串应用 Integer 类的 parseInt() 方法，将其转换为整数值。然后，map() 方法使用此 Lambda 表达式创建一个包含转换后元素的新流。</p><p>Note that in this example, we are using the method reference notation (::) to refer to the parseInt() method of the Integer class. This is a shorthand notation for a Lambda expression that simply calls a single method.</p><p>请注意，在本例中，我们使用方法引用符号（::）来引用 Integer 类的 parseInt() 方法。这是一个 Lambda 表达式的简写符号，只需调用一个方法即可。</p><p>Here is another example of using a Lambda expression to map a list of strings to a list of uppercase strings:</p><p>下面是另一个使用 <code>Lambda</code> 表达式将字符串列表映射为大写字符串列表的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; words = Arrays.asList(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"cherry"</span>, <span class="string">"date"</span>, <span class="string">"elderberry"</span>);  </span><br><span class="line">List&lt;String&gt; uppercaseWords = words.stream().map(s -&gt; s.toUpperCase()).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>In this example, we are using a Lambda expression to map the list of strings to a list of uppercase strings. The Lambda expression applies the toUpperCase() method of the String class to each string in the list, converting it to an uppercase string. The map() method then uses this Lambda expression to create a new stream that contains the transformed elements.</p><p>在本例中，我们使用 Lambda 表达式将字符串列表映射为大写字符串列表。Lambda 表达式将 String 类的 toUpperCase() 方法应用于列表中的每个字符串，将其转换为大写字符串。然后，map() 方法使用此 Lambda 表达式创建一个包含转换后元素的新流。</p><h2 id="Use-Lambda-expressions-to-Reduce-Collections-使用-Lambda-表达式精简集合"><a href="#Use-Lambda-expressions-to-Reduce-Collections-使用-Lambda-表达式精简集合" class="headerlink" title="Use Lambda expressions to Reduce Collections 使用 Lambda 表达式精简集合"></a>Use Lambda expressions to Reduce Collections 使用 Lambda 表达式精简集合</h2><p>Reducing is the process of applying an operation to all the elements of a collection to produce a single result. In Java, collections can be reduced using the reduce() method of the Stream API.</p><p><code>Reducing</code> 是对集合中的所有元素进行操作以产生单一结果的过程。在 Java 中，可以使用流 API 的 <code>reduce()</code>方法对集合进行还原。</p><blockquote><p>When using Lambda expressions to reduce collections, the Lambda expression is used to define the operation that should be applied to each element in the collection. The Lambda expression takes two arguments as input: an accumulator and an element from the collection. The accumulator is the result of the previous operation, or an initial value if this is the first operation. The Lambda expression returns a new value that represents the result of applying the operation to the accumulator and the current element.</p><p>使用 Lambda 表达式还原集合时，Lambda 表达式用于定义应用于集合中每个元素的操作。Lambda 表达式将两个参数作为输入：累加器和集合中的一个元素。累加器是前一次操作的结果，如果是第一次操作，则是初始值。Lambda 表达式返回一个新值，该值代表对累加器和当前元素应用操作的结果。</p></blockquote><p>Here is an example of using Lambda expressions to reduce a list of integers to a single sum:</p><p>下面是一个使用 Lambda 表达式将整数列表简化为单个和的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);  </span><br><span class="line"><span class="keyword">int</span> sum = numbers.stream().reduce(<span class="number">0</span>, (a, b) -&gt; a + b);</span><br></pre></td></tr></table></figure><p>In this example, we are using a Lambda expression to reduce the list of integers to a single sum. The Lambda expression takes two integer values as input: an accumulator (initialized to zero in this case), and an element from the list. The Lambda expression adds the element to the accumulator, and returns the new value of the <em>accumulator</em>. The reduce() method then uses this Lambda expression to apply the operation to each element in the list, producing the final sum.</p><p>在本例中，我们使用 Lambda 表达式将整数列表还原为单个和。Lambda 表达式将两个整数值作为输入：一个累加器（本例中初始化为零）和列表中的一个元素。Lambda 表达式将元素加到累加器中，并返回_accumulator_的新值。然后，reduce() 方法使用此 Lambda 表达式对列表中的每个元素进行运算，得出最终总和。</p><p>Note that in this example, we are using the “arrow” notation (-&gt;) to separate the parameter list  from the body of the Lambda expression. The parameter list consists of two integer values: the accumulator and the current element from the list. The body of the Lambda expression adds the current element to the accumulator using the + operator.</p><p>请注意，在本例中，我们使用了 “箭头 “符号 (-&gt;) 来分隔参数列表和 Lambda 表达式的主体。参数列表由两个整数值组成：累加器和列表中的当前元素。Lambda 表达式的主体使用 + 运算符将当前元素添加到累加器中。</p><p>Here is another example of using a Lambda expression to reduce a list of strings to a single concatenated string:</p><p>下面是另一个使用 Lambda 表达式将字符串列表缩减为单个连接字符串的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; words = Arrays.asList(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"cherry"</span>, <span class="string">"date"</span>, <span class="string">"elderberry"</span>);  </span><br><span class="line">String concatenated = words.stream().reduce(<span class="string">""</span>, (a, b) -&gt; a + b);</span><br></pre></td></tr></table></figure><p>In this example, we are using a Lambda expression to reduce the list of strings to a single concatenated string. The Lambda expression takes two string values as input: an accumulator (initialized to an empty string in this case), and an element from the list. The Lambda expression concatenates the element to the accumulator, and returns the new value of the accumulator. The reduce() method then uses this Lambda expression to apply the operation to each element in the list, producing the final concatenated string.</p><p>在本例中，我们使用 Lambda 表达式将字符串列表还原为单个连接字符串。Lambda 表达式将两个字符串值作为输入：一个累加器（本例中初始化为空字符串）和列表中的一个元素。Lambda 表达式将元素连接到累加器，并返回累加器的新值。然后，reduce() 方法使用此 Lambda 表达式对列表中的每个元素进行操作，生成最终的连接字符串。</p><h2 id="Use-Lambda-expressions-to-Group-Collections-使用-Lambda-表达式对集合进行分组"><a href="#Use-Lambda-expressions-to-Group-Collections-使用-Lambda-表达式对集合进行分组" class="headerlink" title="Use Lambda expressions to Group Collections  使用 Lambda 表达式对集合进行分组"></a>Use Lambda expressions to Group Collections  使用 Lambda 表达式对集合进行分组</h2><p>Grouping is the process of grouping the elements of a collection based on a common property or criterion. In Java, collections can be grouped using the <em>groupingBy()</em> method of the Collectors class.</p><p>分组是根据共同属性或标准对集合中的元素进行分组的过程。在 Java 中，可以使用 Collectors 类的 <em>groupingBy()</em> 方法对集合进行分组。</p><blockquote><p>When using Lambda expressions to group collections, the Lambda expression is used to define the criterion that should be used to group the elements. The Lambda expression takes an element from the collection as input, and returns a value that represents the grouping criterion.</p><p>使用 Lambda 表达式对集合进行分组时，Lambda 表达式用于定义对元素进行分组的标准。Lambda 表达式将集合中的元素作为输入，并返回一个代表分组标准的值。</p></blockquote><p>Here is an example of using Lambda expressions to group a list of words by their length:</p><p>下面是一个使用 Lambda 表达式按单词长度分组的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; words = Arrays.asList(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"cherry"</span>, <span class="string">"date"</span>, <span class="string">"elderberry"</span>);  </span><br><span class="line">Map&lt;Integer, List&lt;String&gt;&gt; groups = words.stream().collect(Collectors.groupingBy(String::length));</span><br></pre></td></tr></table></figure><p>In this example, we are using a Lambda expression to group the list of words by their length. The groupingBy() method uses this Lambda expression to create a map that groups the words by their length. The key of each entry in the map is an integer value representing the length of the words, and the value of each entry is a list of words with that length.</p><p>在本例中，我们使用 <code>Lambda</code> 表达式按单词长度对单词列表进行分组。<code>groupingBy()</code> 方法使用此 <code>Lambda</code> 表达式创建一个按单词长度分组的映射。映射中每个条目的键是代表单词长度的整数值，每个条目的值是具有该长度的单词列表。</p><p>Note that in this example, we are using the method reference notation (::) to refer to the length() method of the String class. This is a shorthand notation for a Lambda expression that simply calls a single method.</p><p>请注意，在本例中，我们使用方法引用符号（<code>::</code>）来引用 <code>String</code> 类的 <code>length()</code> 方法。这是简单调用单个方法的 Lambda 表达式的速记符号。</p><p>Here is another example of using a Lambda expression to group a list of employees by their department:</p><p>下面是另一个使用 Lambda 表达式按部门对员工列表进行分组的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Employee&gt; employees = Arrays.asList(  </span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="string">"Alice"</span>, <span class="string">"Sales"</span>),  </span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="string">"Bob"</span>, <span class="string">"Marketing"</span>),  </span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="string">"Charlie"</span>, <span class="string">"Sales"</span>),  </span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="string">"Dave"</span>, <span class="string">"Marketing"</span>),  </span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="string">"Eve"</span>, <span class="string">"HR"</span>)  </span><br><span class="line">);  </span><br><span class="line"></span><br><span class="line">Map&lt;String, List&lt;Employee&gt;&gt; groups = employees.stream().collect(Collectors.groupingBy(Employee::getDepartment));</span><br></pre></td></tr></table></figure><p>In this example, we are using a Lambda expression to group the list of employees by their department. The groupingBy() method uses this Lambda expression to create a map that groups the employees by their department. The key of each entry in the map is a string value representing the department of the employees, and the value of each entry is a list of employees in that department.</p><p>在本例中，我们使用 Lambda 表达式按部门对员工列表进行分组。groupingBy()方法使用此 Lambda 表达式创建了一个按部门对员工进行分组的映射。映射中每个条目的键是代表员工部门的字符串值，每个条目的值是该部门的员工列表。</p><h2 id="Use-Lambda-expressions-to-Handle-Exceptions-使用-Lambda-表达式处理异常"><a href="#Use-Lambda-expressions-to-Handle-Exceptions-使用-Lambda-表达式处理异常" class="headerlink" title="Use Lambda expressions to Handle Exceptions 使用 Lambda 表达式处理异常"></a>Use Lambda expressions to Handle Exceptions 使用 Lambda 表达式处理异常</h2><p>Lambda expressions can be used to handle checked exceptions in Java. Checked exceptions are a type of exception that must be declared in a method’s signature or handled by the caller. When using Lambda expressions to handle checked exceptions, the Lambda expression is used to define the behavior that should be executed in case of an exception, while still allowing the checked exception to be propagated up to the caller.</p><p>Lambda 表达式可用于处理 Java 中的校验异常。校验异常是一种必须在方法签名中声明或由调用者处理的异常类型。使用 Lambda 表达式处理校验异常时，Lambda 表达式用于定义异常情况下应执行的行为，同时仍允许将校验异常传播给调用者。</p><p>Here is an example of using Lambda expressions to handle a checked exception when reading a file:</p><p>下面是一个使用 Lambda 表达式处理读取文件时已检查异常的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; lines = <span class="keyword">null</span>;  </span><br><span class="line"><span class="keyword">try</span> (BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"file.txt"</span>))) &#123;  </span><br><span class="line">    lines = reader.lines()  </span><br><span class="line">                  .map(line -&gt; &#123;  </span><br><span class="line">                      <span class="keyword">try</span> &#123;  </span><br><span class="line">                          <span class="keyword">return</span> process(line);  </span><br><span class="line">                      &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">                          <span class="keyword">throw</span> <span class="keyword">new</span> UncheckedIOException(e);  </span><br><span class="line">                      &#125;  </span><br><span class="line">                  &#125;)  </span><br><span class="line">                  .collect(Collectors.toList());  </span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">    e.printStackTrace();  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">process</span><span class="params">(String line)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">    <span class="comment">// process the line  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In this example, we are using a Lambda expression to handle a checked exception when processing each line of a file. The code first creates a <em>BufferedReader</em> object that reads from a file named “file.txt”. The lines from the file are then processed using the map() method of the Stream interface. The map() method takes a Function object as input, which is implemented as a Lambda expression in this case. The Lambda expression calls the process() method to process each line, and catches any IOException that may occur. If an IOException occurs, the Lambda expression throws an UncheckedIOException, which is a runtime exception that wraps the original checked exception.</p><p>在本示例中，我们使用 Lambda 表达式来处理处理文件每一行时检查到的异常。代码首先创建了一个 <em>BufferedReader</em> 对象，用于读取名为 “file.txt “的文件。</p><p>然后使用 Stream 接口的 map() 方法处理文件中的行。</p><p>map() 方法将一个 Function 对象作为输入，在本例中实现为一个 Lambda 表达式。Lambda 表达式调用 process() 方法处理每一行，并捕获可能出现的任何 IOException。</p><p>如果出现 IO 异常，Lambda 表达式会抛出一个未检查的 IO 异常，这是一个运行时异常，它封装了原始的已检查异常。</p><p>Note that in this example, we are using a Lambda expression with a block of statements enclosed in braces. This is because the <em>process()</em> method throws an <em>IOException</em>, which must be caught or re-thrown by the Lambda expression.</p><p>请注意，在这个示例中，我们使用的是一个 Lambda 表达式和一个用大括号括起来的语句块。这是因为 <em>process()</em> 方法会抛出一个<em>IOException_，而 Lambda 表达式必须捕获或重新抛出这个 _IOException</em> 。</p><p>By using Lambda expressions to handle checked exceptions, you can create more concise and readable code, and handle exceptions with greater flexibility and modularity. Lambda expressions provide a powerful and flexible way to handle checked exceptions in Java, and can be used in a wide range of scenarios, such as file I/O, network communication, and database access.</p><p>通过使用 <code>Lambda</code> 表达式来处理校验异常，您可以创建更简洁、更易读的代码，并以更大的灵活性和模块化来处理异常。Lambda 表达式为在 Java 中处理检查异常提供了一种强大而灵活的方法，可用于文件 I/O、网络通信和数据库访问等多种场景。</p><h2 id="Use-Lambda-expressions-to-Handle-Null-Values-使用-Lambda-表达式处理空值"><a href="#Use-Lambda-expressions-to-Handle-Null-Values-使用-Lambda-表达式处理空值" class="headerlink" title="Use Lambda expressions to Handle Null Values 使用 Lambda 表达式处理空值"></a>Use Lambda expressions to Handle Null Values 使用 Lambda 表达式处理空值</h2><p>In Java, NullPointerExceptions (NPEs) can often occur when dealing with null values. Lambda expressions can be used to handle null values in a more concise and expressive way, and to prevent <em>NullPointerExceptions</em> from occurring. Here is an example of using Lambda expressions to handle null values when filtering a list of strings:</p><p>在 Java 中，处理空值时经常会出现 <code>NullPointerException（NPE）</code>。可以使用 Lambda 表达式以更简洁、更具表现力的方式处理空值，并防止发生 <em>NullPointerException</em> 异常。下面是一个在过滤字符串列表时使用 Lambda 表达式处理空值的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"apple"</span>, <span class="keyword">null</span>, <span class="string">"banana"</span>, <span class="string">"cherry"</span>, <span class="keyword">null</span>);  </span><br><span class="line">List&lt;String&gt; filteredList = list.stream()  </span><br><span class="line">                                .filter(s -&gt; s != <span class="keyword">null</span>)  </span><br><span class="line">                                .collect(Collectors.toList());  </span><br><span class="line">System.out.println(filteredList);</span><br></pre></td></tr></table></figure><p>In this example, we are using the <em>filter()</em> method of the Stream interface to filter a list of strings. The filter() method takes a Predicate object as input, which is implemented as a Lambda expression in this case. The Lambda expression defines a predicate that tests whether a string is not null.</p><p>在本例中，我们使用 Stream 接口的 <em>filter()</em> 方法过滤字符串列表。filter()方法将一个谓词对象作为输入，在本例中是以 Lambda 表达式的形式实现的。Lambda 表达式定义了一个谓词，用于测试字符串是否为空。</p><p>Note that in this example, we are using the != operator to test for null values. This is because the null value is not equal to any other value, including null itself.</p><p>请注意，在本例中，我们使用 != 操作符来测试空值。这是因为null值不等于任何其他值，包括null值本身。</p><h2 id="Use-Lambda-expressions-to-perform-Parallel-Operations-使用-Lambda-表达式执行并行操作"><a href="#Use-Lambda-expressions-to-perform-Parallel-Operations-使用-Lambda-表达式执行并行操作" class="headerlink" title="Use Lambda expressions to perform Parallel Operations 使用 Lambda 表达式执行并行操作"></a>Use Lambda expressions to perform Parallel Operations 使用 Lambda 表达式执行并行操作</h2><p>Lambda expressions are anonymous functions in Java that can be used to perform a variety of operations, including parallel operations.</p><p>Lambda 表达式是 Java 中的匿名函数（但是细节上和真正的匿名函数不一样），可用于执行各种操作，包括并行操作。</p><blockquote><p>Parallelism refers to the ability to perform multiple operations simultaneously, thereby reducing the amount of time it takes to complete a task. In Java, parallelism can be achieved using the Stream API and lambda expressions.</p><p>并行性是指同时执行多个操作的能力，从而减少完成任务所需的时间。在 Java 中，可以使用流 API 和 lambda 表达式来实现并行性</p></blockquote><p>The Stream API provides a <em>parallelStream()</em> method that allows you to create parallel streams. Streams are collections of objects that can be processed sequentially or in parallel. By default, streams are processed sequentially, but you can use the <em>parallelStream()</em> method to process them in parallel.</p><p>流 API 提供了一个 <em>parallelStream()</em> 方法，允许您创建并行流。</p><p>流是可以按顺序或并行处理的对象集合。默认情况下，流是按顺序处理的，但您可以使用 <em>parallelStream()</em> 方法并行处理它们。</p><p>To use lambda expressions to perform parallel operations, you first need to create a stream using the parallelStream() method. You can then use lambda expressions to define the operations that are performed on the elements of the stream. <strong>The Stream API will automatically split the stream into multiple substreams and distribute them across multiple threads, allowing the operations to be performed in parallel.</strong></p><p>要使用 lambda 表达式执行并行操作，首先需要使用 parallelStream() 方法创建一个流。然后，就可以使用 lambda 表达式定义对流元素执行的操作。 **流 API 会自动将流拆分成多个子流，并将它们分配给多个线程，从而允许并行执行操作。</p><p>Here’s an example of using lambda expressions to perform a parallel operation:</p><p>下面是一个使用 lambda 表达式执行并行操作的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = numbers.parallelStream()  </span><br><span class="line">                .filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>)  </span><br><span class="line">                .mapToInt(n -&gt; n)  </span><br><span class="line">                .sum();</span><br></pre></td></tr></table></figure><h2 id="Use-Lambda-expressions-to-create-Custom-Collectors-使用-Lambda-表达式创建自定义收集器"><a href="#Use-Lambda-expressions-to-create-Custom-Collectors-使用-Lambda-表达式创建自定义收集器" class="headerlink" title="Use Lambda expressions to create Custom Collectors  使用 Lambda 表达式创建自定义收集器"></a>Use Lambda expressions to create Custom Collectors  使用 Lambda 表达式创建自定义收集器</h2><p>A collector is an operation that can be performed on a stream to accumulate the elements of the stream into a final result. Collectors are used with the <em>collect()</em> method of the Stream interface.</p><p>收集器是一种可在流上执行的操作，用于将流的元素累加为最终结果。收集器与流接口的 <em>collect()</em> 方法一起使用。</p><blockquote><p>Java provides a number of built-in collectors that perform common operations like grouping elements, counting elements, and calculating averages. However, you can also create your own custom collectors using lambda expressions.</p><p>Java 提供了许多内置收集器，可执行分组元素、计数元素和计算平均值等常见操作。<br>不过，您也可以使用 lambda 表达式创建自己的自定义收集器。</p></blockquote><p>To create a custom collector using lambda expressions, you need to define a new class that implements the <em>Collector</em> interface. The Collector interface has four methods that you need to implement:</p><p>要使用 lambda 表达式创建自定义收集器，需要定义一个实现 <em>Collector</em> 接口的新类。收集器接口有四个方法需要实现：</p><ul><li><p>The <em>supplier()</em> method returns a function that creates a new mutable result container.</p></li><li><p>The <em>accumulator()</em> method returns a function that adds an element to the result container.</p></li><li><p>The <em>combiner()</em> method returns a function that combines two result containers.</p></li><li><p>The <em>finisher()</em> method returns a function that performs a final transformation on the result container.</p></li><li><p>_supplier()_： 方法返回一个函数，用于创建一个新的可变结果容器。</p></li><li><p>_Accumulator()_：  方法返回一个将元素添加到结果容器的函数。</p></li><li><p>_combiner()_：方法返回一个将两个结果容器组合在一起的函数。</p></li><li><p>_finisher()_： 方法返回一个对结果容器执行最终转换的函数。</p></li></ul><p>Here’s an example of creating a custom collector that calculates the average of a stream of integers:</p><p>下面是一个创建自定义收集器的示例，用于计算整数流的平均值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class AverageCollector implements Collector&lt;Integer, int[], Double&gt; &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> Supplier&lt;<span class="keyword">int</span>[]&gt; supplier() &#123;  </span><br><span class="line">        <span class="keyword">return</span> () -&gt; <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> BiConsumer&lt;<span class="keyword">int</span>[], Integer&gt; accumulator() &#123;  </span><br><span class="line">        <span class="keyword">return</span> (acc, val) -&gt; &#123;  </span><br><span class="line">            acc[<span class="number">0</span>] += val;  </span><br><span class="line">            acc[<span class="number">1</span>]++;  </span><br><span class="line">        &#125;;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> BinaryOperator&lt;<span class="keyword">int</span>[]&gt; combiner() &#123;  </span><br><span class="line">        <span class="keyword">return</span> (acc1, acc2) -&gt; &#123;  </span><br><span class="line">            acc1[<span class="number">0</span>] += acc2[<span class="number">0</span>];  </span><br><span class="line">            acc1[<span class="number">1</span>] += acc2[<span class="number">1</span>];  </span><br><span class="line">            <span class="keyword">return</span> acc1;  </span><br><span class="line">        &#125;;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> Function&lt;<span class="keyword">int</span>[], Double&gt; finisher() &#123;  </span><br><span class="line">        <span class="keyword">return</span> acc -&gt; ((<span class="keyword">double</span>) acc[<span class="number">0</span>]) / acc[<span class="number">1</span>];  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> Collections.emptySet();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In this example, we define a new class called <em>AverageCollector</em> that implements the Collector interface. The <em>supplier()</em> method returns a function that creates a new integer array with two elements to store the sum and count of the elements in the stream. </p><p>在本例中，我们定义了一个名为 <em>AverageCollector</em> 的新类，该类实现了收集器接口。<em>supplier()</em> 方法返回一个函数，用于创建一个包含两个元素的新整数数组，用于存储数据流中元素的总和与计数。</p><p>The accumulator() method returns a function that adds each element to the sum and increments the count. The <em>combiner()</em> method returns a function that combines two integer arrays by adding their corresponding elements. The <em>finisher()</em> method returns a function that calculates the average by dividing the sum by the count. Finally, the <em>characteristics()</em> method returns an empty set because this collector does not have any special characteristics.</p><p>累加器()方法返回一个将每个元素加到总和中并递增计数的函数。<em>combiner()</em> 方法返回一个函数，该函数通过将两个整数数组中的相应元素相加来合并两个数组。<em>finisher()</em> 方法返回一个函数，通过用总和除以计数来计算平均值。最后，<em>characteristics()</em> 方法返回空集，因为该收集器没有任何特殊特征。</p><p>Once you’ve defined your custom collector, you can use it with the collect() method of the Stream interface like this:</p><p>一旦定义了自定义收集器，就可以像这样将其与 Stream 接口的 collect() 方法结合使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> average = numbers.stream()  </span><br><span class="line">                        .collect(<span class="keyword">new</span> AverageCollector());</span><br></pre></td></tr></table></figure><p>In this example, we create a stream of integers and use the collect() method with our custom AverageCollector to calculate the average of the integers in the stream. The lambda expressions we defined in the AverageCollector class are used to perform the accumulation and transformation operations.</p><p>在本例中，我们创建了一个整数流，并使用带有自定义 AverageCollector 的 collect() 方法计算流中整数的平均值。我们在 AverageCollector 类中定义的 lambda 表达式用于执行累加和转换操作。</p><h2 id="Use-Lambda-expressions-to-create-Higher-order-Functions-使用-Lambda-表达式创建高阶函数"><a href="#Use-Lambda-expressions-to-create-Higher-order-Functions-使用-Lambda-表达式创建高阶函数" class="headerlink" title="Use Lambda expressions to create Higher-order Functions 使用 Lambda 表达式创建高阶函数"></a>Use Lambda expressions to create Higher-order Functions 使用 Lambda 表达式创建高阶函数</h2><p>A higher-order function is a function that takes one or more functions as arguments and/or returns a function as its result. Lambda expressions can be used to create functions that take other functions as arguments or return functions as results.</p><p>高阶函数是将一个或多个函数作为参数和/或将一个函数作为结果返回的函数。Lambda 表达式可用于创建将其他函数作为参数或将函数作为结果返回的函数。</p><blockquote><p>To create a higher-order function using lambda expressions, you can define a method that takes a functional interface as a parameter or return value. A functional interface is an interface that has exactly one abstract method and is annotated with the @FunctionalInterface annotation.</p><p>要使用 lambda 表达式创建高阶函数，可以定义一个将功能接口作为参数或返回值的方法。功能接口是一个拥有一个抽象方法并使用 @FunctionalInterface 注解的接口。</p></blockquote><p>Here’s an example of creating a higher-order function that takes a function as an argument:</p><p>下面是一个创建以函数为参数的高阶函数的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span>  </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">BinaryOperator</span>&lt;<span class="title">T</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="function">T <span class="title">apply</span><span class="params">(T t1, T t2)</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">BinaryOperator&lt;T&gt; <span class="title">compose</span><span class="params">(BinaryOperator&lt;T&gt; op1, BinaryOperator&lt;T&gt; op2)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> (x, y) -&gt; op1.apply(op2.apply(x, y), y);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In this example, we define a functional interface called <em>BinaryOperator</em> that has an <em>apply()</em> method that takes two arguments and returns a result. We then define a static method called <em>compose()</em> that takes two BinaryOperator functions as arguments and returns a new BinaryOperator function that composes the two input functions.</p><p>在本例中，我们定义了一个名为 <em>BinaryOperator</em> 的函数接口，它有一个 <em>apply()</em> 方法，该方法接收两个参数并返回一个结果。然后，我们定义了一个名为 <em>compose()</em> 的静态方法，该方法接收两个 <strong>BinaryOperator</strong> 函数作为参数，并返回一个新的 <strong>BinaryOperator</strong> 函数，该函数将两个输入函数合成。</p><p>The <em>compose()</em> method takes two BinaryOperator functions as arguments, op1 and op2. It then returns a new BinaryOperator function that applies op1 to the result of applying op2 to its arguments. The lambda expression (x, y) -&gt; op1.apply(op2.apply(x, y), y) defines the new BinaryOperator function. The first argument of the lambda expression (x) is the result of applying op2 to the original arguments, and the second argument (y) is the second original argument.</p><p><em>compose()</em> 方法将 op1 和 op2 这两个二进制操作符函数作为参数。然后，它返回一个新的二进制操作符函数，该函数将 op1 应用于将 op2 应用于其参数的结果。lambda 表达式<code>(x, y) -&gt; op1.apply(op2.apply(x, y), y)</code> 定义了新的二元运算符函数。lambda 表达式的第一个参数 (x) 是将 op2 应用于原始参数的结果，第二个参数 (y) 是第二个原始参数。</p><p>Here’s an example of using the compose() method to compose two BinaryOperator functions:</p><p>下面是一个使用 <code>compose()</code> 方法组合两个 <code>BinaryOperator</code> 函数的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BinaryOperator&lt;Integer&gt; add = (x, y) -&gt; x + y;  </span><br><span class="line">BinaryOperator&lt;Integer&gt; multiply = (x, y) -&gt; x * y;  </span><br><span class="line"></span><br><span class="line">BinaryOperator&lt;Integer&gt; composed = compose(add, multiply);  </span><br><span class="line"></span><br><span class="line">System.out.println(composed.apply(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// Output: 8</span></span><br></pre></td></tr></table></figure><p>In this example, we define two BinaryOperator functions: add, which adds its two arguments, and multiply, which multiplies its two arguments. We then use the compose() method to create a new BinaryOperator function that first multiplies its arguments and then adds the result. We test the composed function by applying it to the values 2 and 3, which should result in 8.</p><p>在本例中，我们定义了两个 BinaryOperator 函数：add 和 multiply，前者用于将两个参数相加，后者用于将两个参数相乘。然后，我们使用 compose() 方法创建一个新的 BinaryOperator 函数，首先乘以参数，然后将结果相加。我们对组成的函数进行测试，将其应用于数值 2 和 3，结果应为 8。</p><p>Lambda expressions can also be used to create higher-order functions that return functions as results. Here’s an example of creating a higher-order function that returns a UnaryOperator function:</p><p>Lambda 表达式还可用于创建高阶函数，将函数作为结果返回。下面是创建返回 UnaryOperator 函数的高阶函数的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span>  </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UnaryOperator</span>&lt;<span class="title">T</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="function">T <span class="title">apply</span><span class="params">(T t)</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">UnaryOperator&lt;T&gt; <span class="title">addValue</span><span class="params">(T value)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> x -&gt; x + value;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In this example, we define a functional interface called UnaryOperator that has an apply() method that takes one argument and returns a result. We then define a static method called addValue() that takes a value of type T and returns a new UnaryOperator function that adds the value to its argument.</p><p>在本例中，我们定义了一个名为 UnaryOperator 的函数接口，它有一个 apply() 方法，该方法接收一个参数并返回一个结果。然后，我们定义了一个名为 addValue() 的静态方法，该方法接收一个 T 类型的值，并返回一个新的 UnaryOperator 函数，将值添加到其参数中。</p><p>The addValue() method returns a lambda expression that defines the new UnaryOperator function. The lambda expression x -&gt; x + value takes one argument (x) and adds the value to it.</p><p><code>addValue()</code> 方法返回一个 lambda 表达式，该表达式定义了新的 <code>UnaryOperator</code> 函数。lambda 表达式<code>x -&gt; x + value</code> 接收一个参数<code>（x）</code>并将值添加到参数中。</p><p>Here’s an example of using the addValue() method to create a new UnaryOperator function:</p><p>下面是一个使用 <code>addValue()</code> 方法创建新的 <code>UnaryOperator</code> 函数的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UnaryOperator&lt;Integer&gt; add5 = addValue(<span class="number">5</span>);  </span><br><span class="line"></span><br><span class="line">System.out.println(add5.apply(<span class="number">2</span>)); <span class="comment">// Output: 7</span></span><br></pre></td></tr></table></figure><p>In this example, we use the addValue() method to create a new UnaryOperator function that adds 5 to its argument. We assign the result to the add5 variable, which is now a function that adds 5 to its argument. We test the add5 function by applying it to the value 2, which should result in 7.</p><p>在本例中，我们使用 addValue() 方法创建了一个新的 UnaryOperator 函数，将 5 添加到参数中。我们将结果赋值给 add5 变量，它现在是一个将 5 添入其参数的函数。我们对 add5 函数进行测试，将其应用于数值 2，结果应为 7。</p><h2 id="Use-Lambda-expressions-to-create-Closures-使用-Lambda-表达式创建闭包"><a href="#Use-Lambda-expressions-to-create-Closures-使用-Lambda-表达式创建闭包" class="headerlink" title="Use Lambda expressions to create Closures 使用 Lambda 表达式创建闭包"></a>Use Lambda expressions to create Closures 使用 Lambda 表达式创建闭包</h2><p>A closure is a function that can access and modify variables in its enclosing scope. In other words, a closure “closes over” the variables in its enclosing scope and can use them as if they were local variables.</p><p>闭包是一个可以访问和修改其外层作用域中变量的函数。换句话说，闭包 “关闭 “其外层作用域中的变量，并能像使用局部变量一样使用它们。</p><blockquote><p>To create a closure using lambda expressions, you can define a lambda expression that references a variable in its enclosing scope. The lambda expression will then capture the value of the variable at the time the lambda expression is created and use that value whenever it is called.</p><p>要使用 lambda 表达式创建闭包，可以定义一个 lambda 表达式，在其外层作用域中引用一个变量。然后，在创建 lambda 表达式时，lambda 表达式将捕获变量的值，并在调用时使用该值。</p></blockquote><p>Here’s an example of creating a closure using a lambda expression:</p><p>下面是一个使用 lambda 表达式创建闭包的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClosureExample</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">5</span>;  </span><br><span class="line">        Runnable runnable = () -&gt; System.out.println(x);  </span><br><span class="line">        x = <span class="number">10</span>;  </span><br><span class="line">        runnable.run(); <span class="comment">// Output: 10  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In this example, we define a variable x with the value 5. We then define a lambda expression that references x and prints its value. Finally, we change the value of x to 10 and call the lambda expression.</p><p>在本例中，我们定义了一个值为 5 的变量 x。然后，我们定义一个 lambda 表达式，引用 x 并打印其值。最后，我们将 x 的值改为 10 并调用 lambda 表达式。</p><p>When the lambda expression is created, it captures the value of x, which is 5 at the time. When we call the lambda expression, it prints the value of x, which is now 10 because we changed its value after the lambda expression was created. The lambda expression “closes over” the variable x and uses it as if it were a local variable.</p><p>创建 lambda 表达式时，它会捕捉 x 的值，当时的值是 5。当我们调用 lambda 表达式时，它会打印出 x 的值，现在是 10，因为我们在创建 lambda 表达式后更改了它的值。lambda 表达式 “关闭 “了变量 x，并像使用局部变量一样使用它。</p><p>Here’s another example of creating a closure using a lambda expression:</p><p>下面是另一个使用lambda表达式创建闭包的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClosureExample</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);  </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;  </span><br><span class="line">        numbers.forEach(n -&gt; sum += n);  </span><br><span class="line">        System.out.println(sum); <span class="comment">// Output: 15  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In this example, we define a list of integers and a variable sum with the initial value 0. We then use a lambda expression to iterate over the list and add each element to the sum variable. Finally, we print the value of sum.</p><p>在本例中，我们定义了一个整数列表和一个初始值为 0 的变量 sum。然后，我们使用 lambda 表达式遍历列表，并将每个元素添加到 sum 变量中。最后，我们打印 sum 的值。</p><p>The lambda expression “closes over” the variable sum and updates its value each time it is called. This allows us to calculate the sum of the list using a single lambda expression and a single variable, without the need for a separate loop or accumulator.</p><p>lambda 表达式 “关闭 “变量 sum，并在每次调用时更新其值。这样，我们就可以使用单个 lambda 表达式和单个变量计算列表的总和，而无需单独的循环或累加器。</p><h2 id="Use-Lambda-expressions-with-Method-References-在方法引用中使用-Lambda-表达式"><a href="#Use-Lambda-expressions-with-Method-References-在方法引用中使用-Lambda-表达式" class="headerlink" title="Use Lambda expressions with Method References 在方法引用中使用 Lambda 表达式"></a>Use Lambda expressions with Method References 在方法引用中使用 Lambda 表达式</h2><blockquote><p>Method references allow you to refer to an existing method by name instead of defining a new lambda expression. This can make code more concise and readable, especially when working with simple functions.</p><p>方法引用允许你通过通过引用一个现有方法，而不是重新定一个新的函数表达式。这会使得代码更加简洁并且可读，特别是在处理简单函数时。</p></blockquote><p>There are four types of method references in Java:</p><ol><li>Reference to a static method</li><li>Reference to an instance method of a particular object</li><li>Reference to an instance method of an arbitrary object of a particular type</li><li>Reference to a constructor</li></ol><p>Java中有四种方法引用类型：</p><ol><li>静态方法引用</li><li>对特定对象的实例方法的引用</li><li>对特定类型的任意对象的实例方法的引用</li><li>对构造函数的引用</li></ol><blockquote><p>To use a method reference, you can replace the lambda expression with a reference to the method by name. The method reference syntax is similar to the lambda expression syntax, but with the method name and class name instead of the parameter list and arrow.</p><p>使用方法引用，你可以使用引用的方法名称替换Lambda表达式，<strong>方法引用的语法与 lambda 表达式的语法类似</strong>，只是用方法名和类名代替了参数列表和箭头。</p></blockquote><p>Here’s an example of using a method reference to a static method:</p><p>下面是使用静态方法引用的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodReferenceExample</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);  </span><br><span class="line">        numbers.forEach(System.out::println);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In this example, we define a list of integers and use the forEach() method to print each element to the console. Instead of using a lambda expression to define the action, we use a method reference to the static method System.out.println(). The double colon (::) operator is used to indicate that we want to reference a method instead of defining a new lambda expression.</p><p>这个例子中，我们定义一个整型列表，使用<code>forEach()</code>方法打印到控制台，这里不需要使用Lambda表达式，而是直接使用静态方法<code>System.out.println()</code>的方法引用，<strong>双冒号（::）操作符用于表示我们要引用一个方法</strong>，而不是定义一个新的 lambda 表达式</p><p>Here’s an example of using a method reference to an instance method of a particular object:</p><p>下面是一个使用方法引用到特定对象的实例方法的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodReferenceExample</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        List&lt;String&gt; strings = Arrays.asList(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"cherry"</span>);  </span><br><span class="line">        strings.sort(String::compareToIgnoreCase);  </span><br><span class="line">        System.out.println(strings); <span class="comment">// Output: [apple, banana, cherry]  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In this example, we define a list of strings and use the sort() method to sort the list in a case-insensitive manner. Instead of using a lambda expression to define the comparator function, we use a method reference to the compareToIgnoreCase() method of the String class.</p><p>在这个案例中，我们定义字符串列表并且用 <code>sort()</code> 方法以不区分大小写的方式对列表进行排序，我们没有使用 lambda 表达式来定义比较器函数，而是使用了对 String 类的 compareToIgnoreCase() 方法的引用。</p><p>Here’s an example of using a method reference to an instance method of an arbitrary object of a particular type:</p><p>下面是一个示例，说明如何使用方法引用来引用特定类型的任意对象的实例方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodReferenceExample</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        List&lt;String&gt; strings = Arrays.asList(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"cherry"</span>);  </span><br><span class="line">        strings.forEach(String::toUpperCase);  </span><br><span class="line">        System.out.println(strings); <span class="comment">// Output: [apple, banana, cherry]  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here’s an example of using a method reference to a constructor:</p><p>下面是一个将方法引用用于构造函数的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodReferenceExample</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        List&lt;String&gt; strings = Arrays.asList(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"cherry"</span>);  </span><br><span class="line">        List&lt;String&gt; copy = strings.stream()  </span><br><span class="line">                                   .map(String::<span class="keyword">new</span>)  </span><br><span class="line">                                   .collect(Collectors.toList());  </span><br><span class="line">        System.out.println(copy); <span class="comment">// Output: [apple, banana, cherry]  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In this example, we define a list of strings and use the stream() method to create a stream of the strings. We then use the map() method to create a new stream of strings, each of which is created using the String constructor that takes a single argument. This constructor is referenced using a method reference to the String class constructor. Finally, we collect the new stream into a list and print the result.</p><p>在这个例子中，我们定义包含字符串的列表并且使用stream 方法创建一个String 流，接着我们使用map方法创建一个新的String流，每个字符串都是使用String构造函数新创建的，该构造函数只需要一个参数。构造函数使用String类构造函数的方法引用。最后，我们将新的数据流收集到一个列表中并打印结果。</p><h2 id="Use-Lambda-expressions-with-default-methods-in-Interfaces-在接口中使用带有默认方法的-Lambda-表达式"><a href="#Use-Lambda-expressions-with-default-methods-in-Interfaces-在接口中使用带有默认方法的-Lambda-表达式" class="headerlink" title="Use Lambda expressions with default methods in Interfaces 在接口中使用带有默认方法的 Lambda 表达式"></a>Use Lambda expressions with default methods in Interfaces 在接口中使用带有默认方法的 Lambda 表达式</h2><p>Default methods were introduced in Java 8 to allow interfaces to define a default implementation for a method. This allows interfaces to evolve over time without breaking existing implementations.</p><p>Default 默认方法是 Java 8 的新特性之一，主要是允许接口定义默认方法并且实现自己的逻辑，这使得接口可以在不破坏现有实现的情况下随着时间的推移而发展。</p><blockquote><p>Lambda expressions can be used with default methods in interfaces by providing an implementation for the default method in the lambda expression. This allows the lambda expression to be used as an implementation of the interface, even if the interface defines a default method.</p><p><strong>通过在 lambda 表达式中为缺省方法提供实现，lambda 表达式可以与接口中的缺省方法一起使用。</strong> 即使接口定义了缺省方法，也可以将 lambda 表达式用作接口的实现。</p></blockquote><p>Here’s an example of using a lambda expression with a default method in an interface:</p><p>下面是一个使用Lambda表达式和使用静态方法接口的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span>  </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Calculator</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">subtract</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> add(x, -y);  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultMethodExample</span> </span>&#123;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">    Calculator calculator = (x, y) -&gt; x + y;  </span><br><span class="line">    System.out.println(calculator.add(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// Output: 5  </span></span><br><span class="line">    System.out.println(calculator.subtract(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// Output: -1  </span></span><br><span class="line">&#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>In this example, we define a functional interface called Calculator that has an add() method and a default subtract() method. The subtract() method calls the add() method to perform the subtraction.</p><p>上面例子中我们定义<code>Calculator</code>接口和静态方法<code>subtract</code>和接口方法<code>add()</code>,<code>subtract</code>方法内部会调用<code>add()</code>方法实现减法操作。</p><p>We then define a lambda expression that implements the add() method of the Calculator interface. We can use this lambda expression as an implementation of the interface, even though the interface defines a default method.</p><p>我们接着使用Lambda表达式定义一个实现了Calculator 接口的<code>add()</code>方法的实现类，我们可以使用这个lambda表达式作为接口的实现，尽管接口定义了一个<strong>缺省方法</strong>。</p><h2 id="Use-Lambda-expressions-with-the-Optional-Class-与可选类一起使用-Lambda-表达式"><a href="#Use-Lambda-expressions-with-the-Optional-Class-与可选类一起使用-Lambda-表达式" class="headerlink" title="Use Lambda expressions with the Optional Class 与可选类一起使用 Lambda 表达式"></a>Use Lambda expressions with the Optional Class 与可选类一起使用 Lambda 表达式</h2><p>The Optional class was introduced in Java 8 to help prevent null pointer exceptions by providing a container object that may or may not contain a value. Optional provides a set of methods for working with potentially null values in a safer and more concise way.</p><p><strong>Optional</strong> 是Java8 当中引入的类，它提供一个可能包含或者不包含值的容器预防控制针异常，Optional提供了一组方法，用于以更安全、更简洁的方式处理潜在的空值。</p><blockquote><p>Lambda expressions can be used with the Optional class to define custom behavior for cases where a value is present or absent. Optional provides several methods for working with values, including map(), flatMap(), filter(), ifPresent(), and orElse(). These methods can be used with lambda expressions to define custom behavior for these cases.</p><p>Lambda 是可以和 Optional 类一起使用，在值存在或不存在的情况下定义自定义行为，比如map(), flatMap(), filter(), ifPresent(), and orElse() 等方法，可以和 Lambda一起使用</p></blockquote><p>Here’s an example of using a lambda expression with the map() method of the Optional class:</p><p>下面是使用Optional.map() 方法的简单案例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optional = Optional.of(<span class="string">"hello"</span>);  </span><br><span class="line">Optional&lt;Integer&gt; result = optional.map(s -&gt; s.length());  </span><br><span class="line">System.out.println(result.get()); <span class="comment">// Output: 5</span></span><br></pre></td></tr></table></figure><p>In this example, we create an Optional object that contains the string “hello”. We then use the map() method to apply a lambda expression that returns the length of the string. The result of the map() method is an Optional object that contains the result of the lambda expression. We can then use the get() method to retrieve the value from the Optional object and print it to the console.</p><p>例子中创建一个内容为“hello”的Optional对象，接着使用 map() 函数应用一个返回字符串长度的lambda表达式。map() 结果是包含Lambda表达式结果的可选对象，我们使用get() 方法从 Optional 对象中获取值。</p><p>Here’s an example of using a lambda expression with the filter() method of the Optional class:</p><p>下面是使用<code>Optional.filter()</code>的另一个案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optional = Optional.of(<span class="string">"hello"</span>);  </span><br><span class="line">Optional&lt;String&gt; result = optional.filter(s -&gt; s.length() &gt; <span class="number">5</span>);  </span><br><span class="line">System.out.println(result.isPresent()); <span class="comment">// Output: false</span></span><br></pre></td></tr></table></figure><p>In this example, we create an Optional object that contains the string “hello”. We then use the filter() method to apply a lambda expression that filters out strings with length less than or equal to 5. Since “hello” has a length of 5, it does not pass the filter and the resulting Optional object is empty. We can then use the isPresent() method to check whether the Optional object contains a value and print the result to the console.</p><p>例子中创建一个内容为“hello”的Optional对象，接着使用 filter() 函数应用一个<strong>过滤掉</strong>字符串长度小于等于5的值lambda表达式，这时候得到的Optional 对象是为空的，使用 <code>isPresent</code> 方法便可以检查是否包含一个值，最终打印结果到控制台。</p><p>Here’s an example of using a lambda expression with the orElse() method of the Optional class:</p><p>最后是一个<code>orElse()</code>的栗子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optional = Optional.empty();  </span><br><span class="line">String result = optional.orElseGet(() -&gt; <span class="string">"default"</span>);  </span><br><span class="line">System.out.println(result); <span class="comment">// Output: default</span></span><br></pre></td></tr></table></figure><p>In this example, we create an empty Optional object and use the orElseGet() method to provide a default value if the Optional object is empty. We pass a lambda expression that returns the default value “default”. Since the Optional object is empty, the orElseGet() method returns the default value, which we then print to the console.</p><p>这个例子中我们创建一个空的 <strong>Optional</strong> 对象并且使用<code>orElseGet()</code>方法在Optional 内部内容为空的的时候提供一个默认值。我们传递一个 lambda 表达式，返回默认值 “default”。由于 Optional 对象为空，orElseGet() 方法返回默认值，然后我们将其打印到控制台。</p><p><em>Thanks for your Attention! Happy Learning!</em></p><p>感谢您的关注！学习愉快！_</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      Effective Lambda Expressions
    
    </summary>
    
    
      <category term="Java" scheme="https://whitestore.top/categories/Java/"/>
    
    
      <category term="Java" scheme="https://whitestore.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【English】literally 到底是什么意思，为什么美国人老把 literally 挂嘴边？</title>
    <link href="https://whitestore.top/2023/08/10/literallywhy/"/>
    <id>https://whitestore.top/2023/08/10/literallywhy/</id>
    <published>2023-08-10T08:51:14.000Z</published>
    <updated>2023-09-09T00:53:49.932Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>事情的起因是《Who moved my cheese》这本书的一段话：</p><blockquote><p>But when the Cheese story was shared with <strong>literally</strong> everyone in our organization ….</p></blockquote><p>但是，当《奶酪》的故事在我们组织的每个人中流传开来时…. 这里有一个【literally】单词经过查阅之后，发现它的含义基本上都是”按字面上“，这种说法显然说不通，所以它有另一种含义，那就是 <strong>真的</strong>。</p><p>渣渣英语的我，对于这段话的理解是强调<strong>事情本身是事实，实际发生的</strong>，抱着验证的疑问，这里去翻了翻知乎的说法：</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzYyNTE4MDEx" title="https://www.zhihu.com/question/62518011">literally 到底是什么意思，为什么美国人老把 literally 挂嘴边？ - 知乎 (zhihu.com)<i class="fa fa-external-link"></i></span></p><blockquote><p>关于这个单词的讨论挺有意思的</p></blockquote><p>下面是个人对于【literally】单词含义这种奇怪的变化做一个归档整理。</p><a id="more"></a><h1 id="原文含义"><a href="#原文含义" class="headerlink" title="原文含义"></a>原文含义</h1><ol><li>【真的】【简直的】</li><li>【按字面】；【字面上】</li></ol><p>按照中文思维，这个词确实用在一些介绍中：</p><blockquote><p>Meiguo literllay means beautiful conutry</p><ul><li>美国，字面上的意思是「有美丽风景线的国家」。</li></ul></blockquote><h1 id="口语中的各种用法"><a href="#口语中的各种用法" class="headerlink" title="口语中的各种用法"></a>口语中的各种用法</h1><p>1）简直是…</p><p>2）实在是..</p><p>3）真的是…</p><p>4）的确是…</p><h1 id="如何理解"><a href="#如何理解" class="headerlink" title="如何理解"></a>如何理解</h1><p><strong>通俗一点就是「字面上说的这样，没有夸张和虚假成分」= I mean what I said。</strong></p><p>换一种理解就是：「名副其实的」， live up to its name。</p><p><strong>名副其实</strong>，就是literally= really。</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><h2 id="例1：There-are-literally-100-people-lined-up-outside-the-store"><a href="#例1：There-are-literally-100-people-lined-up-outside-the-store" class="headerlink" title="例1：There are literally 100 people lined up outside the store"></a>例1：There are <strong>literally</strong> 100 people lined up outside the store</h2><p>足足有100个人在外面排队</p><h2 id="例2：-She-is-literally-the-woman-i-love-the-most-in-my-life"><a href="#例2：-She-is-literally-the-woman-i-love-the-most-in-my-life" class="headerlink" title="例2： She is literally the woman i love the most in my life"></a>例2： She is <strong>literally</strong> the woman i love the most in my life</h2><p>她真的是我这辈子最爱的人。</p><h2 id="例3：I-literally-stayed-at-home-and-watched-Netflix-all-day-yesterday"><a href="#例3：I-literally-stayed-at-home-and-watched-Netflix-all-day-yesterday" class="headerlink" title="例3：I literally stayed at home and watched Netflix all day yesterday."></a>例3：I literally stayed at home and watched Netflix all day yesterday.</h2><p>昨天我在家呆着看了一天的Netflix。这件事确实发生了，literally表示的是一种<strong>语气加强</strong>，或者是你对这件事的<strong>一种惊讶、不可置信。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Literally 的用法主要分为：</p><ul><li>①表“字面上的”意义；</li><li>②表强调。</li></ul><p>这个常见于出现会让我们 <strong>”really？“</strong> 的场景。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      literally 到底是什么意思
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://whitestore.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://whitestore.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【Java】Exploring the New HTTP Client in Java</title>
    <link href="https://whitestore.top/2023/08/10/httpclientjdk11/"/>
    <id>https://whitestore.top/2023/08/10/httpclientjdk11/</id>
    <published>2023-08-10T08:49:34.000Z</published>
    <updated>2023-09-09T00:53:49.934Z</updated>
    
    <content type="html"><![CDATA[<h1 id="探索-Java-中的新-HTTP-客户端"><a href="#探索-Java-中的新-HTTP-客户端" class="headerlink" title="探索 Java 中的新 HTTP 客户端"></a>探索 Java 中的新 HTTP 客户端</h1><h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFlbGR1bmcuY29tL2phdmEtOS1odHRwLWNsaWVudA==" title="https://www.baeldung.com/java-9-http-client">https://www.baeldung.com/java-9-http-client<i class="fa fa-external-link"></i></span></p><h2 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a><a href="https://www.baeldung.com/java-9-http-client#introduction" target="_blank" rel="noopener"><strong>1. Overview</strong></a></h2><p>In this tutorial, we’ll explore Java 11’s standardization of <strong>HTTP client API that implements HTTP/2 and Web Socket.</strong></p><p>本文讲讨论Java 11 的新HTTP客户端API是如何实现 HTTP/2 和 WebSocket的。</p><p>It aims to replace the legacy <em><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vZW4vamF2YS9qYXZhc2UvMTcvZG9jcy9hcGkvamF2YS5iYXNlL2phdmEvbmV0L0h0dHBVUkxDb25uZWN0aW9uLmh0bWw=" title="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/net/HttpURLConnection.html">HttpUrlConnection<i class="fa fa-external-link"></i></span></em> class that has been present in the JDK since the very early years of Java.</p><p>它旨在取代自 Java 诞生之初就存在于 JDK 中的传统<em><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vZW4vamF2YS9qYXZhc2UvMTcvZG9jcy9hcGkvamF2YS5iYXNlL2phdmEvbmV0L0h0dHBVUkxDb25uZWN0aW9uLmh0bWw=" title="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/net/HttpURLConnection.html">HttpUrlConnection<i class="fa fa-external-link"></i></span></em> 类。</p><a id="more"></a><blockquote><p>It aims to …. 旨在</p></blockquote><p>Until very recently, Java provided only the <em>HttpURLConnection</em> API, which is low-level and isn’t known for being feature-rich and user-friendly.</p><p>在旧版本中，Java 提供 <em>HttpURLConnection</em> API，该 API 是低级的，并不以功能丰富和用户友好而著称。</p><p>Therefore, some widely used third-party libraries were commonly used, such as <span class="exturl" data-url="aHR0cHM6Ly9oYy5hcGFjaGUub3JnL2h0dHBjb21wb25lbnRzLWNsaWVudC1nYS8=" title="https://hc.apache.org/httpcomponents-client-ga/">Apache HttpClient<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly9lY2xpcHNlLmRldi9qZXR0eS9kb2N1bWVudGF0aW9uL2pldHR5LTkvaW5kZXguaHRtbCNodHRwLWNsaWVudC1hcGk=" title="https://eclipse.dev/jetty/documentation/jetty-9/index.html#http-client-api">Jetty<i class="fa fa-external-link"></i></span> and Spring’s <span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFlbGR1bmcuY29tL3Jlc3QtdGVtcGxhdGU=" title="https://www.baeldung.com/rest-template">RestTemplate<i class="fa fa-external-link"></i></span>.</p><p>所以，我们通常都会使用 类似   <span class="exturl" data-url="aHR0cHM6Ly9oYy5hcGFjaGUub3JnL2h0dHBjb21wb25lbnRzLWNsaWVudC1nYS8=" title="https://hc.apache.org/httpcomponents-client-ga/">Apache HttpClient<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly9lY2xpcHNlLmRldi9qZXR0eS9kb2N1bWVudGF0aW9uL2pldHR5LTkvaW5kZXguaHRtbCNodHRwLWNsaWVudC1hcGk=" title="https://eclipse.dev/jetty/documentation/jetty-9/index.html#http-client-api">Jetty<i class="fa fa-external-link"></i></span> 或者 Spring’s <span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFlbGR1bmcuY29tL3Jlc3QtdGVtcGxhdGU=" title="https://www.baeldung.com/rest-template">RestTemplate<i class="fa fa-external-link"></i></span> 这样的第三方库作为替代。</p><h2 id="Further-reading-（相关阅读）"><a href="#Further-reading-（相关阅读）" class="headerlink" title="Further reading:（相关阅读）"></a>Further reading:（相关阅读）</h2><h2 id="Posting-with-Java-HttpClient"><a href="#Posting-with-Java-HttpClient" class="headerlink" title="Posting with Java HttpClient"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFlbGR1bmcuY29tL2phdmEtaHR0cGNsaWVudC1wb3N0" title="https://www.baeldung.com/java-httpclient-post">Posting with Java HttpClient<i class="fa fa-external-link"></i></span></h2><p>From Java 9 onwards, the new <em>HttpClient</em> API provides both a synchronous and asynchronous modern web client. We look at how it can be used to make requests.</p><p>从 Java 9 开始，新的 <em>HttpClient</em> API 提供了<strong>同步</strong>和<strong>异步</strong>的现代 Web 客户端。我们来看看如何使用它来发出请求。</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFlbGR1bmcuY29tL2phdmEtaHR0cGNsaWVudC1wb3N0" title="https://www.baeldung.com/java-httpclient-post">Read more<i class="fa fa-external-link"></i></span> →</p><h2 id="Java-HttpClient-With-SSL"><a href="#Java-HttpClient-With-SSL" class="headerlink" title="Java HttpClient With SSL"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFlbGR1bmcuY29tL2phdmEtaHR0cGNsaWVudC1zc2w=" title="https://www.baeldung.com/java-httpclient-ssl">Java HttpClient With SSL<i class="fa fa-external-link"></i></span></h2><p>Learn how to use the Java HttpClient to connect to HTTPS URLs and also find out how to bypass certificate verification in non-production environments.</p><p>了解如何使用 Java HttpClient 连接 HTTPS URL，以及如何在非生产环境中绕过证书验证。</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFlbGR1bmcuY29tL2phdmEtaHR0cGNsaWVudC1zc2w=" title="https://www.baeldung.com/java-httpclient-ssl">Read more<i class="fa fa-external-link"></i></span> →</p><h2 id="Adding-Parameters-to-Java-HttpClient-Requests"><a href="#Adding-Parameters-to-Java-HttpClient-Requests" class="headerlink" title="Adding Parameters to Java HttpClient Requests"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFlbGR1bmcuY29tL2phdmEtaHR0cGNsaWVudC1yZXF1ZXN0LXBhcmFtZXRlcnM=" title="https://www.baeldung.com/java-httpclient-request-parameters">Adding Parameters to Java HttpClient Requests<i class="fa fa-external-link"></i></span></h2><p>Different examples of HTTPClient core Java.</p><p>HTTPClient core Java 的不同示例。</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFlbGR1bmcuY29tL2phdmEtaHR0cGNsaWVudC1yZXF1ZXN0LXBhcmFtZXRlcnM=" title="https://www.baeldung.com/java-httpclient-request-parameters">Read more<i class="fa fa-external-link"></i></span> →</p><h2 id="2-Background"><a href="#2-Background" class="headerlink" title="2. Background"></a><a href="https://www.baeldung.com/java-9-http-client#introduction-1" target="_blank" rel="noopener"><strong>2. Background</strong></a></h2><p>The change was implemented as a part of JEP 321.</p><p>所有的改变均实现自<strong>JEP 321</strong>。 </p><h3 id="2-1-Major-Changes-as-Part-of-JEP-321"><a href="#2-1-Major-Changes-as-Part-of-JEP-321" class="headerlink" title="2.1. Major Changes as Part of JEP 321"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFlbGR1bmcuY29tL2phdmEtOS1odHRwLWNsaWVudCMxLW1ham9yLWNoYW5nZXMtYXMtcGFydC1vZi1qZXAtMzIx" title="https://www.baeldung.com/java-9-http-client#1-major-changes-as-part-of-jep-321">2.1. Major Changes as Part of JEP 321<i class="fa fa-external-link"></i></span></h3><ol><li>The incubated HTTP API from Java 9 is now officially incorporated into the Java SE API. The new <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vZW4vamF2YS9qYXZhc2UvMTcvZG9jcy9hcGkvamF2YS5uZXQuaHR0cC9qYXZhL25ldC9odHRwL3BhY2thZ2Utc3VtbWFyeS5odG1s" title="https://docs.oracle.com/en/java/javase/17/docs/api/java.net.http/java/net/http/package-summary.html">HTTP APIs<i class="fa fa-external-link"></i></span> can be found in <strong>java.net.HTTP.*</strong></li></ol><p>Java 9 中孵化的 HTTP API 现已正式纳入 Java SE API。新的 <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vZW4vamF2YS9qYXZhc2UvMTcvZG9jcy9hcGkvamF2YS5uZXQuaHR0cC9qYXZhL25ldC9odHRwL3BhY2thZ2Utc3VtbWFyeS5odG1s" title="https://docs.oracle.com/en/java/javase/17/docs/api/java.net.http/java/net/http/package-summary.html">HTTP APIs<i class="fa fa-external-link"></i></span> 可在 <strong>java.net.HTTP.</strong> 中找到。</p><ol start="2"><li>The newer version of the HTTP protocol is designed to improve the overall performance of sending requests by a client and receiving responses from the server. This is achieved by introducing a number of changes such as stream multiplexing, header compression and push promises.</li></ol><p>较新版本的 HTTP 协议旨在提高客户端发送请求和服务器接收响应的整体性能。这是通过引入流<strong>多路复用</strong>、报头压缩和推送承诺来实现的。</p><ol start="3"><li>As of Java 11, <strong>the API is now fully asynchronous (the previous HTTP/1.1 implementation was blocking).</strong> Asynchronous calls are implemented using <em>CompletableFuture</em>.The <em>CompletableFuture</em> implementation takes care of applying each stage once the previous one has finished, so this whole flow is asynchronous.</li></ol><p>从 Java 11 开始，<strong>应用程序接口现在是完全异步的（以前的 HTTP/1.1 实现是阻塞的）。</strong> 异步调用是使用 <em>CompletableFuture</em> 实现的。</p><ol start="4"><li>The new HTTP client API provides a standard way to perform HTTP network operations with support for modern Web features such as HTTP/2, without the need to add third-party dependencies.</li></ol><p>新的 HTTP 客户端 API 提供了执行 HTTP 网络操作的标准方法，支持 HTTP/2 等现代网络功能，无需添加第三方依赖性。</p><ol start="5"><li>The new APIs provide native support for HTTP 1.1/2 WebSocket. The core classes and interface providing the core functionality include:</li></ol><p>新的应用程序接口为 <code>HTTP 1.1/2</code> WebSocket 提供本地支持。提供核心功能的核心类和接口包括</p><ul><li><p>The <em>HttpClient</em> class, <em>java.net.http.HttpClient</em></p></li><li><p>The <em>HttpRequest</em> class, <em>java.net.http.HttpRequest</em></p></li><li><p>The <em>HttpResponse</em>&lt; T &gt; interface, <em>java.net.http.HttpResponse</em></p></li><li><p>The <em>WebSocket</em> interface, <em>java.net.http.WebSocket</em></p></li><li><p><em>HttpClient</em> 类， <em>java.net.http.HttpClient</em> 。</p></li><li><p><em>HttpRequest</em> 类，<em>java.net.http.HttpRequest</em></p></li><li><p>接口<em>HttpResponse</em>&lt; T &gt;,  <em>java.net.http.HttpResponse</em></p></li><li><p><em>WebSocket</em> 接口，<em>java.net.http.WebSocket</em> &lt; T &gt;。</p><h3 id="2-2-Problems-With-the-Pre-Java-11-HTTP-Client"><a href="#2-2-Problems-With-the-Pre-Java-11-HTTP-Client" class="headerlink" title="2.2. Problems With the Pre-Java 11 HTTP Client"></a><a href="https://www.baeldung.com/java-9-http-client#2-problems-with-the-pre-java-11-http-client" target="_blank" rel="noopener"><strong>2.2. Problems With the Pre-Java 11 HTTP Client</strong></a></h3></li></ul><p>The existing <em>HttpURLConnection</em> API and its implementation had numerous problems:</p><p>现有的 <em>HttpURLConnection</em> API 及其实现存在许多问题：</p><ul><li><p>URLConnection API was designed with multiple protocols that are now no longer functioning (FTP, gopher, etc.).</p></li><li><p>The API predates HTTP/1.1 and is too abstract.</p></li><li><p>It works in blocking mode only (i.e., one thread per request/response).</p></li><li><p>It is very hard to maintain.</p></li><li><p>URLConnection API 在设计时使用了多个现已失效的协议（FTP、gopher 等）。</p></li><li><p>该 API 早于 HTTP/1.1，过于抽象。</p></li><li><p>只能在阻塞模式下工作（即每个请求/响应只有一个线程）。</p></li><li><p>很难维护。</p><h2 id="3-HTTP-Client-API-Overview"><a href="#3-HTTP-Client-API-Overview" class="headerlink" title="3. HTTP Client API Overview"></a><a href="https://www.baeldung.com/java-9-http-client#api" target="_blank" rel="noopener"><strong>3. HTTP Client API Overview</strong></a></h2></li></ul><p>Unlike <em>HttpURLConnection</em>, HTTP Client provides synchronous and asynchronous request mechanisms.</p><p>与 <em>HttpURLConnection</em> 不同，HTTP 客户端提供同步和异步请求机制。</p><p>The API consists of three core classes:</p><p>API 由三个核心类组成：</p><ul><li><p><em>HttpRequest</em> represents the request to be sent via the <em>HttpClient</em>.</p></li><li><p><em>HttpClient</em> behaves as a container for configuration information common to multiple requests.</p></li><li><p><em>HttpResponse</em> represents the result of an <em>HttpRequest</em> call.</p></li><li><p><em>HttpRequest</em> 表示要通过 <em>HttpClient</em> 发送的请求。</p></li><li><p><em>HttpClient</em> 是多个请求所共有的配置信息的容器。</p></li><li><p><em>HttpResponse</em> 表示 <em>HttpRequest</em> 调用的结果。</p></li></ul><p>We’ll examine each of them in more details in the following sections. First, let’s focus on a request.</p><p>我们将在下面的章节中对它们逐一进行详细介绍。首先，我们来关注一个请求。</p><h2 id="4-HttpRequest"><a href="#4-HttpRequest" class="headerlink" title="4. HttpRequest"></a><a href="https://www.baeldung.com/java-9-http-client#requests" target="_blank" rel="noopener"><strong>4. <em>HttpRequest</em></strong></a></h2><p><em>HttpRequest</em> is an object that represents the request we want to send. New instances can be created using <em>HttpRequest.Builder.</em></p><p><em>HttpRequest</em> 是一个对象，代表我们要发送的请求。可以使用 <em>HttpRequest.Builder.</em> 创建新实例。</p><p>We can get it by calling <em>HttpRequest.newBuilder()</em>. <em>Builder</em> class provides a bunch of methods that we can use to configure our request.</p><p>我们可以通过调用 <em>HttpRequest.newBuilder()</em> 来获取它。 <em>Builder</em> 类提供了许多方法，我们可以用它们来配置我们的请求。</p><p>We’ll cover the most important ones.</p><p>我们将介绍最重要的几项。</p><p>Note: In JDK 16, there is a new <em>HttpRequest.newBuilder(HttpRequest request, BiPredicate&lt;String,​String&gt; filter)</em> method, which creates a <em>Builder</em> whose initial state is copied from an existing <em>HttpRequest</em>.</p><blockquote><p>注意：在JDK16， 有一个新的 <em>HttpRequest.newBuilder(HttpRequest request, BiPredicate&lt;String,String&gt; filter)</em>  方法，用于创建一个_Builder_，其初始状态是从现有的_HttpRequest_复制而来。</p></blockquote><p>This builder can be used to build an <em>HttpRequest</em>, equivalent to the original, while allowing amendment of the request state prior to construction, for example, removing headers:</p><p>该构建器可用于构建一个 _HttpRequest_，等同于原始请求，同时允许在构建之前修改请求状态，例如删除头信息：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HttpRequest.newBuilder(request, <span class="function"><span class="params">(name, value)</span> -&gt;</span> !name.equalsIgnoreCase(<span class="string">"Foo-Bar"</span>))</span><br></pre></td></tr></table></figure><h3 id="4-1-Setting-URI"><a href="#4-1-Setting-URI" class="headerlink" title="4.1. Setting URI"></a><a href="https://www.baeldung.com/java-9-http-client#1-setting-uri" target="_blank" rel="noopener"><strong>4.1. Setting <em>URI</em></strong></a></h3><p>The first thing we have to do when creating a request is to provide the URL.</p><p>创建请求时，我们要做的第一件事就是提供 URL。</p><p>We can do that in two ways — using the constructor for <em>Builder</em> with <em>URI</em> parameter or calling method <em>uri(URI)</em> on the <em>Builder</em> instance:</p><p>我们可以通过两种方法实现这一目的：使用 <em>URI</em> 参数的 <em>Builder</em> 构造函数，或者调用 <em>Builder</em> 实例上的 <em>uri(URI)</em> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HttpRequest.newBuilder(<span class="keyword">new</span> URI(<span class="string">"https://postman-echo.com/get"</span>))</span><br><span class="line"> </span><br><span class="line">HttpRequest.newBuilder()</span><br><span class="line">  .uri(<span class="keyword">new</span> URI(<span class="string">"https://postman-echo.com/get"</span>))</span><br></pre></td></tr></table></figure><p>The last thing we have to configure to create a basic request is an HTTP method.</p><p>创建基本请求的最后一项配置是 HTTP 方法。</p><h3 id="4-2-Specifying-the-HTTP-Method"><a href="#4-2-Specifying-the-HTTP-Method" class="headerlink" title="4.2. Specifying the HTTP Method"></a><a href="https://www.baeldung.com/java-9-http-client#2-specifying-the-http-method" target="_blank" rel="noopener"><strong>4.2. Specifying the HTTP Method</strong></a></h3><p>We can define the HTTP method that our request will use by calling one of the methods from <em>Builder</em>:</p><p>我们可以通过调用 <em>Builder</em> 中的一个方法来定义请求将使用的 HTTP 方法：</p><ul><li><em>GET()</em></li><li><em>POST(BodyPublisher body)</em></li><li><em>PUT(BodyPublisher body)</em></li><li><em>DELETE()</em></li></ul><p>We’ll cover <em>BodyPublisher</em> in detail, later.</p><p>稍后我们将详细介绍 <em>BodyPublisher</em> 的内容。</p><p>Now let’s just create <strong>a very simple GET request example</strong>:</p><p>现在，让我们创建<strong>个非常简单的 GET 请求示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HttpRequest request = HttpRequest.newBuilder()</span><br><span class="line">  .uri(<span class="keyword">new</span> URI(<span class="string">"https://postman-echo.com/get"</span>))</span><br><span class="line">  .GET()</span><br><span class="line">  .build();</span><br></pre></td></tr></table></figure><p>This request has all parameters required by <em>HttpClient</em>.</p><p>该请求包含 <em>HttpClient</em> 要求的所有参数。</p><p>However, we sometimes need to add additional parameters to our request. Here are some important ones:</p><p>不过，有时我们需要在请求中添加其他参数。下面是一些重要的参数：</p><ul><li><p>The version of the HTTP protocol</p></li><li><p>Headers</p></li><li><p>A timeout</p></li><li><p>HTTP 协议的版本</p></li><li><p>标题</p></li><li><p>超时</p><h3 id="4-3-Setting-HTTP-Protocol-Version"><a href="#4-3-Setting-HTTP-Protocol-Version" class="headerlink" title="4.3. Setting HTTP Protocol Version"></a><a href="https://www.baeldung.com/java-9-http-client#3-setting-http-protocol-version" target="_blank" rel="noopener"><strong>4.3. Setting HTTP Protocol Version</strong></a></h3></li></ul><p>The API fully leverages the HTTP/2 protocol and uses it by default, but we can define which version of the protocol we want to use:</p><p>该应用程序接口完全利用 HTTP/2 协议，并默认使用该协议，但我们可以定义要使用的协议版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HttpRequest request = HttpRequest.newBuilder()</span><br><span class="line">  .uri(<span class="keyword">new</span> URI(<span class="string">"https://postman-echo.com/get"</span>))</span><br><span class="line">  .version(HttpClient.Version.HTTP_2)</span><br><span class="line">  .GET()</span><br><span class="line">  .build();</span><br></pre></td></tr></table></figure><p><strong>Important to mention here is that the client will fall back to, e.g., HTTP/1.1 if HTTP/2 isn’t supported.</strong></p><p><strong>这里需要指出的是，如果不支持 HTTP/2，客户端将退回到 HTTP/1.1 等协议。</strong></p><h3 id="4-4-Setting-Headers"><a href="#4-4-Setting-Headers" class="headerlink" title="4.4. Setting Headers"></a><a href="https://www.baeldung.com/java-9-http-client#4-setting-headers" target="_blank" rel="noopener"><strong>4.4. Setting Headers</strong></a></h3><p>In case we want to add additional headers to our request, we can use the provided builder methods.</p><p>如果我们想在请求中添加其他标头，可以使用提供的构建器方法。</p><p>We can do that by either passing all headers as key-value pairs to the <em>headers()</em> method or by using <em>header()</em> method for the single key-value header:</p><p>为此，我们可以将所有标头作为键值对传递给 <em>headers()</em> 方法，或者使用 <em>header()</em> 方法来处理单个键值标头：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HttpRequest request = HttpRequest.newBuilder()</span><br><span class="line">  .uri(<span class="keyword">new</span> URI(<span class="string">"https://postman-echo.com/get"</span>))</span><br><span class="line">  .headers(<span class="string">"key1"</span>, <span class="string">"value1"</span>, <span class="string">"key2"</span>, <span class="string">"value2"</span>)</span><br><span class="line">  .GET()</span><br><span class="line">  .build();</span><br><span class="line"></span><br><span class="line">HttpRequest request2 = HttpRequest.newBuilder()</span><br><span class="line">  .uri(<span class="keyword">new</span> URI(<span class="string">"https://postman-echo.com/get"</span>))</span><br><span class="line">  .header(<span class="string">"key1"</span>, <span class="string">"value1"</span>)</span><br><span class="line">  .header(<span class="string">"key2"</span>, <span class="string">"value2"</span>)</span><br><span class="line">  .GET()</span><br><span class="line">  .build();</span><br></pre></td></tr></table></figure><p>The last useful method we can use to customize our request is a <em>timeout()</em>.</p><p>我们可以用来定制请求的最后一个有用方法是 <em>timeout()</em> 。</p><h3 id="4-5-Setting-a-Timeout"><a href="#4-5-Setting-a-Timeout" class="headerlink" title="4.5. Setting a Timeout"></a><a href="https://www.baeldung.com/java-9-http-client#5-setting-a-timeout" target="_blank" rel="noopener"><strong>4.5. Setting a Timeout</strong></a></h3><p>Let’s now define the amount of time we want to wait for a response.</p><p>现在我们来定义等待响应的时间。</p><p>If the set time expires, a <em>HttpTimeoutException</em> will be thrown. The default timeout is set to infinity.</p><p>如果设定的时间已过，就会抛出一个 <em>HttpTimeoutException</em> 异常。默认超时设置为无穷大。</p><p>The timeout can be set with the <em>Duration</em> object by calling method <em>timeout()</em> on the builder instance:</p><p>可以通过调用构建器实例上的 <em>timeout()</em> 方法，使用 <em>Duration</em> 对象设置超时时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HttpRequest request = HttpRequest.newBuilder()</span><br><span class="line">  .uri(<span class="keyword">new</span> URI(<span class="string">"https://postman-echo.com/get"</span>))</span><br><span class="line">  .timeout(Duration.of(<span class="number">10</span>, SECONDS))</span><br><span class="line">  .GET()</span><br><span class="line">  .build();</span><br></pre></td></tr></table></figure><h2 id="5-Setting-a-Request-Body"><a href="#5-Setting-a-Request-Body" class="headerlink" title="5. Setting a Request Body"></a><a href="https://www.baeldung.com/java-9-http-client#setting-a-request-body" target="_blank" rel="noopener"><strong>5. Setting a Request Body</strong></a></h2><p>We can add a body to a request by using the request builder methods: <em>POST(BodyPublisher body)</em>, <em>PUT(BodyPublisher body)</em> and <em>DELETE()</em>.</p><p>我们可以使用请求生成器方法为请求添加正文： <em>POST(BodyPublisher body)<em>、</em>PUT(BodyPublisher body)</em>  和 _DELETE()_。</p><p>The new API provides a number of <em>BodyPublisher</em> implementations out-of-the-box that simplify passing the request body:</p><p>新的 API 提供了许多开箱即用的 <em>BodyPublisher</em> 实现，简化了请求正文的传递：</p><ul><li><p><em>StringProcessor</em> – reads body from a <em>String</em>, created with <em>HttpRequest.BodyPublishers.ofString</em></p></li><li><p><em>InputStreamProcessor</em> – reads body from an <em>InputStream</em>, created with <em>HttpRequest.BodyPublishers.ofInputStream</em></p></li><li><p><em>ByteArrayProcessor</em> – reads body from a byte array, created with <em>HttpRequest.BodyPublishers.ofByteArray</em></p></li><li><p><em>FileProcessor</em> – reads body from a file at the given path, created with <em>HttpRequest.BodyPublishers.ofFile</em></p></li><li><p><em>StringProcessor</em> - 从 <em>String</em> 中读取正文，使用 <em>HttpRequest.BodyPublishers.ofString</em> 创建。</p></li><li><p><em>InputStreamProcessor</em> - 从 <em>InputStream</em> 中读取正文，使用 <em>HttpRequest.BodyPublishers.ofInputStream</em> 创建。</p></li><li><p><em>ByteArrayProcessor</em> - 从字节数组中读取正文，使用 <em>HttpRequest.BodyPublishers.ofByteArray</em> 创建。</p></li><li><p><em>FileProcessor</em> - 从指定路径的文件中读取正文，使用 <em>HttpRequest.BodyPublishers.ofFile</em> 创建。</p></li></ul><p>In case we don’t need a body, we can simply pass in an <em>HttpRequest.BodyPublishers.__noBody()</em>:</p><p>如果不需要正文，我们只需传入 <em>HttpRequest.BodyPublishers. __noBody()</em>  即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HttpRequest request = HttpRequest.newBuilder()</span><br><span class="line">  .uri(<span class="keyword">new</span> URI(<span class="string">"https://postman-echo.com/post"</span>))</span><br><span class="line">  .POST(HttpRequest.BodyPublishers.noBody())</span><br><span class="line">  .build();</span><br></pre></td></tr></table></figure><p>Note: In JDK 16, there’s a new <em>HttpRequest.BodyPublishers.concat(BodyPublisher…)</em> method that helps us building a request body from the concatenation of the request bodies published by a sequence of publishers. The request body published by a <em>concatenation publisher</em> is logically equivalent to the request body that would have been published by concatenating all the bytes of each publisher in sequence.</p><blockquote><p>注：在 JDK 16 中，有一个新的 <em>HttpRequest.BodyPublishers.concat(BodyPublisher…)</em> 方法，可以帮助我们通过串联一系列发布者发布的请求体来构建请求体。由 <em>concatenation 发布者</em> 发布的请求正文在逻辑上等同于按顺序连接每个发布者的所有字节后发布的请求正文。</p></blockquote><h3 id="5-1-StringBodyPublisher"><a href="#5-1-StringBodyPublisher" class="headerlink" title="5.1. StringBodyPublisher"></a><a href="https://www.baeldung.com/java-9-http-client#1-stringbodypublisher" target="_blank" rel="noopener"><strong>5.1. <em>StringBodyPublisher</em></strong></a></h3><p>Setting a request body with any <em>BodyPublishers</em> implementation is very simple and intuitive.</p><p>使用任何 <em>BodyPublishers</em> 实现来设置请求正文都非常简单直观。</p><p>For example, if we want to pass a simple <em>String</em> as a body, we can use <em>StringBodyPublishers</em>.</p><p>例如，如果我们想传递一个简单的 <em>String</em> 作为正文，我们可以使用 _StringBodyPublishers_。</p><p>As we already mentioned, this object can be created with a factory method <em>ofString()</em> — it takes just a <em>String</em> object as an argument and creates a body from it:</p><p>正如我们已经提到的，可以使用工厂方法 <em>ofString()</em> 创建该对象 – 该方法只接受一个 <em>String</em> 对象作为参数，并从中创建一个正文：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HttpRequest request = HttpRequest.newBuilder()</span><br><span class="line">  .uri(<span class="keyword">new</span> URI(<span class="string">"https://postman-echo.com/post"</span>))</span><br><span class="line">  .headers(<span class="string">"Content-Type"</span>, <span class="string">"text/plain;charset=UTF-8"</span>)</span><br><span class="line">  .POST(HttpRequest.BodyPublishers.ofString(<span class="string">"Sample request body"</span>))</span><br><span class="line">  .build();</span><br></pre></td></tr></table></figure><h3 id="5-2-InputStreamBodyPublisher"><a href="#5-2-InputStreamBodyPublisher" class="headerlink" title="5.2. InputStreamBodyPublisher"></a><a href="https://www.baeldung.com/java-9-http-client#2-inputstreambodypublisher" target="_blank" rel="noopener"><strong>5.2. <em>InputStreamBodyPublisher</em></strong></a></h3><p>To do that, the <em>InputStream</em> has to be passed as a <em>Supplier</em> (to make its creation lazy), so it’s a little bit different than <em>StringBodyPublishers</em>.</p><p>要做到这一点，必须将 <em>InputStream</em> 作为 <em>Supplier</em> 传递（变为懒加载），因此它与 <em>StringBodyPublishers</em> 有点不同。</p><p>However, this is also quite straightforward:</p><p>不过，这也很简单明了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] sampleData = <span class="string">"Sample request body"</span>.getBytes();</span><br><span class="line">HttpRequest request = HttpRequest.newBuilder()</span><br><span class="line">  .uri(<span class="keyword">new</span> URI(<span class="string">"https://postman-echo.com/post"</span>))</span><br><span class="line">  .headers(<span class="string">"Content-Type"</span>, <span class="string">"text/plain;charset=UTF-8"</span>)</span><br><span class="line">  .POST(HttpRequest.BodyPublishers</span><br><span class="line">   .ofInputStream(() -&gt; <span class="keyword">new</span> ByteArrayInputStream(sampleData)))</span><br><span class="line">  .build();</span><br></pre></td></tr></table></figure><p>Notice how we used a simple <em>ByteArrayInputStream</em> here. Of course, that can be any <em>InputStream</em> implementation.</p><p>请注意我们在这里使用了一个简单的 <em>ByteArrayInputStream</em> 。当然，这可以是任何 <em>InputStream</em> 的实现。</p><h3 id="5-3-ByteArrayProcessor"><a href="#5-3-ByteArrayProcessor" class="headerlink" title="5.3. ByteArrayProcessor"></a><a href="https://www.baeldung.com/java-9-http-client#3-bytearrayprocessor" target="_blank" rel="noopener"><strong>5.3. <em>ByteArrayProcessor</em></strong></a></h3><p>We can also use <em>ByteArrayProcessor</em> and pass an array of bytes as the parameter:</p><p>我们还可以使用 <em>ByteArrayProcessor</em> 并将字节数组作为参数传递：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] sampleData = <span class="string">"Sample request body"</span>.getBytes();</span><br><span class="line">HttpRequest request = HttpRequest.newBuilder()</span><br><span class="line">  .uri(<span class="keyword">new</span> URI(<span class="string">"https://postman-echo.com/post"</span>))</span><br><span class="line">  .headers(<span class="string">"Content-Type"</span>, <span class="string">"text/plain;charset=UTF-8"</span>)</span><br><span class="line">  .POST(HttpRequest.BodyPublishers.ofByteArray(sampleData))</span><br><span class="line">  .build();</span><br></pre></td></tr></table></figure><h3 id="5-4-FileProcessor"><a href="#5-4-FileProcessor" class="headerlink" title="5.4. FileProcessor"></a><a href="https://www.baeldung.com/java-9-http-client#4-fileprocessor" target="_blank" rel="noopener"><strong>5.4. <em>FileProcessor</em></strong></a></h3><p>To work with a File, we can make use of the provided <em>FileProcessor</em>.、</p><p>要处理文件，我们可以使用所提供的 _FileProcessor_。</p><p>Its factory method takes a path to the file as a parameter and creates a body from the content:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HttpRequest request = HttpRequest.newBuilder()</span><br><span class="line">  .uri(<span class="keyword">new</span> URI(<span class="string">"https://postman-echo.com/post"</span>))</span><br><span class="line">  .headers(<span class="string">"Content-Type"</span>, <span class="string">"text/plain;charset=UTF-8"</span>)</span><br><span class="line">  .POST(HttpRequest.BodyPublishers.fromFile(</span><br><span class="line">    Paths.get(<span class="string">"src/test/resources/sample.txt"</span>)))</span><br><span class="line">  .build();</span><br></pre></td></tr></table></figure><p>We’ve covered how to create <em>HttpRequest</em> and how to set additional parameters in it.</p><p>我们已经介绍了如何创建 <em>HttpRequest</em> 以及如何在其中设置附加参数。</p><p>Now it’s time to take a deeper look at <em>HttpClient</em> class, which is responsible for sending requests and receiving responses.</p><p>现在是深入了解 <em>HttpClient</em> 类的时候了，它负责发送请求和接收响应。</p><h2 id="6-HttpClient"><a href="#6-HttpClient" class="headerlink" title="6. HttpClient"></a><a href="https://www.baeldung.com/java-9-http-client#requests-1" target="_blank" rel="noopener"><strong>6. <em>HttpClient</em></strong></a></h2><p>All requests are sent using <em>HttpClient</em>, which can be instantiated using the <em>HttpClient.newBuilder()</em> method or by calling <em>HttpClient.newHttpClient()</em>.</p><p>所有请求都是通过 <em>HttpClient</em> 发送的，可以使用 <em>HttpClient.newBuilder()</em> 方法或调用 <em>HttpClient.newHttpClient()</em> 来实例化 _HttpClient。</p><p>It provides a lot of useful and self-describing methods we can use to handle our request/response.</p><p>它提供了许多有用的自描述方法，我们可以用它们来处理请求/响应。</p><p>Let’s cover some of these here.</p><p>下面我们就来介绍其中的一些方法。</p><h3 id="6-1-Handling-Response-Body"><a href="#6-1-Handling-Response-Body" class="headerlink" title="6.1. Handling Response Body"></a><a href="https://www.baeldung.com/java-9-http-client#1-handling-response-body" target="_blank" rel="noopener"><strong>6.1. Handling Response Body</strong></a></h3><p>Similar to the fluent methods for creating publishers, there are methods dedicated to creating handlers for common body types:</p><p>与创建发布器的流畅方法类似，也有一些方法专门用于为常见的主体类型创建处理程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BodyHandlers.ofByteArray</span><br><span class="line">BodyHandlers.ofString</span><br><span class="line">BodyHandlers.ofFile</span><br><span class="line">BodyHandlers.discarding</span><br><span class="line">BodyHandlers.replacing</span><br><span class="line">BodyHandlers.ofLines</span><br><span class="line">BodyHandlers.fromLineSubscriber</span><br></pre></td></tr></table></figure><p>Pay attention to the usage of the new <em>BodyHandlers</em> factory class.</p><p>请注意新的 <em>BodyHandlers</em> 工厂类的用法。</p><p>Before Java 11, we had to do something like this:</p><p>在 Java 11 之前，我们不得不这样做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandler.asString());</span><br></pre></td></tr></table></figure><p>And we can now simplify it:</p><p>现在我们可以将其简化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HttpResponse&lt;String&gt; response = client.send(request, BodyHandlers.ofString());</span><br></pre></td></tr></table></figure><h3 id="6-2-Setting-a-Proxy"><a href="#6-2-Setting-a-Proxy" class="headerlink" title="6.2. Setting a Proxy"></a><a href="https://www.baeldung.com/java-9-http-client#2-setting-a-proxy" target="_blank" rel="noopener"><strong>6.2. Setting a Proxy</strong></a></h3><p>We can define a proxy for the connection by just calling <em>proxy()</em> method on a <em>Builder</em> instance:</p><p>我们只需在 <em>Builder</em> 实例上调用 <em>proxy()</em> 方法，就能为连接定义一个代理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HttpResponse&lt;String&gt; response = HttpClient</span><br><span class="line">  .newBuilder()</span><br><span class="line">  .proxy(ProxySelector.getDefault())</span><br><span class="line">  .build()</span><br><span class="line">  .send(request, BodyHandlers.ofString());</span><br></pre></td></tr></table></figure><p>In our example, we used the default system proxy.</p><p>在我们的示例中，我们使用了默认的系统代理。</p><h3 id="6-3-Setting-the-Redirect-Policy"><a href="#6-3-Setting-the-Redirect-Policy" class="headerlink" title="6.3. Setting the Redirect Policy"></a><a href="https://www.baeldung.com/java-9-http-client#3-setting-the-redirect-policy" target="_blank" rel="noopener"><strong>6.3. Setting the Redirect Policy</strong></a></h3><p>Sometimes the page we want to access has moved to a different address.</p><p>有时，我们想要访问的页面已经转移到了不同的地址。</p><p>In that case, we’ll receive HTTP status code 3xx, usually with the information about new URI. <strong><em>HttpClient</em> can redirect the request to the new URI automatically if we set the appropriate redirect policy.</strong></p><p>在这种情况下，我们会收到 HTTP 状态代码 <strong>3xx</strong>，其中通常包含有关新 URI 的信息。 <strong>如果我们设置了适当的重定向策略，</strong><em>HttpClient</em> 就能自动将请求重定向到新的 URI。</p><p>We can do it with the <em>followRedirects()</em> method on <em>Builder</em>:</p><p>我们可以通过 <em>Builder</em> 上的 <em>followRedirects()</em> 方法来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HttpResponse&lt;String&gt; response = HttpClient.newBuilder()</span><br><span class="line">  .followRedirects(HttpClient.Redirect.ALWAYS)</span><br><span class="line">  .build()</span><br><span class="line">  .send(request, BodyHandlers.ofString());</span><br></pre></td></tr></table></figure><p>All policies are defined and described in enum <em>HttpClient.Redirect</em>.</p><p>所有策略都在枚举 <em>HttpClient.Redirect</em> 中定义和描述。</p><h3 id="6-4-Setting-Authenticator-for-a-Connection"><a href="#6-4-Setting-Authenticator-for-a-Connection" class="headerlink" title="6.4. Setting Authenticator for a Connection"></a><a href="https://www.baeldung.com/java-9-http-client#4-setting-authenticator-for-a-connection" target="_blank" rel="noopener"><strong>6.4. Setting <em>Authenticator</em> for a Connection</strong></a></h3><p>An <em>Authenticator</em> is an object that negotiates credentials (HTTP authentication) for a connection.</p><p>验证器是一个为连接协商凭证（HTTP 验证）的对象。</p><p>It provides different authentication schemes (such as basic or digest authentication).</p><p>它提供不同的验证方案（如基本验证或摘要验证）。</p><p>In most cases, authentication requires username and password to connect to a server.</p><p>在大多数情况下，身份验证需要用户名和密码才能连接服务器。</p><p>We can use <em>PasswordAuthentication</em> class, which is just a holder of these values:</p><p>我们可以使用 <em>PasswordAuthentication</em> 类，它只是这些值的持有者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HttpResponse&lt;String&gt; response = HttpClient.newBuilder()</span><br><span class="line">  .authenticator(<span class="keyword">new</span> Authenticator() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> PasswordAuthentication <span class="title">getPasswordAuthentication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> PasswordAuthentication(</span><br><span class="line">        <span class="string">"username"</span>, </span><br><span class="line">        <span class="string">"password"</span>.toCharArray());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).build()</span><br><span class="line">  .send(request, BodyHandlers.ofString());</span><br></pre></td></tr></table></figure><p>Here we passed the username and password values as a plaintext. Of course, this would have to be different in a production scenario.</p><p>在这里，我们以明文形式传递用户名和密码值。当然，这在生产场景中必须有所不同。</p><p>Note that not every request should use the same username and password. The <em>Authenticator</em> class provides a number of <em>getXXX</em> (e.g., <em>getRequestingSite()</em>) methods that can be used to find out what values should be provided.</p><blockquote><p>请注意，并非每个请求都应使用相同的用户名和密码。<em>Authenticator</em> 类提供了许多 _getXXX_（例如 _getRequestingSite()_）方法，可用于查找应提供哪些值。</p></blockquote><p>Now we’re going to explore one of the most useful features of new <em>HttpClient</em> — asynchronous calls to the server.</p><p>现在，我们将探索新_HttpClient_最有用的功能之一–<strong>对服务器的异步调用</strong>。</p><h3 id="6-5-Send-Requests-–-Sync-vs-Async"><a href="#6-5-Send-Requests-–-Sync-vs-Async" class="headerlink" title="6.5. Send Requests – Sync vs Async"></a><a href="https://www.baeldung.com/java-9-http-client#5-send-requests---sync-vs-async" target="_blank" rel="noopener"><strong>6.5. Send Requests – Sync vs Async</strong></a></h3><p>New <em>HttpClient</em> provides two possibilities for sending a request to a server:</p><p>新的 <em>HttpClient</em> 提供了两种向服务器发送请求的可能性：</p><ul><li><p><strong><em>send(…)</em> – synchronously</strong> (blocks until the response comes)</p></li><li><p><strong><em>sendAsync(…)</em> – asynchronously</strong> (doesn’t wait for the response, non-blocking)</p></li><li><p><strong><em>send(…)</em>-同步</strong>（阻塞直到响应到来）</p></li><li><p><strong><em>sendAsync(…)</em>-异步</strong>（不等待响应，非阻塞）。</p></li></ul><p>Up until now, the <em>send(.</em>..) method naturally waits for a response:</p><p>到目前为止，<em>send(.</em>..) 方法一直在等待响应：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HttpResponse&lt;String&gt; response = HttpClient.newBuilder()</span><br><span class="line">  .build()</span><br><span class="line">  .send(request, BodyHandlers.ofString());</span><br></pre></td></tr></table></figure><p>This call returns an <em>HttpResponse</em> object, and we’re sure that the next instruction from our application flow will be run only when the response is already here.</p><p>该调用会返回一个 <em>HttpResponse</em> 对象，我们可以确信，只有当响应已经存在时，应用流程的下一条指令才会运行。</p><p>However, it has a lot of drawbacks especially when we are processing large amounts of data.</p><p>不过，这种方法有很多缺点，尤其是在处理大量数据时。</p><p>So, now we can use <em>sendAsync(.</em>..) method — which returns  <em>CompletableFeature&lt; HttpResponse&gt;</em>  — <strong>to process a request asynchronously</strong>:</p><p>因此，现在我们可以使用<em>sendAsync(.</em>..)方法（该方法返回_CompletableFeature&lt; HttpResponse&gt;_）<strong>异步处理请求</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;HttpResponse&lt;String&gt;&gt; response = HttpClient.newBuilder()</span><br><span class="line">  .build()</span><br><span class="line">  .sendAsync(request, HttpResponse.BodyHandlers.ofString());</span><br></pre></td></tr></table></figure><p>The new API can also deal with multiple responses, and stream the request and response bodies:</p><p>新的应用程序接口还可以处理多个响应，并对请求和响应体进行流式处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;URI&gt; targets = Arrays.asList(</span><br><span class="line">  <span class="keyword">new</span> URI(<span class="string">"https://postman-echo.com/get?foo1=bar1"</span>),</span><br><span class="line">  <span class="keyword">new</span> URI(<span class="string">"https://postman-echo.com/get?foo2=bar2"</span>));</span><br><span class="line">HttpClient client = HttpClient.newHttpClient();</span><br><span class="line">List&lt;CompletableFuture&lt;String&gt;&gt; futures = targets.stream()</span><br><span class="line">  .map(target -&gt; client</span><br><span class="line">    .sendAsync(</span><br><span class="line">      HttpRequest.newBuilder(target).GET().build(),</span><br><span class="line">      HttpResponse.BodyHandlers.ofString())</span><br><span class="line">    .thenApply(response -&gt; response.body()))</span><br><span class="line">  .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h3 id="6-6-Setting-Executor-for-Asynchronous-Calls"><a href="#6-6-Setting-Executor-for-Asynchronous-Calls" class="headerlink" title="6.6. Setting Executor for Asynchronous Calls"></a><a href="https://www.baeldung.com/java-9-http-client#6-setting-executor-for-asynchronous-calls" target="_blank" rel="noopener"><strong>6.6. Setting <em>Executor</em> for Asynchronous Calls</strong></a></h3><p>We can also define an <em>Executor</em> that provides threads to be used by asynchronous calls.</p><p>我们还可以定义一个 <em>Executor</em> 来提供线程供异步调用使用。</p><p>This way we can, for example, limit the number of threads used for processing requests:</p><p>例如，这样我们就可以限制用于处理请求的线程数量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;HttpResponse&lt;String&gt;&gt; response1 = HttpClient.newBuilder()</span><br><span class="line">  .executor(executorService)</span><br><span class="line">  .build()</span><br><span class="line">  .sendAsync(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;HttpResponse&lt;String&gt;&gt; response2 = HttpClient.newBuilder()</span><br><span class="line">  .executor(executorService)</span><br><span class="line">  .build()</span><br><span class="line">  .sendAsync(request, HttpResponse.BodyHandlers.ofString());</span><br></pre></td></tr></table></figure><p>By default, the <em>HttpClient</em> uses executor <em>java.util.concurrent.Executors.newCachedThreadPool()</em>.</p><p>默认情况下，<em>HttpClient</em> 使用执行器 _java.util.concurrent.Executors.newCachedThreadPool()_。</p><h3 id="6-7-Defining-a-CookieHandler"><a href="#6-7-Defining-a-CookieHandler" class="headerlink" title="6.7. Defining a CookieHandler"></a><a href="https://www.baeldung.com/java-9-http-client#7-defining-a-cookiehandler" target="_blank" rel="noopener"><strong>6.7. Defining a <em>CookieHandler</em></strong></a></h3><p>With new API and builder, it’s straightforward to set a <em>CookieHandler</em> for our connection. We can use builder method <em>cookieHandler(CookieHandler cookieHandler)</em> to define client-specific <em>CookieHandler</em>.</p><p>有了新的 API 和构建器，为连接设置 <em>CookieHandler</em> 就变得简单易行了。</p><p>我们可以使用构建器方法 <em>cookieHandler(CookieHandler cookieHandler)</em> 来定义客户端特定的 _CookieHandler_。</p><p>Let’s define <em>CookieManager (_a concrete implementation of _CookieHandler</em> that separates the storage of cookies from the policy surrounding accepting and rejecting cookies) that doesn’t allow to accept cookies at all:</p><p>让我们定义  <em>CookieManager_（ _CookieHandler</em> 的具体实现，它将 Cookie 的存储与接受和拒绝 Cookie 的策略分离开来），它完全不接受 Cookie：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HttpClient.newBuilder()</span><br><span class="line">  .cookieHandler(<span class="keyword">new</span> CookieManager(<span class="keyword">null</span>, CookiePolicy.ACCEPT_NONE))</span><br><span class="line">  .build();</span><br></pre></td></tr></table></figure><p>In case our <em>CookieManager</em> allows cookies to be stored, we can access them by checking <em>CookieHandler</em> from our <em>HttpClient</em>:</p><p>如果 <em>CookieManager</em> 允许存储 cookie，我们就可以通过检查 <em>HttpClient</em> 中的 <em>CookieHandler</em> 来访问它们：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((CookieManager) httpClient.cookieHandler().get()).getCookieStore()</span><br></pre></td></tr></table></figure><p>Now let’s focus on the last class from Http API — the <em>HttpResponse</em>.</p><p>现在，让我们来关注 Http API 的最后一个类–_HttpResponse_。</p><h2 id="7-HttpResponse-Object"><a href="#7-HttpResponse-Object" class="headerlink" title="7. HttpResponse Object"></a><a href="https://www.baeldung.com/java-9-http-client#requests-2" target="_blank" rel="noopener"><strong>7. <em>HttpResponse</em> Object</strong></a></h2><p>The <em>HttpResponse</em> class represents the response from the server. It provides a number of useful methods, but these are the two most important:</p><p><em>HttpResponse</em> 类表示来自服务器的响应。它提供了许多有用的方法，但其中最重要的有两个：</p><ul><li><p><em>statusCode()</em> returns status code (type <em>int</em>) for a response (<em>HttpURLConnection</em> class contains possible values).</p></li><li><p><em>body()</em> returns a body for a response (return type depends on the response <em>BodyHandler</em> parameter passed to the <em>send()</em> method).</p></li><li><p><em>statusCode()</em> 返回响应的状态代码（注意类型 <em>int_）（_HttpURLConnection</em> 类包含可能的值）。</p></li><li><p><em>body()</em> 返回响应的正文（返回类型取决于传递给 <em>send()</em> 方法的响应 <em>BodyHandler</em> 参数）。</p></li></ul><p>The response object has other useful methods that we’ll cover such as <em>uri()</em>, <em>headers()</em>, <em>trailers()</em> and <em>version()</em>.</p><p>响应对象还有其他有用的方法，如 <em>uri()<em>、</em>headers()<em>、</em>trailers()</em> 和 _version()_。</p><h3 id="7-1-URI-of-Response-Object"><a href="#7-1-URI-of-Response-Object" class="headerlink" title="7.1. URI of Response Object"></a><a href="https://www.baeldung.com/java-9-http-client#1-uri-of-response-object" target="_blank" rel="noopener"><strong>7.1. <em>URI</em> of Response Object</strong></a></h3><p>The method <em>uri()</em> on the response object returns the <em>URI</em> from which we received the response.</p><p>响应对象上的 <em>uri()</em> 方法会返回我们收到响应的 <em>URI</em> 地址。</p><p>Sometimes it can be different than <em>URI</em> in the request object because a redirection may occur:</p><p>有时它可能与请求对象中的 <em>URI</em> 不同，因为可能会发生重定向：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assertThat(request.uri()</span><br><span class="line">  .toString(), equalTo(<span class="string">"http://stackoverflow.com"</span>));</span><br><span class="line">assertThat(response.uri()</span><br><span class="line">  .toString(), equalTo(<span class="string">"https://stackoverflow.com/"</span>));</span><br></pre></td></tr></table></figure><h3 id="7-2-Headers-from-Response"><a href="#7-2-Headers-from-Response" class="headerlink" title="7.2. Headers from Response"></a><a href="https://www.baeldung.com/java-9-http-client#2-headers-from-response" target="_blank" rel="noopener"><strong>7.2. Headers from Response</strong></a></h3><p>We can obtain headers from the response by calling method <em>headers()</em> on a response object:</p><p>我们可以通过调用响应对象上的 <em>headers()</em> 方法来获取响应的标题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HttpResponse&lt;String&gt; response = HttpClient.newHttpClient()</span><br><span class="line">  .send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line">HttpHeaders responseHeaders = response.headers();</span><br></pre></td></tr></table></figure><p>It returns <em>HttpHeaders</em> object, which represents a read-only view of HTTP Headers.</p><p>它返回 <em>HttpHeaders</em> 对象，该对象表示 HTTP 头信息的只读视图。</p><p>It has some useful methods that simplify searching for headers value.</p><p>它有一些有用的方法，可以简化头信息值的搜索。</p><h3 id="7-3-Version-of-the-Response"><a href="#7-3-Version-of-the-Response" class="headerlink" title="7.3. Version of the Response"></a><a href="https://www.baeldung.com/java-9-http-client#3-version-of-the-response" target="_blank" rel="noopener"><strong>7.3. Version of the Response</strong></a></h3><p>The method <em>version()</em> defines which version of HTTP protocol was used to talk with a server.</p><p>方法 <em>version()</em> 定义了与服务器通信时使用的 HTTP 协议版本。</p><p><strong>Remember that even if we define that we want to use HTTP/2, the server can answer via HTTP/1.1.</strong></p><p><strong>请记住，即使我们定义要使用 HTTP/2，服务器也可以通过 HTTP/1.1 进行应答</strong>。</p><p>The version in which the server answered is specified in the response:</p><p>响应中指定了服务器应答的版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HttpRequest request = HttpRequest.newBuilder()</span><br><span class="line">  .uri(<span class="keyword">new</span> URI(<span class="string">"https://postman-echo.com/get"</span>))</span><br><span class="line">  .version(HttpClient.Version.HTTP_2)</span><br><span class="line">  .GET()</span><br><span class="line">  .build();</span><br><span class="line">HttpResponse&lt;String&gt; response = HttpClient.newHttpClient()</span><br><span class="line">  .send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line">assertThat(response.version(), equalTo(HttpClient.Version.HTTP_1_1));</span><br></pre></td></tr></table></figure><h2 id="8-Handling-Push-Promises-in-HTTP-2"><a href="#8-Handling-Push-Promises-in-HTTP-2" class="headerlink" title="8. Handling Push Promises in HTTP/2"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFlbGR1bmcuY29tL2phdmEtOS1odHRwLWNsaWVudCNoYW5kbGluZy1wdXNoLXByb21pc2VzLWluLWh0dHAy" title="https://www.baeldung.com/java-9-http-client#handling-push-promises-in-http2">8. Handling Push Promises in HTTP/2<i class="fa fa-external-link"></i></span></h2><p>New <em>HttpClient</em> supports push promises through <em>PushPromiseHandler</em> interface_._ </p><p>新的 <em>HttpClient</em> 通过 <em>PushPromiseHandler</em> 接口支持推送承诺。</p><p><strong>It allows the server to “push” content to the client additional resources while requesting the primary resource, saving more roundtrip and as a result improves performance in page rendering.</strong></p><p><strong>它允许服务器在请求主要资源的同时向客户端 “推送 “附加资源内容，从而节省了更多的往返时间，并因此提高了页面渲染的性能。</strong></p><p>It is really the multiplexing feature of HTTP/2 that allows us to forget about resource bundling. For each resource, the server sends a special request, known as a push promise to the client.</p><p>实际上，正是 HTTP/2 的多路复用功能让我们忘记了资源捆绑。对于每个资源，服务器都会向客户端发送一个特殊请求，即推送承诺。</p><p>Push promises received, if any, are handled by the given <em>PushPromiseHandler</em>. A null valued <em>PushPromiseHandler</em> rejects any push promises.</p><p>收到的推送承诺（如果有）将由给定的 <em>PushPromiseHandler</em> 处理。空值_PushPromiseHandler_将拒绝任何推送承诺。</p><p>The <em>HttpClient</em> has an overloaded <strong>sendAsync</strong> method that allows us to handle such promises, as shown below.</p><p>如下所示，<em>HttpClient</em> 有一个重载的 <strong>sendAsync</strong> 方法，允许我们处理此类承诺。</p><p>Let’s first create a <em>PushPromiseHandler</em>:</p><p>让我们先创建一个 <em>PushPromiseHandler</em> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> PushPromiseHandler&lt;String&gt; <span class="title">pushPromiseHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (HttpRequest initiatingRequest, </span><br><span class="line">        HttpRequest pushPromiseRequest, </span><br><span class="line">        Function&lt;HttpResponse.BodyHandler&lt;String&gt;, </span><br><span class="line">        CompletableFuture&lt;HttpResponse&lt;String&gt;&gt;&gt; acceptor) -&gt; &#123;</span><br><span class="line">        acceptor.apply(BodyHandlers.ofString())</span><br><span class="line">            .thenAccept(resp -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">" Pushed response: "</span> + resp.uri() + <span class="string">", headers: "</span> + resp.headers());</span><br><span class="line">            &#125;);</span><br><span class="line">        System.out.println(<span class="string">"Promise request: "</span> + pushPromiseRequest.uri());</span><br><span class="line">        System.out.println(<span class="string">"Promise request: "</span> + pushPromiseRequest.headers());</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Next, let’s use <em>sendAsync</em> method to handle this push promise:</p><p>接下来，让我们使用 <em>sendAsync</em> 方法来处理这个推送承诺：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">httpClient.sendAsync(pageRequest, BodyHandlers.ofString(), pushPromiseHandler())</span><br><span class="line">    .thenAccept(pageResponse -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"Page response status code: "</span> + pageResponse.statusCode());</span><br><span class="line">        System.out.println(<span class="string">"Page response headers: "</span> + pageResponse.headers());</span><br><span class="line">        String responseBody = pageResponse.body();</span><br><span class="line">        System.out.println(responseBody);</span><br><span class="line">    &#125;)</span><br><span class="line">    .join();</span><br></pre></td></tr></table></figure><h2 id="9-Conclusion"><a href="#9-Conclusion" class="headerlink" title="9. Conclusion"></a><a href="https://www.baeldung.com/java-9-http-client#conclusion" target="_blank" rel="noopener"><strong>9. Conclusion</strong></a></h2><p>In this article, we explored the Java 11 <em>HttpClient</em> API that standardized the incubating HttpClient introduced in Java 9 with more powerful changes.</p><p>在本文中，我们探讨了 Java 11 <em>HttpClient</em> API，它对 Java 9 中引入的孵化 HttpClient 进行了标准化，并做出了更强大的更改。</p><p>这篇文章讨论了JDK11全新的HTTP API，</p><p>The complete code used can be found <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2V1Z2VucC90dXRvcmlhbHMvdHJlZS9tYXN0ZXIvY29yZS1qYXZhLW1vZHVsZXMvY29yZS1qYXZhLTEx" title="https://github.com/eugenp/tutorials/tree/master/core-java-modules/core-java-11">over on GitHub<i class="fa fa-external-link"></i></span>.</p><p>使用的完整代码可在 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2V1Z2VucC90dXRvcmlhbHMvdHJlZS9tYXN0ZXIvY29yZS1qYXZhLW1vZHVsZXMvY29yZS1qYXZhLTEx" title="https://github.com/eugenp/tutorials/tree/master/core-java-modules/core-java-11">GitHub<i class="fa fa-external-link"></i></span> 上找到。</p><p>In the examples, we’ve used sample REST endpoints provided by <em><span class="exturl" data-url="aHR0cHM6Ly9wb3N0bWFuLWVjaG8uY29t" title="https://postman-echo.com">https://postman-echo.com<i class="fa fa-external-link"></i></span></em>.</p><p>在示例中，我们使用了 <em><span class="exturl" data-url="aHR0cHM6Ly9wb3N0bWFuLWVjaG8uY29t" title="https://postman-echo.com">https://postman-echo.com<i class="fa fa-external-link"></i></span></em> 提供的 REST 端点示例。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      新HTTPClient API介绍
    
    </summary>
    
    
      <category term="Java" scheme="https://whitestore.top/categories/Java/"/>
    
    
      <category term="Java" scheme="https://whitestore.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】Linux Performance</title>
    <link href="https://whitestore.top/2023/08/10/linuxperformance/"/>
    <id>https://whitestore.top/2023/08/10/linuxperformance/</id>
    <published>2023-08-10T08:48:04.000Z</published>
    <updated>2023-09-09T00:53:49.936Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【Linux】Linux-性能"><a href="#【Linux】Linux-性能" class="headerlink" title="【Linux】Linux 性能"></a>【Linux】Linux 性能</h1><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>干货不是一般的多。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9saW51eHBlcmYuaHRtbA==" title="https://www.brendangregg.com/linuxperf.html">https://www.brendangregg.com/linuxperf.html<i class="fa fa-external-link"></i></span></p><p>This page links to various Linux performance material I’ve created, including the tools maps on the right. These use a large font size to suit slide decks. You can also print them out for your office wall. They show: <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9QZXJmL2xpbnV4X29ic2VydmFiaWxpdHlfdG9vbHMucG5n" title="https://www.brendangregg.com/Perf/linux_observability_tools.png">Linux observability tools<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9QZXJmL2xpbnV4X3N0YXRpY190b29scy5wbmc=" title="https://www.brendangregg.com/Perf/linux_static_tools.png">Linux static performance analysis tools<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9QZXJmL2xpbnV4X2JlbmNobWFya2luZ190b29scy5wbmc=" title="https://www.brendangregg.com/Perf/linux_benchmarking_tools.png">Linux benchmarking tools<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9QZXJmL2xpbnV4X3R1bmluZ190b29scy5wbmc=" title="https://www.brendangregg.com/Perf/linux_tuning_tools.png">Linux tuning tools<i class="fa fa-external-link"></i></span>, and <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9QZXJmL2xpbnV4X29ic2VydmFiaWxpdHlfc2FyLnBuZw==" title="https://www.brendangregg.com/Perf/linux_observability_sar.png">Linux sar<i class="fa fa-external-link"></i></span>. Check the year on the image (bottom right) to see how recent it is.</p><p>本页链接到我制作的各种 Linux 性能材料，包括右侧的工具图。这些地图使用大号字体，适合幻灯片使用。你也可以打印出来贴在办公室墙上。它们显示 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9QZXJmL2xpbnV4X29ic2VydmFiaWxpdHlfdG9vbHMucG5n" title="https://www.brendangregg.com/Perf/linux_observability_tools.png">Linux 可观察性工具<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9QZXJmL2xpbnV4X3N0YXRpY190b29scy5wbmc=" title="https://www.brendangregg.com/Perf/linux_static_tools.png">Linux 静态性能分析工具<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9QZXJmL2xpbnV4X2JlbmNobWFya2luZ190b29scy5wbmc=" title="https://www.brendangregg.com/Perf/linux_benchmarking_tools.png">Linux 基准测试工具<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9QZXJmL2xpbnV4X3R1bmluZ190b29scy5wbmc=" title="https://www.brendangregg.com/Perf/linux_tuning_tools.png">Linux 调试工具<i class="fa fa-external-link"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9QZXJmL2xpbnV4X29ic2VydmFiaWxpdHlfc2FyLnBuZw==" title="https://www.brendangregg.com/Perf/linux_observability_sar.png">Linux sar<i class="fa fa-external-link"></i></span>。请查看图片（右下角）上的年份，了解其最新版本。 </p><a id="more"></a><p>There is also a hi-res diagram combining observability, static performance tuning, and perf-tools/bcc: <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9QZXJmL2xpbnV4X3BlcmZfdG9vbHNfZnVsbC5wbmc=" title="https://www.brendangregg.com/Perf/linux_perf_tools_full.png">png<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9QZXJmL2xpbnV4X3BlcmZfdG9vbHNfZnVsbC5zdmc=" title="https://www.brendangregg.com/Perf/linux_perf_tools_full.svg">svg<i class="fa fa-external-link"></i></span> (see <span class="exturl" data-url="aHR0cHM6Ly93d3cucmVkZGl0LmNvbS9yL2xpbnV4L2NvbW1lbnRzLzR4NHNtdS9saW51eF9wZXJmb3JtYW5jZV90b29sc19mdWxsX3ZlcnNpb25fZHJhZnQv" title="https://www.reddit.com/r/linux/comments/4x4smu/linux_performance_tools_full_version_draft/">discussion<i class="fa fa-external-link"></i></span>), but it is not as complete as the other diagrams. For even more diagrams, see my slide decks below.</p><p>还有一个结合了可观察性、静态性能调优和 <strong>perf-tools/bcc</strong> 的高清图表：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9QZXJmL2xpbnV4X3BlcmZfdG9vbHNfZnVsbC5wbmc=" title="https://www.brendangregg.com/Perf/linux_perf_tools_full.png">png<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9QZXJmL2xpbnV4X3BlcmZfdG9vbHNfZnVsbC5zdmc=" title="https://www.brendangregg.com/Perf/linux_perf_tools_full.svg">svg<i class="fa fa-external-link"></i></span>（见<span class="exturl" data-url="aHR0cHM6Ly93d3cucmVkZGl0LmNvbS9yL2xpbnV4L2NvbW1lbnRzLzR4NHNtdS9saW51eF9wZXJmb3JtYW5jZV90b29sc19mdWxsX3ZlcnNpb25fZHJhZnQv" title="https://www.reddit.com/r/linux/comments/4x4smu/linux_performance_tools_full_version_draft/">讨论<i class="fa fa-external-link"></i></span>），但不如其他图表完整。需更多图表，请参阅下面的幻灯片。</p><p>On this page: <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9saW51eHBlcmYuaHRtbCNUb29scw==" title="https://www.brendangregg.com/linuxperf.html#Tools">Tools<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9saW51eHBlcmYuaHRtbCNEb2N1bWVudGF0aW9u" title="https://www.brendangregg.com/linuxperf.html#Documentation">Documentation<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9saW51eHBlcmYuaHRtbCNUYWxrcw==" title="https://www.brendangregg.com/linuxperf.html#Talks">Talks<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9saW51eHBlcmYuaHRtbCNSZXNvdXJjZXM=" title="https://www.brendangregg.com/linuxperf.html#Resources">Resources<i class="fa fa-external-link"></i></span>.</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9QZXJmL2xpbnV4X3BlcmZfdG9vbHNfZnVsbC5wbmc=" title="https://www.brendangregg.com/Perf/linux_perf_tools_full.png">png<i class="fa fa-external-link"></i></span></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230803143138.png" alt="image.png"></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9QZXJmL2xpbnV4X3BlcmZfdG9vbHNfZnVsbC5zdmc=" title="https://www.brendangregg.com/Perf/linux_perf_tools_full.svg">svg<i class="fa fa-external-link"></i></span>（注意只有部分）</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230803143201.png" alt="image.png"></p><p>在本页中：<strong>Tools</strong>, <strong>Documentation</strong>, <strong>Talks</strong>, <strong>Resources</strong>.</p><h1 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h1><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9wZXJmLmh0bWw=" title="https://www.brendangregg.com/perf.html">perf<i class="fa fa-external-link"></i></span>: perf one-liners, examples, visualizations. （perf 、实例、可视化。）</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9lYnBmLmh0bWw=" title="https://www.brendangregg.com/ebpf.html">eBPF tools<i class="fa fa-external-link"></i></span>: BPF/bcc tracing tools and examples.  （BPF/bcc 跟踪工具和示例）</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JyZW5kYW5ncmVnZy9wZXJmLXRvb2xz" title="https://github.com/brendangregg/perf-tools">perf-tools<i class="fa fa-external-link"></i></span>: Ftrace perf tools (github). （Ftrace perf 工具（github））</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lvdmlzb3IvYmNjI3Rvb2xz" title="https://github.com/iovisor/bcc#tools">bcc<i class="fa fa-external-link"></i></span>: BPF/bcc perf tools (github). （BPF/bcc perf 工具（github））</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lvdmlzb3IvYnBmdHJhY2UjdG9vbHM=" title="https://github.com/iovisor/bpftrace#tools">bpftrace<i class="fa fa-external-link"></i></span>: BPF/bpftrace perf tools (github).（BPF/bpftrace perf 工具（github）。）</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9mbGFtZWdyYXBocy5odG1s" title="https://www.brendangregg.com/flamegraphs.html">Flame Graphs<i class="fa fa-external-link"></i></span>: using <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9GbGFtZUdyYXBocy9jcHVmbGFtZWdyYXBocy5odG1sI3BlcmY=" title="https://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html#perf">perf<i class="fa fa-external-link"></i></span> and other profilers.（使用 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9GbGFtZUdyYXBocy9jcHVmbGFtZWdyYXBocy5odG1sI3BlcmY=" title="https://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html#perf">perf<i class="fa fa-external-link"></i></span> 和其他剖析器。）</li></ul><h1 id="Documentation"><a href="#Documentation" class="headerlink" title="Documentation"></a>Documentation</h1><ul><li><span class="exturl" data-url="aHR0cDovL3RlY2hibG9nLm5ldGZsaXguY29tLzIwMTUvMTEvbGludXgtcGVyZm9ybWFuY2UtYW5hbHlzaXMtaW4tNjBzLmh0bWw=" title="http://techblog.netflix.com/2015/11/linux-performance-analysis-in-60s.html">Linux Performance Analysis in 60,000 Milliseconds<i class="fa fa-external-link"></i></span> shows the first ten commands to use in an investigation (<span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTUtMTItMDMvbGludXgtcGVyZi02MHMtdmlkZW8uaHRtbA==" title="https://www.brendangregg.com/blog/2015-12-03/linux-perf-60s-video.html">video<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9BcnRpY2xlcy9OZXRmbGl4X0xpbnV4X1BlcmZfQW5hbHlzaXNfNjBzLnBkZg==" title="https://www.brendangregg.com/Articles/Netflix_Linux_Perf_Analysis_60s.pdf">PDF<i class="fa fa-external-link"></i></span>). Written by myself and the performance engineering team at Netflix (2015).</li></ul><p><span class="exturl" data-url="aHR0cDovL3RlY2hibG9nLm5ldGZsaXguY29tLzIwMTUvMTEvbGludXgtcGVyZm9ybWFuY2UtYW5hbHlzaXMtaW4tNjBzLmh0bWw=" title="http://techblog.netflix.com/2015/11/linux-performance-analysis-in-60s.html">Linux Performance Analysis in 60,000 Milliseconds<i class="fa fa-external-link"></i></span> 显示了调查中使用的前十个命令（<span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTUtMTItMDMvbGludXgtcGVyZi02MHMtdmlkZW8uaHRtbA==" title="https://www.brendangregg.com/blog/2015-12-03/linux-perf-60s-video.html">视频<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9BcnRpY2xlcy9OZXRmbGl4X0xpbnV4X1BlcmZfQW5hbHlzaXNfNjBzLnBkZg==" title="https://www.brendangregg.com/Articles/Netflix_Linux_Perf_Analysis_60s.pdf">PDF<i class="fa fa-external-link"></i></span>）。由我本人和 Netflix 的性能工程团队撰写（2015 年）。</p><ul><li>My post <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTUtMDMtMDMvcGVyZm9ybWFuY2UtdHVuaW5nLWxpbnV4LWluc3RhbmNlcy1vbi1lYzIuaHRtbA==" title="https://www.brendangregg.com/blog/2015-03-03/performance-tuning-linux-instances-on-ec2.html">Performance Tuning Linux Instances on EC2<i class="fa fa-external-link"></i></span> includes the tunables we’re using at Netflix (2015).</li></ul><p>我的文章 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTUtMDMtMDMvcGVyZm9ybWFuY2UtdHVuaW5nLWxpbnV4LWluc3RhbmNlcy1vbi1lYzIuaHRtbA==" title="https://www.brendangregg.com/blog/2015-03-03/performance-tuning-linux-instances-on-ec2.html">Performance Tuning Linux Instances on EC2<i class="fa fa-external-link"></i></span>包含了我们在 Netflix 使用的可调性（2015 年）。</p><ul><li>A post on <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTctMDgtMDgvbGludXgtbG9hZC1hdmVyYWdlcy5odG1s" title="https://www.brendangregg.com/blog/2017-08-08/linux-load-averages.html">Linux Load Averages: Solving the Mystery<i class="fa fa-external-link"></i></span>, explaining what they are and why they include the uninterruptible sleep state (2017).</li></ul><p>关于[Linux 负载平均值：解开之谜]的帖子(<span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTctMDgtMDgvbGludXgtbG9hZC1hdmVyYWdlcy5odG1sKe+8jOino+mHiuS6huS7gOS5iOaYr+i0n+i9veW5s+Wdh+WAvOS7peWPiuS4uuS7gOS5iOWMheWQq+S4jemXtOaWreedoeecoOeKtuaAge+8iDIwMTc=" title="https://www.brendangregg.com/blog/2017-08-08/linux-load-averages.html)，解释了什么是负载平均值以及为什么包含不间断睡眠状态（2017">https://www.brendangregg.com/blog/2017-08-08/linux-load-averages.html)，解释了什么是负载平均值以及为什么包含不间断睡眠状态（2017<i class="fa fa-external-link"></i></span> 年）。</p><ul><li><p>A <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTYtMDgtMDkvZ2RiLWV4YW1wbGUtbmN1cnNlcy5odG1s" title="https://www.brendangregg.com/blog/2016-08-09/gdb-example-ncurses.html">gdb Debugging Full Example (Tutorial)<i class="fa fa-external-link"></i></span>, including the use of some perf/debugging tools (2016).</p></li><li><p>gdb 调试完整示例（教程）](<span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTYtMDgtMDkvZ2RiLWV4YW1wbGUtbmN1cnNlcy5odG1sKe+8jOWMheaLrOS4gOS6mw==" title="https://www.brendangregg.com/blog/2016-08-09/gdb-example-ncurses.html)，包括一些">https://www.brendangregg.com/blog/2016-08-09/gdb-example-ncurses.html)，包括一些<i class="fa fa-external-link"></i></span> perf/debugging 工具的使用（2016 年）。</p></li><li><p>The book <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9zeXN0ZW1zLXBlcmZvcm1hbmNlLTJuZC1lZGl0aW9uLWJvb2suaHRtbA==" title="https://www.brendangregg.com/systems-performance-2nd-edition-book.html">Systems Performance: Enterprise and the Cloud, 2nd Edition (2020)<i class="fa fa-external-link"></i></span> covers performance analysis methods and Linux tools, including perf, Ftrace, and eBPF.</p></li><li><p>系统性能：企业与云，第 2 版 (2020)](<span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9zeXN0ZW1zLXBlcmZvcm1hbmNlLTJuZC1lZGl0aW9uLWJvb2suaHRtbA==" title="https://www.brendangregg.com/systems-performance-2nd-edition-book.html">https://www.brendangregg.com/systems-performance-2nd-edition-book.html<i class="fa fa-external-link"></i></span>) 一书介绍了性能分析方法和 Linux 工具，包括 perf、Ftrace 和 eBPF。</p></li><li><p>The book <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9icGYtcGVyZm9ybWFuY2UtdG9vbHMtYm9vay5odG1s" title="https://www.brendangregg.com/bpf-performance-tools-book.html">BPF Performance Tools: Linux System and Application Observability<i class="fa fa-external-link"></i></span> tours over 100 eBPF performance analysis tools, while including short summaries of the traditional tools. In a way, this is volume 2, and Systems Performance 2nd Edition is volume 1.</p></li><li><p>BPF 性能工具：Linux 系统和应用程序可观察性](<span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9icGYtcGVyZm9ybWFuY2UtdG9vbHMtYm9vay5odG1s" title="https://www.brendangregg.com/bpf-performance-tools-book.html">https://www.brendangregg.com/bpf-performance-tools-book.html<i class="fa fa-external-link"></i></span>) 一书介绍了 100 多种 eBPF 性能分析工具，同时还包括传统工具的简短摘要。在某种程度上，这本书是第二卷，而《系统性能第二版》是第一卷。</p></li></ul><ul><li><p>Generating flame graphs on Linux using perf &amp; eBPF:<br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9GbGFtZUdyYXBocy9jcHVmbGFtZWdyYXBocy5odG1sI0xpbnV4" title="https://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html#Linux">CPU Flame Graphs<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9GbGFtZUdyYXBocy9vZmZjcHVmbGFtZWdyYXBocy5odG1sI0xpbnV4" title="https://www.brendangregg.com/FlameGraphs/offcpuflamegraphs.html#Linux">Off-CPU Flame Graphs<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9GbGFtZUdyYXBocy9tZW1vcnlmbGFtZWdyYXBocy5odG1sI0xpbnV4" title="https://www.brendangregg.com/FlameGraphs/memoryflamegraphs.html#Linux">Memory Flame Graphs<i class="fa fa-external-link"></i></span></p></li><li><p>使用 perf 和 eBPF 在 Linux 上生成火焰图：<br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9GbGFtZUdyYXBocy9jcHVmbGFtZWdyYXBocy5odG1sI0xpbnV4" title="https://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html#Linux">CPU 火焰图<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9GbGFtZUdyYXBocy9vZmZjcHVmbGFtZWdyYXBocy5odG1sI0xpbnV4" title="https://www.brendangregg.com/FlameGraphs/offcpuflamegraphs.html#Linux">非 CPU 火焰图<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9GbGFtZUdyYXBocy9tZW1vcnlmbGFtZWdyYXBocy5odG1sI0xpbnV4" title="https://www.brendangregg.com/FlameGraphs/memoryflamegraphs.html#Linux">内存火焰图<i class="fa fa-external-link"></i></span></p></li><li><p>Posts about eBPF, bcc, and bpftrace (2015-21):</p></li><li><p>关于 eBPF、bcc 和 bpftrace 的帖子 (2015-21)：</p><p>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTUtMDUtMTUvZWJwZi1vbmUtc21hbGwtc3RlcC5odG1s" title="https://www.brendangregg.com/blog/2015-05-15/ebpf-one-small-step.html">Linux eBPF<i class="fa fa-external-link"></i></span> (2015)<br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTUtMDktMjIvYmNjLWxpbnV4LTQuMy10cmFjaW5nLmh0bWw=" title="https://www.brendangregg.com/blog/2015-09-22/bcc-linux-4.3-tracing.html">bcc: Taming Linux 4.3+ Tracing Superpowers<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTUtMTAtMzEvdGNwY29ubmVjdC10Y3BhY2NlcHQtYmNjLmh0bWw=" title="https://www.brendangregg.com/blog/2015-10-31/tcpconnect-tcpaccept-bcc.html">tcpconnect and tcpaccept for Linux (bcc)<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTYtMDEtMTgvZWJwZi1zdGFjay10cmFjZS1oYWNrLmh0bWw=" title="https://www.brendangregg.com/blog/2016-01-18/ebpf-stack-trace-hack.html">Linux eBPF Stack Trace Hack (bcc)<i class="fa fa-external-link"></i></span> (2016)<br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTYtMDEtMjAvZWJwZi1vZmZjcHUtZmxhbWUtZ3JhcGguaHRtbA==" title="https://www.brendangregg.com/blog/2016-01-20/ebpf-offcpu-flame-graph.html">Linux eBPF Off-CPU Flame Graph (bcc)<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTYtMDItMDEvbGludXgtd2FrZXVwLW9mZndha2UtcHJvZmlsaW5nLmh0bWw=" title="https://www.brendangregg.com/blog/2016-02-01/linux-wakeup-offwake-profiling.html">Linux Wakeup and Off-Wake Profiling (bcc)<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTYtMDItMDUvZWJwZi1jaGFpbmdyYXBoLXByb3RvdHlwZS5odG1s" title="https://www.brendangregg.com/blog/2016-02-05/ebpf-chaingraph-prototype.html">Linux chain graph prototype (bcc)<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTYtMDItMDgvbGludXgtZWJwZi1iY2MtdXByb2Jlcy5odG1s" title="https://www.brendangregg.com/blog/2016-02-08/linux-ebpf-bcc-uprobes.html">Linux eBPF/bcc uprobes<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTYtMDMtMjgvbGludXgtYnBmLWJjYy1yb2FkLWFoZWFkLTIwMTYuaHRtbA==" title="https://www.brendangregg.com/blog/2016-03-28/linux-bpf-bcc-road-ahead-2016.html">Linux BPF/bcc Road Ahead<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTYtMDYtMTQvdWJ1bnR1LXhlbmlhbC1iY2MtYnBmLmh0bWw=" title="https://www.brendangregg.com/blog/2016-06-14/ubuntu-xenial-bcc-bpf.html">Ubuntu Xenial bcc/BPF<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTYtMTAtMDEvbGludXgtYmNjLXNlY3VyaXR5LWNhcGFiaWxpdGllcy5odG1s" title="https://www.brendangregg.com/blog/2016-10-01/linux-bcc-security-capabilities.html">Linux bcc/BPF Tracing Security Capabilities<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTYtMTAtMDQvbGludXgtYmNjLW15c3FsZC1xc2xvd2VyLmh0bWw=" title="https://www.brendangregg.com/blog/2016-10-04/linux-bcc-mysqld-qslower.html">Linux MySQL Slow Query Tracing with bcc/BPF<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTYtMTAtMDYvbGludXgtYmNjLWV4dDRkaXN0LWV4dDRzbG93ZXIuaHRtbA==" title="https://www.brendangregg.com/blog/2016-10-06/linux-bcc-ext4dist-ext4slower.html">Linux bcc/BPF ext4 Latency Tracing<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTYtMTAtMDgvbGludXgtYmNjLXJ1bnFsYXQuaHRtbA==" title="https://www.brendangregg.com/blog/2016-10-08/linux-bcc-runqlat.html">Linux bcc/BPF Run Queue (Scheduler) Latency<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTYtMTAtMTIvbGludXgtYmNjLW5vZGVqcy11c2R0Lmh0bWw=" title="https://www.brendangregg.com/blog/2016-10-12/linux-bcc-nodejs-usdt.html">Linux bcc/BPF Node.js USDT Tracing<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTYtMTAtMTUvbGludXgtYmNjLXRjcHRvcC5odG1s" title="https://www.brendangregg.com/blog/2016-10-15/linux-bcc-tcptop.html">Linux bcc tcptop<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTYtMTAtMjEvbGludXgtZWZmaWNpZW50LXByb2ZpbGVyLmh0bWw=" title="https://www.brendangregg.com/blog/2016-10-21/linux-efficient-profiler.html">Linux 4.9’s Efficient BPF-based Profiler<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTYtMTAtMjcvZHRyYWNlLWZvci1saW51eC0yMDE2Lmh0bWw=" title="https://www.brendangregg.com/blog/2016-10-27/dtrace-for-linux-2016.html">DTrace for Linux 2016<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cDovL3d3dy5zbGlkZXNoYXJlLm5ldC9icmVuZGFuZ3JlZ2cvbGludXgtNHgtdHJhY2luZy10b29scy11c2luZy1icGYtc3VwZXJwb3dlcnM=" title="http://www.slideshare.net/brendangregg/linux-4x-tracing-tools-using-bpf-superpowers">Linux 4.x Tracing Tools: Using BPF Superpowers<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTYtMTEtMzAvbGludXgtYmNjLXRjcGxpZmUuaHRtbA==" title="https://www.brendangregg.com/blog/2016-11-30/linux-bcc-tcplife.html">Linux bcc/BPF tcplife: TCP Lifespans<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTctMDEtMzEvZ29sYW5nLWJjYy1icGYtZnVuY3Rpb24tdHJhY2luZy5odG1s" title="https://www.brendangregg.com/blog/2017-01-31/golang-bcc-bpf-function-tracing.html">Golang bcc/BPF Function Tracing<i class="fa fa-external-link"></i></span> (2017)<br>  <span class="exturl" data-url="aHR0cHM6Ly9vcGVuc291cmNlLmNvbS9hcnRpY2xlLzE3LzExL2JjY2JwZi1wZXJmb3JtYW5jZQ==" title="https://opensource.com/article/17/11/bccbpf-performance">7 BPF tools for performance analysis on Fedora<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTgtMDMtMjIvdGNwLXRyYWNlcG9pbnRzLmh0bWw=" title="https://www.brendangregg.com/blog/2018-03-22/tcp-tracepoints.html">TCP Tracepoints<i class="fa fa-external-link"></i></span> (2018)<br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTgtMDUtMzEvbGludXgtdGNwZHJvcC5odG1s" title="https://www.brendangregg.com/blog/2018-05-31/linux-tcpdrop.html">Linux bcc/eBPF tcpdrop<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTgtMTAtMDgvZHRyYWNlLWZvci1saW51eC0yMDE4Lmh0bWw=" title="https://www.brendangregg.com/blog/2018-10-08/dtrace-for-linux-2018.html">bpftrace (DTrace 2.0) for Linux 2018<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTktMDEtMDEvbGVhcm4tZWJwZi10cmFjaW5nLmh0bWw=" title="https://www.brendangregg.com/blog/2019-01-01/learn-ebpf-tracing.html">Learn eBPF Tracing: Tutorial and Examples<i class="fa fa-external-link"></i></span> (2019)<br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTktMDgtMTkvYnBmdHJhY2UuaHRtbA==" title="https://www.brendangregg.com/blog/2019-08-19/bpftrace.html">A thorough introduction to bpftrace<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTktMTItMDIvYnBmLWEtbmV3LXR5cGUtb2Ytc29mdHdhcmUuaHRtbA==" title="https://www.brendangregg.com/blog/2019-12-02/bpf-a-new-type-of-software.html">BPF: A New Type of Software<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTktMTItMjIvYnBmLXRoZXJlbWluLmh0bWw=" title="https://www.brendangregg.com/blog/2019-12-22/bpf-theremin.html">BPF Theremin, Tetris, and Typewriters<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMjAtMTEtMDQvYnBmLWNvLXJlLWJ0Zi1saWJicGYuaHRtbA==" title="https://www.brendangregg.com/blog/2020-11-04/bpf-co-re-btf-libbpf.html">BPF binaries: BTF, CO-RE, and the future of BPF perf tools<i class="fa fa-external-link"></i></span> (2020)<br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMjEtMDYtMTUvYnBmLWludGVybmFscy5odG1s" title="https://www.brendangregg.com/blog/2021-06-15/bpf-internals.html">USENIX LISA2021 BPF Internals (eBPF)<i class="fa fa-external-link"></i></span> (2021)<br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMjEtMDctMDMvaG93LXRvLWFkZC1icGYtb2JzZXJ2YWJpbGl0eS5odG1s" title="https://www.brendangregg.com/blog/2021-07-03/how-to-add-bpf-observability.html">How To Add eBPF Observability To Your Product<i class="fa fa-external-link"></i></span>  </p></li><li><p>My <span class="exturl" data-url="aHR0cDovL2x3bi5uZXQv" title="http://lwn.net/">lwn.net<i class="fa fa-external-link"></i></span> article <span class="exturl" data-url="aHR0cDovL2x3bi5uZXQvQXJ0aWNsZXMvNjA4NDk3Lw==" title="http://lwn.net/Articles/608497/">Ftrace: The Hidden Light Switch<i class="fa fa-external-link"></i></span> shows a use case for Linux ftrace (Aug, 2014).</p></li><li><p>我的 <span class="exturl" data-url="aHR0cDovL2x3bi5uZXQv" title="http://lwn.net/">lwn.net<i class="fa fa-external-link"></i></span>文章 <span class="exturl" data-url="aHR0cDovL2x3bi5uZXQvQXJ0aWNsZXMvNjA4NDk3Lw==" title="http://lwn.net/Articles/608497/">Ftrace：隐藏的电灯开关<i class="fa fa-external-link"></i></span> 展示了 Linux ftrace 的使用案例（2014 年 8 月）。</p></li><li><p>Posts about ftrace-based perf-tools (2014-5):</p></li><li><p>关于基于 ftrace 的 perf 工具的帖子 (2014-5)：</p><p>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTQtMDctMTYvaW9zbm9vcC1mb3ItbGludXguaHRtbA==" title="https://www.brendangregg.com/blog/2014-07-16/iosnoop-for-linux.html">iosnoop for Linux<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTQtMDctMjMvbGludXgtaW9zbm9vcC1sYXRlbmN5LWhlYXQtbWFwcy5odG1s" title="https://www.brendangregg.com/blog/2014-07-23/linux-iosnoop-latency-heat-maps.html">iosnoop Latency Heat Maps<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTQtMDctMjUvb3BlbnNub29wLWZvci1saW51eC5odG1s" title="https://www.brendangregg.com/blog/2014-07-25/opensnoop-for-linux.html">opensnoop for Linux<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTQtMDctMjgvZXhlY3Nub29wLWZvci1saW51eC5odG1s" title="https://www.brendangregg.com/blog/2014-07-28/execsnoop-for-linux.html">execsnoop for Linux<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTQtMDgtMzAvZnRyYWNlLXRoZS1oaWRkZW4tbGlnaHQtc3dpdGNoLmh0bWw=" title="https://www.brendangregg.com/blog/2014-08-30/ftrace-the-hidden-light-switch.html">ftrace: The Hidden Light Switch<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTQtMDktMDYvbGludXgtZnRyYWNlLXRjcC1yZXRyYW5zbWl0LXRyYWNpbmcuaHRtbA==" title="https://www.brendangregg.com/blog/2014-09-06/linux-ftrace-tcp-retransmit-tracing.html">tcpretrans<i class="fa fa-external-link"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTQtMTItMzEvbGludXgtcGFnZS1jYWNoZS1oaXQtcmF0aW8uaHRtbA==" title="https://www.brendangregg.com/blog/2014-12-31/linux-page-cache-hit-ratio.html">Page Cache Hit Ratio<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTUtMDYtMjgvbGludXgtZnRyYWNlLXVwcm9iZS5odG1s" title="https://www.brendangregg.com/blog/2015-06-28/linux-ftrace-uprobe.html">uprobe: User-Level Dynamic Tracing<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTUtMDctMDMvaGFja2luZy1saW51eC11c2R0LWZ0cmFjZS5odG1s" title="https://www.brendangregg.com/blog/2015-07-03/hacking-linux-usdt-ftrace.html">Hacking Linux USDT<i class="fa fa-external-link"></i></span></p></li></ul><ul><li>Posts about perf-based perf-tools: <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTQtMDctMTAvcGVyZi1oYWNrdG9ncmFtLmh0bWw=" title="https://www.brendangregg.com/blog/2014-07-10/perf-hacktogram.html">perf Hacktogram<i class="fa fa-external-link"></i></span>.</li></ul><p>关于基于 perf 的 perf 工具的帖子</p><ul><li>Posts about perf_events (2014-7):<br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTQtMDYtMjIvcGVyZi1jcHUtc2FtcGxlLmh0bWw=" title="https://www.brendangregg.com/blog/2014-06-22/perf-cpu-sample.html">perf CPU Sampling<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTQtMDYtMjkvcGVyZi1zdGF0aWMtdHJhY2Vwb2ludHMuaHRtbA==" title="https://www.brendangregg.com/blog/2014-06-29/perf-static-tracepoints.html">perf Static Tracepoints<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTQtMDctMDEvcGVyZi1oZWF0LW1hcHMuaHRtbA==" title="https://www.brendangregg.com/blog/2014-07-01/perf-heat-maps.html">perf Heat Maps<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTQtMDctMDMvcGVyZi1jb3VudGluZy5odG1s" title="https://www.brendangregg.com/blog/2014-07-03/perf-counting.html">perf Counting<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTQtMDktMTEvcGVyZi1rZXJuZWwtbGluZS10cmFjaW5nLmh0bWw=" title="https://www.brendangregg.com/blog/2014-09-11/perf-kernel-line-tracing.html">perf Kernel Line Tracing<i class="fa fa-external-link"></i></span>,<br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTUtMDItMjYvbGludXgtcGVyZi1vZmYtY3B1LWZsYW1lLWdyYXBoLmh0bWw=" title="https://www.brendangregg.com/blog/2015-02-26/linux-perf-off-cpu-flame-graph.html">perf Off-CPU Time Flame Graphs<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTUtMDItMjcvbGludXgtcHJvZmlsaW5nLWF0LW5ldGZsaXguaHRtbA==" title="https://www.brendangregg.com/blog/2015-02-27/linux-profiling-at-netflix.html">Linux Profiling at Netflix<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cDovL3RlY2hibG9nLm5ldGZsaXguY29tLzIwMTUvMDcvamF2YS1pbi1mbGFtZXMuaHRtbA==" title="http://techblog.netflix.com/2015/07/java-in-flames.html">Java Mixed-Mode Flame Graphs<i class="fa fa-external-link"></i></span> (<span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9BcnRpY2xlcy9OZXRmbGl4X0phdmFfaW5fRmxhbWVzLnBkZg==" title="https://www.brendangregg.com/Articles/Netflix_Java_in_Flames.pdf">PDF<i class="fa fa-external-link"></i></span>), <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTYtMDQtMzAvbGludXgtcGVyZi1mb2xkZWQuaHRtbA==" title="https://www.brendangregg.com/blog/2016-04-30/linux-perf-folded.html">Linux 4.5 perf folded format<i class="fa fa-external-link"></i></span>,<br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTctMDMtMTYvcGVyZi1zY2hlZC5odG1s" title="https://www.brendangregg.com/blog/2017-03-16/perf-sched.html">perf sched for Linux CPU scheduler analysis<i class="fa fa-external-link"></i></span></li></ul><ul><li><p>A page on <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS93c3MuaHRtbA==" title="https://www.brendangregg.com/wss.html">Working Set Size Estimation<i class="fa fa-external-link"></i></span> for Linux (2018+).</p></li><li><p>A post on <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTgtMDItMDkva3B0aS1rYWlzZXItbWVsdGRvd24tcGVyZm9ybWFuY2UuaHRtbA==" title="https://www.brendangregg.com/blog/2018-02-09/kpti-kaiser-meltdown-performance.html">KPTI/KAISER Meltdown Initial Performance Regressions<i class="fa fa-external-link"></i></span> (2018).</p></li><li><p>In <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTctMDUtMDQvdGhlLXBtY3Mtb2YtZWMyLmh0bWw=" title="https://www.brendangregg.com/blog/2017-05-04/the-pmcs-of-ec2.html">The PMCs of EC2: Measuring IPC<i class="fa fa-external-link"></i></span> I showed the new Performance Monitoring Counter (PMC) support in the AWS EC2 cloud (2017).</p><p>我展示了 AWS EC2 云中新的性能监控计数器（PMC）支持（2017 年）。</p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTctMDUtMDkvY3B1LXV0aWxpemF0aW9uLWlzLXdyb25nLmh0bWw=" title="https://www.brendangregg.com/blog/2017-05-09/cpu-utilization-is-wrong.html">CPU Utilization is Wrong<i class="fa fa-external-link"></i></span>: a post explaining the growing problem of memory stall cycles dominating the %CPU metric (2017).</p></li></ul><p>解释了内存停滞周期主导 %CPU 指标这一日益严重的问题（2017 年）。</p><ul><li>A post about <span class="exturl" data-url="aHR0cDovL3d3dy5icmVuZGFuZ3JlZ2cuY29tL2Jsb2cvMjAxNi0wNi0wOC9saW51eC1oaXN0LXRyaWdnZXJzLmh0bWw=" title="http://www.brendangregg.com/blog/2016-06-08/linux-hist-triggers.html">Linux 4.7 Hist Triggers<i class="fa fa-external-link"></i></span> (2016).</li><li>The blog post <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTQtMDUtMTEvc3RyYWNlLXdvdy1tdWNoLXN5c2NhbGwuaHRtbA==" title="https://www.brendangregg.com/blog/2014-05-11/strace-wow-much-syscall.html">strace Wow Much Syscall<i class="fa fa-external-link"></i></span> discusses strace(1) for production use, and compares it to advanced tracing tools (2014).</li></ul><p>讨论了用于生产的 strace(1)，并将其与高级跟踪工具进行了比较（2014 年）。</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9VU0VtZXRob2QvdXNlLWxpbnV4Lmh0bWw=" title="https://www.brendangregg.com/USEmethod/use-linux.html">USE Method: Linux Performance Checklist<i class="fa fa-external-link"></i></span>; also see the <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS91c2VtZXRob2QuaHRtbA==" title="https://www.brendangregg.com/usemethod.html">USE Method<i class="fa fa-external-link"></i></span> page for the description of this methodology.</li></ul><p>另请参阅 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS91c2VtZXRob2QuaHRtbA==" title="https://www.brendangregg.com/usemethod.html">USE Method<i class="fa fa-external-link"></i></span> 页面，了解该方法的说明。</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9vZmZjcHVhbmFseXNpcy5odG1s" title="https://www.brendangregg.com/offcpuanalysis.html">Off-CPU Analysis Method<i class="fa fa-external-link"></i></span>, where I demonstrate this methodology on Linux.</li></ul><p>我在 Linux 上演示了这种方法。</p><h1 id="Talks"><a href="#Talks" class="headerlink" title="Talks"></a>Talks</h1><p>In rough order of recommended viewing or difficulty, intro to more advanced:</p><p>按推荐观看或难度从入门到高级的大致顺序排列：</p><h2 id="1-Linux-Systems-Performance-USENIX-LISA-2019"><a href="#1-Linux-Systems-Performance-USENIX-LISA-2019" class="headerlink" title="1. Linux Systems Performance (USENIX LISA 2019)"></a>1. Linux Systems Performance (USENIX LISA 2019)</h2><p>This is my summary of Linux systems performance in 40 minutes, covering six facets: observability, methodologies, benchmarking, profiling, tracing, and tuning. It’s intended for everyone as a tour of fundamentals, and some companies have indicated they will use it for new hire training.</p><p>这是我在 40 分钟内对 Linux 系统性能的总结，涵盖六个方面：可观察性、方法、基准测试、剖析、跟踪和调整。它面向所有人，是基础知识的巡礼，一些公司表示将把它用于新员工培训。</p><p>A video of the talk is on <span class="exturl" data-url="aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9jb25mZXJlbmNlL2xpc2ExOS9wcmVzZW50YXRpb24vZ3JlZ2ctbGludXg=" title="https://www.usenix.org/conference/lisa19/presentation/gregg-linux">usenix.org<i class="fa fa-external-link"></i></span> and <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1maEJIdnNpMFFsMCZmZWF0dXJlPWVtYl9sb2dv" title="https://www.youtube.com/watch?v=fhBHvsi0Ql0&feature=emb_logo">youtube<i class="fa fa-external-link"></i></span>, and the slides are on <span class="exturl" data-url="aHR0cHM6Ly93d3cuc2xpZGVzaGFyZS5uZXQvYnJlbmRhbmdyZWdnL2xpc2EyMDE5LWxpbnV4LXN5c3RlbXMtcGVyZm9ybWFuY2U=" title="https://www.slideshare.net/brendangregg/lisa2019-linux-systems-performance">slideshare<i class="fa fa-external-link"></i></span> or as a <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9TbGlkZXMvTElTQTIwMTlfTGludXhfU3lzdGVtc19QZXJmb3JtYW5jZS5wZGY=" title="https://www.brendangregg.com/Slides/LISA2019_Linux_Systems_Performance.pdf">PDF<i class="fa fa-external-link"></i></span><br>讲座视频可在 <span class="exturl" data-url="aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9jb25mZXJlbmNlL2xpc2ExOS9wcmVzZW50YXRpb24vZ3JlZ2ctbGludXg=" title="https://www.usenix.org/conference/lisa19/presentation/gregg-linux">usenix.org<i class="fa fa-external-link"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1maEJIdnNpMFFsMCZmZWF0dXJlPWVtYl9sb2dv" title="https://www.youtube.com/watch?v=fhBHvsi0Ql0&feature=emb_logo">youtube<i class="fa fa-external-link"></i></span> 上观看，幻灯片可在 <span class="exturl" data-url="aHR0cHM6Ly93d3cuc2xpZGVzaGFyZS5uZXQvYnJlbmRhbmdyZWdnL2xpc2EyMDE5LWxpbnV4LXN5c3RlbXMtcGVyZm9ybWFuY2U=" title="https://www.slideshare.net/brendangregg/lisa2019-linux-systems-performance">slideshare<i class="fa fa-external-link"></i></span> 或 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9TbGlkZXMvTElTQTIwMTlfTGludXhfU3lzdGVtc19QZXJmb3JtYW5jZS5wZGY=" title="https://www.brendangregg.com/Slides/LISA2019_Linux_Systems_Performance.pdf">PDF<i class="fa fa-external-link"></i></span> 上观看。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230803144043.png" alt="image.png"></p><p>For a lot more information on observability tools, profiling, and tracing, see the talks that follow.</p><p>有关可观察性工具、剖析和跟踪的更多信息，请参阅后面的讲座。</p><h2 id="2-Linux-Performance-2018-PerconaLive-2018"><a href="#2-Linux-Performance-2018-PerconaLive-2018" class="headerlink" title="2. Linux Performance 2018 (PerconaLive 2018)"></a>2. Linux Performance 2018 (PerconaLive 2018)</h2><p>This was a 20 minute keynote summary of recent changes and features in Linux performance in 2018.</p><p>这是一个 20 分钟的主题演讲，总结了 2018 年 Linux 性能方面的最新变化和功能。</p><p>A video of the talk is on <span class="exturl" data-url="aHR0cHM6Ly95b3V0dS5iZS9zVjNYZnJmanJQbz90PTMwbTUxcw==" title="https://youtu.be/sV3XfrfjrPo?t=30m51s">youtube<i class="fa fa-external-link"></i></span>, and the slides are on <span class="exturl" data-url="aHR0cHM6Ly93d3cuc2xpZGVzaGFyZS5uZXQvYnJlbmRhbmdyZWdnL2xpbnV4LXBlcmZvcm1hbmNlLTIwMTgtcGVyY29uYWxpdmUta2V5bm90ZS05NTUxNjkzNA==" title="https://www.slideshare.net/brendangregg/linux-performance-2018-perconalive-keynote-95516934">slideshare<i class="fa fa-external-link"></i></span> or as a <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9TbGlkZXMvUGVyY29uYTIwMThfTGludXhfUGVyZm9ybWFuY2UucGRm" title="https://www.brendangregg.com/Slides/Percona2018_Linux_Performance.pdf">PDF.<i class="fa fa-external-link"></i></span></p><p>讲座视频可在 <span class="exturl" data-url="aHR0cHM6Ly95b3V0dS5iZS9zVjNYZnJmanJQbz90PTMwbTUxcw==" title="https://youtu.be/sV3XfrfjrPo?t=30m51s">youtube<i class="fa fa-external-link"></i></span> 上观看，幻灯片可在 <span class="exturl" data-url="aHR0cHM6Ly93d3cuc2xpZGVzaGFyZS5uZXQvYnJlbmRhbmdyZWdnL2xpbnV4LXBlcmZvcm1hbmNlLTIwMTgtcGVyY29uYWxpdmUta2V5bm90ZS05NTUxNjkzNA==" title="https://www.slideshare.net/brendangregg/linux-performance-2018-perconalive-keynote-95516934">slideshare<i class="fa fa-external-link"></i></span> 上观看，也可下载 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9TbGlkZXMvUGVyY29uYTIwMThfTGludXhfUGVyZm9ybWFuY2UucGRm" title="https://www.brendangregg.com/Slides/Percona2018_Linux_Performance.pdf">PDF.<i class="fa fa-external-link"></i></span></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230803144100.png" alt="image.png"></p><h2 id="3-Linux-Performance-Tools-Velocity-2015"><a href="#3-Linux-Performance-Tools-Velocity-2015" class="headerlink" title="3. Linux Performance Tools (Velocity 2015)"></a>3. Linux Performance Tools (Velocity 2015)</h2><p>At Velocity 2015, I gave a 90 minute tutorial on Linux performance tools, summarizing performance observability, benchmarking, tuning, static performance tuning, and tracing tools. I also covered performance methodology, and included some live demos. This should be useful for everyone working on Linux systems. If you just saw my PerconaLive2016 talk, then some content should be familiar, but with many extras: I focus a lot more on the tools in this talk.</p><p>在Velocity 2015大会上，我做了90分钟的Linux性能工具教程，总结了性能可观测性、基准测试、调优、静态性能调优和跟踪工具。我还介绍了性能方法论，并包括一些现场演示。这对每个在 Linux 系统上工作的人都很有用。如果您刚刚看过我的 PerconaLive2016 演讲，那么有些内容应该不会陌生，但还有很多额外的内容： 在本讲座中，我更关注工具。</p><p>A video of the talk is on youtube (<span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1GSlc4bkdWNGp4WSZsaXN0PVBMaGhkSU1WaTBvNVJOcmY4RTJkVWlqdkdwcUtMQjlUQ1I=" title="https://www.youtube.com/watch?v=FJW8nGV4jxY&list=PLhhdIMVi0o5RNrf8E2dUijvGpqKLB9TCR">playlist<i class="fa fa-external-link"></i></span>; <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1GSlc4bkdWNGp4WQ==" title="https://www.youtube.com/watch?v=FJW8nGV4jxY">part 1<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj16cnIyblVsbjlLaw==" title="https://www.youtube.com/watch?v=zrr2nUln9Kk">part 2<i class="fa fa-external-link"></i></span>) and the slides are on <span class="exturl" data-url="aHR0cDovL3d3dy5zbGlkZXNoYXJlLm5ldC9icmVuZGFuZ3JlZ2cvdmVsb2NpdHktMjAxNS1saW51eC1wZXJmLXRvb2xz" title="http://www.slideshare.net/brendangregg/velocity-2015-linux-perf-tools">slideshare<i class="fa fa-external-link"></i></span> or as a <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9TbGlkZXMvVmVsb2NpdHkyMDE1X0xpbnV4UGVyZlRvb2xzLnBkZg==" title="https://www.brendangregg.com/Slides/Velocity2015_LinuxPerfTools.pdf">PDF<i class="fa fa-external-link"></i></span>.</p><p>讲座视频可在 youtube 上观看（<span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1GSlc4bkdWNGp4WSZsaXN0PVBMaGhkSU1WaTBvNVJOcmY4RTJkVWlqdkdwcUtMQjlUQ1I=" title="https://www.youtube.com/watch?v=FJW8nGV4jxY&list=PLhhdIMVi0o5RNrf8E2dUijvGpqKLB9TCR">播放列表<i class="fa fa-external-link"></i></span>；<span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1GSlc4bkdWNGp4WQ==" title="https://www.youtube.com/watch?v=FJW8nGV4jxY">第一部分<i class="fa fa-external-link"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj16cnIyblVsbjlLaw==" title="https://www.youtube.com/watch?v=zrr2nUln9Kk">第二部分<i class="fa fa-external-link"></i></span>），幻灯片可在 <span class="exturl" data-url="aHR0cDovL3d3dy5zbGlkZXNoYXJlLm5ldC9icmVuZGFuZ3JlZ2cvdmVsb2NpdHktMjAxNS1saW51eC1wZXJmLXRvb2xz" title="http://www.slideshare.net/brendangregg/velocity-2015-linux-perf-tools">slideshare<i class="fa fa-external-link"></i></span> 或 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9TbGlkZXMvVmVsb2NpdHkyMDE1X0xpbnV4UGVyZlRvb2xzLnBkZg==" title="https://www.brendangregg.com/Slides/Velocity2015_LinuxPerfTools.pdf">PDF<i class="fa fa-external-link"></i></span> 上观看。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230803144135.png" alt="image.png"></p><blockquote><p>幻灯片失效了，视频貌似还有用</p></blockquote><p>This was similar to my <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj0weXlvcmhsNklqTQ==" title="https://www.youtube.com/watch?v=0yyorhl6IjM">SCaLE11x<i class="fa fa-external-link"></i></span> and <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTQtMDgtMjMvbGludXgtcGVyZi10b29scy1saW51eGNvbi1uYS0yMDE0Lmh0bWw=" title="https://www.brendangregg.com/blog/2014-08-23/linux-perf-tools-linuxcon-na-2014.html">LinuxCon<i class="fa fa-external-link"></i></span> talks, however, with 90 minutes I was able to cover more tools and methodologies, making it the most complete tour of the topic I’ve done. I also posted about it on the <span class="exturl" data-url="aHR0cDovL3RlY2hibG9nLm5ldGZsaXguY29tLzIwMTUvMDgvbmV0ZmxpeC1hdC12ZWxvY2l0eS0yMDE1LWxpbnV4Lmh0bWw=" title="http://techblog.netflix.com/2015/08/netflix-at-velocity-2015-linux.html">Netflix Tech Blog<i class="fa fa-external-link"></i></span>.</p><p>这与我的<span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj0weXlvcmhsNklqTQ==" title="https://www.youtube.com/watch?v=0yyorhl6IjM">SCaLE11x<i class="fa fa-external-link"></i></span> 和<span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTQtMDgtMjMvbGludXgtcGVyZi10b29scy1saW51eGNvbi1uYS0yMDE0Lmh0bWw=" title="https://www.brendangregg.com/blog/2014-08-23/linux-perf-tools-linuxcon-na-2014.html">LinuxCon<i class="fa fa-external-link"></i></span> 演讲类似，不过，在 90 分钟的时间里，我可以介绍更多的工具和方法，这是我做过的最完整的一次演讲。我还在 <span class="exturl" data-url="aHR0cDovL3RlY2hibG9nLm5ldGZsaXguY29tLzIwMTUvMDgvbmV0ZmxpeC1hdC12ZWxvY2l0eS0yMDE1LWxpbnV4Lmh0bWw=" title="http://techblog.netflix.com/2015/08/netflix-at-velocity-2015-linux.html">Netflix 技术博客<i class="fa fa-external-link"></i></span> 上发布了相关内容。</p><h2 id="4-How-Netflix-Tunes-EC2-Instances-for-Performance-AWS-re-Invent-2017"><a href="#4-How-Netflix-Tunes-EC2-Instances-for-Performance-AWS-re-Invent-2017" class="headerlink" title="4. How Netflix Tunes EC2 Instances for Performance (AWS re:Invent, 2017)"></a>4. How Netflix Tunes EC2 Instances for Performance (AWS re:Invent, 2017)</h2><p>Instead of performance observability, this talk is about tuning. I begin by providing Netflix background, covering instance types and features in the AWS EC2 cloud, and then talk about Linux kernel tunables and observability.</p><p>本讲座的主题不是性能可观测性，而是调优。首先，我将介绍 Netflix 的背景，涵盖 AWS EC2 云的实例类型和功能，然后谈谈 Linux 内核可调性和可观测性。</p><p>A video of the talk is on <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj04OWZZT28xVjJwQQ==" title="https://www.youtube.com/watch?v=89fYOo1V2pA">youtube<i class="fa fa-external-link"></i></span> and the slides are on <span class="exturl" data-url="aHR0cHM6Ly93d3cuc2xpZGVzaGFyZS5uZXQvYnJlbmRhbmdyZWdnL2hvdy1uZXRmbGl4LXR1bmVzLWVjMi1pbnN0YW5jZXMtZm9yLXBlcmZvcm1hbmNl" title="https://www.slideshare.net/brendangregg/how-netflix-tunes-ec2-instances-for-performance">slideshare<i class="fa fa-external-link"></i></span>:</p><p>讲座视频在 <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj04OWZZT28xVjJwQQ==" title="https://www.youtube.com/watch?v=89fYOo1V2pA">youtube<i class="fa fa-external-link"></i></span> 上，幻灯片在 <span class="exturl" data-url="aHR0cHM6Ly93d3cuc2xpZGVzaGFyZS5uZXQvYnJlbmRhbmdyZWdnL2hvdy1uZXRmbGl4LXR1bmVzLWVjMi1pbnN0YW5jZXMtZm9yLXBlcmZvcm1hbmNl" title="https://www.slideshare.net/brendangregg/how-netflix-tunes-ec2-instances-for-performance">slideshare<i class="fa fa-external-link"></i></span> 上：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230803144210.png" alt="image.png"></p><h2 id="5-Container-Performance-Analysis-DockerCon-2017"><a href="#5-Container-Performance-Analysis-DockerCon-2017" class="headerlink" title="5. Container Performance Analysis (DockerCon, 2017)"></a>5. Container Performance Analysis (DockerCon, 2017)</h2><p>At DockerCon 2017 in Austin, I gave a talk on Linux container performance analysis, showing how to find bottlenecks in the host vs the container, how to profiler container apps, and dig deeper into the kernel.</p><p>在奥斯汀举行的 DockerCon 2017 上，我发表了关于 Linux 容器性能分析的演讲，展示了如何找到主机与容器的瓶颈，如何对容器应用程序进行剖析，以及如何深入挖掘内核。</p><p>A video of the talk is on <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1iSzlBNU9ESWdhYw==" title="https://www.youtube.com/watch?v=bK9A5ODIgac">youtube<i class="fa fa-external-link"></i></span> and the slides are on <span class="exturl" data-url="aHR0cHM6Ly93d3cuc2xpZGVzaGFyZS5uZXQvYnJlbmRhbmdyZWdnL2NvbnRhaW5lci1wZXJmb3JtYW5jZS1hbmFseXNpcw==" title="https://www.slideshare.net/brendangregg/container-performance-analysis">slideshare<i class="fa fa-external-link"></i></span>.</p><p>讲座视频在 <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1iSzlBNU9ESWdhYw==" title="https://www.youtube.com/watch?v=bK9A5ODIgac">youtube<i class="fa fa-external-link"></i></span> 上，幻灯片在 <span class="exturl" data-url="aHR0cHM6Ly93d3cuc2xpZGVzaGFyZS5uZXQvYnJlbmRhbmdyZWdnL2NvbnRhaW5lci1wZXJmb3JtYW5jZS1hbmFseXNpcw==" title="https://www.slideshare.net/brendangregg/container-performance-analysis">slideshare<i class="fa fa-external-link"></i></span> 上。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230803144229.png" alt="image.png"></p><h2 id="6-Broken-Linux-Performance-Tools-SCaLE14x-2016"><a href="#6-Broken-Linux-Performance-Tools-SCaLE14x-2016" class="headerlink" title="6. Broken Linux Performance Tools (SCaLE14x, 2016)"></a>6. Broken Linux Performance Tools (SCaLE14x, 2016)</h2><p>At the Southern California Linux Expo (<span class="exturl" data-url="aHR0cDovL3d3dy5zb2NhbGxpbnV4ZXhwby5vcmcvc2NhbGUvMTR4" title="http://www.socallinuxexpo.org/scale/14x">SCaLE 14x<i class="fa fa-external-link"></i></span>), I gave a talk on Broken Linux Performance Tools. This was a follow-on to my earlier Linux Performance Tools talk originally at SCaLE11x (and more recently at <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9saW51eHBlcmYuaHRtbCNWZWxvY2l0eTIwMTU=" title="https://www.brendangregg.com/linuxperf.html#Velocity2015">Velocity<i class="fa fa-external-link"></i></span> as a tutorial). This broken tools talk was a tour of common problems with Linux system tools, metrics, statistics, visualizations, measurement overhead, and benchmarks. It also includes advice on how to cope (the green “What You Can Do” slides).</p><p>在南加州Linux博览会（<span class="exturl" data-url="aHR0cDovL3d3dy5zb2NhbGxpbnV4ZXhwby5vcmcvc2NhbGUvMTR4" title="http://www.socallinuxexpo.org/scale/14x">SCaLE 14x<i class="fa fa-external-link"></i></span>）上，我做了一个关于破碎的Linux性能工具的演讲。这是我之前在SCaLE11x上发表的Linux性能工具演讲（最近在<span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9saW51eHBlcmYuaHRtbCNWZWxvY2l0eTIwMTU=" title="https://www.brendangregg.com/linuxperf.html#Velocity2015">Velocity<i class="fa fa-external-link"></i></span>上作为教程发表）的后续演讲。这篇 “破损的工具 “演讲讲述了 Linux 系统工具、度量、统计、可视化、测量开销和基准的常见问题。其中还包括应对建议（绿色的 “你能做什么 “幻灯片）。</p><p>A video of the talk is on <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1PUGlvOFYtejAzYw==" title="https://www.youtube.com/watch?v=OPio8V-z03c">youtube<i class="fa fa-external-link"></i></span> and the slides are on <span class="exturl" data-url="aHR0cDovL3d3dy5zbGlkZXNoYXJlLm5ldC9icmVuZGFuZ3JlZ2cvYnJva2VuLWxpbnV4LXBlcmZvcm1hbmNlLXRvb2xzLTIwMTY=" title="http://www.slideshare.net/brendangregg/broken-linux-performance-tools-2016">slideshare<i class="fa fa-external-link"></i></span> or as a <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9TbGlkZXMvU0NBTEUyMDE2X0Jyb2tlbl9MaW51eF9QZXJmb3JtYW5jZV9Ub29scy5wZGY=" title="https://www.brendangregg.com/Slides/SCALE2016_Broken_Linux_Performance_Tools.pdf">PDF<i class="fa fa-external-link"></i></span>.</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230803144249.png" alt="image.png"></p><h2 id="7-Using-Linux-perf-at-Netflix-Kernel-Recipes-2017"><a href="#7-Using-Linux-perf-at-Netflix-Kernel-Recipes-2017" class="headerlink" title="7. Using Linux perf at Netflix (Kernel Recipes, 2017)"></a>7. Using Linux perf at Netflix (Kernel Recipes, 2017)</h2><p>At <span class="exturl" data-url="aHR0cHM6Ly9rZXJuZWwtcmVjaXBlcy5vcmcvZW4vMjAxNy90YWxrcy9wZXJmLWluLW5ldGZsaXgv" title="https://kernel-recipes.org/en/2017/talks/perf-in-netflix/">Kernel Recipes 2017<i class="fa fa-external-link"></i></span> I gave an updated talk on Linux perf at Netflix, focusing on getting CPU profiling and flame graphs to work. This talk includes a crash course on perf_events, plus gotchas such as fixing stack traces and symbols when profiling Java, Node.js, VMs, and containers.</p><p>在 <span class="exturl" data-url="aHR0cHM6Ly9rZXJuZWwtcmVjaXBlcy5vcmcvZW4vMjAxNy90YWxrcy9wZXJmLWluLW5ldGZsaXgv" title="https://kernel-recipes.org/en/2017/talks/perf-in-netflix/">Kernel Recipes 2017<i class="fa fa-external-link"></i></span> 上，我发表了关于 Netflix Linux perf 的最新演讲，重点是如何让 CPU 剖析和火焰图发挥作用。本讲座包括 perf_events 的速成课程，以及在剖析 Java、Node.js、虚拟机和容器时修复堆栈跟踪和符号等疑难问题。</p><p>A video of the talk is on <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1VVk0zV1g4THEyaw==" title="https://www.youtube.com/watch?v=UVM3WX8Lq2k">youtube<i class="fa fa-external-link"></i></span> and the slides are on <span class="exturl" data-url="aHR0cHM6Ly93d3cuc2xpZGVzaGFyZS5uZXQvYnJlbmRhbmdyZWdnL2tlcm5lbC1yZWNpcGVzLTIwMTctdXNpbmctbGludXgtcGVyZi1hdC1uZXRmbGl4" title="https://www.slideshare.net/brendangregg/kernel-recipes-2017-using-linux-perf-at-netflix">slideshare<i class="fa fa-external-link"></i></span>:</p><p>讲座视频在 <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1VVk0zV1g4THEyaw==" title="https://www.youtube.com/watch?v=UVM3WX8Lq2k">youtube<i class="fa fa-external-link"></i></span> 上，幻灯片在 <span class="exturl" data-url="aHR0cHM6Ly93d3cuc2xpZGVzaGFyZS5uZXQvYnJlbmRhbmdyZWdnL2tlcm5lbC1yZWNpcGVzLTIwMTctdXNpbmctbGludXgtcGVyZi1hdC1uZXRmbGl4" title="https://www.slideshare.net/brendangregg/kernel-recipes-2017-using-linux-perf-at-netflix">slideshare<i class="fa fa-external-link"></i></span> 上：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230803144318.png" alt="image.png"></p><p>There’s also an older version of this talk from 2015, which I’ve <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTUtMDItMjcvbGludXgtcHJvZmlsaW5nLWF0LW5ldGZsaXguaHRtbA==" title="https://www.brendangregg.com/blog/2015-02-27/linux-profiling-at-netflix.html">posted<i class="fa fa-external-link"></i></span> about. To learn more about flame graphs, see my <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9mbGFtZWdyYXBocy5odG1sI1ByZXNlbnRhdGlvbg==" title="https://www.brendangregg.com/flamegraphs.html#Presentation">flame graphs presentation<i class="fa fa-external-link"></i></span>.</p><p>这个讲座还有一个 2015 年的旧版本，我已经<span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTUtMDItMjcvbGludXgtcHJvZmlsaW5nLWF0LW5ldGZsaXguaHRtbA==" title="https://www.brendangregg.com/blog/2015-02-27/linux-profiling-at-netflix.html">发布<i class="fa fa-external-link"></i></span>了。要了解有关火焰图的更多信息，请参阅我的 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9mbGFtZWdyYXBocy5odG1sI1ByZXNlbnRhdGlvbg==" title="https://www.brendangregg.com/flamegraphs.html#Presentation">火焰图演示<i class="fa fa-external-link"></i></span>。</p><h2 id="8-Give-me-15-minutes-and-I’ll-change-your-view-of-Linux-tracing-LISA-2016"><a href="#8-Give-me-15-minutes-and-I’ll-change-your-view-of-Linux-tracing-LISA-2016" class="headerlink" title="8. Give me 15 minutes and I’ll change your view of Linux tracing (LISA, 2016)"></a>8. Give me 15 minutes and I’ll change your view of Linux tracing (LISA, 2016)</h2><p>I gave this demo at USENIX/LISA 2016, showing ftrace, perf, and bcc/BPF. A video is on <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1Hc01zM244Q0I2Zw==" title="https://www.youtube.com/watch?v=GsMs3n8CB6g">youtube<i class="fa fa-external-link"></i></span> (sorry, the sound effects are a bit too loud):.</p><p>我在 USENIX/LISA 2016 上做了这个演示，展示了 ftrace、perf 和 bcc/BPF。视频在 <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1Hc01zM244Q0I2Zw==" title="https://www.youtube.com/watch?v=GsMs3n8CB6g">youtube<i class="fa fa-external-link"></i></span>（抱歉，音效有点大）：。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230803144334.png" alt="image.png"></p><p>This was the first part of a longer talk on Linux 4.x Tracing Tools: Using BPF Superpowers. See the full <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1VbU9VM0kzNlQyVQ==" title="https://www.youtube.com/watch?v=UmOU3I36T2U">talk video<i class="fa fa-external-link"></i></span> and <span class="exturl" data-url="aHR0cDovL3d3dy5zbGlkZXNoYXJlLm5ldC9icmVuZGFuZ3JlZ2cvbGludXgtNHgtdHJhY2luZy10b29scy11c2luZy1icGYtc3VwZXJwb3dlcnM=" title="http://www.slideshare.net/brendangregg/linux-4x-tracing-tools-using-bpf-superpowers">talk slides<i class="fa fa-external-link"></i></span>.</p><p>这是关于 Linux 4.x 跟踪工具的长篇演讲的第一部分： 使用 BPF 超强功能。请参阅完整的 <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1VbU9VM0kzNlQyVQ==" title="https://www.youtube.com/watch?v=UmOU3I36T2U">讲座视频<i class="fa fa-external-link"></i></span> 和 <span class="exturl" data-url="aHR0cDovL3d3dy5zbGlkZXNoYXJlLm5ldC9icmVuZGFuZ3JlZ2cvbGludXgtNHgtdHJhY2luZy10b29scy11c2luZy1icGYtc3VwZXJwb3dlcnM=" title="http://www.slideshare.net/brendangregg/linux-4x-tracing-tools-using-bpf-superpowers">讲座幻灯片<i class="fa fa-external-link"></i></span>。</p><h2 id="9-Performance-analysis-superpowers-with-Linux-eBPF-O’Reilly-Velocity-2017"><a href="#9-Performance-analysis-superpowers-with-Linux-eBPF-O’Reilly-Velocity-2017" class="headerlink" title="9. Performance analysis superpowers with Linux eBPF (O’Reilly Velocity, 2017)"></a>9. Performance analysis superpowers with Linux eBPF (O’Reilly Velocity, 2017)</h2><p>This talk covers using enhanced BPF (aka eBPF) features added to the Linux 4.x series for performance analysis, observability, and debugging. The front-end used in this talk is bcc (BPF compiler collection), an open source project that provides BPF interfaces and a collection of tools.</p><p>本讲座将介绍如何使用 Linux 4.x 系列新增的增强型 BPF（又称 eBPF）功能进行性能分析、可观察性和调试。本讲座中使用的前端是 bcc（BPF 编译器集合），它是一个提供 BPF 接口和工具集合的开源项目。</p><p>A video of the talk is on <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1iajNxZEVEYkNENA==" title="https://www.youtube.com/watch?v=bj3qdEDbCD4">youtube<i class="fa fa-external-link"></i></span>, and the slides are on <span class="exturl" data-url="aHR0cHM6Ly93d3cuc2xpZGVzaGFyZS5uZXQvYnJlbmRhbmdyZWdnL3ZlbG9jaXR5LTIwMTctcGVyZm9ybWFuY2UtYW5hbHlzaXMtc3VwZXJwb3dlcnMtd2l0aC1saW51eC1lYnBm" title="https://www.slideshare.net/brendangregg/velocity-2017-performance-analysis-superpowers-with-linux-ebpf">slideshare<i class="fa fa-external-link"></i></span> or as a <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9TbGlkZXMvVmVsb2NpdHkyMDE3X0JQRl9zdXBlcnBvd2Vycy5wZGY=" title="https://www.brendangregg.com/Slides/Velocity2017_BPF_superpowers.pdf">PDF<i class="fa fa-external-link"></i></span>.</p><p>讲座视频在 <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1iajNxZEVEYkNENA==" title="https://www.youtube.com/watch?v=bj3qdEDbCD4">youtube<i class="fa fa-external-link"></i></span> 上，幻灯片在 <span class="exturl" data-url="aHR0cHM6Ly93d3cuc2xpZGVzaGFyZS5uZXQvYnJlbmRhbmdyZWdnL3ZlbG9jaXR5LTIwMTctcGVyZm9ybWFuY2UtYW5hbHlzaXMtc3VwZXJwb3dlcnMtd2l0aC1saW51eC1lYnBm" title="https://www.slideshare.net/brendangregg/velocity-2017-performance-analysis-superpowers-with-linux-ebpf">slideshare<i class="fa fa-external-link"></i></span> 或 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9TbGlkZXMvVmVsb2NpdHkyMDE3X0JQRl9zdXBlcnBvd2Vycy5wZGY=" title="https://www.brendangregg.com/Slides/Velocity2017_BPF_superpowers.pdf">PDF<i class="fa fa-external-link"></i></span> 上。</p><h2 id="10-Linux-Performance-Analysis-New-Tools-and-Old-Secrets-ftrace-LISA-2014"><a href="#10-Linux-Performance-Analysis-New-Tools-and-Old-Secrets-ftrace-LISA-2014" class="headerlink" title="10. Linux Performance Analysis: New Tools and Old Secrets (ftrace) (LISA 2014)"></a>10. Linux Performance Analysis: New Tools and Old Secrets (ftrace) (LISA 2014)</h2><p>At USENIX LISA 2014, I gave a talk on the new ftrace and perf_events tools I’ve been developing: the <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JyZW5kYW5ncmVnZy9wZXJmLXRvb2xz" title="https://github.com/brendangregg/perf-tools">perf-tools<i class="fa fa-external-link"></i></span> collection on github, which mostly uses ftrace: a tracer that has been built into the Linux kernel for many years, but few have discovered (practically a secret).</p><p>在 2014 年的 USENIX LISA 大会上，我发表了关于我一直在开发的新 ftrace 和 perf_events 工具的演讲：github 上的 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JyZW5kYW5ncmVnZy9wZXJmLXRvb2xz" title="https://github.com/brendangregg/perf-tools">perf-tools<i class="fa fa-external-link"></i></span> 套件，其中大部分使用了 ftrace：这是一个内置于 Linux 内核多年的跟踪器，但很少有人发现它（实际上是一个秘密）。</p><p>A video of the talk is on <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1SNElLZU1RaE0wWQ==" title="https://www.youtube.com/watch?v=R4IKeMQhM0Y">youtube<i class="fa fa-external-link"></i></span>, and the slides are on <span class="exturl" data-url="aHR0cDovL3d3dy5zbGlkZXNoYXJlLm5ldC9icmVuZGFuZ3JlZ2cvbGludXgtcGVyZm9ybWFuY2UtYW5hbHlzaXMtbmV3LXRvb2xzLWFuZC1vbGQtc2VjcmV0cw==" title="http://www.slideshare.net/brendangregg/linux-performance-analysis-new-tools-and-old-secrets">slideshare<i class="fa fa-external-link"></i></span> or as a <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9TbGlkZXMvTElTQTIwMTRfTGludXhQZXJmQW5hbHlzaXNOZXdUb29scy5wZGY=" title="https://www.brendangregg.com/Slides/LISA2014_LinuxPerfAnalysisNewTools.pdf">PDF<i class="fa fa-external-link"></i></span>. In a <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTUtMDMtMTcvdXNlbml4LWxpc2EtMjAxNC1saW51eC1mdHJhY2UtcGVyZi10b29scy5tYXJrZG93bg==" title="https://www.brendangregg.com/blog/2015-03-17/usenix-lisa-2014-linux-ftrace-perf-tools.markdown">post<i class="fa fa-external-link"></i></span> about this talk, I included some more screenshots of these tools in action.</p><p>演讲视频在 <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1SNElLZU1RaE0wWQ==" title="https://www.youtube.com/watch?v=R4IKeMQhM0Y">youtube<i class="fa fa-external-link"></i></span> 上，幻灯片在 <span class="exturl" data-url="aHR0cDovL3d3dy5zbGlkZXNoYXJlLm5ldC9icmVuZGFuZ3JlZ2cvbGludXgtcGVyZm9ybWFuY2UtYW5hbHlzaXMtbmV3LXRvb2xzLWFuZC1vbGQtc2VjcmV0cw==" title="http://www.slideshare.net/brendangregg/linux-performance-analysis-new-tools-and-old-secrets">slideshare<i class="fa fa-external-link"></i></span> 或 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9TbGlkZXMvTElTQTIwMTRfTGludXhQZXJmQW5hbHlzaXNOZXdUb29scy5wZGY=" title="https://www.brendangregg.com/Slides/LISA2014_LinuxPerfAnalysisNewTools.pdf">PDF<i class="fa fa-external-link"></i></span> 上。在一篇关于本讲座的<span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTUtMDMtMTcvdXNlbml4LWxpc2EtMjAxNC1saW51eC1mdHJhY2UtcGVyZi10b29scy5tYXJrZG93bg==" title="https://www.brendangregg.com/blog/2015-03-17/usenix-lisa-2014-linux-ftrace-perf-tools.markdown">帖子<i class="fa fa-external-link"></i></span>中，我还附上了这些工具的截图。</p><h2 id="11-Performance-Checklists-for-SREs-SREcon-2016"><a href="#11-Performance-Checklists-for-SREs-SREcon-2016" class="headerlink" title="11. Performance Checklists for SREs (SREcon, 2016)"></a>11. Performance Checklists for SREs (SREcon, 2016)</h2><p>At <span class="exturl" data-url="aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9jb25mZXJlbmNlL3NyZWNvbjE2L3Byb2dyYW0=" title="https://www.usenix.org/conference/srecon16/program">SREcon 2016 Santa Clara<i class="fa fa-external-link"></i></span>, I gave the closing talk on performance checklists for SREs (Site Reliability Engineers). The later half of this talk included Linux checklists for incident performance response. These may be useful whether you’re analyzing Linux performance in a hurry or not.</p><p>在<span class="exturl" data-url="aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9jb25mZXJlbmNlL3NyZWNvbjE2L3Byb2dyYW0=" title="https://www.usenix.org/conference/srecon16/program">SREcon 2016 Santa Clara<i class="fa fa-external-link"></i></span>上，我做了关于站点可靠性工程师（SRE）性能检查表的闭幕演讲。演讲的后半部分包括用于事件性能响应的 Linux 检查单。无论您是否在匆忙中分析 Linux 性能，这些清单都可能很有用。</p><p>A video of the talk is on <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj16eENXWE5pZ0RwQQ==" title="https://www.youtube.com/watch?v=zxCWXNigDpA">youtube<i class="fa fa-external-link"></i></span> and <span class="exturl" data-url="aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9jb25mZXJlbmNlL3NyZWNvbjE2L3Byb2dyYW0vcHJlc2VudGF0aW9uL2dyZWdn" title="https://www.usenix.org/conference/srecon16/program/presentation/gregg">usenix<i class="fa fa-external-link"></i></span>, and the slides are on <span class="exturl" data-url="aHR0cDovL3d3dy5zbGlkZXNoYXJlLm5ldC9icmVuZGFuZ3JlZ2cvc3JlY29uLTIwMTYtcGVyZm9ybWFuY2UtY2hlY2tsaXN0cy1mb3Itc3Jlcw==" title="http://www.slideshare.net/brendangregg/srecon-2016-performance-checklists-for-sres">slideshare<i class="fa fa-external-link"></i></span> and as a <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9TbGlkZXMvU1JFY29uXzIwMTZfcGVyZl9jaGVja2xpc3RzLnBkZg==" title="https://www.brendangregg.com/Slides/SREcon_2016_perf_checklists.pdf">PDF<i class="fa fa-external-link"></i></span>. I included the checklists in a <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTYtMDUtMDQvc3JlY29uMjAxNi1wZXJmLWNoZWNrbGlzdHMtZm9yLXNyZXMuaHRtbA==" title="https://www.brendangregg.com/blog/2016-05-04/srecon2016-perf-checklists-for-sres.html">blog post<i class="fa fa-external-link"></i></span>.</p><p>讲座视频在 <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj16eENXWE5pZ0RwQQ==" title="https://www.youtube.com/watch?v=zxCWXNigDpA">youtube<i class="fa fa-external-link"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9jb25mZXJlbmNlL3NyZWNvbjE2L3Byb2dyYW0vcHJlc2VudGF0aW9uL2dyZWdn" title="https://www.usenix.org/conference/srecon16/program/presentation/gregg">usenix<i class="fa fa-external-link"></i></span> 上，幻灯片在 <span class="exturl" data-url="aHR0cDovL3d3dy5zbGlkZXNoYXJlLm5ldC9icmVuZGFuZ3JlZ2cvc3JlY29uLTIwMTYtcGVyZm9ybWFuY2UtY2hlY2tsaXN0cy1mb3Itc3Jlcw==" title="http://www.slideshare.net/brendangregg/srecon-2016-performance-checklists-for-sres">slideshare<i class="fa fa-external-link"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9TbGlkZXMvU1JFY29uXzIwMTZfcGVyZl9jaGVja2xpc3RzLnBkZg==" title="https://www.brendangregg.com/Slides/SREcon_2016_perf_checklists.pdf">PDF<i class="fa fa-external-link"></i></span> 上。我在一篇<span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJlbmRhbmdyZWdnLmNvbS9ibG9nLzIwMTYtMDUtMDQvc3JlY29uMjAxNi1wZXJmLWNoZWNrbGlzdHMtZm9yLXNyZXMuaHRtbA==" title="https://www.brendangregg.com/blog/2016-05-04/srecon2016-perf-checklists-for-sres.html">博文<i class="fa fa-external-link"></i></span>中附上了核对表。  </p><h2 id="Resources-相关资源"><a href="#Resources-相关资源" class="headerlink" title="Resources 相关资源"></a>Resources 相关资源</h2><p>Other resources (not by me) I’d recommend for the topic of Linux performance:</p><p>关于 Linux 性能主题，我想推荐的其他资源（不是我写的）：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1ja2FydkdKRThRYw==" title="https://www.youtube.com/watch?v=ckarvGJE8Qc">Performance analysis &amp; tuning of Red Hat Enterprise Linux - 2015 Red Hat Summit<i class="fa fa-external-link"></i></span> (video 2hrs): this is a great and in-depth tour of Linux performance tuning that should be largely applicable to all Linux distros.</li></ul><p><span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1ja2FydkdKRThRYw==" title="https://www.youtube.com/watch?v=ckarvGJE8Qc">红帽企业 Linux 的性能分析与调优 - 2015 红帽峰会<i class="fa fa-external-link"></i></span>(视频 2 小时）：这是一次深入浅出的 Linux 性能调整之旅，在很大程度上适用于所有 Linux 发行版。</p><p> <strong>(视频 2 小时）：这是一次深入浅出的 Linux 性能调整之旅，在很大程度上适用于所有 Linux 发行版。</strong></p><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5zbGlkZXNoYXJlLm5ldC9EYXJrU3RhclN3b3JkL2luc3RydW1lbnRhdGlvbg==" title="http://www.slideshare.net/DarkStarSword/instrumentation">Linux Instrumentation<i class="fa fa-external-link"></i></span>: slides from a great talk in June 2010 by Ian Munsie, which summarizes the different Linux tracers very well. If you’re trying to understand all the tracers and frameworks, this is worth studying (keeping in mind it’s from 2010).</li></ul><p>这是 Ian Munsie 于 2010 年 6 月发表的精彩演讲的幻灯片，其中很好地总结了不同的 Linux 跟踪器。如果您正试图了解所有跟踪器和框架，那么这篇文章值得一读（请注意这是 2010 年的文章）。</p><ul><li><span class="exturl" data-url="aHR0cDovL2p2bnMuY2Ev" title="http://jvns.ca/">Julia Evans blog<i class="fa fa-external-link"></i></span> has many posts about many topics, including performance tools.</li></ul><p>有许多关于性格讨论等问题的帖子，包括性能工具。</p><ul><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuc3Rnb2xhYnMubmV0L3NlYXJjaC9sYWJlbC9saW51eA==" title="http://blog.stgolabs.net/search/label/linux">Davidlohr Bueso’s<i class="fa fa-external-link"></i></span> Linux performance posts.</li></ul><p>Linux 性能讨论文章。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      Linux性能
    
    </summary>
    
    
      <category term="Linux" scheme="https://whitestore.top/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://whitestore.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【Java】BIO源码分析和改造（GraalVM JDK 11.0.19）</title>
    <link href="https://whitestore.top/2023/07/27/biosocketstart/"/>
    <id>https://whitestore.top/2023/07/27/biosocketstart/</id>
    <published>2023-07-27T03:43:47.000Z</published>
    <updated>2023-09-09T00:54:05.258Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>本文介绍网络IO编程的入门部分，Java 的传统BIO Socket编程源码分析，了解如何将BIO阻塞行为<code>accept()</code> 和 <code>read()</code> 改造为非阻塞行为，并且将结合Linux文档介绍其中的机制，文档中描述了如何处理<code>Socket</code>的<code>accept</code>，对比Java的Socket实现代码，基本可以发现和Linux行为基本一致。</p><p>废话不多说，我们直接开始。</p><h1 id="draw-io-文件"><a href="#draw-io-文件" class="headerlink" title="draw.io 文件"></a>draw.io 文件</h1><p>本文涉及的个人源码分析绘图均由 <code>draw.io</code> 绘制，源文件如下：</p><p>链接：<span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMUZIQVl0NEF4V2gwRGQ0cWkySktaTFE/cHdkPXFzbWc=" title="https://pan.baidu.com/s/1FHAYt4AxWh0Dd4qi2JKZLQ?pwd=qsmg">https://pan.baidu.com/s/1FHAYt4AxWh0Dd4qi2JKZLQ?pwd=qsmg <i class="fa fa-external-link"></i></span><br>提取码：qsmg </p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230717073204.png" alt="image.png"></p><a id="more"></a><h1 id="什么是Socket？"><a href="#什么是Socket？" class="headerlink" title="什么是Socket？"></a>什么是Socket？</h1><p>Socket起源于Unix的一种通信机制，中文通常叫他“套接字”，代表了网络IP和端口，可以看作是通信过程的一个“句柄”。</p><p>Socket 也可以理解为网络编程当中的API，编程语言提供了对应的API实现方式，电脑上的网络应用程序也是通过“套接字”完成网络请求接受与应答。</p><p>总而言之：<strong>Socket是应用层与TCP/IP协议族通信的中间软件抽象层</strong>。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230705110036.png" alt="Socket是应用层与TCP/IP协议族通信的中间软件抽象层"></p><blockquote><p>图片来源：<span class="exturl" data-url="aHR0cHM6Ly93d3cudG9wZ29lci5jb20vJUU3JUJEJTkxJUU3JUJCJTlDJUU3JUJDJTk2JUU3JUE4JThCL3NvY2tldCVFNyVCQyU5NiVFNyVBOCU4Qi9zb2NrZXQlRTUlOUIlQkUlRTglQTclQTMuaHRtbA==" title="https://www.topgoer.com/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/socket%E7%BC%96%E7%A8%8B/socket%E5%9B%BE%E8%A7%A3.html">socket图解 · Go语言中文文档 (topgoer.com)<i class="fa fa-external-link"></i></span></p></blockquote><h1 id="阻塞式IO模型"><a href="#阻塞式IO模型" class="headerlink" title="阻塞式IO模型"></a>阻塞式IO模型</h1><p>在 <strong>《UNIX Network Programming》</strong> 一书当中，用UDP传输的案例模拟了阻塞式的IO模型，这个模型的概念和Java BIO的阻塞模型类似。</p><p>下面函数中应用进程在调用 <code>recvfrom</code> 之后就开始系统调用并且进行阻塞，等待内核把数据准备并且复制完成之后才得到结果，或者等待过程中发生错误返回。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230411212436.png" alt="阻塞式IO模型"></p><p>从图片可以看到，在内核工作的整个过程中应用进程无法做其他任何操作。</p><h1 id="BIO-通信模型"><a href="#BIO-通信模型" class="headerlink" title="BIO 通信模型"></a>BIO 通信模型</h1><p>我们把上面的阻塞IO模型转为IO通信模型，结果如下：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230705103727.png" alt="BIO 通信模型"></p><p>BIO对于每一个客户端进行阻塞等待接收连接，同一个时间只能处理一个Socket请求，并且在构建完成之后通常会分配一个Thread线程为其进行服务。</p><h1 id="BIO-阻塞案例代码"><a href="#BIO-阻塞案例代码" class="headerlink" title="BIO 阻塞案例代码"></a>BIO 阻塞案例代码</h1><h2 id="BioClientSocket"><a href="#BioClientSocket" class="headerlink" title="BioClientSocket"></a>BioClientSocket</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> *  BioClientSocket 客户端 Socket实现  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Xander  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> v1.0.0  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Package</span> : com.zxd.interview.niosource.bio  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> : BioClientSocket 客户端 Socket实现  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Create</span> on : 2023/7/5 09:52  </span></span><br><span class="line"><span class="comment"> **/</span><span class="meta">@Slf</span>4j  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BioClientSocket</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initBIOClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;  </span><br><span class="line">        BufferedReader reader = <span class="keyword">null</span>;  </span><br><span class="line">        BufferedWriter writer = <span class="keyword">null</span>;  </span><br><span class="line">        Socket socket = <span class="keyword">null</span>;  </span><br><span class="line">        String inputContent;  </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));  </span><br><span class="line">            socket = <span class="keyword">new</span> Socket(host, port);  </span><br><span class="line">            writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(socket.getOutputStream()));  </span><br><span class="line">            log.info(<span class="string">"clientSocket started: "</span> + stringNowTime());  </span><br><span class="line">            <span class="keyword">while</span> (((inputContent = reader.readLine()) != <span class="keyword">null</span>) &amp;&amp; count &lt; <span class="number">2</span>) &#123;  </span><br><span class="line">                inputContent = stringNowTime() + <span class="string">": 第"</span> + count + <span class="string">"条消息: "</span> + inputContent + <span class="string">"\n"</span>;  </span><br><span class="line">                writer.write(inputContent);<span class="comment">//将消息发送给服务端  </span></span><br><span class="line">                writer.flush();  </span><br><span class="line">                count++;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                socket.close();  </span><br><span class="line">                reader.close();  </span><br><span class="line">                writer.close();  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">stringNowTime</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);  </span><br><span class="line">        <span class="keyword">return</span> format.format(<span class="keyword">new</span> Date());  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        BioClientSocket client = <span class="keyword">new</span> BioClientSocket();  </span><br><span class="line">        client.initBIOClient(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>);  </span><br><span class="line">    &#125;<span class="comment">/**  </span></span><br><span class="line"><span class="comment">     运行结果：  </span></span><br><span class="line"><span class="comment">     clientSocket started: 2023-07-05 10:26:05  </span></span><br><span class="line"><span class="comment">     7978987     797898     tyuytu     */</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="BioServerSocket"><a href="#BioServerSocket" class="headerlink" title="BioServerSocket"></a>BioServerSocket</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * ServerSocket 实现  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Xander  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> v1.0.0  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Package</span> : com.zxd.interview.niosource.bio  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> : ServerSocket 实现  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Create</span> on : 2023/7/5 09:48  </span></span><br><span class="line"><span class="comment"> **/</span><span class="meta">@Slf</span>4j  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BioServerSocket</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initBIOServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;  </span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">null</span>;<span class="comment">//服务端Socket  </span></span><br><span class="line">        Socket socket = <span class="keyword">null</span>;<span class="comment">//客户端socket  </span></span><br><span class="line">        BufferedReader reader = <span class="keyword">null</span>;  </span><br><span class="line">        String inputContent;  </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(port);  </span><br><span class="line">           log.info(stringNowTime() + <span class="string">": serverSocket started"</span>);  </span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </span><br><span class="line">                socket = serverSocket.accept();  </span><br><span class="line">               log.info(stringNowTime() + <span class="string">": id为"</span> + socket.hashCode() + <span class="string">"的Clientsocket connected"</span>);  </span><br><span class="line">                reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));  </span><br><span class="line">                <span class="keyword">while</span> ((inputContent = reader.readLine()) != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                   log.info(<span class="string">"收到id为"</span> + socket.hashCode() + <span class="string">"  "</span> + inputContent);  </span><br><span class="line">                    count++;  </span><br><span class="line">                &#125;  </span><br><span class="line">               log.info(<span class="string">"id为"</span> + socket.hashCode() + <span class="string">"的Clientsocket "</span> + stringNowTime() + <span class="string">"读取结束"</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="keyword">if</span>(Objects.nonNull(reader))&#123;  </span><br><span class="line">  </span><br><span class="line">                    reader.close();  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">if</span>(Objects.nonNull(socket))&#123;  </span><br><span class="line">  </span><br><span class="line">                    socket.close();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">    &#125;<span class="comment">/**  </span></span><br><span class="line"><span class="comment">     运行结果：  </span></span><br><span class="line"><span class="comment">     10:25:57.731 [main] INFO com.zxd.interview.niosource.bio.BioServerSocket - 2023-07-05 10:25:57: serverSocket started  </span></span><br><span class="line"><span class="comment">     10:26:08.442 [main] INFO com.zxd.interview.niosource.bio.BioServerSocket - 2023-07-05 10:26:08: id为161960012的Clientsocket connected  </span></span><br><span class="line"><span class="comment">     10:26:29.356 [main] INFO com.zxd.interview.niosource.bio.BioServerSocket - 收到id为161960012  2023-07-05 10:26:26: 第0条消息: 7978987  </span></span><br><span class="line"><span class="comment">     10:26:34.409 [main] INFO com.zxd.interview.niosource.bio.BioServerSocket - 收到id为161960012  2023-07-05 10:26:34: 第1条消息: 797898  </span></span><br><span class="line"><span class="comment">     10:26:38.298 [main] INFO com.zxd.interview.niosource.bio.BioServerSocket - id为161960012的Clientsocket 2023-07-05 10:26:38读取结束  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">stringNowTime</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);  </span><br><span class="line">        <span class="keyword">return</span> format.format(<span class="keyword">new</span> Date());  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        BioServerSocket server = <span class="keyword">new</span> BioServerSocket();  </span><br><span class="line">        server.initBIOServer(<span class="number">8888</span>);  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BIO 阻塞模型中，需要关注的代码主要是这几个：</p><ul><li><code>serverSocket = new ServerSocket(port);</code></li><li><code>socket = serverSocket.accept();</code></li><li><code>socket = new Socket(host, port);</code></li></ul><p>从代码中可以看出，客户端在获取Socket建立连接后，通过系统输入输出流完成读写IO操作，服务端则通过系统缓冲流Buffer来提高读写效率。 </p><h1 id="ServerSocket-中-bind-解读"><a href="#ServerSocket-中-bind-解读" class="headerlink" title="ServerSocket 中 bind 解读"></a>ServerSocket 中 bind 解读</h1><p>在具体的解读之前，先看下整个调用的大致流程图。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230706174016.png" alt="ServerSocket 中 bind 解读"></p><p>由于是<code>ServerSocket</code>服务端先启动，这里先对<code>bind</code>操作进行解读，<code>bind</code>操作是在本机的某个端口和IP地址上进行listen监听。</p><p>在bind成功之后，服务端进入<code>accept</code>阻塞等待，此时客户端Socket请求此地址将会进行Socket连接绑定。</p><p>我们从<code>ServerSocket</code>的初始化代码作为入口进行介绍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.net.ServerSocket#ServerSocket(int)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServerSocket</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(port, <span class="number">50</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServerSocket</span><span class="params">(<span class="keyword">int</span> port, <span class="keyword">int</span> backlog, InetAddress bindAddr)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    setImpl();</span><br><span class="line">    <span class="comment">// 检查端口是否越界</span></span><br><span class="line">    <span class="comment">// 0xFFFF = 15 * 16^3 + 15 * 16^2 + 15 * 16^1 + 15 * 16^0 = **65535**</span></span><br><span class="line">    <span class="keyword">if</span> (port &lt; <span class="number">0</span> || port &gt; <span class="number">0xFFFF</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"Port value out of range: "</span> + port);</span><br><span class="line">    <span class="keyword">if</span> (backlog &lt; <span class="number">1</span>)</span><br><span class="line">        backlog = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 核心部分</span></span><br><span class="line">        bind(<span class="keyword">new</span> InetSocketAddress(bindAddr, port), backlog);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(SecurityException e) &#123;</span><br><span class="line">        close();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">        close();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>setImpl();</code>这个方法我们先暂时放到一边，我们简单扫一下其他代码。</p><p>在上面的案例代码当中，我们传入的<code>ip</code>和<code>port</code>都处在合法的范围内，Socket规定的端口范围是<strong>0 - 65525</strong>，超过这个范围不允许进行<code>bind</code>。</p><p>上面代码的核心逻辑是<code>bind(xxx)</code>这一段操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind(<span class="keyword">new</span> InetSocketAddress(bindAddr, port), backlog);</span><br></pre></td></tr></table></figure><h2 id="new-InetSocketAddress-bindAddr-port"><a href="#new-InetSocketAddress-bindAddr-port" class="headerlink" title="new InetSocketAddress(bindAddr, port)"></a>new InetSocketAddress(bindAddr, port)</h2><p>在<code>bind</code>方法调用之前，<code>ServerSocket</code>会先构建 <strong>InetSocketAddress</strong> 对象。<strong>InetSocketAddress</strong>对象构建实际为<strong>InetSocketAddressHolder</strong>包装类。包装类的作用是可以防止<code>IP</code>和<code>Port</code>等敏感字段的外部篡改。</p><p>此外从代码可以看到，构建对象会对于<code>IP</code>和<code>Port</code>进行二次检查，如果IP地址不存在，会给一个默认值（通常是<code>0.0.0.0</code> ）。</p><blockquote><p>Creates a socket address from an IP address and a port number.<br>    A valid port value is between 0 and 65535. A port number of zero will let the system pick up an ephemeral port in a bind operation.|<br>    根据IP地址和端口号创建Socket地址。有效的端口值介于0和65535之间。端口号为0时，系统将在绑定操作中使用短暂端口。</p></blockquote><p><strong>InetSocketAddressHolder</strong> 对象构建完成之后，接着就进入到核心的<code>bind(SocketAddress endpoint, int backlog)</code>内部代码。</p><h2 id="bind-SocketAddress-endpoint-int-backlog"><a href="#bind-SocketAddress-endpoint-int-backlog" class="headerlink" title="bind(SocketAddress endpoint, int backlog)"></a>bind(SocketAddress endpoint, int backlog)</h2><p><strong>java.net.ServerSocket#bind(java.net.SocketAddress, int)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Binds the ServerSocket to a specific address (IP address and port number).</span></span><br><span class="line"><span class="comment">将ServerSocket绑定到一个特定的地址（IP地址和端口号）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">If the address is null, then the system will pick up an ephemeral port and a valid local address to bind the socket.</span></span><br><span class="line"><span class="comment">如果地址为空，那么系统会选取一个短暂的端口和一个有效的本地地址来绑定套接字。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(SocketAddress endpoint, <span class="keyword">int</span> backlog)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// Socket是否已经被关闭</span></span><br><span class="line">        <span class="keyword">if</span> (isClosed())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Socket is closed"</span>);</span><br><span class="line">        <span class="comment">// 判断是否已经绑定</span></span><br><span class="line">        <span class="keyword">if</span> (!oldImpl &amp;&amp; isBound())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Already bound"</span>);</span><br><span class="line">        <span class="keyword">if</span> (endpoint == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 如果地址为空，给一个默认地址</span></span><br><span class="line">            endpoint = <span class="keyword">new</span> InetSocketAddress(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (!(endpoint <span class="keyword">instanceof</span> InetSocketAddress))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unsupported address type"</span>);</span><br><span class="line">        <span class="comment">// 类型强转为 InetSocketAddress</span></span><br><span class="line">        InetSocketAddress epoint = (InetSocketAddress) endpoint;</span><br><span class="line">        <span class="comment">// 如果地址已经被占用了</span></span><br><span class="line">        <span class="keyword">if</span> (epoint.isUnresolved())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Unresolved address"</span>);</span><br><span class="line">        <span class="keyword">if</span> (backlog &lt; <span class="number">1</span>)</span><br><span class="line">          backlog = <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SecurityManager security = System.getSecurityManager();</span><br><span class="line">            <span class="keyword">if</span> (security != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 端口进行安全检查</span></span><br><span class="line">                security.checkListen(epoint.getPort());</span><br><span class="line">            getImpl().bind(epoint.getAddress(), epoint.getPort());</span><br><span class="line">            getImpl().listen(backlog);</span><br><span class="line">            bound = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(SecurityException e) &#123;</span><br><span class="line">            bound = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">            bound = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>bind 方法是将 <strong>ServerSocket</strong> 绑定到一个特定的地址（IP地址和端口号）， 如果地址为空，那么系统会选取一个临时端口和有效的本地地址来绑定 ServerSocket。</p><p>跳过不需要关注的校验代码，在·<code>try</code> 中有三行比较重要的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getImpl().bind(epoint.getAddress(), epoint.getPort());  </span><br><span class="line">getImpl().listen(backlog);  </span><br><span class="line">bound = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p>这里的代码初步理解是获取一个<code>impl</code>对象，绑定地址和端口，调用<code>listen</code>方法传递<code>backlog</code>。</p><p><code>backlog</code>这个值的作用可以看下面的地址，这里整理文章内容大致理解：</p><ul><li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubGludXhqb3VybmFsLmNvbS9maWxlcy9saW51eGpvdXJuYWwuY29tL2xpbnV4am91cm5hbC9hcnRpY2xlcy8wMjMvMjMzMy8yMzMzczIuaHRtbA==" title="https://www.linuxjournal.com/files/linuxjournal.com/linuxjournal/articles/023/2333/2333s2.html">Linux Network Programming, Part 1 (linuxjournal.com)<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMDQ4NzQ2MDU=" title="https://zhuanlan.zhihu.com/p/104874605">详解socket中的backlog 参数 - 知乎 (zhihu.com)<i class="fa fa-external-link"></i></span></p></li></ul><p><code>backlog</code>主要是和<code>Socket</code>有关。在Socket编程中<strong>listen函数的第二个参数为backlog</strong>，用于服务器编程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">listen</span>(sock, backlog);</span><br></pre></td></tr></table></figure><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230706114407.png" alt="TCP 握手"></p><p>在TCP 三次握手当中，LISTEN 状态的服务端 Socket 收到 SYN，会建立一个 <strong>SYN_REVD</strong> 的连接，<strong>SYN_REVD</strong> 是一个半连接状态，只有在收到客户端的ACK之后才会进入<strong>ESTABLISHED</strong>，也就是说三次握手的过程必然会经历<strong>SYN_REVD</strong>和<strong>ESTABLISHED</strong>两个状态。</p><p>针对这两个状态，不同的操作系统有不同实现，<strong>在 FressBSD 中 backlog 就是描述状态为 SYN_REVD 和 ESTABLISHED 的所有连接最大数量</strong>。</p><p>在 Linux 系统当中，使用两个队列 <strong>syn queue</strong>和 <strong>accept queue</strong>，这两个队列分别存储状态为<strong>SYN_REVD</strong>和状态为<strong>ESTABLISHED</strong>的连接，<strong>Llinux2.2及以后，backlog表示accept queue的大小</strong>，而syn queue大小由 <code>/proc/sys/net/ipv4/tcp_max_syn_backlog</code>配置。</p><p>可以看到backlog的值直接影响了建立连接的效率。上面代码中<code>backlog=50</code>，可以认为 accept queue 的容量为 50。</p><p><code>listen</code>方法执行完成之后，此时将设置<code>bound = true</code>，代码执行到此处说明<code>Socket</code>绑定成功了。</p><p>现在我们回过头看<code>getImpl().bind(epoint.getAddress(), epoint.getPort());</code>这块代码工作。</p><h2 id="setImpl"><a href="#setImpl" class="headerlink" title="setImpl()"></a>setImpl()</h2><p>介绍<code>getImpl()</code>的前提是我们要知道如何<code>set</code>的，具体代码位于构造方法中一行不起眼的<code>setImpl()</code>操作。</p><p><strong>java.net.ServerSocket#setImpl</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (factory != <span class="keyword">null</span>) &#123;</span><br><span class="line">            impl = factory.createSocketImpl();</span><br><span class="line">            checkOldImpl();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// No need to do a checkOldImpl() here, we know it's an up to date</span></span><br><span class="line">            <span class="comment">// SocketImpl!</span></span><br><span class="line">            impl = <span class="keyword">new</span> SocksSocketImpl();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (impl != <span class="keyword">null</span>)</span><br><span class="line">            impl.setServerSocket(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注意，在第一次初始化的时候，<code>SocketImplFactory</code>是没有被初始化过的，所以走的是<code>else</code>分支，具体工作是为内部的成员变量 <code>SocketImpl</code>进行初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * The implementation of this Socket. */</span></span><br><span class="line"><span class="keyword">private</span> SocketImpl impl;</span><br></pre></td></tr></table></figure><p><code>SocksSocketImpl</code> 初始化之后，将会设置它的成员变量<code>ServerSocket</code>为<code>this</code>引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (impl != <span class="keyword">null</span>)  </span><br><span class="line">    impl.setServerSocket(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>这里的处理工作很简单，分别是初始化 <strong>SocksSocketImpl</strong> ，把当前对象实例的this引用传递给这个初始化的 <strong>SocksSocketImpl</strong> 的成员变量（这时候自身的引用逸出了）。</p><p>了解<code>setImpl</code>之后，下面这里我们再看看 <code>getImpl()</code> 干了啥。</p><h2 id="getImpl"><a href="#getImpl" class="headerlink" title="getImpl()"></a>getImpl()</h2><p><strong>java.net.ServerSocket#getImpl</strong></p><p>代码内容也比较简单，首先检查<code>SocketImpl</code>是否创建，第一次连接这里为<code>false</code>，此时会进入<code>createImpl()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Get the SocketImpl attached to this socket, creating it if necessary.</span></span><br><span class="line"><span class="comment">获取连接到此套接字的SocketImpl，如果有必要，可以创建它。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">SocketImpl <span class="title">getImpl</span><span class="params">()</span> <span class="keyword">throws</span> SocketException </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (!created)  </span><br><span class="line">        createImpl();  </span><br><span class="line">    <span class="keyword">return</span> impl;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>createImpl()</code>当中，通常 <strong>SocketImpl</strong> 已经在构造器初始化完成，这里直接更新 <code>created</code> 状态即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createImpl</span><span class="params">()</span> <span class="keyword">throws</span> SocketException </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (impl == <span class="keyword">null</span>)  </span><br><span class="line">        setImpl();  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        impl.create(<span class="keyword">true</span>);  </span><br><span class="line">        created = <span class="keyword">true</span>;  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(e.getMessage());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>setImpl()</code> 和 <code>getImpl()</code>方法配合，可以确定 <strong>SocketImpl</strong> 在使用的时候一定是被初始化完成的。</p><h3 id="SocketImpl-bind-epoint-getAddress-epoint-getPort"><a href="#SocketImpl-bind-epoint-getAddress-epoint-getPort" class="headerlink" title="SocketImpl.bind(epoint.getAddress(), epoint.getPort())"></a>SocketImpl.bind(epoint.getAddress(), epoint.getPort())</h3><p>下面再来看看它是如何进行下面两项关键操作的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getImpl().bind(epoint.getAddress(), epoint.getPort());  </span><br><span class="line">getImpl().listen(backlog);</span><br></pre></td></tr></table></figure><p>在之前的初始化代码中，<code>InetAddress</code>对象初始化设置了<code>IP</code>和<code>Port</code>等参数，现在委托 <strong>SocketImpl</strong>执行具体<code>bind</code>操作。</p><p><strong>java.net.AbstractPlainSocketImpl#bind</strong></p><p><code>bind</code>方法是同步的，一开始需要先获取到<code>fdLock</code>锁，然后判断是否满足<code>Socket</code>绑定条件，如果满足则利用钩子(<code>NetHooks</code>) 对象进行前置TCP绑定。</p><blockquote><p>注意，个人发现<code>NetHooks.beforeTcpBind(fd, address, lport);</code>方法发现在<strong>JDK11</strong>之中是一个<strong>空方法</strong>，而<strong>JDK8</strong>当中会有一段<code>provider.implBeforeTcpBind(fdObj, address, port);</code>的调用。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(InetAddress address, <span class="keyword">int</span> lport)</span>  </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"><span class="comment">// 获取 fdLock 锁</span></span><br><span class="line">   <span class="keyword">synchronized</span> (fdLock) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (!closePending &amp;&amp; (socket == <span class="keyword">null</span> || !socket.isBound())) &#123;  </span><br><span class="line">            NetHooks.beforeTcpBind(fd, address, lport);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 是否链接本地地址</span></span><br><span class="line">    <span class="keyword">if</span> (address.isLinkLocalAddress()) &#123;  </span><br><span class="line">        address = IPAddressUtil.toScopedAddress(address);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 关键</span></span><br><span class="line">    socketBind(address, lport);  </span><br><span class="line">    <span class="comment">// 服务端和客户端的Socket走不同的 if 判断</span></span><br><span class="line">    <span class="keyword">if</span> (socket != <span class="keyword">null</span>)  </span><br><span class="line">        socket.setBound();  </span><br><span class="line">    <span class="keyword">if</span> (serverSocket != <span class="keyword">null</span>)  </span><br><span class="line">        serverSocket.setBound();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加锁部分和核心逻辑无太多干系，我们跳过细枝末节，看<code>socketBind(address, lport);</code>这部分代码。</p><blockquote><p>fdLock 锁作用：注释说明它用于在增加/减少<strong>fdUseCount</strong>时锁定。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* lock when increment/decrementing fdUseCount */</span>  </span><br><span class="line"><span class="comment">// 在增加/减少fdUseCount时锁定</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Object fdLock = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><h3 id="PlainSocketImpl-socketBind-InetAddress-address-int-port"><a href="#PlainSocketImpl-socketBind-InetAddress-address-int-port" class="headerlink" title="PlainSocketImpl#socketBind(InetAddress address, int port)"></a>PlainSocketImpl#socketBind(InetAddress address, int port)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">socketBind</span><span class="params">(InetAddress address, <span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> nativefd = checkAndReturnNativeFD();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (address == <span class="keyword">null</span>)  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"inet address argument is null."</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 目前IPv4地址已经分配完毕，所以优先用 IPV6的，并且不支持 IPV4 </span></span><br><span class="line">    <span class="keyword">if</span> (preferIPv4Stack &amp;&amp; !(address <span class="keyword">instanceof</span> Inet4Address))  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Protocol family not supported"</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 核心操作</span></span><br><span class="line">    bind0(nativefd, address, port, useExclusiveBind);  </span><br><span class="line">    <span class="comment">// 如果是之前 InetAddress 为空默认初始化的端口为0，则重新随机分配一个端口</span></span><br><span class="line">    <span class="keyword">if</span> (port == <span class="number">0</span>) &#123;  </span><br><span class="line">        localport = localPort0(nativefd);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        localport = port;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">this</span>.address = address;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>socketBind(address, lport);</code>方法调用，最后绑定操作为JVM的底层C++操作<code>bind0</code>。</p><p><code>bind0</code>属于比较底层的代码，这里我们就不继续探究了，如果读者好奇，可以阅读 <code>HotSpot</code> 的开源实现代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">bind0</span><span class="params">(<span class="keyword">int</span> fd, InetAddress localAddress, <span class="keyword">int</span> localport,  </span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">boolean</span> exclBind)</span>  </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><p>从整体上看，上面这一整个<code>bind</code>操作都是同步完成的，主要逻辑是先做一系列检查，之后调用底层的JVM方法完成<code>Socket</code>绑定。</p><h2 id="画图小结"><a href="#画图小结" class="headerlink" title="画图小结"></a>画图小结</h2><p>笔者通过个人理解画了一幅图，主要描述了 <code>bind</code> 操作大致的逻辑，可以看到很多地方都和<code>JVM</code>的底层C++代码打交道。</p><blockquote><p>有必要说明一下，BIO毕竟是 Java1.0 出来的玩意，看源码我们要抓大放小，后续的JDK提案中，有人提出要收拾这个老古董=-=。</p></blockquote><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230707151128.png" alt="ServerSocket的bind"></p><blockquote><p> 从图中也可以看出，要完成Socket连接构建，必须要获得文件描述符。</p></blockquote><h1 id="ServerSocket中accept解读"><a href="#ServerSocket中accept解读" class="headerlink" title="ServerSocket中accept解读"></a>ServerSocket中accept解读</h1><p><code>ServerSocket</code>的<code>accpet</code>是如何阻塞获取连接的？</p><p><code>accept</code>方法的作用是询问操作系统是否有收到新的<code>Socket</code>套接字信息，操作过程在操作系统底层调用实现上都是 <strong>同步</strong>的。</p><p>操作系统从<code>Socket</code>中没有<code>Socket</code>连接进来怎么办？根据Linux的<code>accept</code>文档描述，以及Java注释的JavaDoc文档描述，都明确说明此时会在底层操作系统<strong>阻塞</strong> 。</p><h2 id="java-net-ServerSocket-accept"><a href="#java-net-ServerSocket-accept" class="headerlink" title="java.net.ServerSocket#accept"></a>java.net.ServerSocket#accept</h2><p>我们从代码层面看看 <code>accept</code> 方法干了啥。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Listens for a connection to be made to this socket and accepts it. The method blocks until a connection is made.</span></span><br><span class="line"><span class="comment">监听并接受与此套接字的连接。该方法会阻塞，直到有一个连接被建立。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">A new Socket s is created and, if there is a security manager, the security manager's checkAccept method is called with s.getInetAddress().getHostAddress() and s.getPort() as its arguments to ensure the operation is allowed. This could result in a SecurityException.</span></span><br><span class="line"><span class="comment">一个新的Socket s被创建，如果有一个安全管理器，安全管理器的checkAccept方法被调用，参数是s.getInetAddress().getHostAddress()和s.getPort()，以确保该操作被允许。这可能会导致一个SecurityException。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Socket <span class="title">accept</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (isClosed())  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Socket is closed"</span>);  </span><br><span class="line">    <span class="keyword">if</span> (!isBound())  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Socket is not bound yet"</span>);  </span><br><span class="line">    Socket s = <span class="keyword">new</span> Socket((SocketImpl) <span class="keyword">null</span>);  </span><br><span class="line">    implAccept(s);  </span><br><span class="line">    <span class="keyword">return</span> s;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java Doc 说明了<code>accept()</code>会进行阻塞，这里疑问比较大的点可能是<code>Socket s = new Socket((SocketImpl) null);</code>，这行代码为什么又要新建一个<code>Socket</code>？带着疑问我们继续看<code>implAccept(s);</code>方法。</p><h2 id="java-net-ServerSocket-implAccept"><a href="#java-net-ServerSocket-implAccept" class="headerlink" title="java.net.ServerSocket#implAccept"></a>java.net.ServerSocket#implAccept</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Subclasses of ServerSocket use this method to override accept() to return their own subclass of socket. So a FooServerSocket will typically hand this method an empty FooSocket. On return from implAccept the FooSocket will be connected to a client.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">ServerSocket的子类使用这个方法来覆盖accept()（的行为），以返回他们自己的socket子类。比如一个FooServerSocket通常会将一个空的FooSocket交给这个方法。从 implAccept 返回时，FooSocket 将被连接到一个客户端。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">implAccept</span><span class="params">(Socket s)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">    SocketImpl si = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">    <span class="comment">// 判断新对象 Socketimpl 是否设置</span></span><br><span class="line">        <span class="keyword">if</span> (s.impl == <span class="keyword">null</span>)  </span><br><span class="line">          s.setImpl();  </span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">            s.impl.reset();  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// si 指向 Socket 对象的 impl </span></span><br><span class="line">        si = s.impl; </span><br><span class="line">        <span class="comment">// Socket 对象的 impl 引用 暂时置空</span></span><br><span class="line">        s.impl = <span class="keyword">null</span>;  </span><br><span class="line">        <span class="comment">// impl 地址和文件描述符初始化</span></span><br><span class="line">        si.address = <span class="keyword">new</span> InetAddress();  </span><br><span class="line">        si.fd = <span class="keyword">new</span> FileDescriptor();  </span><br><span class="line">        <span class="comment">// getImpl() 获取的是 ServerSocket 的 impl，注意不是 Socket的</span></span><br><span class="line"><span class="comment">// 4. 调用 ServerSocket 持有的 SocksSocketImpl 对象完成底层操作系统的 accept 操作</span></span><br><span class="line">        getImpl().accept(si);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// raw fd has been set </span></span><br><span class="line"><span class="comment">// 原始fd已被设置  </span></span><br><span class="line">        SocketCleanable.register(si.fd);    </span><br><span class="line"><span class="comment">// 安全检查</span></span><br><span class="line">        SecurityManager security = System.getSecurityManager();  </span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            security.checkAccept(si.getInetAddress().getHostAddress(),  </span><br><span class="line">                                 si.getPort());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">    <span class="comment">// 如果出现底层IO异常，则s.impl = si;把之前临时置空的引用给重置回来</span></span><br><span class="line">        <span class="keyword">if</span> (si != <span class="keyword">null</span>)  </span><br><span class="line">            si.reset();  </span><br><span class="line">        s.impl = si;  </span><br><span class="line">        <span class="keyword">throw</span> e;  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException e) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (si != <span class="keyword">null</span>)  </span><br><span class="line">            si.reset();  </span><br><span class="line">        s.impl = si;  </span><br><span class="line">        <span class="keyword">throw</span> e;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 把之前临时置空的引用给重置回来</span></span><br><span class="line">    s.impl = si;  </span><br><span class="line">    s.postAccept();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码首先进入一个<code>if</code>判断，检查 <code>new Socket</code> 新对象的<strong>Socketimpl</strong>是否设置，如果为空则就设置，如果不为空，则<code>reset()</code> 重置。</p><p>毫无疑问，这里是刚刚初始化的<code>Socket</code>，此时<strong>Socket.Socketimpl</strong> 肯定是没有设置的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s.impl == <span class="keyword">null</span>)  </span><br><span class="line">  s.setImpl();  </span><br><span class="line"><span class="keyword">else</span> &#123;  </span><br><span class="line">s.impl.reset();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首次进入代码通常就是走<code>if</code>分支。<code>Socket.setImpl</code> 这个方法和<code>ServerSocket</code>的<code>setImpl</code>非常像，<code>new Socket</code> 新对象会为自己的 <strong>SocketImpl</strong> 成员对象进行初始化。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230707160516.png" alt="SocketImpl"></p><p>至此，我们画图理解代码操作逻辑：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230707161437.png" alt="accept 操作分析"></p><p>接下来是一些有点”绕“的操作，建议读者边调试边跟着图示理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. si 指向 Socket 对象的 impl </span></span><br><span class="line">si = s.impl; </span><br><span class="line"><span class="comment">// 2. Socket 对象的 impl引用 暂时置空</span></span><br><span class="line">s.impl = <span class="keyword">null</span>;  </span><br><span class="line"><span class="comment">// 3. impl 地址和文件描述符初始化</span></span><br><span class="line">si.address = <span class="keyword">new</span> InetAddress();  </span><br><span class="line">si.fd = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line"><span class="comment">// getImpl() 获取的是 ServerSocket 的 impl，注意不是 Socket的</span></span><br><span class="line"><span class="comment">// 4. 调用 ServerSocket 持有的 SocksSocketImpl 对象完成底层操作系统的 accept 操作</span></span><br><span class="line">getImpl().accept(si);  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line"><span class="comment">// 假设此时 accept 获取到连接</span></span><br><span class="line">s.impl = si;</span><br></pre></td></tr></table></figure><blockquote><p>这里吐槽下老外这种变量命名给规则，啥<code>si</code>呀<code>s</code>，a，b，c，d 的，不画图很容易绕进去。</p></blockquote><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230707163648.png" alt="ServerSocket 中 accepet 解读"></p><p>格外强调下， <code>getImpl()</code> 的 <strong>impl对象</strong>和 <code>si.impl</code> 对象并不是同一个，这些代码内容非常像但是属于不同的类，切记不要混淆。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230707163430.png" alt="实例对象对比"></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230707163500.png" alt="实例对象对比"></p><p>代码最后有必定会执行的 <code>s.impl = si;</code>操作（因为之前暂时把引用“脱钩”了），如果是异常的<code>si</code>还会进行额外的<code>reset</code>重置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.impl = si;</span><br></pre></td></tr></table></figure><p>这里回答一下之前遗留的问题，<code>Socket s = new Socket((SocketImpl) null);</code>这行代码为什么又要新建一个Socket？</p><p>我们观察上面绘制的操作图，<code>s.impl = null;</code>的执行，此时Socket对象和这个<code>SocketImpl</code>暂时”失去关联“，这个时候确保哪怕<code>new Socket</code>对象绑定失败，此时对于<code>SocketImpl</code>来说根本是无感知的。</p><p>换句话说，如果失败了<code>Socket</code>会完全重置，好像什么都没有发送过，而如果成功了，此时把引用“接回去”，必然得到的可用的<code>Socket</code>。</p><blockquote><p>这里给一个不恰当的比喻，当年诸葛亮草船借箭，如果有碰到没有借箭的船，极端一点是不是就可以直接”烧了“不要了，而如果“接”到箭自然需要回港“卸货‘”，对于吴国来说，它们只看到“成功”借到箭的船只。</p></blockquote><p>执行<code>getImpl().accept(si);</code>方法之后，我们在<strong>AbstractPlainSocketImpl</strong>找到<strong>accept</strong>方法。我</p><h3 id="java-net-AbstractPlainSocketImpl-accept"><a href="#java-net-AbstractPlainSocketImpl-accept" class="headerlink" title="java.net.AbstractPlainSocketImpl#accept"></a>java.net.AbstractPlainSocketImpl#accept</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Accepts connections.</span></span><br><span class="line"><span class="comment">接受连接</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(SocketImpl s)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">    acquireFD();  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        socketAccept(s);  </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">        releaseFD();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>accept</code>调用<code>acquireFD();</code>获取并且植入文件描述符号，加锁获取之后会把<strong>fdUseCount</strong> 的计数器值+1，表示有一个新增的<code>Socket</code>连接。</p><blockquote><p>加锁保证 fdUseCount  计数是线程安全的</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// "Acquires" and returns the FileDescriptor for this impl</span></span><br><span class="line"><span class="comment">// - "获取 "并返回该植入物的文件描述符。</span></span><br><span class="line"><span class="function">FileDescriptor <span class="title">acquireFD</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">synchronized</span> (fdLock) &#123;  </span><br><span class="line">        fdUseCount++;  </span><br><span class="line">        <span class="keyword">return</span> fd;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="java-net-PlainSocketImpl-socketAccept"><a href="#java-net-PlainSocketImpl-socketAccept" class="headerlink" title="java.net.PlainSocketImpl#socketAccept"></a>java.net.PlainSocketImpl#socketAccept</h3><p>不同的操作系统实现不同，这里仅以个人看到的<strong>JDK11</strong>版本源码为例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">socketAccept</span><span class="params">(SocketImpl s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">int</span> nativefd = checkAndReturnNativeFD();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"socket is null"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> newfd = -<span class="number">1</span>;</span><br><span class="line">InetSocketAddress[] isaa = <span class="keyword">new</span> InetSocketAddress[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (timeout &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">newfd = accept0(nativefd, isaa);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">configureBlocking(nativefd, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">waitForNewConnection(nativefd, timeout);</span><br><span class="line">newfd = accept0(nativefd, isaa);</span><br><span class="line"><span class="keyword">if</span> (newfd != -<span class="number">1</span>) &#123;</span><br><span class="line">configureBlocking(newfd, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">configureBlocking(nativefd, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Update (SocketImpl)s' fd */</span></span><br><span class="line">fdAccess.set(s.fd, newfd);</span><br><span class="line"><span class="comment">/* Update socketImpls remote port, address and localport */</span></span><br><span class="line">InetSocketAddress isa = isaa[<span class="number">0</span>];</span><br><span class="line">s.port = isa.getPort();</span><br><span class="line">s.address = isa.getAddress();</span><br><span class="line">s.localport = localport;</span><br><span class="line"><span class="keyword">if</span> (preferIPv4Stack &amp;&amp; !(s.address <span class="keyword">instanceof</span> Inet4Address))</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Protocol family not supported"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只关心下面这部分代码，方法中首先判断 <strong>timeout</strong> 是否小于等于<strong>0</strong>（如果没有设置，那么默认就是 0），如果是则走<code>accept0(nativefd, isaa)</code>方法。</p><p>前面反复提到的，<code>accept</code>操作核心实现这是下面的 <code>native accept0</code> 方法，具体操作是：</p><p><strong>在操作系统层面检查<code>bind</code>的端口上是否有客户端数据接入，如果没有则一直阻塞等待</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (timeout &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">newfd = accept0(nativefd, isaa);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">configureBlocking(nativefd, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">waitForNewConnection(nativefd, timeout);</span><br><span class="line">newfd = accept0(nativefd, isaa);  </span><br><span class="line"><span class="keyword">if</span> (newfd != -<span class="number">1</span>) &#123;</span><br><span class="line">configureBlocking(newfd, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">configureBlocking(nativefd, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// &lt;4&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">accept0</span><span class="params">(<span class="keyword">int</span> fd, InetSocketAddress[] isaa)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><p>因为操作系统层面的阻塞需要影响到应用程序级别阻塞？显然<code>accept0(nativefd, isaa)</code>的操作系统层面阻塞是无 法避免的。</p><p>仔细观察代码，上面的代码分支提供了另外一种选择， <strong>timeout</strong> 的值设置大于0的值，此时<strong>程序会在等到我们设置的时间后返回</strong>，并且只会阻塞设置的这个时间量的值（单位毫秒）。</p><blockquote><p>注意，这里的 <strong>newfd</strong> 如果是 -1，表示底层没有任何数据返回，在Linux的文档中也有对应的介绍。</p></blockquote><h3 id="java-net-ServerSocket-setSoTimeout"><a href="#java-net-ServerSocket-setSoTimeout" class="headerlink" title="java.net.ServerSocket#setSoTimeout"></a>java.net.ServerSocket#setSoTimeout</h3><p>既然不阻塞的关键参数是<strong>timeout</strong> ， 接下来我们看下 <strong>timeout</strong> 值要如何设置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Enable/disable SO_TIMEOUT with the specified timeout, in milliseconds. With this option set to a non-zero timeout, a call to accept() for this ServerSocket will block for only this amount of time. If the timeout expires, a java.net.SocketTimeoutException is raised, though the ServerSocket is still valid. The option must be enabled prior to entering the blocking operation to have effect. The timeout must be &gt; 0. A timeout of zero is interpreted as an infinite timeout.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">启用/禁用SO_TIMEOUT，指定超时时间，单位为毫秒。在这个选项被设置为非零超时的情况下，对这个ServerSocket的accept()的调用将只阻塞这个时间量。如果超时过后，会引发java.net.SocketTimeoutException，尽管ServerSocket仍然有效。该选项必须在进入阻塞操作之前启用才能生效。超时必须大于0。超时为0会被解释为无限期超时。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setSoTimeout</span><span class="params">(<span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> SocketException </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (isClosed())  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Socket is closed"</span>);  </span><br><span class="line">    getImpl().setOption(SocketOptions.SO_TIMEOUT, timeout);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单明了，<strong>java.net.SocketOptions#setOption</strong> 方法最终调用的是<code>java.net.AbstractPlainSocketImpl#setOption()</code>。</p><h3 id="java-net-AbstractPlainSocketImpl-setOption"><a href="#java-net-AbstractPlainSocketImpl-setOption" class="headerlink" title="java.net.AbstractPlainSocketImpl#setOption"></a>java.net.AbstractPlainSocketImpl#setOption</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOption</span><span class="params">(<span class="keyword">int</span> opt, Object val)</span> <span class="keyword">throws</span> SocketException </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (isClosedOrPending()) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Socket Closed"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">boolean</span> on = <span class="keyword">true</span>;  </span><br><span class="line">    <span class="keyword">switch</span> (opt) &#123;  </span><br><span class="line"><span class="keyword">case</span> SO_LINGER:  </span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">    <span class="keyword">case</span> SO_TIMEOUT:  </span><br><span class="line">        <span class="keyword">if</span> (val == <span class="keyword">null</span> || (!(val <span class="keyword">instanceof</span> Integer)))</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Bad parameter for SO_TIMEOUT"</span>);</span><br><span class="line">            <span class="keyword">int</span> tmp = ((Integer) val).intValue();</span><br><span class="line">            <span class="keyword">if</span> (tmp &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout &lt; 0"</span>);</span><br><span class="line">            timeout = tmp;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TCP_NODELAY:  </span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    <span class="keyword">case</span> SO_RCVBUF:  </span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    <span class="keyword">case</span> SO_KEEPALIVE:  </span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;  </span><br><span class="line">    socketSetOption(opt, on, val);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了方便阅读，这里把其他的代码都删除了，只保留传参部分。</p><p>可以看到，这里仅仅是将<code>setOption</code>里面传入的<code>timeout</code>值，设置到了<code>AbstractPlainSocketImpl</code>的全局变量<code>timeout</code>。</p><h2 id="画图小结-1"><a href="#画图小结-1" class="headerlink" title="画图小结"></a>画图小结</h2><p>个人认为整个<code>accept()</code>操作比较”恶心“（个人观点）的是几个引用的赋值变化上面，暂时”解绑“的目的是在进行底层Socket连接的时候，如果<code>Socket</code>出现异常也没有影响，此时<code>Socket</code>持有的引用也是<code>null</code>，可以无阻碍的重新进行下一次Socket连接。</p><p>换句话说，<strong>整个Socket要么对接成功，要么就是重置回没对接之前的状态可以进行下一次尝试，保证ServerSocket会收到一个没有任何异常的Socket连接</strong>。</p><p>最后再看一眼图：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230707175534.png" alt="accept 操作总结"></p><h1 id="改造并实现accept的非阻塞实现"><a href="#改造并实现accept的非阻塞实现" class="headerlink" title="改造并实现accept的非阻塞实现"></a>改造并实现accept的非阻塞实现</h1><p>在进行案例程序的改造之前，必须要先理解<strong>同步、异步、阻塞、非阻塞</strong>这几个概念。</p><p>这个概念在之前的笔记中 [[《跟闪电侠学Netty》阅读笔记 - 开篇入门Netty]] 【洗衣机案例理解阻塞非阻塞，同步异步概念】这一部分提到过，[[【Java】《2小时搞定多线程》个人笔记]] 中又一次对于这几个概念做了个区分。</p><p>区分<strong>同步</strong>和<strong>异步</strong>的关键点是<strong>被调用方的行为</strong>，没有得到结果之前，服务端不返回任何结果，那么操作就是同步的。</p><p>如果没有得到结果之前，服务器可以返回结果，比如给一个<strong>句柄</strong>，通过这个句柄可以在未来某个时间点之后获得结果，那么操作就是<strong>异步</strong>的。</p><blockquote><p>这个句柄可以对应Java 并发编程的 <strong>Future</strong> 的概念</p></blockquote><p>再举个例子，比如说前面的<code>accept0</code>是<strong>应用程序调用操作系统</strong>，在Linux中就是访问系统内核，此时这一整块逻辑处理是选择”<strong>永久等待一个客户端连接</strong>“，符合 <strong>没有得到结果之前，服务端不返回任何结果</strong> 这种情况，所以它是<strong>同步</strong>的。</p><p>区分阻塞和非阻塞的关键点则是 <strong>对于调用者而言的服务端状态*</strong>，比如我们站在线程状态的角度，阻塞对应 <strong>Blocking</strong>，非阻塞此时应该对应<strong>Running</strong>正常执行。再比如站在<strong>线程发出请求</strong>之后请求方的角度，阻塞和非阻塞分别对应<strong>waiting</strong>和<strong>No waiting</strong>。</p><p>理解同步异步阻塞和非阻塞之后，下面来尝试改造相关代码<code>accept</code>的阻塞问题，实现方式很简单，那就是设置 ** <strong>timeout</strong> ** ， 然后在异常处理上<code>continue</code>重试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * accept 超时时间设置  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SO_TIMEOUT = <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * NIO 改写</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> NIO 改写</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> port</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xander</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/7/12 10:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initNioServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">ServerSocket serverSocket = <span class="keyword">null</span>;<span class="comment">//服务端Socket</span></span><br><span class="line">Socket socket = <span class="keyword">null</span>;<span class="comment">//客户端socket</span></span><br><span class="line">BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">String inputContent;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line"><span class="comment">// 1. 需要设置超时时间，会等待设置的时间之后再进行返回</span></span><br><span class="line">serverSocket.setSoTimeout(SO_TIMEOUT);</span><br><span class="line">log.info(stringNowTime() + <span class="string">": serverSocket started"</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">// 2. 如果超时没有获取，这里会抛出异常，这里的处理策略是不处理异常</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">socket = serverSocket.accept();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SocketTimeoutException e) &#123;</span><br><span class="line"><span class="comment">//运行到这里表示本次accept是没有收到任何数据的，服务端的主线程在这里可以做一些其他事情</span></span><br><span class="line">log.info(<span class="string">"now time is: "</span> + stringNowTime());</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">log.info(stringNowTime() + <span class="string">": id为"</span> + socket.hashCode() + <span class="string">"的Clientsocket connected"</span>);</span><br><span class="line">reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line"><span class="keyword">while</span> ((inputContent = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">log.info(<span class="string">"收到id为"</span> + socket.hashCode() + <span class="string">"  "</span> + inputContent);</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">log.info(<span class="string">"id为"</span> + socket.hashCode() + <span class="string">"的Clientsocket "</span> + stringNowTime() + <span class="string">"读取结束"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(Objects.nonNull(reader))&#123;</span><br><span class="line"></span><br><span class="line">reader.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(Objects.nonNull(socket))&#123;</span><br><span class="line"></span><br><span class="line">socket.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">/**运行结果：</span></span><br><span class="line"><span class="comment">     10:40:49.272 [main] INFO com.zxd.interview.niosource.bio.BioServerSocket - 2023-07-12 10:40:49: serverSocket started</span></span><br><span class="line"><span class="comment">     10:40:52.826 [main] INFO com.zxd.interview.niosource.bio.BioServerSocket - now time is: 2023-07-12 10:40:52</span></span><br><span class="line"><span class="comment">     10:40:54.830 [main] INFO com.zxd.interview.niosource.bio.BioServerSocket - now time is: 2023-07-12 10:40:54</span></span><br><span class="line"><span class="comment">     10:40:56.837 [main] INFO com.zxd.interview.niosource.bio.BioServerSocket - now time is: 2023-07-12 10:40:56</span></span><br><span class="line"><span class="comment">     10:40:58.840 [main] INFO com.zxd.interview.niosource.bio.BioServerSocket - now time is: 2023-07-12 10:40:58</span></span><br><span class="line"><span class="comment">     10:41:00.849 [main] INFO com.zxd.interview.niosource.bio.BioServerSocket - now time is: 2023-07-12 10:41:00</span></span><br><span class="line"><span class="comment">     10:41:02.852 [main] INFO com.zxd.interview.niosource.bio.BioServerSocket - now time is: 2023-07-12 10:41:02</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><p>设置了<strong>timeout</strong>之后，<code>accept</code> 方法每次都会在间隔指定时间之后被唤醒一次，如果没有收到连接就会抛出异常，我们的处理方式是吞掉异常并且重新<code>accept</code>，这样就实现了类似非阻塞的效果。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p> Socket 当中 <code>getInputStream()</code> 的方法解析以及后续的<code>read</code>操作结构图如下。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230712151156.png" alt="Socket.getInputStream()"></p><h1 id="Socket-中的-getInputStream-方法解析"><a href="#Socket-中的-getInputStream-方法解析" class="headerlink" title="Socket 中的 getInputStream() 方法解析"></a>Socket 中的 getInputStream() 方法解析</h1><p>实现了非阻塞的<code>accept</code>之后，再来看下另一个会产生阻塞的方法，那就是<code>Socket.getInputStream</code>，这个方法在Socket连接，服务端在<code>read()</code> 读取数据的时候会进行调用。</p><p><strong>java.net.Socket#getInputStream</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">返回该socket的输入流。</span></span><br><span class="line"><span class="comment">如果该套接字有一个关联的通道，那么生成的输入流会将其所有操作委托给该通道。如果通道处于非阻塞模式，那么输入流的读操作将抛出java.nio.channel.IllegalBlockingModeException。</span></span><br><span class="line"><span class="comment">在异常情况下，底层连接可能会被远程主机或网络软件中断（例如在TCP连接中的连接重置）。当网络软件检测到连接断开时，返回的输入流会出现以下情况：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isClosed())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Socket is closed"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!isConnected())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Socket is not connected"</span>);</span><br><span class="line">        <span class="keyword">if</span> (isInputShutdown())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Socket input is shutdown"</span>);</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            is = AccessController.doPrivileged(</span><br><span class="line">                <span class="keyword">new</span> PrivilegedExceptionAction&lt;&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> InputStream <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> impl.getInputStream();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.security.PrivilegedActionException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (IOException) e.getException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> is;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面通过<code>AccessController</code>进行授权，<code>run</code>方法中调用<strong>java.net.AbstractPlainSocketImpl#getInputStream</strong>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">    <span class="keyword">synchronized</span> (fdLock) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (isClosedOrPending())  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Socket Closed"</span>);  </span><br><span class="line">        <span class="keyword">if</span> (shut_rd)  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Socket input is shutdown"</span>);  </span><br><span class="line">        <span class="keyword">if</span> (socketInputStream == <span class="keyword">null</span>)  </span><br><span class="line">            socketInputStream = <span class="keyword">new</span> SocketInputStream(<span class="keyword">this</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> socketInputStream;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，代码中创建了 <strong>SocketInputStream</strong> 对象，并且会将当前<code>AbstractPlainSocketImpl</code>对象传进去（这个对象实际就是 <strong>SocksSocketImpl</strong> ）。</p><p><code>read</code>读数据的时候，则会调用如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> read(b, off, length, impl.getTimeout());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> length, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EOF already encountered</span></span><br><span class="line"><span class="keyword">if</span> (eof) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// connection reset</span></span><br><span class="line"><span class="keyword">if</span> (impl.isConnectionReset()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Connection reset"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bounds check</span></span><br><span class="line"><span class="keyword">if</span> (length &lt;= <span class="number">0</span> || off &lt; <span class="number">0</span> || length &gt; b.length - off) &#123;</span><br><span class="line"><span class="keyword">if</span> (length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"length == "</span> + length</span><br><span class="line">+ <span class="string">" off == "</span> + off + <span class="string">" buffer length == "</span> + b.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// acquire file descriptor and do the read</span></span><br><span class="line"><span class="comment">// 获取文件描述符并进行读取</span></span><br><span class="line">FileDescriptor fd = impl.acquireFD();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">n = socketRead(fd, b, off, length, timeout);</span><br><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ConnectionResetException rstExc) &#123;</span><br><span class="line">impl.setConnectionReset();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">impl.releaseFD();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we get here we are at EOF, the socket has been closed,</span></span><br><span class="line"><span class="comment"> * or the connection has been reset.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (impl.isClosedOrPending()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Socket closed"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (impl.isConnectionReset()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Connection reset"</span>);</span><br><span class="line">&#125;</span><br><span class="line">eof = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点关注下面这一行代码，这里在读取的时候同样传递了 <strong>timeout</strong> 参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n = socketRead(fd, b, off, length, timeout);</span><br></pre></td></tr></table></figure><p><strong>socketRead</strong> 方法会调用 <strong>native</strong> 的 <code>socketRead0</code> 方法，<strong>timeout</strong> 代表了读取的超时时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">socketRead0</span><span class="params">(FileDescriptor fd,  </span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len,  </span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> timeout)</span>  </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><p><strong>timeout</strong> 参数源于前面的<code>new SocketInputStream(this)</code>（也就是 <strong>AbstractPlainSocketImpl</strong> 对象）中的<strong>this</strong>引用<code>impl.getTimeout()</code>，这个参数的作用是指定<code>read</code>的超时时间，超时之后没有结果抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serverSocket.setSoTimeout(SO_TIMEOUT);</span><br></pre></td></tr></table></figure><p>了解<code>read</code>方法中<code>timeout</code>的作用之后，我们便可以着手改造代码了，具体的改造部分个人放到后文单独的 <code>titile</code> 进行说明，方便后续回顾。</p><p>此外，这里经过仔细考虑，判断这部分代码读者很有可能会存在理解误区，误以为此处的 <strong>AbstractPlainSocketImpl</strong> 属于 <strong>ServerSocket</strong>，实际上它属于 <strong>Socket</strong>，也就是说我们设置的 <code>timeout</code> 是设置到 <strong>Socket</strong> 的 <strong>AbstractPlainSocketImpl</strong> 。</p><p>最为简单的证明方法是先在  <strong>java.net.Socket#setImpl</strong> 中打上断点，在启动BIO的服务端之后，立即启动客户端，具体的Debug断点如下：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230712160311.png" alt="Socket 的 setImpl"></p><p>通过单步调试，我们在<strong>BioServerSocket</strong> 中看到两个对象是不一样的。</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230712160613.png" alt="BioServerSocket"></p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230712160628.png" alt="对象对比"></p><p>为什么不一样呢？这里需要回顾前面的【ServerSocket中accept 解读】这一部分的操作。这里把重要操作标记了一下：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230712161314.png" alt="ServerSocket中accept解读可能的理解误区1"></p><p>这里复习之前提到的内容，在<strong>accept();</strong> 中为了确保Socket连接是正确并且可用的，每次都会<code>new Socket()</code>，而这里的<code>SocksSocketImpl</code> 是属于 <strong>Socket</strong> 的成员变量。</p><p>在进行Socket套接字连接之前会先判断是否初始化，如果初始化没有就先进行初始化（具体可以看红框框的位置）。</p><p>如果还是理解不了，那么只能再次寄出另一张杀手锏图了：</p><p><img src="https://adong-picture.oss-cn-shenzhen.aliyuncs.com/adong/20230712163105.png" alt="ServerSocket中accept解读可能的理解误2"></p><h1 id="实现-Socket-中的-read-方法非阻塞"><a href="#实现-Socket-中的-read-方法非阻塞" class="headerlink" title="实现 Socket 中的 read 方法非阻塞"></a>实现 Socket 中的 read 方法非阻塞</h1><p><strong>AbstractPlainSocketImpl</strong>实现<code>socketRead</code>方法非阻塞，具体做法其实就是使用 <strong>AbstractPlainSocketImpl</strong> 传入了 <strong>timeout</strong> 参数，实现 <strong>SocketInputStream</strong> 非阻塞<code>read</code>。</p><p>表面上看上去 <strong>read</strong> 方法是非阻塞的，实际上这里存在一个明显的 <strong>误区</strong>，那就是在<code>socket = serverSocket.accept();</code>这一段代码中，服务端构建出 <code>Socket</code> 连接之后，客户端和服务端交互是通过独立的<code>Socket</code>对象完成IO读写的。</p><p>然而在第一次改造过后，实际上还有两点不易察觉的问题：</p><p>（1）服务端<code>read</code>的非阻塞轮询效率非常低，基本上是“一核繁忙、多核围观”的情况。</p><p>（2）第一次改造设置的是设定的是<strong>ServerSocket级别</strong>的<strong>SocksSocketImpl</strong>的timeout。每个新的客户端进来都是新的Socket连接，每个Socket又有各自的 <strong>SocksSocketImpl</strong>，这里<strong>客户端连接所产生新的Socket</strong>的<strong>timeout</strong>是没有做设置的，换句话说，服务端针对每个Socket的<code>read</code>依然是完全阻塞。</p><p>前文提到，在BIO非阻塞同步模型中，我们虽然没法解决 系统底层”同步” 问题，但是我们可以让“非阻塞”这一块更为优化合理和更为高效。</p><p>第一个问题的解决策略是启动<strong>多线程</strong>以非阻塞<code>read()</code>方式轮询，这样做的另一点好处是，某个Socket读写压力大并不会影响CPU 切到其他线程的正常工作。</p><p>解决第二点问题，我们需要为<strong>每个新的Socket</strong>设置 <strong>timeout</strong>。</p><p>解决上面两个问题，真正BIO非阻塞实现才算是真正成立，下面我们来看下第二版代码优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. NIO 改写，accept 非阻塞</span></span><br><span class="line"><span class="comment">     * 2. 实现 read() 同样非阻塞</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> port</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> xander</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2023/7/12 16:38</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initNioAndNioReadServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">null</span>;<span class="comment">//服务端Socket</span></span><br><span class="line">        Socket socket = <span class="keyword">null</span>;<span class="comment">//客户端socket</span></span><br><span class="line">        BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">        ExecutorService threadPool = Executors.newCachedThreadPool();</span><br><span class="line">        String inputContent;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">            <span class="comment">// 1. 需要设置超时时间，会等待设置的时间之后再进行返回</span></span><br><span class="line">            serverSocket.setSoTimeout(SO_TIMEOUT);</span><br><span class="line">            log.info(stringNowTime() + <span class="string">": serverSocket started"</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 2. 如果超时没有获取，这里会抛出异常，这里的处理策略是不处理异常</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket = serverSocket.accept();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SocketTimeoutException e) &#123;</span><br><span class="line">                    <span class="comment">//运行到这里表示本次accept是没有收到任何数据的，服务端的主线程在这里可以做一些其他事情</span></span><br><span class="line">                    log.info(<span class="string">"now time is: "</span> + stringNowTime());</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 3. 拿到Socket 之后，应该使用线程池新开线程方式处理客户端连接，提高CPU利用率。</span></span><br><span class="line">                Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ClientSocketThread(socket));</span><br><span class="line">                threadPool.execute(thread);</span><br><span class="line"><span class="comment">//                log.info(stringNowTime() + ": id为" + socket.hashCode() + "的Clientsocket connected");</span></span><br><span class="line"><span class="comment">//                reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                while ((inputContent = reader.readLine()) != null) &#123;</span></span><br><span class="line"><span class="comment">//                    log.info("收到 id为" + socket.hashCode() + "  " + inputContent);</span></span><br><span class="line"><span class="comment">//                    count++;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//                log.info("id为" + socket.hashCode() + "的Clientsocket " + stringNowTime() + "读取结束");</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (Objects.nonNull(reader)) &#123;</span><br><span class="line">                    reader.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (Objects.nonNull(socket)) &#123;</span><br><span class="line"></span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 改写 客户端 Socket 连接为单独线程处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ClientSocketThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SO_TIMEOUT = <span class="number">2000</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SLEEP_TIME = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Socket socket;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ClientSocketThread</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">            String inputContent;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.setSoTimeout(SO_TIMEOUT);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SocketException e1) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">while</span> ((inputContent = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            log.info(<span class="string">"收到id为"</span> + socket.hashCode() + <span class="string">"  "</span> + inputContent);</span><br><span class="line">                            count++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="comment">//执行到这里表示read方法没有获取到任何数据，线程可以执行一些其他的操作</span></span><br><span class="line">                        log.info(<span class="string">"Not read data: "</span> + stringNowTime());</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//执行到这里表示读取到了数据，我们可以在这里进行回复客户端的工作</span></span><br><span class="line">                    log.info(<span class="string">"id为"</span> + socket.hashCode() + <span class="string">"的Clientsocket "</span> + stringNowTime() + <span class="string">"读取结束"</span>);</span><br><span class="line">                    Thread.sleep(SLEEP_TIME);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (Objects.nonNull(reader)) &#123;</span><br><span class="line">                        reader.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (Objects.nonNull(socket)) &#123;</span><br><span class="line">                        socket.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>经过上面的改造，我们基本把 BIO 同步阻塞的工作方式更新为 <strong>同步非阻塞</strong>的工作方式，核心是对于 <code>read()</code>以及服务端接收新连接的<code>accept()</code>设置<code>timeout</code>参数。</p><p>在外部处理上，通过<code>while(true)</code> 加上“吞异常”方式，结合<code>Thread.sleep()</code>的套路实现“非阻塞”定期<code>accept</code>。</p><p>当然，我们也可以看到，通过线程池每次都构建新线程的方式，在连接比较少的时候是比较高效的，但是一旦连接暴增，理论上JVM虽然可以构建非常多线程，实际上CPU肯定是吃不消，多线程“空轮询”判断的方式也十分浪费CPU资源，多线程切换起来更是雪上加霜。</p><blockquote><p>基于BIO的种种弊端，Sun 在JDK1.4 提供了 NIO 来解决上面的几点问题。</p></blockquote><h1 id="native-accept方法在Linux运作解读"><a href="#native-accept方法在Linux运作解读" class="headerlink" title="native accept方法在Linux运作解读"></a>native <code>accept</code>方法在Linux运作解读</h1><p><span class="exturl" data-url="aHR0cHM6Ly9saW51eC5kaWUubmV0L21hbi8yL2FjY2VwdA==" title="https://linux.die.net/man/2/accept">accept(2): accept connection on socket - Linux man page (die.net)<i class="fa fa-external-link"></i></span></p><p>原始文档相关解读：[[【Linux】accept(2) - Linux man page]]，下面的内容基本为文档的翻译和理解介绍。</p><p><code>accept()</code>本地方法，我们可以来试着看一看Linux这块的相关解读：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd,struct sockaddr *addr,socklen_t *addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p><code>accept()</code>系统调用主要用在基于连接的套接字类型，比如<strong>SOCK_STREAM</strong>和<strong>SOCK_SEQPACKET</strong>。它提取出所监听套接字的等待连接队列中第一个连接请求，<strong>创建一个新的套接字</strong>，并返回指向该套接字的文件描述符。新建立的套接字不在监听状态，原来所监听的套接字也不受该系统调用的影响。</p><p><strong>备注：新建立的套接字准备发送<code>send()</code>和接收数据<code>recv()</code>。</strong></p><p><strong>sockfd</strong>，作用是 利用系统调用<code>socket()</code>建立的套接字描述符，通过<code>bind()</code>绑定到一个本地地址(一般为服务器的套接字)，并且通过<code>listen()</code>一直在监听连接；</p><p><strong>addr</strong>, 指向<code>struct sockaddr</code>的指针，该结构用通讯层服务器对等套接字的地址(一般为客户端地址)填写，返回地址<code>addr</code>的确切格式由套接字的地址类别(比如TCP或UDP)决定；</p><p>若<code>addr</code>为NULL，没有有效地址填写，这种情况下，addrlen也不使用，应该置为NULL；</p><p><strong>备注：addr是个指向局部数据结构sockaddr_in的指针，这就是要求接入的信息本地的套接字(地址和指针)。</strong></p><p><code>addrlen</code>， 代表一个值结果参数，调用函数必须初始化为包含addr所指向结构大小的数值，函数返回时包含对等地址(一般为服务器地址)的实际数值；</p><p><strong>备注：addrlen是个局部整形变量，设置为<code>sizeof(struct sockaddr_in)</code>。</strong></p><p>如果队列中没有等待的连接，套接字也没有被标记为Non-blocking，accept()会阻塞调用函数直到连接出现；如果套接字被标记为Non-blocking，队列中也没有等待的连接，accept()返回错误<strong>EAGAIN</strong>或<strong>EWOULDBLOCK</strong>。</p><p><strong>备注：一般来说accept()为阻塞函数，当监听socket调用accept()时，它先到自己的receive_buf中查看是否有连接数据包；若有，把数据拷贝出来，删掉接收到的数据包，创建新的socket与客户发来的地址建立连接；若没有，就阻塞等待；</strong></p><p>为了在套接字中有到来的连接时得到通知，可以使用<strong>select()</strong> 或<strong>poll()</strong>。当尝试建立新连接时，系统发送一个可读事件，然后调用<code>accept()</code>为该连接获取套接字。另一种方法是，当套接字中有连接到来时设定套接字发送SIGIO信号。</p><p>返回值成功时，返回非负整数，该整数是接收到套接字的描述符；<strong>出错时会返回－1</strong>，相应地设定全局变量error。</p><p>所以，在Java部分的源码里（<strong>java.net.ServerSocket#accept</strong>）会new 一个Socket出来，方便连接后拿到的新Socket的文件描述符的信息给设定到我们new出来的这个Socket 上来，这点在<code>java.net.PlainSocketImpl#socketAccept</code>中看到的尤为明显，读者可以回顾相关源码。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文一开始介绍了Bio Socket的基本代码，接着从<code>ServerSocket</code>的<code>bind</code>方法解读，通过图文结合的方式介绍了源码如何处理，整个<code>bind</code>操作过程中有许多<code>native</code>层调用，所以Socket的代码调试是非常麻烦的。</p><p>介绍完<code>bind</code>之后，我们接着介绍了<code>ServerSocket</code>中<code>accept</code>方法，并且介绍了<code>accept</code> 方法的阻塞问题实际上和底层的操作系统行为有关，并且通过画图的方式理解<code>accept</code>中Socket连接比较“绕”的操作。</p><p>最后，文章的后半部分介绍了如何改造<code>accept</code>以及客户端的<code>Socket</code>连接解决非阻塞问题IO，最后我们介绍了  <code>native accept</code>方法在Linux运作，主要内容为Linux的相关文档理解。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>理解Socket的非阻塞操作有助于理解 NIO的Channel和Buffer的概念，实际上从我们的Demo代码可以看到Channel和非阻塞的BIO思路比较类似，而BufferReader缓冲流则贴合了 Buffer 的概念。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubGludXhqb3VybmFsLmNvbS9maWxlcy9saW51eGpvdXJuYWwuY29tL2xpbnV4am91cm5hbC9hcnRpY2xlcy8wMjMvMjMzMy8yMzMzczIuaHRtbA==" title="https://www.linuxjournal.com/files/linuxjournal.com/linuxjournal/articles/023/2333/2333s2.html">Linux Network Programming, Part 1 (linuxjournal.com)<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMDQ4NzQ2MDU=" title="https://zhuanlan.zhihu.com/p/104874605">详解socket中的backlog 参数 - 知乎 (zhihu.com)<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTAzNzUxMTc4NzgwNjg2" title="https://juejin.cn/post/6844903751178780686">BIO到NIO源码的一些事儿之BIO - 掘金 (juejin.cn)<i class="fa fa-external-link"></i></span></p><h2 id="CachedThreadPool的工作原理"><a href="#CachedThreadPool的工作原理" class="headerlink" title="CachedThreadPool的工作原理"></a>CachedThreadPool的工作原理</h2><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,  </span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS, <span class="comment">//60s </span></span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）corePoolSize = 0，maximumPoolSize = 最大值（无限大），keepAliveTime = 60s，workQueue = <strong>SynchronousQueue</strong></p><p>（2）<strong>SynchronousQueue</strong>（实际上没有存储数据的空闲，是用来做多线程通信之间的协调作用的）。一开始提交一个任务过来，要求线程池里<strong>必须有一个线程对应可以处理这个任务</strong>，但是此时一个线程都没有，poolSize &gt;= corePoolSize , workQueue已经满了，poolSize &lt; maximumPoolSize（最大值），直接就会<strong>创建一个新的线程来处理这个任务</strong>。</p><blockquote><p>这样的效果也就是来一个任务就开一个线程，无界，无限开新线程，线程过多容易导致JVM的压力过大甚至直接崩溃。这也是为什么阿里巴巴规范禁掉这个方法的直接原因，容易误用。</p></blockquote><p>（3）如果短期内有大量的任务都涌进来，实际上是走一个直接提交的思路，对每个任务，如果没法找到一个空闲的线程来处理它，那么就会立即创建一个新的线程出来，来处理这个新提交的任务</p><p>（4）短时间内，如果大量的任务涌入，可能会导致瞬间创建出来几百个线程，几千个线程，是不固定的。</p><p>（5）但是当这些线程工作完一段时间之后，就会处于空闲状态，就会看超过60s的空闲，就会直接将空闲的线程给释放掉。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      网络IO编程
    
    </summary>
    
    
      <category term="Java" scheme="https://whitestore.top/categories/Java/"/>
    
    
      <category term="Java" scheme="https://whitestore.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Java】Generics in Java</title>
    <link href="https://whitestore.top/2023/07/27/genericjava/"/>
    <id>https://whitestore.top/2023/07/27/genericjava/</id>
    <published>2023-07-27T03:32:00.000Z</published>
    <updated>2023-09-09T00:53:49.935Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><p><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BzYWxpdGhhY2hhdGh1cmFuZ2E5NC9nZW5lcmljcy1pbi1qYXZhLTNjNzkxNTU1ZTkyNA==" title="https://medium.com/@salithachathuranga94/generics-in-java-3c791555e924">Generics in Java. It’s all about type safety | by Salitha Chathuranga | Medium<i class="fa fa-external-link"></i></span></p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>It’s all about type safety。</p><p>所有内容都是关于线程安全。</p><p><img src="https://miro.medium.com/v2/resize:fit:875/1*77SYONEADgKEPiyVPqUb-A.png" alt=""></p><p>Hi all!!!</p><p>I thought of writing a widely used but less discussed topic in Java. That is <strong>Generics</strong>! We use it, but majority of the developers don’t know about it as I have experienced.</p><p>本次编写的有关内容是讨论较少主题，“<strong>泛型</strong>”，实际上我们经常使用（实际上天天都在用），但是大部分人并不了解。</p><p>Let me clear this…have you ever used List or <strong>ArrayList</strong> in Java? Most probably, answer should be YES. Right? Without collections, we can’t even think of an easy way of handling data. So, do you remember how we define an ArrayList?</p><p>让我澄清一下……您在Java中使用过List或<strong>ArrayList</strong>吗？答案很可能是 “是”。对不对？如果没有集合，我们甚至无法想象处理数据的简单方法。那么，你还记得我们是如何定义ArrayList的吗？</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// with Generics</span></span><br></pre></td></tr></table></figure><p>This is the way we declare it. So, we have used generics. 😃 Here, <code>_&lt;Integer&gt;</code>_ is the Generic we passed. That is a Type. After we create list like this, you can <strong>only add integers</strong> to the list.</p><p>在上面的例子中我们在泛型中指定<code>&lt;Integer&gt;</code>，之后我们创建的List<strong>只能添加</strong>整型类型数据。</p><p>You may remember, if we define the list like below, we would be able to add any type of data which is extended from Object super class, to the list.</p><p>如果我们在定义List的时候不指定任何泛型，我们可以添加任意类型的数据，这些数据是从对象超类中扩展出来的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List numbers = <span class="keyword">new</span> ArrayList(); <span class="comment">// without Generics</span></span><br></pre></td></tr></table></figure><p>We can achieve Type Safety for this List, after we add generics.</p><p>为了实现类型安全，之后我们可以添加泛型。</p><p><strong>Generics</strong> means <strong>parameterized types.</strong> Java let us to create a single class, interface, and method that can be used with different types of data(objects) within the Generics domain.</p><p>泛型也叫参数化类型，Java允许我们创建单一的类、接口和方法，这些类、接口和方法可用于泛型域内的不同类型的数据（对象）。</p><p><strong>Advantages in Generics would be:</strong></p><p>泛型的优点如下：</p><ul><li>Code Reusability — we can use a common code with multiple object types</li></ul><p>代码复用性：我们可以使用通用代码包含多种不同对象类型。</p><ul><li>Compile-time Type Checking — Java will check the generics code at the compile time against errors</li></ul><p>编译时期的类型检查：实现Java在编译时期进行类型检查。</p><ul><li>Type Safety — we can restrict adding unnecessary data</li></ul><p>类型安全：可以限制添加不必要的数据</p><ul><li>Usage in Collections — Collections need object types to deal with data</li></ul><p>集合中使用：集合需要对象类型的数据，泛型可以更好的控制。</p><p><em>Let’s take and example to explain why we need Generics..</em></p><p>下面举个栗子介绍为什么需要泛型。</p><p>Imagine you have to print Numbers and Texts using a printer class. Printer has a method that accepts the data while creating it.</p><p>想象一下你需要数字或者文本类型的打印机对象，打印机在创建时有一个接受数据的方法。</p><p>In traditional way, we will have to creat 2 classes since we have 2 types of data: Number(Integer) and Text(String).</p><p>按照传统的方式，我们会创建两个对象，根据需要的打印机类型构建字符串和整型（打印机）对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextPrinter</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String data;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TextPrinter</span><span class="params">(String data)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.data = data;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"print::: "</span> + data);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberPrinter</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer data;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumberPrinter</span><span class="params">(Integer data)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.data = data;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"print::: "</span> + data);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>How to use:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsMain</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        NumberPrinter numberPrinter = <span class="keyword">new</span> NumberPrinter(<span class="number">5</span>);  </span><br><span class="line">        numberPrinter.print(); <span class="comment">// output = print::: 5  </span></span><br><span class="line">        TextPrinter textPrinter = <span class="keyword">new</span> TextPrinter(<span class="string">"Hello"</span>);  </span><br><span class="line">        textPrinter.print();   <span class="comment">// output = print::: Hello  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>You can see we have <strong>code duplication</strong>! Data type is the only difference here!</p><p>你会发现这里有重复代码，这里仅仅是对象类型不同。</p><p>We can simply use a Printer with a Generic here. Then we will only have 1 Printer! 😎</p><p>只需要非常简单的添加一个泛型，</p><p>Let’s deep dive into Generics and see how we achieve this… 😎</p><p>让我们深入了解泛型，看看如何实现这一点…… </p><h1 id="Create-a-Generic-创建通用型"><a href="#Create-a-Generic-创建通用型" class="headerlink" title="Create a Generic 创建通用型"></a>Create a Generic 创建通用型</h1><p>I’m taking the above simple example and will show how to create a <strong>Generic</strong> Printer.</p><p>我将以上面的简单示例来说明如何创建一个<strong>通用</strong>打印机。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Printer</span>&lt;<span class="title">T</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T data;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Printer</span><span class="params">(T data)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.data = data;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"print::: "</span> + data);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>How to use:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Printer&lt;Integer&gt; integerPrinter = <span class="keyword">new</span> Printer&lt;&gt;(<span class="number">5</span>);  </span><br><span class="line">integerPrinter.print();   <span class="comment">// output = print::: 5  </span></span><br><span class="line">  </span><br><span class="line">Printer&lt;String&gt; stringPrinter = <span class="keyword">new</span> Printer&lt;&gt;(<span class="string">"Hello"</span>);  </span><br><span class="line">stringPrinter.print();   <span class="comment">// output = print::: Hello  </span></span><br><span class="line">  </span><br><span class="line">Printer&lt;Double&gt; doublePrinter = <span class="keyword">new</span> Printer&lt;&gt;(<span class="number">45.34</span>);  </span><br><span class="line">doublePrinter.print();   <span class="comment">// output = print::: 45.34  </span></span><br><span class="line">  </span><br><span class="line">Printer&lt;Long&gt; longPrinter = <span class="keyword">new</span> Printer&lt;&gt;(<span class="number">5L</span>);  </span><br><span class="line">longPrinter.print();z    <span class="comment">// output = print::: 5</span></span><br></pre></td></tr></table></figure><p>Now we only have 1 class! It accepts a Type. Here, T is used to denote the Type as a common standard. We can even create printer objects for other data types also like Double/Long. <strong>Code reusability</strong> is achieved in style. 😎</p><p>现在我们只需要一个类就可以完成构建两种不同类型的打印机，这里的 T 表示作为通用标准的类型，我们甚至可以把这个T改为  Double/Long 类型，最终实现了 “代码重用性” 的风格。</p><p>We can create Generic classes which accepts more than 1 type. Look at the below example. It accepts an Integer and a String both.</p><p>我们可以创建接受多种类型的通用类。请看下面的示例，它同时接受一个整数和一个字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiPrinter</span>&lt;<span class="title">T</span>, <span class="title">V</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T data1;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> V data2;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MultiPrinter</span><span class="params">(T data1, V data2)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.data1 = data1;  </span><br><span class="line">        <span class="keyword">this</span>.data2 = data2;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"print::: "</span> + data1 + <span class="string">" : "</span> + data2);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MultiPrinter&lt;Integer, String&gt; multiPrinter = <span class="keyword">new</span> MultiPrinter&lt;&gt;(<span class="number">5</span>, <span class="string">"Hello"</span>);  </span><br><span class="line">multiPrinter.print(); <span class="comment">// output = print::: 5 : Hello</span></span><br></pre></td></tr></table></figure><p><strong>Java Type Naming conventions</strong></p><ul><li>E — Element (used in Collections)</li><li>K — Key (Used in Map)</li><li>N — Number</li><li>T — Type</li><li>V — Value (Used in Map)</li><li>S, U, V etc. — 2nd, 3rd, 4th types</li></ul><p><strong>Java类型命名规则</strong></p><ul><li>E - 元素（在集合中使用）</li><li>K - 键（在地图中使用）</li><li>N - 数字</li><li>T - 类型</li><li>V - 值（在映射中使用）</li><li>S、U、V 等 - 第二、第三、第四类型</li></ul><h1 id="Bounded-Generics-有限泛型"><a href="#Bounded-Generics-有限泛型" class="headerlink" title="Bounded Generics 有限泛型"></a>Bounded Generics 有限泛型</h1><p>This is an advanced version of Generics. We can restrict more and achieve <strong>more type safety</strong> with bounded Generics.</p><p>这是泛型的高级版本。通过有界泛型，我们可以限制更多，实现<strong>多的类型安全</strong>。</p><p>Let’s say we have an <strong>AnimalPrinter</strong> class which can only print animal details. No other objects are allowed to be used with it. How to achieve this?</p><p>假设我们有一个<strong>AnimalPrinter</strong>类，它只能打印动物的详细信息。不允许使用其他对象。如何实现？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String color;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer age;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name, String color, Integer age)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">        <span class="keyword">this</span>.color = color;  </span><br><span class="line">        <span class="keyword">this</span>.age = age;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> color;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> age;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">        Animal animal = (Animal) o;  </span><br><span class="line">        <span class="keyword">return</span> Objects.equals(name, animal.name) &amp;&amp; Objects.equals(color, animal.color) &amp;&amp; Objects.equals(age, animal.age);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, color, age);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String name, String color, Integer age)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">super</span>(name, color, age);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String name, String color, Integer age)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">super</span>(name, color, age);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalPrinter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Animal</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T animalData;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AnimalPrinter</span><span class="params">(T animalData)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.animalData = animalData;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Name::: "</span> + animalData.getName());  </span><br><span class="line">        System.out.println(<span class="string">"Color::: "</span> + animalData.getColor());  </span><br><span class="line">        System.out.println(<span class="string">"Age::: "</span> + animalData.getAge());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In this class, T extends Animal part does the job! We have limited our generic for Dog and Cat!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AnimalPrinter&lt;Cat&gt; animalPrinter1 = <span class="keyword">new</span> AnimalPrinter&lt;&gt;(<span class="keyword">new</span> Cat(<span class="string">"Jim"</span>, <span class="string">"brown"</span>, <span class="number">2</span>));  </span><br><span class="line">animalPrinter1.print();  </span><br><span class="line">AnimalPrinter&lt;Dog&gt; animalPrinter2 = <span class="keyword">new</span> AnimalPrinter&lt;&gt;(<span class="keyword">new</span> Dog(<span class="string">"Rocky"</span>, <span class="string">"black"</span>, <span class="number">5</span>));  </span><br><span class="line">animalPrinter2.print();</span><br></pre></td></tr></table></figure><p>If we try to define the printer with another Object type, compiler will complain like this =&gt; <em>“Type parameter ‘java.lang.Object’ is not within its bound; should extend ‘generics.Animal’</em></p><p>如果我们尝试使用其他对象类型定义打印机，编译器将发出如下警告 =&gt; <em>“类型参数’java.lang.Object’不在其绑定范围内；应该扩展’generics.Animal’</em>“。</p><h1 id="Multiple-Bounds-多重边界"><a href="#Multiple-Bounds-多重边界" class="headerlink" title="Multiple Bounds 多重边界"></a>Multiple Bounds 多重边界</h1><p>Let’s say we want to add some more features to the Printer generic. We can achieve it like this.</p><p>比方说，我们想为打印机通用程序添加更多的功能。我们可以这样实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalPrinter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Animal</span> &amp; <span class="title">Serializable</span>&gt; </span>&#123;  </span><br><span class="line">    ..................  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>I have provided Serializable functionality using Serializable interface. There are important things to remember here.</p><ul><li>We must implement interface in our child classes(Cat and Dog).</li><li>Class should come first and the &amp; and interface.</li><li>Only 1 class can be extended since Java does not support multiple inheritance.</li></ul><p>我使用Serializable接口提供了Serializable功能。这里有一些重要的事情需要记住。</p><ul><li>我们必须在子类（Cat和Dog）中实现接口。</li><li>类应该放在前面，然后是 <strong>&amp;</strong> 和 <strong>接口</strong>。</li><li>由于Java不支持多重继承，所以只能扩展一个类。</li></ul><h1 id="Wildcards-With-Generics-通用通配符"><a href="#Wildcards-With-Generics-通用通配符" class="headerlink" title="Wildcards With Generics 通用通配符"></a>Wildcards With Generics 通用通配符</h1><p>Wildcards are represented by the question mark <em>?</em> in Java, and we use them to refer to an unknown type. This can be used as a parameter type with Generics. Then it will accept any type. I have used a List of any object as a method argument using wild card, in the below code.</p><p>通配符在Java中用问号 <em>?</em> 表示，我们用它来代指<strong>未知类型</strong>。通配符在Java中用问号 <em>?</em> ，然后它将接受任何类型。在下面的代码中，我使用通配符将任意对象的List作为方法参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(List&lt; ?&gt; list)</span> </span>&#123;  </span><br><span class="line">    System.out.println(list);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">printList(  </span><br><span class="line">    Arrays.asList(  </span><br><span class="line">        <span class="keyword">new</span> Cat(<span class="string">"Jim"</span>, <span class="string">"brown"</span>, <span class="number">2</span>),  </span><br><span class="line">        <span class="keyword">new</span> Dog(<span class="string">"Rocky"</span>, <span class="string">"black"</span>, <span class="number">5</span>)  </span><br><span class="line">    )  </span><br><span class="line">);  </span><br><span class="line">printList(Arrays.asList(<span class="number">50</span>, <span class="number">60</span>));  </span><br><span class="line">printList(Arrays.asList(<span class="number">50.45</span>, <span class="number">60.78</span>));  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// output:  </span></span><br><span class="line"><span class="comment">// [generics.Cat@b1fa3959, generics.Dog@62294cd9]  </span></span><br><span class="line"><span class="comment">// [50, 60]  </span></span><br><span class="line"><span class="comment">// [50.45, 60.78]</span></span><br></pre></td></tr></table></figure><p>List can be of any type now!!!</p><p>List 现在可以是任意类型的。</p><p>1️⃣ <strong>Upper Bounded Wild Cards</strong></p><p>1️⃣ <strong>上界通配符</strong></p><p>Consider this example:</p><p>考虑下面的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAnimals</span><span class="params">(List&lt;Animal&gt; animals)</span> </span>&#123;  </span><br><span class="line">      animals.forEach(Animal::eat);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If we imagine a subtype of <em>Animal</em>, such as a <em>Dog</em>, we can’t use this method with a list of <em>Dog</em>, even though <em>Dog</em> is a subtype of <em>Animal</em>. We can do this with a wild card.</p><p>如果我们想象一个 <em>Animal</em> 的子类型，例如 <em>Dog</em> ，我们就不能在 <em>Dog</em> 的列表中使用这个方法，尽管 <em>Dog</em> 是 <em>Animal</em> 的子类型。</p><p>我们可以使用通配符来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAnimals</span><span class="params">(List&lt;? extends Animal&gt; animals)</span> </span>&#123;  </span><br><span class="line">    ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now this method works with type <strong><em>Animal</em></strong> and all <strong><em>its subtypes</em></strong>.</p><p>现在该方法适用于 <strong><em>Animal</em></strong>  类型和所有 <strong><em>子类型</em></strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">printAnimals(  </span><br><span class="line">    Arrays.asList(  </span><br><span class="line">        <span class="keyword">new</span> Cat(<span class="string">"Jim"</span>, <span class="string">"brown"</span>, <span class="number">2</span>),  </span><br><span class="line">        <span class="keyword">new</span> Dog(<span class="string">"Rocky"</span>, <span class="string">"black"</span>, <span class="number">5</span>)  </span><br><span class="line">    )  </span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>This is called an <strong>upper-bounded wildcard</strong>, where type <strong><em>Animal</em></strong> is the upper bound.</p><p>这被称为 <strong>上界通配符</strong> ，其中 <strong><em>Animal</em></strong> 类型是上界。</p><p>2️⃣ <strong>Lower Bounded Wild Cards</strong></p><p>2️⃣ <strong>下限通配符</strong></p><p>We can also specify wildcards with a lower bound, where the unknown type has to be a <strong>super type of the specified type</strong>. Lower bounds can be specified using the <strong><em>super</em></strong> keyword followed by the specific type.</p><p>我们还可以指定带有下限的通配符，其中未知类型必须是指定类型的 <strong>超类型</strong> 。可以使用 <strong><em>super</em></strong> 关键字指定下限，后面跟上特定的类型。</p><p>Example:</p><p>举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addIntegers</span><span class="params">(List&lt;? <span class="keyword">super</span> Integer&gt; list)</span></span>&#123;  </span><br><span class="line">    list.add(<span class="keyword">new</span> Integer(<span class="number">70</span>));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Generic-Methods-通用方法"><a href="#Generic-Methods-通用方法" class="headerlink" title="Generic Methods 通用方法"></a>Generic Methods 通用方法</h1><p>Imagine we need a method which takes different data types and do something. We can create a Generic method for this and reuse it.</p><p>想象一下，我们需要一个接收不同数据类型的方法来做一些事情。我们可以为此创建一个通用方法并重复使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(T data)</span> </span>&#123;  </span><br><span class="line">    System.out.println(data);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">call(<span class="string">"hello"</span>);  </span><br><span class="line">call(<span class="number">45</span>);  </span><br><span class="line">call(<span class="number">15.67</span>);  </span><br><span class="line">call(<span class="number">5L</span>);  </span><br><span class="line">call(<span class="keyword">new</span> Dog(<span class="string">"Rocky"</span>, <span class="string">"black"</span>, <span class="number">5</span>));  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/* output:  </span></span><br><span class="line"><span class="comment">    hello  </span></span><br><span class="line"><span class="comment">    45  </span></span><br><span class="line"><span class="comment">    15.67  </span></span><br><span class="line"><span class="comment">    5  </span></span><br><span class="line"><span class="comment">    generics.Dog@62294cd9  </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>If we want to return data instead of VOID, we can do that also.</p><p>如果我们想返回数据而不是VOID，我们也可以这样做。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getData</span><span class="params">(T data)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> data;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">System.out.println(getData(<span class="string">"Test"</span>));   <span class="comment">// output: Test</span></span><br></pre></td></tr></table></figure><p>We can accept multiple data types also in a generic method.</p><p>我们也可以在泛型方法中接受多种数据类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, V&gt; <span class="function"><span class="keyword">void</span> <span class="title">getMultiData</span><span class="params">(T data1, V data2)</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"data 1: "</span> + data1);  </span><br><span class="line">    System.out.println(<span class="string">"data 2: "</span> + data2);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">getMultiData(<span class="number">50</span>, <span class="string">"Shades of Grey"</span>);</span><br></pre></td></tr></table></figure><p>I think I have covered almost all the things to be learnt in Generics. So, this would be an ideal article for you to practice Generics in Java. ❤️</p><p>我认为已经覆盖了泛型使用的大部分场景. 因此，这将是您练习Java泛型的理想文章。❤️</p><p>I will bring you another Java stuff next time.</p><p>下次我会给您带来另一款Java产品。</p><p>Bye guys! 🙌</p><p>再见 🙌</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      java中使用
    
    </summary>
    
    
      <category term="Java" scheme="https://whitestore.top/categories/Java/"/>
    
    
      <category term="Java" scheme="https://whitestore.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【周报】20230717 - 20230723 个人周报</title>
    <link href="https://whitestore.top/2023/07/27/weeonotes20230723/"/>
    <id>https://whitestore.top/2023/07/27/weeonotes20230723/</id>
    <published>2023-07-27T03:28:39.000Z</published>
    <updated>2023-09-09T00:53:49.937Z</updated>
    
    <content type="html"><![CDATA[<p>#周报</p><h2 id="进步"><a href="#进步" class="headerlink" title="进步"></a>进步</h2><ul><li>Apach Curator 文章第二篇【<img src="https://progress-bar.dev/100/" alt="进度">】</li><li>阅读文章和笔记记录：【个人成长】你的技术成长战略是什么？【<img src="https://progress-bar.dev/100/" alt="进度">】</li><li>【笔记】笔记分类的思考：来自Obsidian社区（临时笔记归档）【<img src="https://progress-bar.dev/100/" alt="进度">】<ul><li>零碎笔记记录</li></ul></li><li>《手写Mybatis》第一章脱稿自己实现相关代码【<img src="https://progress-bar.dev/100/" alt="进度">】<ul><li>基础完成，发现书中部分代码运行有误。</li></ul></li><li>《手写Mybatis》第二章阅读和实战【<img src="https://progress-bar.dev/100/" alt="进度">】</li><li>《手写Mybatis》第三章阅读和实战【<img src="https://progress-bar.dev/100/" alt="进度">】</li><li>《手写Mybatis》第四章阅读和实战【<img src="https://progress-bar.dev/100/" alt="进度">】</li><li>整理星球收藏的优质资料和主题，归档到自己的笔记【<img src="https://progress-bar.dev/100/" alt="进度">】</li><li>过去的部分笔记同步到各个平台【<img src="https://progress-bar.dev/100/" alt="进度">】</li><li>个人博客标签和分类重新整理【<img src="https://progress-bar.dev/100/" alt="进度">】</li><li>星球笔记第一篇【<img src="https://progress-bar.dev/100/" alt="进度">】</li><li>Postgresql 源码安装方式如何实现开机自启笔记归档 【<img src="https://progress-bar.dev/100/" alt="进度">】</li></ul><a id="more"></a><h1 id="未完成"><a href="#未完成" class="headerlink" title="未完成"></a>未完成</h1><ul><li>星球笔记二篇【<img src="https://progress-bar.dev/40/" alt="进度">】</li><li>《Who Moved My Cheese》生词笔记归档【<img src="https://progress-bar.dev/40/" alt="进度">】</li><li>多级缓存专栏笔记【<img src="https://progress-bar.dev/50/" alt="进度">】</li><li>英文博客Lambda表达式翻译【<img src="https://progress-bar.dev/50/" alt="进度">】</li><li>手写Mybaits【5/ 16】【<img src="https://progress-bar.dev/30/" alt="进度">】</li><li></li></ul><h1 id="不足-改进措施"><a href="#不足-改进措施" class="headerlink" title="不足/改进措施"></a>不足/改进措施</h1><ol><li>手写Mybatis 部分章节过于纠结，需要加快学习进度。</li></ol><p>改进：部分不关键代码不再反复重写，重点编写不理解部分。多看下Mybatis的源码是如何处理的。</p><ol start="2"><li>多级缓存专栏学习进度比较慢</li></ol><p>改进：敲代码实战耗时不固定，规定固定的学习时间，挤时间完成。</p><ol start="3"><li>英文学习安排比较随意</li></ol><p>改进：固定时间段学习。</p><ol start="4"><li>学习时刻三心二意</li></ol><p>改进：以前的倒计时改为正计时，使用滴答清单，走神的时候暂停结算专注时间。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul><li>逛漫展发现新大陆，有点想出COS了，哈哈</li><li>工作需求慢慢堆积上来了，连续学习时间逐渐被切割了</li><li>本周以撸Mybatis源码为主，从不懂到理解如何设计ORM框架，很有意思，顺带回忆很久之前敲过的工具方法。</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      个人周报汇总
    
    </summary>
    
    
      <category term="周报" scheme="https://whitestore.top/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="周报" scheme="https://whitestore.top/tags/%E5%91%A8%E6%8A%A5/"/>
    
  </entry>
  
</feed>
