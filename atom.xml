<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LazyTimes的博客</title>
  
  <subtitle>生死有命，富贵在天</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://whitestore.top/"/>
  <updated>2021-07-06T15:14:40.543Z</updated>
  <id>https://whitestore.top/</id>
  
  <author>
    <name>阿东</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《有限与无限的游戏》读书笔记</title>
    <link href="https://whitestore.top/2021/07/06/youxibiji/"/>
    <id>https://whitestore.top/2021/07/06/youxibiji/</id>
    <published>2021-07-06T15:13:26.000Z</published>
    <updated>2021-07-06T15:14:40.543Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《有限与无限的游戏》读书笔记"><a href="#《有限与无限的游戏》读书笔记" class="headerlink" title="《有限与无限的游戏》读书笔记"></a>《有限与无限的游戏》读书笔记</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这本书更加推荐听书，最开始接触这本书是从樊登读书里面听到的。同时樊登的解读也让我对这本书有着较为深刻的认识。总而言之，这本书还是推荐听书，因为这本书的核心的内容其实并不多。</p><a id="more"></a><h2 id="推荐语"><a href="#推荐语" class="headerlink" title="推荐语"></a>推荐语</h2><p>无论何时，我们都要玩无限的游戏。有限的游戏以死亡为界限，无限的游戏以是否延续为界限。</p><h2 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h2><p>3星吧，内容偏向深奥和哲学。更加推荐去听书而不是看书。</p><p>内容也比较简单，从个人角度来看其实并不是需要那么多的书来介绍这本书。</p><h2 id="内容概要"><a href="#内容概要" class="headerlink" title="内容概要"></a>内容概要</h2><h3 id="什么是有限的游戏"><a href="#什么是有限的游戏" class="headerlink" title="什么是有限的游戏"></a>什么是有限的游戏</h3><p>有限的游戏总是有一个最终的目标，比如考试，拿到比赛冠军，每一个有限的游戏都有一个非常明确并且具像化的目的。</p><p>有限的游戏总是存在竞争的。而胜负必然存在胜利者和失败者，胜利者获得有限游戏的成果，而失败者选择离场或进行下一次有限的游戏。</p><p>有限的游戏总是存在利益的。无利益化无法构成有限的游戏。</p><p>一切对于资源的竞争都可以认为是有限的有消息</p><h3 id="什么是无限的游戏"><a href="#什么是无限的游戏" class="headerlink" title="什么是无限的游戏"></a>什么是无限的游戏</h3><p>无限的游戏是以延续游戏为目的。</p><p>生活中有什么是可以被称之为无限的游戏呢？比如我们学习，学习是一个个人永远成长的事情。</p><p>学习一门语言也是无限的游戏，学习技能也是无限的游戏，我们对于世界构成创造的事情</p><p>从某种意义上来说，慈善也是无限的游戏</p><h3 id="我们总是要玩无限的游戏"><a href="#我们总是要玩无限的游戏" class="headerlink" title="我们总是要玩无限的游戏"></a>我们总是要玩无限的游戏</h3><p>这里并不是意味着我们只玩无限的游戏，因为人生本身就是依靠在不断无限的游戏当中有限的游戏。</p><p>无限的游戏如果按照时间投资法的规划就是重要不紧急的事情，最为典型的是学习技能和掌握知识。我们要尽量的把时间投资到重要不紧急的事情，更多的以个人的成长为目标。</p><h3 id="有限的游戏真的不好么"><a href="#有限的游戏真的不好么" class="headerlink" title="有限的游戏真的不好么"></a>有限的游戏真的不好么</h3><p>从书里的内容来看，作者显然是更加推荐无限的游戏，然而社会就是一个庞大的有限的游戏，优胜劣汰又是自然的法则，我们每天都在玩有限的游戏，但是很少人做大去发现无限的游戏。</p><p>其次，我们可以支配的永远只有无限的游戏，而不是有限的游戏，有限的游戏制造者也是参与者，我们避无可避的在一个闭环当中不断的重复的相似的动作。所以从整体上来看有限的游戏是一件无可避免必须要做的一件事情。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>无论何时，我们都要玩无限的游戏。人生只有一次，在玩好有限游戏的同时，尽可能的玩无限的游戏。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      任何时候都要玩无限的游戏
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://whitestore.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://whitestore.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud openFeign学习【3.0.2版本】</title>
    <link href="https://whitestore.top/2021/07/06/openfeigncloud/"/>
    <id>https://whitestore.top/2021/07/06/openfeigncloud/</id>
    <published>2021-07-06T15:11:40.000Z</published>
    <updated>2021-07-06T15:13:13.793Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Cloud-openFeign学习【3-0-2版本】"><a href="#Spring-Cloud-openFeign学习【3-0-2版本】" class="headerlink" title="Spring Cloud openFeign学习【3.0.2版本】"></a>Spring Cloud openFeign学习【3.0.2版本】</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    内容分为openFeign大致的使用和源码的个人解读，里面参考了不少其他优秀博客作者的内容，很多地方基本算是拾人牙慧了，不过还是顺着源码读了一遍加深理解。</p><a id="more"></a><h1 id="openFeign-是什么？"><a href="#openFeign-是什么？" class="headerlink" title="openFeign 是什么？"></a>openFeign 是什么？</h1><p>​    Feign是一个<strong>声明性web服务客户端</strong>。它使编写web服务客户机更加容易，要使用Feign，需要创建一个接口并对其进行注释。它具有可插入注释支持，包括Feign注释和JAX-RS注释。</p><p>​    Feign还支持<strong>可插拔编码器和解码器</strong>。Spring Cloud增加了对Spring MVC注解的支持，并支持使用Spring Web中默认使用的相同HttpMessageConverters。</p><p>​    Spring Cloud集成了Eureka、Spring Cloud CircuitBreaker和Spring Cloud LoadBalancer，在使用Feign时提供一个<strong>负载均衡的http客户端</strong>。</p><h1 id="如何学习？"><a href="#如何学习？" class="headerlink" title="如何学习？"></a>如何学习？</h1><p>​    框架最大的意义在于使用，其实最好的教程就是边做边参考官方的文档学习。</p><p><span class="exturl" data-url="aHR0cHM6Ly9zcHJpbmcuaW8vcHJvamVjdHMvc3ByaW5nLWNsb3VkLW9wZW5mZWlnbg==" title="https://spring.io/projects/spring-cloud-openfeign">官方文档目录地址<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnNwcmluZy5pby9zcHJpbmctY2xvdWQtb3BlbmZlaWduL2RvY3MvY3VycmVudC9yZWZlcmVuY2UvaHRtbC8=" title="https://docs.spring.io/spring-cloud-openfeign/docs/current/reference/html/">官方openFeign的文档<i class="fa fa-external-link"></i></span></p><h1 id="应用场景？"><a href="#应用场景？" class="headerlink" title="应用场景？"></a>应用场景？</h1><p>​    可以看到openFeign作为服务的调用中转，负责服务之间的连接和请求转发的操作。OpenFeign作为编写服务调用支持组件在spring cloud中占有极为重要的位置。</p><p>​    和RPC的通信框架不同，openFeign使用了传统的http作为传输结构。</p><p>​    在以往使用Ribbon的时候，服务调用通常使用的是手动调用，这需要花费大量的人工协调时间。现在通过openFeign把服务调用“本地化”。调用其他的服务的接口API像调用本地方法一样。这样既不需要频繁的改动接口，又可以控制服务的调用，而不会导致服务提供方的变动而“失效”。</p><h1 id="Ribbon、Feign和OpenFeign的区别"><a href="#Ribbon、Feign和OpenFeign的区别" class="headerlink" title="Ribbon、Feign和OpenFeign的区别"></a>Ribbon、Feign和OpenFeign的区别</h1><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ppbW91NTU4MS9hcnRpY2xlL2RldGFpbHMvODk5NDk4NTI=" title="https://blog.csdn.net/zimou5581/article/details/89949852">Ribbon、Feign和OpenFeign的区别<i class="fa fa-external-link"></i></span></p><h2 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h2><p>​    Ribbon 是 Netflix开源的<strong>基于HTTP和TCP</strong>等协议负载均衡组件</p><p>​    Ribbon 可以用来做<strong>客户端负载均衡</strong>，调用注册中心的服务</p><p>​    Ribbon的使用需要代码里<strong>手动调用目标服务</strong>，请参考官方示例：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL05ldGZsaXgvcmliYm9u" title="https://github.com/Netflix/ribbon">官方示例<i class="fa fa-external-link"></i></span></p><h2 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h2><p>​    Feign是Spring Cloud组件中的一个<strong>轻量级RESTful的HTTP服务</strong>客户端。</p><p>​    Feign内置了Ribbon，用来做<strong>客户端负载均衡</strong>，去调用<strong>服务注册中心的服务</strong>。</p><p>​    Feign的使用方式是：<strong>使用Feign的注解</strong>定义接口，调用这个接口，就可以调用服务注册中心的服务。</p><p>​    Feign支持的注解和用法请参考官方文档：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL09wZW5GZWlnbi9mZWlnbg==" title="https://github.com/OpenFeign/feign">官方文档<i class="fa fa-external-link"></i></span>。</p><p>​    <strong>Feign本身不支持Spring MVC的注解，它有一套自己的注解</strong>。</p><h2 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h2><p>​    OpenFeign是Spring Cloud 在Feign的基础上支持了Spring MVC的注解，如@RequesMapping等等。OpenFeign的@FeignClient可以解析SpringMVC的<strong>@RequestMapping</strong>注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。</p><p>​    根据上面的描述，绘制如下的表格内容：</p><table><thead><tr><th>-</th><th>Ribbon</th><th>Feign</th><th>OpenFeign</th></tr></thead><tbody><tr><td>使用方式</td><td>手动调用目标服务</td><td>Feign的注解定义接口，调用接口就可以调用注册中心服务</td><td>可以直接使用服务调用的方式调用对应的服务</td></tr><tr><td>作用</td><td>客户端负载均衡，服务注册中心的服务调用</td><td>客户端负载均衡，服务注册中心的服务调用</td><td>动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务</td></tr><tr><td>开发商</td><td>Netfix</td><td>Spring Cloud</td><td>Spring Cloud</td></tr><tr><td>特点</td><td><strong>基于HTTP和TCP</strong>等协议负载均衡组件</td><td><strong>轻量级RESTful的HTTP服务</strong>客户端。依靠自我实现的注解进行请求处理</td><td>支持了Spring MVC的注解的<strong>轻量级RESTful的HTTP服务</strong>客户端</td></tr><tr><td>目前情况</td><td>维护中</td><td>停止维护</td><td>维护中</td></tr></tbody></table><h1 id="openFeign增加了那些功能："><a href="#openFeign增加了那些功能：" class="headerlink" title="openFeign增加了那些功能："></a>openFeign增加了那些功能：</h1><ol><li>可插拔的注解支持，包括Feign注解和JSX-RS注解。</li><li>支持可插拔的HTTP编码器和解码器。</li><li>支持Hystrix和它的Fallback。</li><li>支持Ribbon的负载均衡。</li><li>支持HTTP请求和响应的压缩。</li></ol><h1 id="openFeign的client实现方替换："><a href="#openFeign的client实现方替换：" class="headerlink" title="openFeign的client实现方替换："></a>openFeign的client实现方替换：</h1><ol><li>可以使用http client 替换，并且openFeign 提供了良好的配置，可以支持httpclient的细节化配置。</li><li>使用okHttpClient, 可以实现 okhttpClient 实现自定义的httpclient注入模式，但是会出现一定的问题。</li></ol><h1 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h1><h2 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1. 添加依赖"></a>1. 添加依赖</h2><p>​    按照maven的依赖管理，我们需要使用此方式进行处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt;</span><br><span class="line">     &lt;version&gt;$&#123;feign.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">     &lt;scope&gt;compile&lt;&#x2F;scope&gt;</span><br><span class="line">     &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="2-开启注解-EnableFeignClients"><a href="#2-开启注解-EnableFeignClients" class="headerlink" title="2. 开启注解@EnableFeignClients"></a>2. 开启注解@EnableFeignClients</h2><p>​    <code>application</code>启动类 需要添加对应的配置：<code>@EnableFeignClients</code>用于允许访问。</p><blockquote><p>spring cloud feign的默认配置：</p><p>Spring Cloud OpenFeign默认为伪装提供以下bean（<code>BeanType</code>beanName ：）<code>ClassName</code>：</p><ul><li><code>Decoder</code>feignDecoder ：（<code>ResponseEntityDecoder</code>包含<code>SpringDecoder</code>）</li><li><code>Encoder</code> feignEncoder： <code>SpringEncoder</code></li><li><code>Logger</code> feignLogger： <code>Slf4jLogger</code></li><li><code>MicrometerCapability</code>micrometerCapability：如果<code>feign-micrometer</code>在类路径上并且<code>MeterRegistry</code>可用</li><li><code>Contract</code> feignContract： <code>SpringMvcContract</code></li><li><code>Feign.Builder</code> feignBuilder： <code>FeignCircuitBreaker.Builder</code></li><li><code>Client</code>feignClient：如果在类路径<code>FeignBlockingLoadBalancerClient</code>上使用Spring Cloud <strong>LoadBalancer</strong>，则使用。如果它们都不在类路径上，则使用默认的伪装客户端。</li></ul></blockquote><h2 id="3-yml增加配置："><a href="#3-yml增加配置：" class="headerlink" title="3. yml增加配置："></a>3. yml增加配置：</h2><p>​    yml文件内部的文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">feign:</span><br><span class="line">    client:</span><br><span class="line">        config:</span><br><span class="line">            feignName:</span><br><span class="line">                connectTimeout: 5000</span><br><span class="line">                readTimeout: 5000</span><br><span class="line">                loggerLevel: full</span><br><span class="line">                errorDecoder: com.example.SimpleErrorDecoder</span><br><span class="line">                retryer: com.example.SimpleRetryer</span><br><span class="line">                defaultQueryParameters:</span><br><span class="line">                    query: queryValue</span><br><span class="line">                defaultRequestHeaders:</span><br><span class="line">                    header: headerValue</span><br><span class="line">                requestInterceptors:</span><br><span class="line">                    - com.example.FooRequestInterceptor</span><br><span class="line">                    - com.example.BarRequestInterceptor</span><br><span class="line">                decode404: false</span><br><span class="line">                encoder: com.example.SimpleEncoder</span><br><span class="line">                decoder: com.example.SimpleDecoder</span><br><span class="line">                contract: com.example.SimpleContract</span><br><span class="line">                capabilities:</span><br><span class="line">                    - com.example.FooCapability</span><br><span class="line">                    - com.example.BarCapability</span><br><span class="line">                metrics.enabled: false</span><br></pre></td></tr></table></figure><h2 id="4-具体使用"><a href="#4-具体使用" class="headerlink" title="4. 具体使用:"></a>4. 具体使用:</h2><p>​    更多的用法请根据网上资料或者官方文档，下面列举一些具体的配置或者使用方法:</p><blockquote><p>如果openFeign的名称发生冲突，需要使用<code>contextId</code>对于防止bean的名称冲突</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(contextId &#x3D; &quot;fooClient&quot;, name &#x3D; &quot;stores&quot;, configuration &#x3D; FooConfiguration.class)</span><br></pre></td></tr></table></figure></blockquote><h3 id="上下文继承"><a href="#上下文继承" class="headerlink" title="上下文继承"></a>上下文继承</h3><p>​    如果将FeignClient配置为不从父上下文继承bean，可以使用下面的写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class CustomConfiguration&#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public FeignClientConfigurer feignClientConfigurer() &#123;</span><br><span class="line">        return new FeignClientConfigurer() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean inheritParentConfiguration() &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：默认情况下feign不会对与斜杠进行编码，如果要对斜杠编码，需要使用如下方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">feign.client.decodeSlash：false</span><br></pre></td></tr></table></figure></blockquote><h3 id="日志输出"><a href="#日志输出" class="headerlink" title="日志输出"></a>日志输出</h3><p>​    feign的默认日志输出等级如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.level.project.user.UserClient: DEBUG</span><br></pre></td></tr></table></figure><p>​    下面是日志打印的内容：</p><ul><li><code>NONE</code>：默认不记录任何日志（默认设置）</li><li><code>BASIC</code>：只记录和请求以及响应时间相关的日志信息</li><li><code>HEADERS</code>：记录基本信息以及请求和响应<strong>头</strong></li><li><code>FULL</code>:记录请求和响应的头、主体和元数据。(所有信息记录)</li></ul><h3 id="开启压缩"><a href="#开启压缩" class="headerlink" title="开启压缩"></a>开启压缩</h3><p>​    可以通过如下配置，开始http压缩：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">feign.compression.request.enabled&#x3D;true</span><br><span class="line">feign.compression.response.enabled&#x3D;true</span><br></pre></td></tr></table></figure><p>​    如果需要更进一步的配置，可以使用如下的形式进行配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">feign.compression.request.enabled&#x3D;true</span><br><span class="line">feign.compression.request.mime-types&#x3D;text&#x2F;xml,application&#x2F;xml,application&#x2F;json</span><br><span class="line">feign.compression.request.min-request-size&#x3D;2048</span><br></pre></td></tr></table></figure><p>​    注意<strong>2048</strong>值为压缩请求的最小阈值，因为如果对于所有请求进行gzip压缩，对于小文件的性能开销要反而要更大</p><p>​    通过下面的配置来开启gzip压缩（压缩编码为UTF-8，默认）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">feign.compression.response.enabled&#x3D;true</span><br><span class="line">feign.compression.response.useGzipDecoder&#x3D;true</span><br></pre></td></tr></table></figure><h2 id="5-附录："><a href="#5-附录：" class="headerlink" title="5. 附录："></a>5. 附录：</h2><h3 id="yml相关配置表："><a href="#yml相关配置表：" class="headerlink" title="yml相关配置表："></a>yml相关配置表：</h3><p>​    这部分配置可以直接参考官网的处理：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnNwcmluZy5pby9zcHJpbmctY2xvdWQtb3BlbmZlaWduL2RvY3MvY3VycmVudC9yZWZlcmVuY2UvaHRtbC9hcHBlbmRpeC5odG1s" title="https://docs.spring.io/spring-cloud-openfeign/docs/current/reference/html/appendix.html">yml相关配置表<i class="fa fa-external-link"></i></span></p><h1 id="openFeign的源码解读-重点"><a href="#openFeign的源码解读-重点" class="headerlink" title="openFeign的源码解读(重点)"></a>openFeign的源码解读(重点)</h1><p>​    下面为借助文章理解和自己看源码的总结。整个调用过程还是比较好理解的。因为说白了本身就是对于一次http请求的抽象和封装而已。不过这部分用到了很多的设计模式，比如随处可见的建造者模式和策略模式。同时这一块的设计使用大量的包访问结构闭包，所以要对其进行二次开发会稍微麻烦一些，但是使用反射这些屏障基本算是形同虚设了。</p><p>​    参考资料：<strong>掘金【【图文】Spring Cloud OpenFeign 源码解析】：<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTA0MDY2MjI5OTI3OTUwI2hlYWRpbmctMjQ=" title="https://juejin.cn/post/6844904066229927950#heading-24">https://juejin.cn/post/6844904066229927950#heading-24<i class="fa fa-external-link"></i></span></strong></p><h2 id="feign工作流程图"><a href="#feign工作流程图" class="headerlink" title="feign工作流程图"></a>feign工作流程图</h2><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/B837F406-A869-4803-AC74-1B592F4BAF28.png?ynotemdtimestamp=1625580577970" alt="img"></p><h2 id="工作流程概览"><a href="#工作流程概览" class="headerlink" title="工作流程概览"></a>工作流程概览</h2><p>这里主要介绍一次<strong>openFeign</strong>请求调用的流程，对于注解处理以及组件注册的部分放到了文章的结尾部分。</p><ul><li><strong>Feign</strong>实例化<strong>newInstance()</strong><ul><li>实例化<strong>SyncronizedMethodHandler</strong>以及<strong>ParseHandlersByName</strong>，注入到<strong>ReflectFeign</strong>对象。</li></ul></li><li>构建<strong>ParseHandlersByName</strong>对象，对于参数进行转化</li><li>构建<strong>Contract</strong>对象，对于请求参数进行校验和解析<ul><li>实例化<strong>SpringMvcContract</strong>对象（继承自Contract对象）</li><li>调用<strong>parseAndValidateMetadata()</strong> 处理和校验数据类型</li></ul></li><li>通过<strong>jdk动态代理</strong>Proxy创建动态代理对象<strong>MethodInvocationHandler</strong>，调用动态代理对象的<strong>invoke()</strong>方法</li><li>代理类<strong>SyncronizedInvocationHandler</strong>构建 <strong>requestTeamplate</strong>对象，并发送请求<ul><li>调用<strong>create()</strong>构建请求实体对象</li><li>对于请求参数进行<strong>encode()</strong>操作</li><li>构建<strong>client</strong>对象，执行请求</li><li>返回请求结果</li></ul></li><li>获取请求结果，请求完成</li></ul><h2 id="详解openFeign工作流程（重点）"><a href="#详解openFeign工作流程（重点）" class="headerlink" title="详解openFeign工作流程（重点）"></a>详解openFeign工作流程（重点）</h2><h3 id="1-Feign-实例化-newInstance"><a href="#1-Feign-实例化-newInstance" class="headerlink" title="1. Feign 实例化 - newInstance()"></a>1. Feign 实例化 - newInstance()</h3><p>​    当服务通过feign调用另一个服务的时候，在<strong>Fegin.builder</strong>对象中，会调用构造器构造一个<strong>Fegin</strong>实例，下面是<strong>feign.Feign.Builder#build</strong>的代码内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public Feign build() &#123;</span><br><span class="line">      &#x2F;&#x2F; 构建核心组件和相关内容</span><br><span class="line">      Client client &#x3D; Capability.enrich(this.client, capabilities);</span><br><span class="line">      Retryer retryer &#x3D; Capability.enrich(this.retryer, capabilities);</span><br><span class="line">      List&lt;RequestInterceptor&gt; requestInterceptors &#x3D; this.requestInterceptors.stream()</span><br><span class="line">          .map(ri -&gt; Capability.enrich(ri, capabilities))</span><br><span class="line">          .collect(Collectors.toList());</span><br><span class="line">      Logger logger &#x3D; Capability.enrich(this.logger, capabilities);</span><br><span class="line">      Contract contract &#x3D; Capability.enrich(this.contract, capabilities);</span><br><span class="line">      Options options &#x3D; Capability.enrich(this.options, capabilities);</span><br><span class="line">      Encoder encoder &#x3D; Capability.enrich(this.encoder, capabilities);</span><br><span class="line">      Decoder decoder &#x3D; Capability.enrich(this.decoder, capabilities);</span><br><span class="line">      InvocationHandlerFactory invocationHandlerFactory &#x3D;</span><br><span class="line">          Capability.enrich(this.invocationHandlerFactory, capabilities);</span><br><span class="line">      QueryMapEncoder queryMapEncoder &#x3D; Capability.enrich(this.queryMapEncoder, capabilities);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 初始化SynchronousMethodHandler.Factory工厂，后续使用该工厂生成代理对象的方法</span><br><span class="line">      SynchronousMethodHandler.Factory synchronousMethodHandlerFactory &#x3D;</span><br><span class="line">          new SynchronousMethodHandler.Factory(client, retryer, requestInterceptors, logger,</span><br><span class="line">              logLevel, decode404, closeAfterDecode, propagationPolicy, forceDecoding);</span><br><span class="line">      &#x2F;&#x2F; 请求参数解析对象以及参数处理对象。负责根据请求类型构建对应的请求参数处理器</span><br><span class="line">      ParseHandlersByName handlersByName &#x3D;</span><br><span class="line">          new ParseHandlersByName(contract, options, encoder, decoder, queryMapEncoder,</span><br><span class="line">              errorDecoder, synchronousMethodHandlerFactory);</span><br><span class="line">    &#x2F;&#x2F; 这里的 ReflectiveFeign 是整个核心的部分</span><br><span class="line">      return new ReflectiveFeign(handlersByName, invocationHandlerFactory, queryMapEncoder);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>​    执行ReflectiveFeign构建之后，会立马执行该Fegin子类的<code>ReflectiveFeign#newInstance()</code>方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T target(Target&lt;T&gt; target) &#123;</span><br><span class="line">      return build().newInstance(target);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里设计的比较巧妙。但是并不是特别难以理解</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">下面是&#96;ReflectiveFeign#newInstance&#96;方法的代码：</span><br><span class="line"> public &lt;T&gt; T newInstance(Target&lt;T&gt; target) &#123;</span><br><span class="line">     &#x2F;&#x2F; ParseHandlersByName::apply 方法构建请求参数解析模板和验证handler是否有效</span><br><span class="line">    Map&lt;String, MethodHandler&gt; nameToHandler &#x3D; targetToHandlersByName.apply(target);</span><br><span class="line">    Map&lt;Method, MethodHandler&gt; methodToHandler &#x3D; new LinkedHashMap&lt;Method, MethodHandler&gt;();</span><br><span class="line">    List&lt;DefaultMethodHandler&gt; defaultMethodHandlers &#x3D; new LinkedList&lt;DefaultMethodHandler&gt;();</span><br><span class="line">&#x2F;&#x2F; 对于方法handler进行处理</span><br><span class="line">    for (Method method : target.type().getMethods()) &#123;</span><br><span class="line">      if (method.getDeclaringClass() &#x3D;&#x3D; Object.class) &#123;</span><br><span class="line">        continue;</span><br><span class="line">      &#125; else if (Util.isDefault(method)) &#123;</span><br><span class="line">        DefaultMethodHandler handler &#x3D; new DefaultMethodHandler(method);</span><br><span class="line">        defaultMethodHandlers.add(handler);</span><br><span class="line">        methodToHandler.put(method, handler);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        methodToHandler.put(method, nameToHandler.get(Feign.configKey(target.type(), method)));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     &#x2F;&#x2F; 创建接口代理对象。factory在父类build方法进行初始化</span><br><span class="line">    InvocationHandler handler &#x3D; factory.create(target, methodToHandler);</span><br><span class="line">    T proxy &#x3D; (T) Proxy.newProxyInstance(target.type().getClassLoader(),</span><br><span class="line">        new Class&lt;?&gt;[] &#123;target.type()&#125;, handler);</span><br><span class="line">&#x2F;&#x2F; 绑定代理对象</span><br><span class="line">    for (DefaultMethodHandler defaultMethodHandler : defaultMethodHandlers) &#123;</span><br><span class="line">      defaultMethodHandler.bindTo(proxy);</span><br><span class="line">    &#125;</span><br><span class="line">    return proxy;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>​    下面就上面这段代码进行深入的剖析。</p><h3 id="2-ParseHandlersByName-参数解析处理-apply"><a href="#2-ParseHandlersByName-参数解析处理-apply" class="headerlink" title="2. ParseHandlersByName 参数解析处理 - apply()"></a>2. ParseHandlersByName 参数解析处理 - apply()</h3><p>​    <code>ReflectiveFeign#newInstance()</code>当中首先执行的是<code>feign.ReflectiveFeign.ParseHandlersByName</code>对象的<code>aplly()</code>方法，进行参数解析和参数解析构建器的构建。同时可以注意到，如果发现<code>methodHandler</code> 没有在<strong>feign</strong>中找到对应配置，会抛出<code>IllegalStateException</code>异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public Map&lt;String, MethodHandler&gt; apply(Target target) &#123;</span><br><span class="line">    &#x2F;&#x2F; 2.1 小节进行讲解</span><br><span class="line">      List&lt;MethodMetadata&gt; metadata &#x3D; contract.parseAndValidateMetadata(target.type());</span><br><span class="line">      Map&lt;String, MethodHandler&gt; result &#x3D; new LinkedHashMap&lt;String, MethodHandler&gt;();</span><br><span class="line">      for (MethodMetadata md : metadata) &#123;</span><br><span class="line">        BuildTemplateByResolvingArgs buildTemplate;</span><br><span class="line">          &#x2F;&#x2F; 根据请求参数的类型，实例化不同的请求参数构建器</span><br><span class="line">        if (!md.formParams().isEmpty() &amp;&amp; md.template().bodyTemplate() &#x3D;&#x3D; null) &#123;</span><br><span class="line">          &#x2F;&#x2F; form表单提交形式</span><br><span class="line">            buildTemplate &#x3D;</span><br><span class="line">              new BuildFormEncodedTemplateFromArgs(md, encoder, queryMapEncoder, target);</span><br><span class="line">        &#125; else if (md.bodyIndex() !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 普通编码形式处理</span><br><span class="line">          buildTemplate &#x3D; new BuildEncodedTemplateFromArgs(md, encoder, queryMapEncoder, target);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          buildTemplate &#x3D; new BuildTemplateByResolvingArgs(md, queryMapEncoder, target);</span><br><span class="line">        &#125;</span><br><span class="line">        if (md.isIgnored()) &#123;</span><br><span class="line">          result.put(md.configKey(), args -&gt; &#123;</span><br><span class="line">            throw new IllegalStateException(md.configKey() + &quot; is not a method handled by feign&quot;);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          result.put(md.configKey(),</span><br><span class="line">              factory.create(target, md, buildTemplate, options, decoder, errorDecoder));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-Contract-方法参数注解解析和校验-parseAndValidateMetadata"><a href="#2-1-Contract-方法参数注解解析和校验-parseAndValidateMetadata" class="headerlink" title="2.1 Contract 方法参数注解解析和校验 - parseAndValidateMetadata()"></a>2.1 Contract 方法参数注解解析和校验 - parseAndValidateMetadata()</h4><p>​    此方法的作用是：<strong>调用以解析链接到HTTP请求的类中的方法</strong>。</p><p>​    默认实例化对象为：<strong>SpringMvcContract</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于这部分涉及子父类的调用以及多个内部方法的调用并且方法内容较多，下面先介绍下**父类**的&#96;parseAndValidateMetadata()&#96;大致的代码工作流程。</span><br></pre></td></tr></table></figure><ol><li><p>检查handler是否为<strong>单继承</strong>（单实现接口），并且<strong>不支持参数化类型</strong>。否则将会抛出异常</p></li><li><p>遍历所有的内部方法</p><ol><li>如果是静态方法跳过当前循环</li><li>获取method对象以及目标class，执行内部方法<code>parseAndValidateMetadata()</code></li></ol><blockquote><p>内部方法为处理注解方法和参数内容，感兴趣可以自行了解源代码</p></blockquote></li><li><p>检查是否为重写方法，如果是则抛出异常<code>Overrides unsupported</code></p></li></ol><p>根据上面的介绍，下面看一下具体的逻辑代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;MethodMetadata&gt; parseAndValidateMetadata(Class&lt;?&gt; targetType) &#123;</span><br><span class="line">      checkState(targetType.getTypeParameters().length &#x3D;&#x3D; 0, &quot;Parameterized types unsupported: %s&quot;,</span><br><span class="line">          targetType.getSimpleName());</span><br><span class="line">      checkState(targetType.getInterfaces().length &lt;&#x3D; 1, &quot;Only single inheritance supported: %s&quot;,</span><br><span class="line">          targetType.getSimpleName());</span><br><span class="line">      if (targetType.getInterfaces().length &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        checkState(targetType.getInterfaces()[0].getInterfaces().length &#x3D;&#x3D; 0,</span><br><span class="line">            &quot;Only single-level inheritance supported: %s&quot;,</span><br><span class="line">            targetType.getSimpleName());</span><br><span class="line">      &#125;</span><br><span class="line">      final Map&lt;String, MethodMetadata&gt; result &#x3D; new LinkedHashMap&lt;String, MethodMetadata&gt;();</span><br><span class="line">      for (final Method method : targetType.getMethods()) &#123;</span><br><span class="line">        if (method.getDeclaringClass() &#x3D;&#x3D; Object.class ||</span><br><span class="line">            (method.getModifiers() &amp; Modifier.STATIC) !&#x3D; 0 ||</span><br><span class="line">            Util.isDefault(method)) &#123;</span><br><span class="line">          continue;</span><br><span class="line">        &#125;</span><br><span class="line">          &#x2F;&#x2F; 调用内部方法, 处理注解方法和参数信息</span><br><span class="line">        final MethodMetadata metadata &#x3D; parseAndValidateMetadata(targetType, method);</span><br><span class="line">        checkState(!result.containsKey(metadata.configKey()), &quot;Overrides unsupported: %s&quot;,</span><br><span class="line">            metadata.configKey());</span><br><span class="line">        result.put(metadata.configKey(), metadata);</span><br><span class="line">      &#125;</span><br><span class="line">      return new ArrayList&lt;&gt;(result.values());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-SpringMvcContract-方法参数注解解析和校验"><a href="#2-2-SpringMvcContract-方法参数注解解析和校验" class="headerlink" title="2.2 SpringMvcContract 方法参数注解解析和校验"></a>2.2 SpringMvcContract 方法参数注解解析和校验</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public MethodMetadata parseAndValidateMetadata(Class&lt;?&gt; targetType, Method method) &#123;</span><br><span class="line">processedMethods.put(Feign.configKey(targetType, method), method);</span><br><span class="line">       &#x2F;&#x2F; 使用父类方法获取 MethodMetadata</span><br><span class="line">MethodMetadata md &#x3D; super.parseAndValidateMetadata(targetType, method);</span><br><span class="line"></span><br><span class="line">RequestMapping classAnnotation &#x3D; findMergedAnnotation(targetType,</span><br><span class="line">RequestMapping.class);</span><br><span class="line">if (classAnnotation !&#x3D; null) &#123;</span><br><span class="line">&#x2F;&#x2F; produces - use from class annotation only if method has not specified this</span><br><span class="line">           &#x2F;&#x2F; produces - 只有当方法未指定时才从类注释产生</span><br><span class="line">if (!md.template().headers().containsKey(ACCEPT)) &#123;</span><br><span class="line">parseProduces(md, method, classAnnotation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; consumes -- use from class annotation only if method has not specified this</span><br><span class="line">           &#x2F;&#x2F; consumes - 只有当method没有指定时才使用from类注释</span><br><span class="line">if (!md.template().headers().containsKey(CONTENT_TYPE)) &#123;</span><br><span class="line">parseConsumes(md, method, classAnnotation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; headers -- class annotation is inherited to methods, always write these if</span><br><span class="line">&#x2F;&#x2F; present</span><br><span class="line">           &#x2F;&#x2F; headers -- 类注解被继承到方法，如果有的话，一定要写下来</span><br><span class="line">parseHeaders(md, method, classAnnotation);</span><br><span class="line">&#125;</span><br><span class="line">return md;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-创建接口动态代理"><a href="#3-创建接口动态代理" class="headerlink" title="3. 创建接口动态代理"></a>3. 创建接口动态代理</h3><p>​    下面根据一个动态代理的结构图来理解feign是如何完成创建接口的代理对象的。</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20210526144216.png?ynotemdtimestamp=1625580577970" alt="img"></p><p>​    首先target就是我们想要调用的目标服务的方法，在进过contract的注解处理之后，会交给proxy对象创建代理对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InvocationHandler handler &#x3D; factory.create(target, methodToHandler);</span><br><span class="line">    T proxy &#x3D; (T) Proxy.newProxyInstance(target.type().getClassLoader(),</span><br><span class="line">        new Class&lt;?&gt;[] &#123;target.type()&#125;, handler);</span><br></pre></td></tr></table></figure><p>​    在这里的代码利用工厂构建一个<code>InvocationHandler</code>实例，然后再使用<code>proxy.newInstance</code>根据代理目标方法对象的类型构建接口代理对象。</p><p>​    而<code>invocationHandler</code>的构建操作由<code>InvocationHandlerFactory</code>工厂构建而成，而工厂的构建细节又由<code>ReflectiveFeign.FeignInvocationHandler</code>决定。最终返回<code>FeignInvocationHandler</code>完成动态代理的后续代理动作和内容处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static final class Default implements InvocationHandlerFactory &#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public InvocationHandler create(Target target, Map&lt;Method, MethodHandler&gt; dispatch) &#123;</span><br><span class="line">    return new ReflectiveFeign.FeignInvocationHandler(target, dispatch);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    创建接口代理对象之后，会执行FeignInvocationHandler 的<code>invoke()</code>方法，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">  if (&quot;equals&quot;.equals(method.getName())) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      Object otherHandler &#x3D;</span><br><span class="line">          args.length &gt; 0 &amp;&amp; args[0] !&#x3D; null ? Proxy.getInvocationHandler(args[0]) : null;</span><br><span class="line">      return equals(otherHandler);</span><br><span class="line">    &#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (&quot;hashCode&quot;.equals(method.getName())) &#123;</span><br><span class="line">    return hashCode();</span><br><span class="line">  &#125; else if (&quot;toString&quot;.equals(method.getName())) &#123;</span><br><span class="line">    return toString();</span><br><span class="line">  &#125;</span><br><span class="line"> &#x2F;&#x2F; 通过dispatch 获取所有方法的handler的引用，执行具体的handler方法</span><br><span class="line">  return dispatch.get(method).invoke(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里涉及了一个数据结构：</p><p><code>Map&lt;Method, MethodHandler&gt; methodToHandler</code>，也是动态代理的核心部分</p><p>MehtodHandler 是一个 LinkedHashMap的数据结构，他存储的了所有的方法对应接口代理对象的映射。</p><p>此属性由<code>new ReflectiveFeign.FeignInvocationHandler(target, dispatch);</code>创建。</p></blockquote><h4 id="3-1-接口代理对象调用feign-SynchronousMethodHandler-invoke-请求逻辑"><a href="#3-1-接口代理对象调用feign-SynchronousMethodHandler-invoke-请求逻辑" class="headerlink" title="3.1 接口代理对象调用feign.SynchronousMethodHandler#invoke()请求逻辑"></a>3.1 接口代理对象调用<code>feign.SynchronousMethodHandler#invoke()</code>请求逻辑</h4><p>​    到了这一步，就是代理对象执行具体请求逻辑的部分了，这一部分包括创建一个请求模板，参数解析，根据参数配置client，请求编码和请求解码，以及拦截器等等…..涉及的内容比较多。这个小节作为1-3这三个部分的一个分割线。</p><h3 id="4-SynchronousMethodHandler动态代理对象处理详解"><a href="#4-SynchronousMethodHandler动态代理对象处理详解" class="headerlink" title="4. SynchronousMethodHandler动态代理对象处理详解"></a>4. SynchronousMethodHandler动态代理对象处理详解</h3><p>​    首先我们看下整改<strong>SynchronousMethodHandler</strong>的<code>invoke()</code>处理代码逻辑：</p><p>​    这里还是比较容易理解的，最开始先构建一个<code>requestTemplate</code>模板，同时构建请求的相关<strong>option</strong>，复制一个重试器配置给当前的线程使用。然后是核心的<code>executeAndDecode()</code>对于请求进行解码和返回结果，如果整个请求执行过程出现重试异常，则尝试调用重试器进行处理，如果重试依然失败，则抛出未受检查的异常或者抛出受检查的异常。最后根据日志的配置登记判断日志的打印和处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(Object[] argv) throws Throwable &#123;</span><br><span class="line">    &#x2F;&#x2F; 构建请求处理模板</span><br><span class="line">    RequestTemplate template &#x3D; buildTemplateFromArgs.create(argv);</span><br><span class="line">    &#x2F;&#x2F; 配置接口请求参数</span><br><span class="line">    Options options &#x3D; findOptions(argv);</span><br><span class="line">    &#x2F;&#x2F; 重试器创建</span><br><span class="line">    Retryer retryer &#x3D; this.retryer.clone();</span><br><span class="line">    while (true) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">          &#x2F;&#x2F; 执行请求</span><br><span class="line">        return executeAndDecode(template, options);</span><br><span class="line">      &#125; catch (RetryableException e) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 尝试重试和处理</span><br><span class="line">          retryer.continueOrPropagate(e);</span><br><span class="line">        &#125; catch (RetryableException th) &#123;</span><br><span class="line">            &#x2F;&#x2F; 受检异常处理</span><br><span class="line">          Throwable cause &#x3D; th.getCause();</span><br><span class="line">          if (propagationPolicy &#x3D;&#x3D; UNWRAP &amp;&amp; cause !&#x3D; null) &#123;</span><br><span class="line">            throw cause;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            throw th;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">          &#x2F;&#x2F; 日志打印和处理</span><br><span class="line">        if (logLevel !&#x3D; Logger.Level.NONE) &#123;</span><br><span class="line">          logger.logRetry(metadata.configKey(), logLevel);</span><br><span class="line">        &#125;</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>下面是阅读源码时临时做的部分笔记，大致浏览即可。</p><ol><li><p>通过<code>methodHandlerMap</code> 分发到不同的请求实现处理器当中</p></li><li><p>默认走<code>SynchronousMethodHandler</code> 处理不同的请求</p><ul><li>构建<code>requestTemplate</code> 模板</li><li>构建<code>requestOptions</code> 配置</li><li>获取重试器<code>Retry</code></li></ul></li><li><p>使用while(true) 进行无线循环. 执行请求并且对于请求的<strong>template</strong>和请求参数进行<strong>decode</strong>处理</p><ul><li>调用拦截器对于请求进行拦截处理（使用了责任链模式）<ul><li><code>BasicAuthRequestInterceptor</code>：默认的调用权限验证拦截</li><li><code>FeignAcceptGzipEncodingInterceptor</code> gzip编码处理开关连接器。用于判断是否允许开启gzip压缩</li><li><code>FeignContentGzipEncodingInterceptor</code>：请求报文内容gzip压缩拦截处理器</li></ul></li></ul><blockquote><p>如果日志的配置等级不为none，进行对应日志级别的输出</p></blockquote></li><li><p>执行<code>client.execute()</code> 方法，发送http请求</p><ul><li>使用<code>response.toBuilder</code> 对于响应内容进行构建起的处理（注意源代码里面标注后续版本会废弃这种方式? <strong>为什么要废弃？</strong> <strong>那里不好</strong>）</li></ul></li><li><p>对于返回结果解码，调用<code>AsyncResponseHandler.handlerResponse</code>对于结果进行处理</p><ul><li>这里的判断逻辑比较多，判断的顺序如下：<ul><li>如果返回类型为<code>Response.class</code></li><li>如果<code>Body</code>内容为null，执行complete调用</li></ul></li></ul></li></ol><blockquote><p>这里使用了<strong>CompletableFuture</strong> 异步调用处理执行结果。保证整个处理过程是异步执行并且返回的</p><ul><li>CompletableFuture.complete()、</li><li>CompletableFuture.completeExceptionally 只能被调用一次需要注意。</li></ul></blockquote><p>如果长度为空或者长度超过 <strong>缓存结果最大长度。\</strong>需要设置<code>shouldClose</code>为*<em>false*</em>，并且同样执行complete调用</p><ul><li><p>如果返回状态大于</p><p>200</p><p>并且小于</p><p>300</p><ul><li>如果是void返回类型，直接调用<code>complete</code></li><li>否则对于返回结果进行解码，是否需要关闭根据解码之后的结果状态决定<strong>（没看懂）</strong></li><li>如果是404 并且返回值不为void，则错误处理方法</li><li>如果上述都不满足，根据返回结果的错误信息封装错误结果，并且根据错误结果构建错误对象。最后通过：<code>resultFuture.completeExceptionally</code>进行处理</li></ul></li></ul><blockquote><p>特殊处理：如果上面的所有判断出现异常信息，除开io异常需要二次封装处理之外，都会触发默认的<code>comoleteExceptionally</code> 方法抛出一个终止异步线程的调用.</p></blockquote><p>​    + 验证任务是否完成，如果没有完成任务，调用 <code>resultFuture.join()</code> 方法将会在当前线程抛出一个未受检查的异常。</p><ol><li>如果抛出异常，使用retry进行定时重试</li></ol></blockquote><h4 id="构建RequestTemplate模板"><a href="#构建RequestTemplate模板" class="headerlink" title="构建RequestTemplate模板"></a>构建RequestTemplate模板</h4><p>​    作用是使用传递给方法调用的参数来创建请求模板。主要内容为请求的各种url处理包括参数处理，url参数处理，对于迭代参数进行展开等等操作。这部分细节处理比较多，由于篇幅有限这里挑重点讲一下：<code>RequestTemplate template = resolve(argv, mutable, varBuilder);</code>这个方法，这里会根据事先定义的参数处理器处理参数，具体的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RequestTemplate resolve(Object[] argv,</span><br><span class="line">                                      RequestTemplate mutable,</span><br><span class="line">                                      Map&lt;String, Object&gt; variables) &#123;</span><br><span class="line">      return mutable.resolve(variables);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    内部调用的是<code>mutable</code>对象的<code>resolve</code>方法，那么它又是如何处理请求的呢？</p><h5 id="根据不同的参数请求模板进行处理"><a href="#根据不同的参数请求模板进行处理" class="headerlink" title="根据不同的参数请求模板进行处理:"></a>根据不同的参数请求模板进行处理:</h5><p>​    feign通过不同的参数请求模板提供多样化的参数请求处理。 下面先看一下具体的构造图:</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20210526181412.png?ynotemdtimestamp=1625580577970" alt="img"></p><p>​    这里很明显使用了策略模式，代码先根据参数找到具体的参数请求处理对象对于参数进行自定义的处理，在处理完成之后，<strong>调用super.resolve()</strong>进行其他内容统一处理（模板方法）。设计的十分优秀并且巧妙，下面是对应的方法签名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;feign.RequestTemplate#resolve(java.util.Map&lt;java.lang.String,?&gt;)&#96;</span><br></pre></td></tr></table></figure><blockquote><p>这里可能会有疑问，这个<strong>BuildTemplateByResolvingArgs</strong>是在哪里被初始化的？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BuildTemplateByResolvingArgs buildTemplate;</span><br><span class="line">&#x2F;&#x2F; 根据请求参数的类型，实例化不同的请求参数构建器</span><br><span class="line">if (!md.formParams().isEmpty() &amp;&amp; md.template().bodyTemplate() &#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; form表单提交形式</span><br><span class="line">    buildTemplate &#x3D;</span><br><span class="line">        new BuildFormEncodedTemplateFromArgs(md, encoder, queryMapEncoder, target);</span><br><span class="line">&#125; else if (md.bodyIndex() !&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 普通编码形式处理</span><br><span class="line">    buildTemplate &#x3D; new BuildEncodedTemplateFromArgs(md, encoder, queryMapEncoder, target);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 使用默认的处理模板</span><br><span class="line">    buildTemplate &#x3D; new BuildTemplateByResolvingArgs(md, queryMapEncoder, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解答：其实早在第二步<strong>ParseHandlersByName</strong>这一步就对于整个请求处理模板进行确认，同时代理对象也会沿用此处理模板保证请求的幂等性.</p></blockquote><h5 id="请求参数处理细节对比："><a href="#请求参数处理细节对比：" class="headerlink" title="请求参数处理细节对比："></a>请求参数处理细节对比：</h5><p>​    如果是<strong>form表单</strong>提交的参数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; formVariables &#x3D; new LinkedHashMap&lt;String, Object&gt;();</span><br><span class="line">      for (Entry&lt;String, Object&gt; entry : variables.entrySet()) &#123;</span><br><span class="line">        if (metadata.formParams().contains(entry.getKey())) &#123;</span><br><span class="line">          formVariables.put(entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>​    如果<strong>form</strong>格式，一般会将map转为<strong>formVariables</strong> 的格式，注意内部使用的是<strong>LinkedHashMap</strong>进行处理的</p><p>​    如果是<strong>Body</strong>的处理方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object body &#x3D; argv[metadata.bodyIndex()];</span><br><span class="line">      checkArgument(body !&#x3D; null, &quot;Body parameter %s was null&quot;, metadata.bodyIndex());</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>这部分后续的版本可能会增加更多的处理形式，一切以最新的源码为准。注意文章标题声明的版本</p></blockquote><h5 id="关于报文数据编码和解码的细节："><a href="#关于报文数据编码和解码的细节：" class="headerlink" title="关于报文数据编码和解码的细节："></a>关于报文数据编码和解码的细节：</h5><p>​    加密的工作是在: <strong>requestTemplate</strong>当中完成的，并且是在<strong>BuildTemplateByResolvingArgs#resolve</strong>中进行处理，根据不同的请求参数类型进行细微的加密操作调整，但是代码基本类似.</p><p>​    下面是<strong>Encoder</strong>接口的默认实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Default implements Encoder &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void encode(Object object, Type bodyType, RequestTemplate template) &#123;</span><br><span class="line">      if (bodyType &#x3D;&#x3D; String.class) &#123;</span><br><span class="line">        template.body(object.toString());</span><br><span class="line">      &#125; else if (bodyType &#x3D;&#x3D; byte[].class) &#123;</span><br><span class="line">        template.body((byte[]) object, null);</span><br><span class="line">      &#125; else if (object !&#x3D; null) &#123;</span><br><span class="line">        throw new EncodeException(</span><br><span class="line">            format(&quot;%s is not a type supported by this encoder.&quot;, object.getClass()));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li>如果是字符串类型，则调用对象的tostring 方法</li><li>如果是字节数组则转为字节数组进行存储</li><li>如果对象为空，则抛出加密encode异常</li></ol><p>说完了加密，自然也要说下解码的动作如何处理的，下面是默认的解码接口的实现（注意父类是StringDecoder而不是Decoder）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Default extends StringDecoder &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object decode(Response response, Type type) throws IOException &#123;</span><br><span class="line">        &#x2F;&#x2F; 这里的硬编码感觉挺突兀的，不知道是否为设计有失误还是单纯程序员偷懒。</span><br><span class="line">        &#x2F;&#x2F; 比较倾向于加入 if(response &#x3D;&#x3D; null ) return null; 这一段代码</span><br><span class="line">      if (response.status() &#x3D;&#x3D; 404 || response.status() &#x3D;&#x3D; 204)</span><br><span class="line">        return Util.emptyValueOf(type);</span><br><span class="line">      if (response.body() &#x3D;&#x3D; null)</span><br><span class="line">        return null;</span><br><span class="line">      if (byte[].class.equals(type)) &#123;</span><br><span class="line">        return Util.toByteArray(response.body().asInputStream());</span><br><span class="line">      &#125;</span><br><span class="line">      return super.decode(response, type);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里很奇怪居然用了硬编码的形式。（老外编码总是十分自由）当返回状态为404或者204的时候。则根据对象的数据类型构建相关的数据类型默认值，如果是对象则返回一个空对象</p><ul><li>204编码代表了空文件的请求</li><li>200代表成功响应请求</li></ul></blockquote><p>​    最后一行表示如果类型都不符合情况下使用父类 <strong>StringDecoder</strong> 字符串的类型解码的操作，如果字符串无法解码，则抛出异常信息。感兴趣可以看下<code>StringDecoder#decode()</code>的实现细节，这里不再展示。</p><h5 id="如果发生错误，如何对错误信息进行编码？"><a href="#如果发生错误，如何对错误信息进行编码？" class="headerlink" title="如果发生错误，如何对错误信息进行编码？"></a>如果发生错误，如何对错误信息进行编码？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public Exception decode(String methodKey, Response response) &#123;</span><br><span class="line">      FeignException exception &#x3D; errorStatus(methodKey, response);</span><br><span class="line">      Date retryAfter &#x3D; retryAfterDecoder.apply(firstOrNull(response.headers(), RETRY_AFTER));</span><br><span class="line">      if (retryAfter !&#x3D; null) &#123;</span><br><span class="line">        return new RetryableException(</span><br><span class="line">            response.status(),</span><br><span class="line">            exception.getMessage(),</span><br><span class="line">            response.request().httpMethod(),</span><br><span class="line">            exception,</span><br><span class="line">            retryAfter,</span><br><span class="line">            response.request());</span><br><span class="line">      &#125;</span><br><span class="line">      return exception;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>根据错误信息和方法签名，构建异常对象</li><li>使用重试编码进行返回请求头的处理动作，开启失败之后的稍后重试操作</li><li>如果稍后重试失败，则抛出相关异常</li><li>返回异常信息</li></ol><h3 id="4-2-option配置获取"><a href="#4-2-option配置获取" class="headerlink" title="4.2 option配置获取"></a>4.2 option配置获取</h3><p>​    代码比较简单，这里直接展开了，如果没有调用参数，返回默认的option陪孩子，否则按照制定条件构建Options配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Options findOptions(Object[] argv) &#123;</span><br><span class="line">   if (argv &#x3D;&#x3D; null || argv.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">     return this.options;</span><br><span class="line">   &#125;</span><br><span class="line">   return Stream.of(argv)</span><br><span class="line">       .filter(Options.class::isInstance)</span><br><span class="line">       .map(Options.class::cast)</span><br><span class="line">       .findFirst()</span><br><span class="line">       .orElse(this.options);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-构建重试器"><a href="#4-3-构建重试器" class="headerlink" title="4.3 构建重试器"></a>4.3 构建重试器</h3><p>​    重试器这部分会调用一个叫做<code>clone()</code>的方法，注意这个clone方法是被重写过的，使用的是默认实现的重试器。另外，个人认为这个方法的起名容易造成误解，个人比较倾向于构建一个叫做<code>new Default()</code>的构造函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Retryer clone() &#123;</span><br><span class="line">     return new Default(period, maxPeriod, maxAttempts);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>​    异常重试代码如下，逻辑比较简单，大致浏览即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public void continueOrPropagate(RetryableException e) &#123;</span><br><span class="line">     if (attempt++ &gt;&#x3D; maxAttempts) &#123;</span><br><span class="line">       throw e;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     long interval;</span><br><span class="line">     if (e.retryAfter() !&#x3D; null) &#123;</span><br><span class="line">       interval &#x3D; e.retryAfter().getTime() - currentTimeMillis();</span><br><span class="line">       if (interval &gt; maxPeriod) &#123;</span><br><span class="line">         interval &#x3D; maxPeriod;</span><br><span class="line">       &#125;</span><br><span class="line">       if (interval &lt; 0) &#123;</span><br><span class="line">         return;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       interval &#x3D; nextMaxInterval();</span><br><span class="line">     &#125;</span><br><span class="line">     try &#123;</span><br><span class="line">       Thread.sleep(interval);</span><br><span class="line">     &#125; catch (InterruptedException ignored) &#123;</span><br><span class="line">       Thread.currentThread().interrupt();</span><br><span class="line">       throw e;</span><br><span class="line">     &#125;</span><br><span class="line">     sleptForMillis +&#x3D; interval;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>​    这里的重试间隔按照<strong>1.5的倍数</strong>进行重试，如果超过重试设置的最大因子数则停止重试。</p><h3 id="4-4-请求发送和结果处理"><a href="#4-4-请求发送和结果处理" class="headerlink" title="4.4 请求发送和结果处理"></a>4.4 请求发送和结果处理</h3><p>​    当进行上面的基础配置之后紧接着就是执行请求的发送操作了，在发送只求之前还有一步关键的操作：<strong>拦截器处理</strong></p><p>​    这里会遍历事先配置的拦截器，<strong>对于请求模板做最后的处理操作</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Request targetRequest(RequestTemplate template) &#123;</span><br><span class="line">  for (RequestInterceptor interceptor : requestInterceptors) &#123;</span><br><span class="line">    interceptor.apply(template);</span><br><span class="line">  &#125;</span><br><span class="line">  return target.apply(template);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关于日志输出级别的控制"><a href="#关于日志输出级别的控制" class="headerlink" title="关于日志输出级别的控制"></a>关于日志输出级别的控制</h4><p>​    执行请求这部分代码当中，会出现比较多类似下面的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (logLevel !&#x3D; Logger.Level.NONE) &#123;</span><br><span class="line">      logger.logRequest(metadata.configKey(), logLevel, request);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    关于日志输出的级别根据如下的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public enum Level &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * No logging.</span><br><span class="line">     不进行打印，也是默认配置</span><br><span class="line">     *&#x2F;</span><br><span class="line">    NONE,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Log only the request method and URL and the response status code and execution time.</span><br><span class="line">     只记录请求方法和URL以及响应状态代码和执行时间。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    BASIC,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Log the basic information along with request and response headers.</span><br><span class="line">     记录基本信息以及请求和响应头。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    HEADERS,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Log the headers, body, and metadata for both requests and responses.</span><br><span class="line">     记录请求和响应的头、主体和元数据。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    FULL</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="client发送请求（重点）"><a href="#client发送请求（重点）" class="headerlink" title="client发送请求（重点）"></a>client发送请求（重点）</h4><p>​    这里同样截取了<code>feign.SynchronousMethodHandler#executeAndDecode</code>的部分代码，毫无疑问最关键的部分是<code>client.execute(request, options)</code>方法。下面是对应的代码内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Response response;</span><br><span class="line">long start &#x3D; System.nanoTime();</span><br><span class="line">try &#123;</span><br><span class="line">  response &#x3D; client.execute(request, options);</span><br><span class="line">  &#x2F;&#x2F; ensure the request is set. TODO: remove in Feign 12</span><br><span class="line">  response &#x3D; response.toBuilder()</span><br><span class="line">      .request(request)</span><br><span class="line">      .requestTemplate(template)</span><br><span class="line">      .build();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">  if (logLevel !&#x3D; Logger.Level.NONE) &#123;</span><br><span class="line">    logger.logIOException(metadata.configKey(), logLevel, e, elapsedTime(start));</span><br><span class="line">  &#125;</span><br><span class="line">  throw errorExecuting(request, e);</span><br><span class="line">&#125;</span><br><span class="line">long elapsedTime &#x3D; TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);</span><br></pre></td></tr></table></figure><p>​    下面是<strong>client</strong>对象的继承结构图：</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20210527141927.png?ynotemdtimestamp=1625580577970" alt="img"></p><p>​    根据上面的结构图，简单说明<strong>client</strong>的默认实现：</p><ol><li>请求方策略实现，定义顶层接口 <strong>client</strong>，在默认的情况下使用<strong>Default</strong> 类作为实现类。通过子类<strong>proxied</strong>对象实现 <strong><span class="exturl" data-url="aHR0cDovL2phdmEubmV0" title="http://java.net">java.net<i class="fa fa-external-link"></i></span></strong> 的<strong>URL请求方式</strong>。也就是说即使没有任何的辅助三方工具，也可以通过此方法api模拟构建http请求。</li><li>可以使用<strong>okhttp</strong>和<strong>httpclient</strong> 高性能实现进行替代，需要引入对应的feign接入实现。</li></ol><p><strong>client对应的Default代码逻辑：</strong></p><ul><li>构建请求URL对象<strong>HttpUrlConnection</strong></li><li>如果是Http请求对象，可以根据条件设置ssl或者域名签名</li><li>设置http基本请求参数</li><li>收集Header信息，设置GZIP压缩编码</li><li>设置accept：<em>/</em></li><li>检查是否开启内部缓冲，如果设置了则按照指定长度缓冲</li></ul><p>​    代码调用的核心部分，默认按照<strong><span class="exturl" data-url="aHR0cDovL2phdmEubmV0" title="http://java.net">java.net<i class="fa fa-external-link"></i></span></strong>的<strong>httpconnection</strong> 进行处理。使用原始的网络IO流进行请求的处理，效率比较低下面是对应的具体实现代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Response execute(Request request, Options options) throws IOException &#123;</span><br><span class="line">      HttpURLConnection connection &#x3D; convertAndSend(request, options);</span><br><span class="line">      return convertResponse(connection, request);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    通过数据转化和请求发送之后下面根据结果进行响应内容的封装和处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 请求结果处理</span><br><span class="line">Response convertResponse(HttpURLConnection connection, Request request) throws IOException &#123;</span><br><span class="line">    int status &#x3D; connection.getResponseCode();</span><br><span class="line">    String reason &#x3D; connection.getResponseMessage();</span><br><span class="line">&#x2F;&#x2F; 状态码异常处理</span><br><span class="line">    if (status &lt; 0) &#123;</span><br><span class="line">        throw new IOException(format(&quot;Invalid status(%s) executing %s %s&quot;, status,</span><br><span class="line">                                     connection.getRequestMethod(), connection.getURL()));</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F; 请求头的处理</span><br><span class="line">    Map&lt;String, Collection&lt;String&gt;&gt; headers &#x3D; new LinkedHashMap&lt;&gt;();</span><br><span class="line">    for (Map.Entry&lt;String, List&lt;String&gt;&gt; field : connection.getHeaderFields().entrySet()) &#123;</span><br><span class="line">        &#x2F;&#x2F; response message</span><br><span class="line">        if (field.getKey() !&#x3D; null) &#123;</span><br><span class="line">            headers.put(field.getKey(), field.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Integer length &#x3D; connection.getContentLength();</span><br><span class="line">    if (length &#x3D;&#x3D; -1) &#123;</span><br><span class="line">        length &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">    InputStream stream;</span><br><span class="line">    &#x2F;&#x2F; 对于状态码400以上的内容进行错误处理</span><br><span class="line">    if (status &gt;&#x3D; 400) &#123;</span><br><span class="line">        stream &#x3D; connection.getErrorStream();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        stream &#x3D; connection.getInputStream();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 构建返回结果</span><br><span class="line">    return Response.builder()</span><br><span class="line">        .status(status)</span><br><span class="line">        .reason(reason)</span><br><span class="line">        .headers(headers)</span><br><span class="line">        .request(request)</span><br><span class="line">        .body(stream, length)</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>小插曲：关于reason属性（可以跳过）</p><p>​    查看源代码的时候无意间看到这里有一个个人比较在意的点，下面是respose中有一个叫做reason的字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Nullable and not set when using http&#x2F;2</span><br><span class="line"> * 作者如下说明 在http2中可以不设置改属性</span><br><span class="line"> * See https:&#x2F;&#x2F;github.com&#x2F;http2&#x2F;http2-spec&#x2F;issues&#x2F;202</span><br><span class="line"> *&#x2F;</span><br><span class="line">public String reason() &#123;</span><br><span class="line">  return reason;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    看到这一段顿时有些好奇<strong>为什么不需要设置reason</strong>，当然github上面也有类似的提问。</p><p>这个老哥是在2013年是这么回答的，直白翻译就是：<strong>关我卵事</strong>！</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20210527115406.png?ynotemdtimestamp=1625580577970" alt="img"></p><p>然而事情没有结束，后面又有人详细的进行了提问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原文</span><br><span class="line">i&#39;m curious what was the logical reason for dropping the reason phrase?</span><br><span class="line">i was using the reason phrase as a title for messages presented to a user in the web browser client. i think most users are accustomed to such phrases, &quot;Bad Request&quot;, &quot;Not Found&quot;, etc. Now I will just have to write a mapping from status codes to my own reason phrases in the client.</span><br><span class="line">机翻：</span><br><span class="line">我很好奇，放弃&quot;reason&quot;这个词的逻辑原因是什么? 我使用“reason”作为在web浏览器客户端向用户呈现的消息的标题。我认为大多数用户习惯于这样的短语，“错误请求”，“未找到”等。现在我只需要在客户机中编写一个从状态代码到我自己的理由短语的映射。</span><br></pre></td></tr></table></figure><p>然后估计是受不了各种提问，上文的<strong>mnot</strong>五年后给出了一个明确的回答：</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20210527120005.png?ynotemdtimestamp=1625580577970" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原因短语——即使在HTTP&#x2F;1.1中——也不能保证端到端携带;</span><br><span class="line">实现可以(也确实)忽略它并替换自己的值(例如，200总是“OK”，不管在网络上发生什么)。</span><br><span class="line"></span><br><span class="line">考虑到这一点，再加上携带额外字节的开销，将其从线路上删除是有意义的。</span><br></pre></td></tr></table></figure><p>为了证实他的说法，从 <strong><span class="exturl" data-url="aHR0cHM6Ly93d3cudzMub3JnL1Byb3RvY29scy9yZmMyNjE2L3JmYzI2MTYtc2VjNi5odG1s" title="https://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html">https://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html<i class="fa fa-external-link"></i></span></strong> w3c的网站中找到的如下的说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The Status-Code is intended for use by automata and the Reason-Phrase is intended for the human user. The client is not required to examine or display the Reason- Phrase.</span><br><span class="line">状态代码用于自动机，而原因短语用于人类用户。客户端不需要检查或显示原因-短语。</span><br></pre></td></tr></table></figure><p>这一段来源于Http1.1的规范描述。</p><p><strong>所以有时候能从源码发掘出不少的故事，挺有趣的</strong></p></blockquote><h4 id="FeignBlockingLoadBalancerClient-作为负载均衡使用："><a href="#FeignBlockingLoadBalancerClient-作为负载均衡使用：" class="headerlink" title="FeignBlockingLoadBalancerClient 作为负载均衡使用："></a>FeignBlockingLoadBalancerClient 作为负载均衡使用：</h4><p>​    这个类相当于openFeign和ribbon的中转类，将openfeign的请求转接给ribbon实现负载均衡。到这里会有一个疑问：client是如何做出选择使用ribbon还是spring cloud的呢的呢？</p><p>​    其实仔细想想不难理解，负载均衡肯定是在spring bean初始化的时候完成的。<strong>FeignClientFactoryBean</strong>是整个实现的关键。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class FeignClientFactoryBean implements FactoryBean&lt;Object&gt;, InitializingBean, ApplicationContextAware</span><br></pre></td></tr></table></figure><p>​    下面是<code>org.springframework.cloud.openfeign.FeignClientFactoryBean#getTarget</code>方法代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"></span><br><span class="line">  public Object getObject() **throws** Exception &#123;</span><br><span class="line"></span><br><span class="line">    return getTarget();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"></span><br><span class="line">   \* @param &lt;T&gt; the target type of the Feign client 客户端的目标类型</span><br><span class="line"></span><br><span class="line">   \* @return a &#123;@link Feign&#125; client created with the specified data and the context 指定数据或者上下文</span><br><span class="line"></span><br><span class="line">   \* information</span><br><span class="line"></span><br><span class="line">   *&#x2F;</span><br><span class="line"></span><br><span class="line">  &lt;T&gt; T getTarget() &#123;</span><br><span class="line"></span><br><span class="line">    FeignContext context &#x3D; applicationContext.getBean(FeignContext.class);</span><br><span class="line"></span><br><span class="line">    Feign.Builder builder &#x3D; feign(context);</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 如果URL为空，默认会尝试使用**</span><br><span class="line"></span><br><span class="line">    if (!StringUtils.hasText(url)) &#123;</span><br><span class="line"></span><br><span class="line">      if (!name.startsWith(&quot;http&quot;)) &#123;</span><br><span class="line"></span><br><span class="line">        url &#x3D; &quot;http:&#x2F;&#x2F;&quot; + name;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      else &#123;</span><br><span class="line"></span><br><span class="line">        url &#x3D; name;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      url +&#x3D; cleanPath();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; **默认使用ribbon作为负载均衡，如果没有找到，会抛出异常**</span><br><span class="line"></span><br><span class="line">      return (T) loadBalance(builder, context,</span><br><span class="line"></span><br><span class="line">          new HardCodedTarget&lt;&gt;(type, name, url));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (StringUtils.hasText(url) &amp;&amp; !url.startsWith(&quot;http&quot;)) &#123;</span><br><span class="line"></span><br><span class="line">      url &#x3D; &quot;http:&#x2F;&#x2F;&quot; + url;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String url &#x3D; this.url + cleanPath();</span><br><span class="line"></span><br><span class="line">    Client client &#x3D; getOptional(context, Client.class);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 根据当前的系统设置实例化不同的负载均衡器</span><br><span class="line"></span><br><span class="line">    if (client !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">      if (client instanceof LoadBalancerFeignClient) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; not load balancing because we have a url,but ribbon is on the classpath, so unwrap</span><br><span class="line">          &#x2F;&#x2F; 不是负载平衡，因为我们有一个url，但是ribbon在类路径上，所以展开</span><br><span class="line">        client &#x3D; ((LoadBalancerFeignClient) client).getDelegate();</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (client instanceof FeignBlockingLoadBalancerClient) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; not load balancing because we have a url, but Spring Cloud LoadBalancer is on the classpath, so unwrap</span><br><span class="line">          &#x2F;&#x2F; 不是负载平衡，因为我们有一个url，但Spring Cloud LoadBalancer是在类路径上，所以展开</span><br><span class="line"></span><br><span class="line">        client &#x3D; ((FeignBlockingLoadBalancerClient) client).getDelegate();</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      builder.client(client);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Targeter targeter &#x3D; get(context, Targeter.class);</span><br><span class="line"></span><br><span class="line">    return (T) targeter.target(this, builder, context,</span><br><span class="line"></span><br><span class="line">        new HardCodedTarget&lt;&gt;(type, name, url));</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>​    上面的内容描述了一个负载均衡器的初始化的完整过程。也证明了<strong>spring cloud 使用 ribbon 作为默认的初始化</strong>，感兴趣可以全局搜索一下这一段异常，间接说明默认使用的是ribbon作为负载均衡：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw new IllegalStateException(&quot;No Feign Client for defined. Did you forget to include spring-cloud-starter-netflix-ribbon?&quot;);</span><br></pre></td></tr></table></figure><blockquote><p>拓展：</p><p>​    在feign.Client.Default#convertAndSend()，有一段如下的代码设置</p><p>​    <code>connection.setChunkedStreamingMode(8196);</code></p><p>​    如果在代码中禁用ChunkedStreamMode，与设置4096的代码相比有什么效果？</p><p>​    <strong>这样做的结果是整个输出都被缓冲，直到关闭为止，这样Content-length标头可以被首先设置和发送，这增加了很多延迟和内存。对于大文件，不建议使用。</strong></p><p>答案来源：<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDYyNDk0MDEvZWZmZWN0LW9mLWh0dHB1cmxjb25uZWN0aW9uLXNldGNodW5rZWRzdHJlYW1pbmdtb2Rl" title="https://stackoverflow.com/questions/46249401/effect-of-httpurlconnection-setchunkedstreamingmode">HttpUrlConnection.setChunkedStreamingMode的效果<i class="fa fa-external-link"></i></span></p></blockquote><h4 id="关于编解码的处理"><a href="#关于编解码的处理" class="headerlink" title="关于编解码的处理"></a>关于编解码的处理</h4><p>​    这一部分请阅读4.1 部分的<strong>关于报文数据编码和解码的细节</strong>部分内容</p><p>至此一个基本的调用流程基本就算是完成了。</p><h2 id="openFeign-整体调用链路图"><a href="#openFeign-整体调用链路图" class="headerlink" title="openFeign 整体调用链路图"></a>openFeign 整体调用链路图</h2><p>​    先借（偷）一张参考资料的图来看下整个openFeign的链路调用：</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20210527160429.png?ynotemdtimestamp=1625580577970" alt="img"></p><p>​    下面是个人根据资料自己画的图：</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/openFeign%E8%B0%83%E7%94%A8%E9%93%BE%E8%B7%AF.png?ynotemdtimestamp=1625580577970" alt="img"></p><h2 id="openFeign注解处理流程"><a href="#openFeign注解处理流程" class="headerlink" title="openFeign注解处理流程"></a>openFeign注解处理流程</h2><p>​    我们先看下开启openFeign的方式注解：<strong>@EnableFeignClients</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Documented</span><br><span class="line">@Import(FeignClientsRegistrar.class)</span><br><span class="line">public @interface EnableFeignClients &#123;&#125;</span><br></pre></td></tr></table></figure><p>​    注意这里的一个注解<code>@Import(FeignClientsRegistrar.class)</code>。毫无疑问，实现的细节在<code>FeignClientsRegistrar.class</code>内部：</p><p>​    剔除掉其他的逻辑和细节，关键代码在这一块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (String basePackage : basePackages) &#123;</span><br><span class="line">         &#x2F;&#x2F;….</span><br><span class="line">registerFeignClient(registry, annotationMetadata, attributes);</span><br><span class="line">        &#x2F;&#x2F;….</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>​    这里调用了<code>registerFeignClient</code>注册feign，根据注解配置扫描得到响应的basepakage，如果没有配置，则默认按照注解所属类的路径进行扫描。</p><p>​    下面的代码根据扫描的结果注入相关的bean信息，比如url，path，name，回调函数等。最后使用BeanDefinitionReaderUtils 对于bean的方法和内容进行注入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">private void registerFeignClient(BeanDefinitionRegistry registry,</span><br><span class="line">            AnnotationMetadata annotationMetadata, Map&lt;String, Object&gt; attributes) &#123;</span><br><span class="line">        String className &#x3D; annotationMetadata.getClassName();</span><br><span class="line">    &#x2F;&#x2F;bean配置</span><br><span class="line">    </span><br><span class="line">        BeanDefinitionBuilder definition &#x3D; BeanDefinitionBuilder</span><br><span class="line">                .genericBeanDefinition(FeignClientFactoryBean.class);</span><br><span class="line">        validate(attributes);</span><br><span class="line">        definition.addPropertyValue(&quot;url&quot;, getUrl(attributes));</span><br><span class="line">        definition.addPropertyValue(&quot;path&quot;, getPath(attributes));</span><br><span class="line">        String name &#x3D; getName(attributes);</span><br><span class="line">        definition.addPropertyValue(&quot;name&quot;, name);</span><br><span class="line">        String contextId &#x3D; getContextId(attributes);</span><br><span class="line">        definition.addPropertyValue(&quot;contextId&quot;, contextId);</span><br><span class="line">        definition.addPropertyValue(&quot;type&quot;, className);</span><br><span class="line">        definition.addPropertyValue(&quot;decode404&quot;, attributes.get(&quot;decode404&quot;));</span><br><span class="line">        definition.addPropertyValue(&quot;fallback&quot;, attributes.get(&quot;fallback&quot;));</span><br><span class="line">        definition.addPropertyValue(&quot;fallbackFactory&quot;, attributes.get(&quot;fallbackFactory&quot;));</span><br><span class="line">        definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line"> </span><br><span class="line">        String alias &#x3D; contextId + &quot;FeignClient&quot;;</span><br><span class="line">        AbstractBeanDefinition beanDefinition &#x3D; definition.getBeanDefinition();</span><br><span class="line">        beanDefinition.setAttribute(FactoryBean.OBJECT_TYPE_ATTRIBUTE, className);</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; has a default, won&#39;t be null</span><br><span class="line">    &#x2F;&#x2F; 如果未配置会存在默认的配置</span><br><span class="line">        boolean primary &#x3D; (Boolean) attributes.get(&quot;primary&quot;);</span><br><span class="line"> </span><br><span class="line">        beanDefinition.setPrimary(primary);</span><br><span class="line"> </span><br><span class="line">        String qualifier &#x3D; getQualifier(attributes);</span><br><span class="line">        if (StringUtils.hasText(qualifier)) &#123;</span><br><span class="line">            alias &#x3D; qualifier;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        BeanDefinitionHolder holder &#x3D; new BeanDefinitionHolder(beanDefinition, className,</span><br><span class="line">                new String[] &#123; alias &#125;);</span><br><span class="line">    &#x2F;&#x2F; 注册Bean</span><br><span class="line">        BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    看完了基本的注册机制，我们再来看看Bean是如何完成自动注入的：这里又牵扯到另一个注解-@FeignAutoConfiguration</p><h3 id="FeignAutoConfiguration-简单介绍"><a href="#FeignAutoConfiguration-简单介绍" class="headerlink" title="@FeignAutoConfiguration 简单介绍"></a>@FeignAutoConfiguration 简单介绍</h3><p>​    关于feign的注入，在此类中提供了两种的形式：</p><ul><li><p>如果存在<strong>HystrixFeign</strong>，则使用 <strong>HystrixTargeter</strong> 方法。</p></li><li><p>如果不存在，此时会实例化一个<strong>DefaultTargeter</strong> 作为默认的实现者</p><p>具体的操作代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Configuration(proxyBeanMethods &#x3D; false)</span><br><span class="line">   @ConditionalOnClass(name &#x3D; &quot;feign.hystrix.HystrixFeign&quot;)</span><br><span class="line">   protected static class HystrixFeignTargeterConfiguration &#123;</span><br><span class="line"></span><br><span class="line">       @Bean</span><br><span class="line">          &#x2F;&#x2F; 优先使用Hystrix</span><br><span class="line">       @ConditionalOnMissingBean</span><br><span class="line">       public Targeter feignTargeter() &#123;</span><br><span class="line">           return new HystrixTargeter();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Configuration(proxyBeanMethods &#x3D; false)</span><br><span class="line">&#x2F;&#x2F;如果不存在Hystrix，则使用默认的tagerter</span><br><span class="line">   @ConditionalOnMissingClass(&quot;feign.hystrix.HystrixFeign&quot;)</span><br><span class="line">   protected static class DefaultFeignTargeterConfiguration &#123;</span><br><span class="line"></span><br><span class="line">       @Bean</span><br><span class="line">       @ConditionalOnMissingBean</span><br><span class="line">       public Targeter feignTargeter() &#123;</span><br><span class="line">           return new DefaultTargeter();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>复习一下springboot几个核心的注解代表的含义：</p><ul><li><strong>@ConditionalOnBean</strong> // 当给定的在bean存在时,则实例化当前Bean</li><li><strong>@ConditionalOnMissingBean</strong> // 当给定的在bean不存在时,则实例化当前Bean</li><li><strong>@ConditionalOnClass</strong> // 当给定的类名在类路径上存在，则实例化当前Bean</li><li><strong>@ConditionalOnMissingClass</strong> // 当给定的类名在类路径上不存在，则实例化当前Bea</li></ul></blockquote><h3 id="关于HystrixInvocationHandler的invoke方法："><a href="#关于HystrixInvocationHandler的invoke方法：" class="headerlink" title="关于HystrixInvocationHandler的invoke方法："></a>关于HystrixInvocationHandler的invoke方法：</h3><p>​    <code>Feign.hystrix.HystrixInvocationHandler</code> <em>当中执行的<strong>invoke</strong>实际上还是SyncronizedMethodHandler</em> <em>方法</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HystrixInvocationHandler.this.dispatch.get(method).invoke(args);</span><br></pre></td></tr></table></figure><p>​    内部代码同时还使用了命令模式的命令 <strong>HystrixCommand</strong> 进行封装。由于不是本文重点，这里不做扩展。</p><blockquote><p><strong>HystrixCommand 这个对象又是拿来干嘛的？</strong></p><p>简介：用于包装代码，将执行具有潜在风险的功能(通常是指通过网络的服务调用)与故障和延迟容忍，统计和性能指标捕获，断路器和隔板功能。这个命令本质上是一个阻塞命令，但如果与<code>observe()</code>一起使用，它提供了一个可观察对象外观。</p><p>实现接口：<code>HystrixObservable</code> / <code>HystrixInvokableInfo</code></p><p><code>HystrixInvokableInfo</code>: 存储命令接口的规范，子类要求实现</p><p><code>HystrixObservable</code>: 变成观察者支持非阻塞调用</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​    第一次总结源码，更多的是参考网上的资料顺着别人的思路自己去一点点看的。（哈哈，闻道有先后，术业有专攻）如果有错误欢迎指出。</p><p>​    不同于spring那复杂层层抽象，openFeign的学习和“模仿”价值更具有意义，很多代码一眼就可以看到设计模式的影子，比较适合自己练手和学习提高个人的编程技巧。</p><p>​    另外，openFeign使用了很多的包访问结构，这对于在此基础上二次扩展的sentianl框架是个头疼的问题，不过好在可以站在反射大哥的背后，直接暴力访问。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTA0MDY2MjI5OTI3OTUwI2hlYWRpbmctMTY=" title="https://juejin.cn/post/6844904066229927950#heading-16">掘金博客【非常好】<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9teS5vc2NoaW5hLm5ldC93ZWNhbndldXAvYmxvZy8zMjM4MjYx" title="https://my.oschina.net/wecanweup/blog/3238261">关于负载均衡的介绍来源<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnNwcmluZy5pby9zcHJpbmctY2xvdWQtb3BlbmZlaWduL2RvY3MvY3VycmVudC9yZWZlcmVuY2UvaHRtbC8jZmVpZ24tbWV0cmljcw==" title="https://docs.spring.io/spring-cloud-openfeign/docs/current/reference/html/#feign-metrics">官方文档<i class="fa fa-external-link"></i></span></p><blockquote><p>结合源码再回顾官方文档提到的功能</p></blockquote><p><span class="exturl" data-url="aHR0cHM6Ly90b29sLm9zY2hpbmEubmV0L2hpZ2hsaWdodA==" title="https://tool.oschina.net/highlight">在线代码格式化<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cud2Vic2VxdWVuY2VkaWFncmFtcy5jb20v" title="https://www.websequencediagrams.com/">在线画图软件<i class="fa fa-external-link"></i></span></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      源码阅读
    
    </summary>
    
    
      <category term="springcloud" scheme="https://whitestore.top/categories/springcloud/"/>
    
    
      <category term="springcloud" scheme="https://whitestore.top/tags/springcloud/"/>
    
  </entry>
  
  <entry>
    <title>【ipad】xmind使用快捷键技巧</title>
    <link href="https://whitestore.top/2021/07/06/xmindipad/"/>
    <id>https://whitestore.top/2021/07/06/xmindipad/</id>
    <published>2021-07-06T14:40:37.000Z</published>
    <updated>2021-07-06T15:11:14.970Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【ipad】xmind使用快捷键技巧"><a href="#【ipad】xmind使用快捷键技巧" class="headerlink" title="【ipad】xmind使用快捷键技巧"></a>【ipad】xmind使用快捷键技巧</h1><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20210519142029.png" alt=""></p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ol><li>k380键盘按键在空格的左边（比较反人类）</li><li>向上大箭头代表了<code>Shirft</code>键</li></ol><blockquote><p>个人在今年买了一个ipad进行笔记记录和学习，这里记录的主要是一些比较简单和实用方便的技巧和内容，不定时更新</p></blockquote><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      ipad技巧
    
    </summary>
    
    
      <category term="ipad" scheme="https://whitestore.top/categories/ipad/"/>
    
    
      <category term="ipad" scheme="https://whitestore.top/tags/ipad/"/>
    
  </entry>
  
  <entry>
    <title>《非暴力沟通》读书笔记</title>
    <link href="https://whitestore.top/2021/07/06/feibaoli/"/>
    <id>https://whitestore.top/2021/07/06/feibaoli/</id>
    <published>2021-07-06T14:40:21.000Z</published>
    <updated>2021-07-06T15:10:12.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《非暴力沟通》读书笔记"><a href="#《非暴力沟通》读书笔记" class="headerlink" title="《非暴力沟通》读书笔记"></a>《非暴力沟通》读书笔记</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    不知道为什么这本书总是让我想到印度战神甘地，对于他当初的非暴力不合作观点印象深刻。而看这本书的契机毫无疑问是“沟通”这两个字，无论从事何种职业，人际交往无疑是极为重要的，特别是人情关系复杂的中国。而这本书的大致内容就是告诉你如何把话说的更好。简单理解就是把低情商容易让人反感的话转化思维变成高情商更容易让人理解并且听着舒服的话，如果用更简单的话来说，就是学习如何换位思考。</p><a id="more"></a><h1 id="资源链接："><a href="#资源链接：" class="headerlink" title="资源链接："></a>资源链接：</h1><p>​    资源还是比较好找的</p><blockquote><p>链接：<span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMV8yYnZkNnhueHptMFhtZ3hPQ0FBT3c=" title="https://pan.baidu.com/s/1_2bvd6xnxzm0XmgxOCAAOw">https://pan.baidu.com/s/1_2bvd6xnxzm0XmgxOCAAOw<i class="fa fa-external-link"></i></span></p></blockquote><h1 id="推荐语"><a href="#推荐语" class="headerlink" title="推荐语"></a>推荐语</h1><p>​    语言是一门艺术，而学会如何更好的表达语言成为每一个人的必修课。非暴力沟通阐述了一个独特的沟通流程，用观察，感受，需要，请求四个重点阐述非暴力沟通的魅力。非暴力不仅意味着对待他人非暴力，从这本书中，你能学会如何用非暴力来“爱自己”。</p><h1 id="推荐程度"><a href="#推荐程度" class="headerlink" title="推荐程度"></a>推荐程度</h1><p>​    <strong>4星</strong>（满分五星），书中比较实用的部分是对于非暴力每一个内容沟通后面配套的练习，对于理解这本书作者的观点比较有用，同时也能更好的理解非暴力沟通的特点。</p><p>​    这本书的案例虽然比较“套路”，但是却能十分简单的表达作者表达的观点。配合小朋友的插画整本书阅读起来十分的轻松和愉快。</p><h1 id="内容概要"><a href="#内容概要" class="headerlink" title="内容概要"></a>内容概要</h1><p>在推荐里面说明了，这本书核心的内容主要为下面的内容：</p><ul><li>观察：<ul><li>区分观察与评论</li><li>区分观察与评论的要诀</li></ul></li><li>感受：<ul><li>区分感受与想法</li><li>学会表达感受</li></ul></li><li>需要：<ul><li>学会表达需要</li><li>学会倾听需要</li><li>学会爱自己</li></ul></li><li>请求<ul><li>学会表达请求</li><li>把握真实的需要</li></ul></li></ul><h2 id="观察"><a href="#观察" class="headerlink" title="观察"></a>观察</h2><p>​    观察非暴力沟通的第一个要义。而很多人分不清什么是观察什么是评论，比如“这个人很懒”就是一个典型的观察与评论混为一谈。而这种混淆视听很有可能带来误解，这也是为什么要首先要区分观察和评论，因为这是人在沟通中最容易犯的错误。</p><h3 id="区分观察与评论"><a href="#区分观察与评论" class="headerlink" title="区分观察与评论"></a>区分观察与评论</h3><p>​    区分观察与评论的重要方法是要杜绝对他人的“脸谱化”和“标签化”，推测他人想法和观察他人是两码事。这里按照书中的一个案例来介绍：”他太大方了”，这明显是对于一个人的标签化，“出手阔绰”变成这个人标签，按照区分观察与评论的方式，转化为“他经常请别人吃饭（观察），我认为他是一个阔绰的人（评论）”这样一拆分之后，我们便能很清楚的分解出观察与评论，同时这样一拆分一看，我们能更加客观的看待一个人，因为经常请人吃饭并不一定意味着阔绰。但是我们常常因为简单思考无意中把观察与评论混为一谈。</p><h3 id="区分观察与评论的要诀"><a href="#区分观察与评论的要诀" class="headerlink" title="区分观察与评论的要诀"></a>区分观察与评论的要诀</h3><p>​    如果要加以区分，我认为观察与评论的区分的要诀如下：</p><ul><li><strong>你的描述是否含有“副作用”</strong></li><li><strong>先描述行为过程，再描述对于行为的看法</strong></li><li><strong>三思而后行</strong></li></ul><p>​    要满足上面的点似乎并不是十分容易的一件事情，因为沟通过程中往往没有短暂的思考时间，这需要小心的练习。</p><h2 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h2><p>​    感受的正确与否决定了我们沟通能否充分满足他人的需要。</p><h3 id="区分感受与想法"><a href="#区分感受与想法" class="headerlink" title="区分感受与想法"></a>区分感受与想法</h3><p>​    感受往往意味着个人对于心情的描述，他具备丰富的情感色彩。而想法往往是对一件事情引发后果的“感悟”，所以感受与想法经常容易混为一谈。</p><p>​    关于感受这部分的内容对个人的触动比较大，因为我们很多时候并不习惯表达自己的感受，对于书中印象比较深的部分是作者询问一个大学生对于室友晚上听歌音量过大的感受，而大学生认为自己室友放歌音量太大对于周围的人影响不好，这里其实是“想法”而不是“感受”，正确的感受应该是：“你听歌的声音太大了，这吵到我睡不着觉，请问你可以稍微关小点声么”等等，这才是真切的表达感受，这一段也可以看到个人性格是对感受的表达影响最大的部分。</p><p>​    感受的另一个方面是感同身受，有时候我们往往“自以为是”的感受别人的想法去安慰他人并且表达自己的感受，然而多数情况下这种做法反而更容易伤害到他人。我们按照自己的想法去替他人出谋划策的行为往往是不负责任的，因为这并没有区分感受与想法，我们并没有听到对方的真实需要。</p><h3 id="学会表达感受"><a href="#学会表达感受" class="headerlink" title="学会表达感受"></a>学会表达感受</h3><p>​    学会表达感受，其实简单来看就是四个字：<strong>换位思考</strong>。</p><p>​    作者在书中阐述了对于不中听的话的四种行为：</p><ul><li><strong>责备自己</strong></li><li><strong>指责他人</strong></li><li><strong>体会自己的感受和需要</strong></li><li><strong>体会他人的感受和需要</strong></li></ul><p>​    很明显这是一个递进的过程，多数情况下人会在第一点或者第二点止步，要么责备自己说错了话，要么责备他人不理解自己，然而很明显这仅仅是表达想法而不是表达自己的感受。那么如何才算是表达感受呢？在多数情况下，我们冷静之后通常会反思自己的行为，会回想自己当初为何如此愤怒甚至会认为自己当时十分可笑。所以第三点基本是可以满足的，我们体会自己的感受和真实需要之后，让矛盾化解和重归于好，当我们正确阐述完自己的当时的心情感受和对于事情的想法之后，问题迎刃而解。</p><p>​    然而最后一点才是至关重要的，体会他人的感受和需要意味着跨出自己的视野，用照镜子的角度来双向的看待问题，“他在当时为什么会说那种话”，这是他真实的心情还是一时的气话，该不该各自冷静一下再去解决问题。换位带来的是更多的思考，我们越是尝试去感受他人的感受，我们越会发现问题并不是出在谁的身上，问题往往是出在沟通的方式身上。</p><p>​    所以从各种案例来看，学会表达感受最重要的还是学会换位思考。</p><h2 id="需要"><a href="#需要" class="headerlink" title="需要"></a>需要</h2><p>​    这一部分是《非暴力沟通》的核心部分，需要是沟通最为核心的部分，因为沟通多数情况下是为了满足个人的需要，就比如我们在无聊的时候用闲聊来打发时间，在犯困的时候想要睡觉，这些事最表层的需要，而有些时候，我们常常将自己最真实的需要压抑在自己的内心深处。</p><p>​    学会表达需要是最为重要的，和观察与评论一样，人很容易混淆自己的感受和需要，人有时候甚至会欺骗自己，很多时候我们的感受并没有贴切我们的需要，我们会借由其他的事情发泄我们的烦恼，我们常常将我们不喜欢的习惯强加给自己，比如有的人不喜欢做饭却又不得不做饭，这种自相矛盾不断的伤害自己的感受，当我们转变自己，改变自己的需要，我们会发现寻找更快的做菜方法，甚至偶尔买一些便利菜问题便迎刃而解，这才是真正的满足我们的内心需要，满足我们偶尔想要偷懒的心情（但请不要放纵）。</p><h3 id="学会表达需要"><a href="#学会表达需要" class="headerlink" title="学会表达需要"></a>学会表达需要</h3><p>​    学会表达需要的要诀在于：询问自己内心最迫切的想法 需要有时候会和感受混为一谈，通常我们需要区分体会感受和体会需要。比如“我需要安静”从表面的意义来看是让他人安静一些，实际这明显不是表达自己的需要（更像是在发牢骚），因为这句话并没有清楚的表达需要，如果把这句话换为：“这里的环境噪音太大了，我需要换个安静的地方呆一呆”，这句话经过的细微的转换，询问了自己内心真实的想法，所以他的需要能准确的传达个他人而没有造成误解。</p><h3 id="学会倾听需要"><a href="#学会倾听需要" class="headerlink" title="学会倾听需要"></a>学会倾听需要</h3><p>​    在没有明白他人的需要之前，我们应该放下自己的脚步充分的倾听他人的需要。</p><p>​    倾听需要我们猜测和感受他人的想法，体会他人的个人情感和需要，如果不能明白充分的感情需要，此时我们需要根据猜测和反馈，逐渐引导自非暴力沟通的方式进行交流。</p><p>​    学会倾听需要的核心在于：</p><ul><li><strong>猜测与揣摩他人真实的意图。</strong></li><li><strong>感受和体会他人隐藏的需要。</strong></li><li><strong>如果无法推测，直接请求反馈</strong></li></ul><h3 id="学会爱自己"><a href="#学会爱自己" class="headerlink" title="学会爱自己"></a>学会爱自己</h3><p>​    这个可能在最初看到的时候有些好奇，为什么需要和爱自己会扯上关系，后文通过解释因为自己的努力没有达成自己的目标的自信心受挫，这一块似乎又是《自控力》这本书提到的内容。人在受挫的时候通常情况下不会越挫越勇，反而会因此堕落逃避而一蹶不振。所以爱自己自然就是要学会倾听自己内心真实感受和需    要，抵消掉这种负面情绪，不再责备自己而是学会如何通过非暴力来宽恕自己，所以遇到挫折更应该原谅自己，重整旗鼓。</p><h2 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h2><p>​    请求是非暴力沟通的最后一步，请求意味着我们理解了对方的需要或者想让对方理解我们的需要，请求同样也是不可知的，因为个人思想容易导致请求的曲解，这时候需要更多的思考请求的需要。</p><p>​    请求和需要的关系是什么呢？请求意味着我们目标清晰的词语，我口渴了我需要水，请给我水喝可以明确的表达我们的需要，然而“我希望你能理解我”这种需要往往是很难传递的，因为他可能并不是实际的需要。这里在书中有一个具体的案例，讲述一个病床的老夫妇，丈夫病床上希望妻子的关怀，而妻子因为丈夫生病以及子女的不作为生气，两人深深陷入“假需要”陷阱，这种看似是请求实际上又根本对不到点上的情况十分常见。</p><h3 id="学会表达请求"><a href="#学会表达请求" class="headerlink" title="学会表达请求"></a>学会表达请求</h3><p>​    那么如何学会表达请求呢，书中首先要求避免使用非确定性的词汇，比如渴望/希望/觉得等等一系列容易产生误解的词语，这种词汇需要竭力的避免。</p><p>​    学会表达请求的另一个方式是请求帮助，适当的请求帮助可以达到互利共赢的效果，如果我们通过穷尽所有手段依然无法解决问题下，使用请求帮助是一个好方式，我们用诚恳的请求打动他人希望得到他人的帮助（当然别人拒绝帮助也应该正常对待）。</p><p>​    表达请求有时候可以通过请求反馈的方式完成，我们“猜测”他人的请求有时候不能准确把握他人的需要甚至会导致偏离原有的想法，这时候通过请求反馈的方式可以更容易抓住对方的感受以及需要，请求反馈也是一个不错的方式，也同样达到了换位思考的目的，让对方认可我们是在尽力的体会他人的感受和需要。</p><p>​    另外这部分内容的几个案例都十分有趣，值得仔细的推敲说话方式以及遇到沟通不顺的时候如何转化思路。</p><p>学会请求的方式：</p><ul><li><strong>仔细斟酌每一个词汇是否具备多重含义，尽量使用准确词语。</strong></li><li><strong>转化思路，用请求帮助的形式度过难关</strong></li><li><strong>深切的感受他人的感受和需要，如果无法体会，适时请求反馈</strong></li></ul><h3 id="把握真实的需要"><a href="#把握真实的需要" class="headerlink" title="把握真实的需要"></a>把握真实的需要</h3><p>​    真实的需要往往是难以琢磨的，究竟何为真实的需要呢？</p><p>​    真实的首先需要我们从观察开始，这里推荐看看<strong>《战争与和平》</strong>演员的表演，演员的表演是最容易锻炼我们看待人物的动作和表现来反映人物的心理的眼光的。</p><p>​    真实需要其次需要根据评论来阐述我们的观点，这一部分较为主观，对于一个事件每一个都有是非标准，我们永远无法猜透别人的答案，所以这需要准确的评论来体会他人的需要。</p><p>​    真实需要最终需要体会感受，体会感受意味着要体会当事人的心情，比如下雨了需要一把伞，天热了需要一杯可乐，感受有时候贴近人的本能，潜意识会伴随着这种真实的感受驱使大脑工作。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>观察评论，感受想法，体会需要，表达请求</strong>，这便是我对这本书的最终的理解。</p><p>每一个人有不同的性格，沟通对于有的人来说十分容易，对于有的人的来说却十分难以掌握技巧。这需要逼迫自己不断的训练。在沟通这个技能上面，生活无疑是最好的老师。</p><p>《非暴力沟通》的语言都十分的质朴但是十分的切入要点，当然也因为是书籍难免被人诟病理论高于实践而缺少意义。然而有什么技能是不需要实践可以学会的呢。现在社会的学习似乎陷入一种误区，看了代表会了，看了代表学了。然而不论看书也好学习也好，哪怕是学到书中的10%也好过一闪而过的100%。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      描述信息
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://whitestore.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://whitestore.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>jmeter压力测试学习</title>
    <link href="https://whitestore.top/2021/06/02/note20/"/>
    <id>https://whitestore.top/2021/06/02/note20/</id>
    <published>2021-06-02T09:52:09.791Z</published>
    <updated>2020-10-29T15:03:31.706Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>jmeter 作为实操性的软件，更注重练习，理论作为参考掌握即可，不需要去具体的纠结</p><a id="more"></a><h1 id="1-目前用的常用测试工具对比"><a href="#1-目前用的常用测试工具对比" class="headerlink" title="1. 目前用的常用测试工具对比"></a>1. 目前用的常用测试工具对比</h1><h2 id="1、loadrunner"><a href="#1、loadrunner" class="headerlink" title="1、loadrunner"></a>1、loadrunner</h2><p>​    性能稳定，压测结果及细粒度大，可以自定义脚本进行压测，但是太过于重大，功能比较繁多</p><p>​    1、loadrunner</p><h2 id="2、apache-ab-单接口压测最方便"><a href="#2、apache-ab-单接口压测最方便" class="headerlink" title="2、apache ab(单接口压测最方便)"></a>2、apache ab(单接口压测最方便)</h2><p>​    模拟多线程并发请求,ab命令对发出负载的计算机要求很低，既不会占用很多CPU，也不会占用太多的内存，但却会给目标服务器造成巨大的负载, 简单DDOS攻击等</p><h2 id="3、webbench"><a href="#3、webbench" class="headerlink" title="3、webbench"></a>3、webbench</h2><p>​    webbench首先fork出多个子进程，每个子进程都循环做web访问测试。子进程把访问的结果通过pipe告诉父进程，父进程做最终的统计结果。</p><h1 id="2-Jmeter基本介绍和使用场景"><a href="#2-Jmeter基本介绍和使用场景" class="headerlink" title="2. Jmeter基本介绍和使用场景"></a>2. Jmeter基本介绍和使用场景</h1><h2 id="1、压测不同的协议和应用"><a href="#1、压测不同的协议和应用" class="headerlink" title="1、压测不同的协议和应用"></a>1、压测不同的协议和应用</h2><p>​    1) Web - HTTP, HTTPS (Java, NodeJS, PHP, <span class="exturl" data-url="aHR0cDovL0FTUC5ORVQ=" title="http://ASP.NET">ASP.NET<i class="fa fa-external-link"></i></span>, …)     2) SOAP / REST Webservices     3) FTP     4) Database via JDBC     5) LDAP 轻量目录访问协议     6) Message-oriented middleware (MOM) via JMS     7) Mail - SMTP(S), POP3(S) and IMAP(S)     8) TCP等等</p><h2 id="2、使用场景及优点"><a href="#2、使用场景及优点" class="headerlink" title="2、使用场景及优点"></a>2、使用场景及优点</h2><p>1）功能测试     </p><p>2）压力测试     </p><p>3）分布式压力测试     </p><p>4）纯java开发     </p><p>5）上手容易，高性能     </p><p>6）提供测试数据分析     </p><p>7）各种报表数据图形展示</p><h1 id="3-本地快速安装Jmeter4-x"><a href="#3-本地快速安装Jmeter4-x" class="headerlink" title="3. 本地快速安装Jmeter4.x"></a>3. 本地快速安装Jmeter4.x</h1><h2 id="1、需要安装JDK8。或者JDK9-JDK10-建议不要使用jre10"><a href="#1、需要安装JDK8。或者JDK9-JDK10-建议不要使用jre10" class="headerlink" title="1、需要安装JDK8。或者JDK9,JDK10 (建议不要使用jre10)"></a>1、需要安装JDK8。或者JDK9,JDK10 (建议不要使用jre10)</h2><h2 id="2、快速下载"><a href="#2、快速下载" class="headerlink" title="2、快速下载"></a>2、快速下载</h2><p>​    windows： <span class="exturl" data-url="aHR0cDovL21pcnJvcnMudHVuYS50c2luZ2h1YS5lZHUuY24vYXBhY2hlLy9qbWV0ZXIvYmluYXJpZXMvYXBhY2hlLWptZXRlci00LjAuemlw" title="http://mirrors.tuna.tsinghua.edu.cn/apache//jmeter/binaries/apache-jmeter-4.0.zip">http://mirrors.tuna.tsinghua.edu.cn/apache//jmeter/binaries/apache-jmeter-4.0.zip<i class="fa fa-external-link"></i></span>     </p><p>mac或者linux：<span class="exturl" data-url="aHR0cDovL21pcnJvcnMudHVuYS50c2luZ2h1YS5lZHUuY24vYXBhY2hlLy9qbWV0ZXIvYmluYXJpZXMvYXBhY2hlLWptZXRlci00LjAudGd6" title="http://mirrors.tuna.tsinghua.edu.cn/apache//jmeter/binaries/apache-jmeter-4.0.tgz">http://mirrors.tuna.tsinghua.edu.cn/apache//jmeter/binaries/apache-jmeter-4.0.tgz<i class="fa fa-external-link"></i></span></p><h2 id="3、文档地址：http-jmeter-apache-org-usermanual-get-started-html"><a href="#3、文档地址：http-jmeter-apache-org-usermanual-get-started-html" class="headerlink" title="3、文档地址：http://jmeter.apache.org/usermanual/get-started.html"></a>3、文档地址：<span class="exturl" data-url="aHR0cDovL2ptZXRlci5hcGFjaGUub3JnL3VzZXJtYW51YWwvZ2V0LXN0YXJ0ZWQuaHRtbA==" title="http://jmeter.apache.org/usermanual/get-started.html">http://jmeter.apache.org/usermanual/get-started.html<i class="fa fa-external-link"></i></span></h2><h2 id="4、建议安装JDK环境，虽然JRE也可以，但是压测https需要JDK里面的-keytool工具"><a href="#4、建议安装JDK环境，虽然JRE也可以，但是压测https需要JDK里面的-keytool工具" class="headerlink" title="4、建议安装JDK环境，虽然JRE也可以，但是压测https需要JDK里面的 keytool工具"></a>4、建议安装JDK环境，虽然JRE也可以，但是压测https需要JDK里面的 keytool工具</h2><h1 id="4-jemeter-目录结构"><a href="#4-jemeter-目录结构" class="headerlink" title="4. jemeter 目录结构"></a>4. jemeter 目录结构</h1><h2 id="bin-核心可执行文件，包含配置"><a href="#bin-核心可执行文件，包含配置" class="headerlink" title="bin:核心可执行文件，包含配置"></a>bin:核心可执行文件，包含配置</h2><p>jmeter.bat: windows启动文件：     </p><p>jmeter: mac或者linux启动文件：     </p><p>jmeter-server：mac或者Liunx分布式压测使用的启动文件  </p><p>jmeter-server.bat：mac或者Liunx分布式压测使用的启动文件     </p><p>jmeter.properties: 核心配置文件 </p><h2 id="extras：插件拓展的包"><a href="#extras：插件拓展的包" class="headerlink" title="extras：插件拓展的包"></a>extras：插件拓展的包</h2><p>lib:核心的依赖包     </p><p>ext:核心包     </p><p>junit:单元测试包</p><h1 id="5-改变jmeter的GUI界面语言版本"><a href="#5-改变jmeter的GUI界面语言版本" class="headerlink" title="5. 改变jmeter的GUI界面语言版本"></a>5. 改变jmeter的GUI界面语言版本</h1><h2 id="1、控制台修改"><a href="#1、控制台修改" class="headerlink" title="1、控制台修改"></a>1、控制台修改</h2><p>​    <code>menu -&gt; options -&gt; choose language</code></p><h2 id="2、配置文件修改"><a href="#2、配置文件修改" class="headerlink" title="2、配置文件修改"></a>2、配置文件修改</h2><p>​    <code>bin目录 -&gt; jmeter.properties     默认 #language=en     改为 language=zh_CN</code></p><h1 id="6-jemeter-菜单介绍"><a href="#6-jemeter-菜单介绍" class="headerlink" title="6. jemeter 菜单介绍"></a>6. jemeter 菜单介绍</h1><h2 id="1、添加-gt-threads-gt-线程组（控制总体并发）"><a href="#1、添加-gt-threads-gt-线程组（控制总体并发）" class="headerlink" title="1、添加-&gt;threads-&gt;线程组（控制总体并发）"></a>1、添加-&gt;threads-&gt;线程组（控制总体并发）</h2><ul><li>线程数：虚拟用户数。一个虚拟用户占用一个进程或线程</li><li>准备时长（Ramp-Up Period(in seconds)）：全部线程启动的时长，比如100个线程，20秒，则表示20秒内100个线程都要启动完成，每秒启动5个线程</li><li>循环次数：每个线程发送的次数，假如值为5，100个线程，则会发送500次请求，可以勾选永远循环</li></ul><h2 id="2、线程组-gt-添加-gt-Sampler-采样器-gt-Http-（一个线程组下面可以增加几个Sampler）"><a href="#2、线程组-gt-添加-gt-Sampler-采样器-gt-Http-（一个线程组下面可以增加几个Sampler）" class="headerlink" title="2、线程组-&gt;添加-&gt; Sampler(采样器) -&gt; Http （一个线程组下面可以增加几个Sampler）"></a>2、线程组-&gt;添加-&gt; Sampler(采样器) -&gt; Http （一个线程组下面可以增加几个Sampler）</h2><ul><li>名称：采样器名称</li><li>注释：对这个采样器的描述</li><li>web服务器：<ul><li>默认协议是http</li><li>默认端口是80</li><li>服务器名称或IP ：请求的目标服务器名称或IP地址</li></ul></li><li>路径：服务器URL</li><li><strong>Use multipart/from-data for HTTP POST</strong> ：当发送POST请求时，使用Use multipart/from-data方法发送，默认不选中。</li></ul><h2 id="3、查看测试结果"><a href="#3、查看测试结果" class="headerlink" title="3、查看测试结果"></a>3、查看测试结果</h2><h3 id="线程组-gt-添加-gt-监听器-gt-察看结果树"><a href="#线程组-gt-添加-gt-监听器-gt-察看结果树" class="headerlink" title="线程组-&gt;添加-&gt;监听器-&gt;察看结果树"></a>线程组-&gt;添加-&gt;监听器-&gt;察看结果树</h3><h1 id="7-断言的基本使用"><a href="#7-断言的基本使用" class="headerlink" title="7. 断言的基本使用"></a>7. 断言的基本使用</h1><h2 id="1-增加断言-线程组-gt-添加-gt-断言-gt-响应断言"><a href="#1-增加断言-线程组-gt-添加-gt-断言-gt-响应断言" class="headerlink" title="1. 增加断言: 线程组 -&gt; 添加 -&gt; 断言 -&gt; 响应断言"></a>1. 增加断言: 线程组 -&gt; 添加 -&gt; 断言 -&gt; 响应断言</h2><p>apply to(应用范围):     Main sample only: 仅当前父取样器 进行断言，一般一个请求，如果发一个请求会触发多个，则就有sub sample（比较少用）</p><h2 id="2-要测试的响应字段："><a href="#2-要测试的响应字段：" class="headerlink" title="2.要测试的响应字段："></a>2.要测试的响应字段：</h2><ul><li>响应文本：即响应的数据，比如json等文本</li><li>响应代码：http的响应状态码，比如200，302，404这些</li><li>响应信息：http响应代码对应的响应信息，例如：OK, Found</li><li>Response Header: 响应头</li></ul><h2 id="3-模式匹配规则："><a href="#3-模式匹配规则：" class="headerlink" title="3.模式匹配规则："></a>3.模式匹配规则：</h2><ul><li>包括：包含在里面就成功</li><li>匹配：响应内容完全匹配，不区分大小写</li><li>equals：完全匹配，区分大小写</li></ul><h2 id="4-断言结果监听器-线程组-gt-添加-gt-监听器-gt-断言结果"><a href="#4-断言结果监听器-线程组-gt-添加-gt-监听器-gt-断言结果" class="headerlink" title="4.断言结果监听器: 线程组-&gt; 添加 -&gt; 监听器 -&gt; 断言结果"></a>4.断言结果监听器: 线程组-&gt; 添加 -&gt; 监听器 -&gt; 断言结果</h2><p>里面的内容是sampler采样器的名称     断言失败，查看结果树任务结果颜色标红(通过结果数里面双击不通过的记录，可以看到错误信息)</p><h2 id="5-每个sample下面可以加单独的结果树，然后同时加多个断言，最外层可以加个结果树进行汇总"><a href="#5-每个sample下面可以加单独的结果树，然后同时加多个断言，最外层可以加个结果树进行汇总" class="headerlink" title="5.每个sample下面可以加单独的结果树，然后同时加多个断言，最外层可以加个结果树进行汇总"></a>5.每个sample下面可以加单独的结果树，然后同时加多个断言，最外层可以加个结果树进行汇总</h2><h1 id="8-Jmeter压测结果聚合报告分析"><a href="#8-Jmeter压测结果聚合报告分析" class="headerlink" title="8. Jmeter压测结果聚合报告分析"></a>8. Jmeter压测结果聚合报告分析</h1><h2 id="1-新增聚合报告：线程组-gt-添加-gt-监听器-gt-聚合报告（Aggregate-Report）"><a href="#1-新增聚合报告：线程组-gt-添加-gt-监听器-gt-聚合报告（Aggregate-Report）" class="headerlink" title="1.新增聚合报告：线程组-&gt;添加-&gt;监听器-&gt;聚合报告（Aggregate Report）"></a>1.新增聚合报告：线程组-&gt;添加-&gt;监听器-&gt;聚合报告（Aggregate Report）</h2><ul><li>lable: sampler的名称</li><li>Samples: 一共发出去多少请求,例如10个用户，循环10次，则是 100</li><li>Average: 平均响应时间</li><li>Median: 中位数，也就是 50％ 用户的响应时间</li><li>90% Line : 90％ 用户的响应不会超过该时间 （90% of the samples took no more than this time. The remaining samples at least as long as this）</li><li>95% Line : 95％ 用户的响应不会超过该时间</li><li>99% Line : 99％ 用户的响应不会超过该时间</li><li>min : 最小响应时间</li><li>max : 最大响应时间</li><li>Error%：错误的请求的数量/请求的总数</li><li><strong>Throughput： 吞吐量——默认情况下表示每秒完成的请求数（Request per Second) 可类比为qps     KB/Sec: 每秒接收数据量</strong></li></ul><h2 id="2-为什么使用：很多变量在全局中都有使用，或者测试数据更改，可以在一处定义，四处使用-比如服务器地址"><a href="#2-为什么使用：很多变量在全局中都有使用，或者测试数据更改，可以在一处定义，四处使用-比如服务器地址" class="headerlink" title="2.为什么使用：很多变量在全局中都有使用，或者测试数据更改，可以在一处定义，四处使用(比如服务器地址)"></a>2.为什么使用：很多变量在全局中都有使用，或者测试数据更改，可以在一处定义，四处使用(比如服务器地址)</h2><h3 id="1、线程组-gt-add-gt-Config-Element-配置原件-gt-User-Definde-Variable（用户定义的变量）"><a href="#1、线程组-gt-add-gt-Config-Element-配置原件-gt-User-Definde-Variable（用户定义的变量）" class="headerlink" title="1、线程组-&gt;add -&gt; Config Element(配置原件)-&gt; User Definde Variable（用户定义的变量）"></a>1、线程组-&gt;add -&gt; Config Element(配置原件)-&gt; User Definde Variable（用户定义的变量）</h3><h3 id="2、引用方式-XXX-，在接口中变量中使用"><a href="#2、引用方式-XXX-，在接口中变量中使用" class="headerlink" title="2、引用方式${XXX}，在接口中变量中使用"></a>2、引用方式${XXX}，在接口中变量中使用</h3><h3 id="3、原始查看结果树和非原生查看（基础按钮）"><a href="#3、原始查看结果树和非原生查看（基础按钮）" class="headerlink" title="3、原始查看结果树和非原生查看（基础按钮）"></a>3、原始查看结果树和非原生查看（基础按钮）</h3><h1 id="9-CSV可变参数压测（重要）"><a href="#9-CSV可变参数压测（重要）" class="headerlink" title="9. CSV可变参数压测（重要）"></a>9. CSV可变参数压测（重要）</h1><p><strong>实战操作jmeter读取CSV和Txt文本文件里面的参数进行压测</strong></p><h2 id="1、线程组-gt-add-gt-Config-Element-配置原件-gt-CSV-data-set-config-CSV数据文件设置"><a href="#1、线程组-gt-add-gt-Config-Element-配置原件-gt-CSV-data-set-config-CSV数据文件设置" class="headerlink" title="1、线程组-&gt;add -&gt; Config Element(配置原件)-&gt; CSV data set config (CSV数据文件设置)"></a>1、线程组-&gt;add -&gt; Config Element(配置原件)-&gt; CSV data set config (CSV数据文件设置)</h2><h2 id="2、在读取的配置文件里面，同时使用多个自定义参数"><a href="#2、在读取的配置文件里面，同时使用多个自定义参数" class="headerlink" title="2、在读取的配置文件里面，同时使用多个自定义参数"></a>2、在读取的配置文件里面，同时使用多个自定义参数</h2><p>如果是多个参数需要同时引用，则在CSV数据文件里面设置加多个字段 Variabled names(comma-delitited): csv_name,csv_pwd</p><h1 id="10、JDBC-request压测Mysql"><a href="#10、JDBC-request压测Mysql" class="headerlink" title="10、JDBC request压测Mysql"></a>10、JDBC request压测Mysql</h1><h2 id="1、Thread-Group-gt-add-gt-sampler-gt-jdbc-request"><a href="#1、Thread-Group-gt-add-gt-sampler-gt-jdbc-request" class="headerlink" title="1、Thread Group -&gt; add -&gt; sampler -&gt; jdbc request"></a>1、Thread Group -&gt; add -&gt; sampler -&gt; jdbc request</h2><h2 id="2、jar包添加-mysql-connector-java-5-1-30-jar"><a href="#2、jar包添加-mysql-connector-java-5-1-30-jar" class="headerlink" title="2、jar包添加 mysql-connector-java-5.1.30.jar"></a>2、jar包添加 mysql-connector-java-5.1.30.jar</h2><h2 id="3、JDBC-connection-Configuration-配置"><a href="#3、JDBC-connection-Configuration-配置" class="headerlink" title="3、JDBC connection Configuration 配置"></a>3、JDBC connection Configuration 配置</h2><p><strong>JDBC request-&gt;add -&gt; config element -&gt; JDBC connection configuration</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">核心配置</span><br><span class="line">Max Number of connections : 最大连接数</span><br><span class="line">MAX wait :最大等待时间</span><br><span class="line">Auto Commit: 是否自动提交事务</span><br><span class="line"></span><br><span class="line">DataBase URL : 数据库连接地址 jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;blog</span><br><span class="line">JDBC Driver Class : 数据库驱动，选择对应的mysql</span><br><span class="line">username:数据库用户名</span><br><span class="line">password:数据库密码</span><br></pre></td></tr></table></figure><h1 id="11-request压测Mysql-select语句"><a href="#11-request压测Mysql-select语句" class="headerlink" title="11. request压测Mysql, select语句"></a>11. request压测Mysql, select语句</h1><ul><li>个人测试1</li></ul><p>\</p><ul><li>个人测试2<ul><li>注意：需要添加一个全局的debug采集器采集查询结果</li><li>可以看到如图所示结果</li></ul></li></ul><h2 id="1-Debug-Sampler使用（结果树中查看）"><a href="#1-Debug-Sampler使用（结果树中查看）" class="headerlink" title="1. Debug Sampler使用（结果树中查看）"></a>1. Debug Sampler使用（结果树中查看）</h2><p>​    Thread Group -&gt; add -&gt; sampler -&gt; debug sampler</p><h2 id="2-参数讲解：-sql结尾不要加”-”"><a href="#2-参数讲解：-sql结尾不要加”-”" class="headerlink" title="2. 参数讲解：(sql结尾不要加”;”)"></a>2. 参数讲解：(sql结尾不要加”;”)</h2><ul><li>variable name of pool declared in JDBC connection configuration（和配置文件同名）</li><li>Query Type 查询类型</li><li>parameter values 参数值</li><li>parameter types 参数类型</li><li>variable names sql执行结果变量名</li><li>result variable names 所有结果当做一个对象存储</li><li>query timeouts 查询超时时间</li><li>handle results 处理结果集</li></ul><h1 id="12-分布式压测（学习重点）"><a href="#12-分布式压测（学习重点）" class="headerlink" title="12. 分布式压测（学习重点）"></a>12. 分布式压测（学习重点）</h1><p>官网教程： <span class="exturl" data-url="aHR0cDovL2ptZXRlci5hcGFjaGUub3JnL3VzZXJtYW51YWwvam1ldGVyX2Rpc3RyaWJ1dGVkX3Rlc3Rpbmdfc3RlcF9ieV9zdGVwLmh0bWw=" title="http://jmeter.apache.org/usermanual/jmeter_distributed_testing_step_by_step.html">http://jmeter.apache.org/usermanual/jmeter_distributed_testing_step_by_step.html<i class="fa fa-external-link"></i></span></p><ul><li>普通压测：单台机可以对目标机器产生的压力比较小，受限因素包括CPU，网络，IO等</li><li>分布式压测：利用多台机器向目标机器产生压力，模拟几万用户并发访问</li></ul><h1 id="13-Jmeter分布式压测原理-了解"><a href="#13-Jmeter分布式压测原理-了解" class="headerlink" title="13. Jmeter分布式压测原理(了解)"></a>13. Jmeter分布式压测原理(了解)</h1><p>1、总控机器的节点master，其他产生压力的机器叫“肉鸡” server</p><p>2、master会把压测脚本发送到 server上面</p><p>3、执行的时候，server上只需要把jmeter-server打开就可以了，不用启动jmeter</p><p>4、结束后，server会把压测数据回传给master,然后master汇总输出报告</p><p>5、配置详情</p><h1 id="14-阿里云安装jmeter-守护进程：nohup-java-jar-xxxxx-amp"><a href="#14-阿里云安装jmeter-守护进程：nohup-java-jar-xxxxx-amp" class="headerlink" title="14. 阿里云安装jmeter (守护进程：nohup java -jar xxxxx &amp;)"></a>14. 阿里云安装jmeter (守护进程：nohup java -jar xxxxx &amp;)</h1><h2 id="1-下载方式：wget-http-apache-osuosl-org-jmeter-binaries-apache-jmeter-4-0-tgz"><a href="#1-下载方式：wget-http-apache-osuosl-org-jmeter-binaries-apache-jmeter-4-0-tgz" class="headerlink" title="1. 下载方式：wget http://apache.osuosl.org//jmeter/binaries/apache-jmeter-4.0.tgz"></a>1. 下载方式：wget <span class="exturl" data-url="aHR0cDovL2FwYWNoZS5vc3Vvc2wub3JnLy9qbWV0ZXIvYmluYXJpZXMvYXBhY2hlLWptZXRlci00LjAudGd6" title="http://apache.osuosl.org//jmeter/binaries/apache-jmeter-4.0.tgz">http://apache.osuosl.org//jmeter/binaries/apache-jmeter-4.0.tgz<i class="fa fa-external-link"></i></span></h2><h2 id="2-直接到官网下载对应tag-gz包，并在服务器解压"><a href="#2-直接到官网下载对应tag-gz包，并在服务器解压" class="headerlink" title="2. 直接到官网下载对应tag.gz包，并在服务器解压"></a>2. 直接到官网下载对应tag.gz包，并在服务器解压</h2><h1 id="15-Jmeter非GUI界面-参数讲解-必须掌握"><a href="#15-Jmeter非GUI界面-参数讲解-必须掌握" class="headerlink" title="15. Jmeter非GUI界面 参数讲解(必须掌握)"></a>15. Jmeter非GUI界面 参数讲解(必须掌握)</h1><p>官方配置文件地址： <span class="exturl" data-url="aHR0cDovL2ptZXRlci5hcGFjaGUub3JnL3VzZXJtYW51YWwvZ2V0LXN0YXJ0ZWQuaHRtbA==" title="http://jmeter.apache.org/usermanual/get-started.html">http://jmeter.apache.org/usermanual/get-started.html<i class="fa fa-external-link"></i></span></p><ul><li><strong>-h</strong> 帮助</li><li><strong>-n</strong> 非GUI模式</li><li><strong>-t</strong> 指定要运行的 JMeter 测试脚本文件</li><li><strong>-l</strong> 记录结果的文件 每次运行之前，(要确保之前没有运行过,即xxx.jtl不存在，不然报错)</li><li><strong>-r</strong> Jmter.properties文件中指定的所有远程服务器</li><li><strong>-e</strong> 在脚本运行结束后生成html报告</li><li><strong>-o</strong> 用于存放html报告的目录（目录要为空，不然报错）</li></ul><p>jmeter -n -t linux_users_api.jmx -l result.jtl -e -o /usr/local/softwate/jmeter/temp/ResultReport</p><p>jmeter -n -t /Users/jack/Desktop/linux_users_api.jmx -l result.jtl -e -o /Users/jack/Desktop/person/jmeter/temp</p><p>个人： /usr/local/software/jmeter/project/temp 。。。。</p><h2 id="1-阿里云非GUI-jmeter-压测"><a href="#1-阿里云非GUI-jmeter-压测" class="headerlink" title="1.阿里云非GUI jmeter 压测"></a>1.阿里云非GUI jmeter 压测</h2><p>jmx目录：/usr/local/software/jmeter/temp</p><p>示例</p><p>jmeter -n -t /usr/local/software/jmeter/temp/linux_users_api.jmx -l /usr/local/software/jmeter/temp/jtl/result.jtl</p><p>利用软件从阿里云Centos服务器下载压测报告，讲解Jtl文件，并怎么查看文件 可以通过打开jmeter，新建线程组-&gt;summary report-&gt;浏览文件 进行查看</p><h2 id="2-讲解Jmeter压测减少资源使用的一些建议，即压测结果更准确"><a href="#2-讲解Jmeter压测减少资源使用的一些建议，即压测结果更准确" class="headerlink" title="2.讲解Jmeter压测减少资源使用的一些建议，即压测结果更准确"></a>2.讲解Jmeter压测减少资源使用的一些建议，即压测结果更准确</h2><p>1、使用非GUI模式：jmeter -n -t test.jmx -l result.jtl</p><p>2、少使用Listener， 如果使用-l参数，它们都可以被删除或禁用。</p><p>3、在加载测试期间不要使用“查看结果树”或“查看结果”表监听器，只能在脚本阶段使用它们来调试脚本。</p><p>4、包含控制器在这里没有帮助，因为它将文件中的所有测试元素添加到测试计划中。]</p><p>5、不要使用功能模式,使用CSV输出而不是XML</p><p>6、只保存你需要的数据,尽可能少地使用断言</p><p>7、如果测试需要大量数据，可以提前准备好测试数据放到数据文件中，以CSV Read方式读取。</p><p>8、用内网压测，减少其他带宽影响压测结果</p><p>9、如果压测大流量，尽量用多几个节点以非GUI模式向服务器施压</p><p>官方推荐 ：<span class="exturl" data-url="aHR0cDovL2pha2FydGEuYXBhY2hlLm9yZy9qbWV0ZXIvdXNlcm1hbnVhbC9iZXN0LXByYWN0aWNlcy5odG1sI2xlYW5fbWVhbg==" title="http://jakarta.apache.org/jmeter/usermanual/best-practices.html#lean_mean">http://jakarta.apache.org/jmeter/usermanual/best-practices.html#lean_mean<i class="fa fa-external-link"></i></span></p><h2 id="3-把Jmtere压测结果转换为Html"><a href="#3-把Jmtere压测结果转换为Html" class="headerlink" title="3. 把Jmtere压测结果转换为Html"></a>3. 把Jmtere压测结果转换为Html</h2><p>jmeter -n -t /usr/local/software/jmeter/temp/linux_users_api.jmx -l /usr/local/software/jmeter/temp/jtl/result.jtl -e -o /usr/local/software/jmeter/temp/result讲解压测报告 html里面Dashboard的核心指标</p><h3 id="1、dashboard讲解"><a href="#1、dashboard讲解" class="headerlink" title="1、dashboard讲解"></a>1、dashboard讲解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1）Test and Report informations</span><br><span class="line">Source file：jtl文件名</span><br><span class="line">Start Time ：压测开始时间</span><br><span class="line">End Time ：压测结束时间</span><br><span class="line">Filter for display：过滤器</span><br><span class="line">Lable:sampler采样器名称</span><br><span class="line"></span><br><span class="line">2）APDEX(Application performance Index)</span><br><span class="line">apdex:应用程序性能指标,范围在0~1之间，1表示达到所有用户均满意</span><br><span class="line">T(Toleration threshold)：可接受阀值</span><br><span class="line">F(Frustration threshold)：失败阀值</span><br><span class="line"></span><br><span class="line">3）Requests Summary</span><br><span class="line">OK:成功率</span><br><span class="line">KO:失败率</span><br><span class="line">4）Statistics 统计数据</span><br><span class="line">lable:sampler采样器名称</span><br><span class="line"></span><br><span class="line">samples:请求总数，并发数*循环次数</span><br><span class="line">KO:失败次数</span><br><span class="line">Error%:失败率</span><br><span class="line"></span><br><span class="line">Average:平均响应时间</span><br><span class="line">Min:最小响应时间</span><br><span class="line">Max:最大响应时间</span><br><span class="line">90th pct: 90%的用户响应时间不会超过这个值（关注这个就可以了）</span><br><span class="line">2ms,3ms,4,5,2,6,8,3,9</span><br><span class="line"></span><br><span class="line">95th pct: 95%的用户响应时间不会超过这个值</span><br><span class="line">99th pct: 99%的用户响应时间不会超过这个值 (存在极端值)</span><br><span class="line">throughtput:Request per Second吞吐量 qps</span><br><span class="line"></span><br><span class="line">received:每秒从服务器接收的数据量</span><br><span class="line">send：每秒发送的数据量</span><br></pre></td></tr></table></figure><h3 id="2、charts讲解"><a href="#2、charts讲解" class="headerlink" title="2、charts讲解"></a>2、charts讲解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1)Over Time（随着时间的变化）</span><br><span class="line">Response Times Over Time：响应时间变化趋势</span><br><span class="line">Response Time Percentiles Over Time (successful responses)：最大，最小，平均，用户响应时间分布</span><br><span class="line">Active Threads Over Time：并发用户数趋势</span><br><span class="line">Bytes Throughput Over Time：每秒接收和请求字节数变化，蓝色表示发送，黄色表示接受</span><br><span class="line">Latencies Over Time：平均响应延时趋势</span><br><span class="line">Connect Time Over Time：连接耗时趋势</span><br><span class="line"></span><br><span class="line">1)Throughput</span><br><span class="line">Hits Per Second (excluding embedded resources):每秒点击次数</span><br><span class="line">Codes Per Second (excluding embedded resources)：每秒状态码数量</span><br><span class="line">Transactions Per Second：即TPS，每秒事务数</span><br><span class="line">Response Time Vs Request：响应时间和请求数对比</span><br><span class="line">Latency Vs Request：延迟时间和请求数对比</span><br><span class="line"></span><br><span class="line">1)Response Times</span><br><span class="line">Response Time Percentiles：响应时间百分比</span><br><span class="line">Response Time Overview：响应时间概述</span><br><span class="line">Time Vs Threads：活跃线程数和响应时间</span><br><span class="line">Response Time Distribution：响应时间分布图</span><br></pre></td></tr></table></figure><h1 id="16、Linux服务器上jmeter进行分布式压测"><a href="#16、Linux服务器上jmeter进行分布式压测" class="headerlink" title="16、Linux服务器上jmeter进行分布式压测"></a>16、Linux服务器上jmeter进行分布式压测</h1><h2 id="1、压测注意事项"><a href="#1、压测注意事项" class="headerlink" title="1、压测注意事项"></a>1、压测注意事项</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">the firewalls on the systems are turned off or correct ports are opened.</span><br><span class="line">系统上的防火墙被关闭或正确的端口被打开。</span><br><span class="line"></span><br><span class="line">all the clients are on the same subnet.</span><br><span class="line">所有的客户端都在同一个子网上。</span><br><span class="line"></span><br><span class="line">the server is in the same subnet, if 192.x.x.x or 10.x.x.x IP addresses are used. If the server doesn&#39;t use 192.xx or 10.xx IP address, there shouldn&#39;t be any problems.</span><br><span class="line">如果使用192.x.x.x或10.x.x.x IP地址，则服务器位于同一子网中。 如果服务器不使用192.xx或10.xx IP地址，则不应该有任何问题。</span><br><span class="line"></span><br><span class="line">Make sure JMeter can access the server.</span><br><span class="line">确保JMeter可以访问服务器。</span><br><span class="line"></span><br><span class="line">Make sure you use the same version of JMeter and Java on all the systems. Mixing versions will not work correctly.</span><br><span class="line">确保在所有系统上使用相同版本的JMeter和Java。 混合版本将无法正常工作。</span><br><span class="line"></span><br><span class="line">You have setup SSL for RMI or disabled it.</span><br><span class="line">您已为RMI设置SSL或将其禁用。</span><br><span class="line"></span><br><span class="line">官网地址 http:&#x2F;&#x2F;jmeter.apache.org&#x2F;usermanual&#x2F;jmeter_distributed_testing_step_by_step.html</span><br><span class="line"></span><br><span class="line">压测注意事项：一定要用内网IP，不用用公网IP,用ping去检查</span><br></pre></td></tr></table></figure><h2 id="2、专业名字"><a href="#2、专业名字" class="headerlink" title="2、专业名字"></a>2、专业名字</h2><p>master:司令 slave：</p><p>奴隶 target：目标</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>地址：<span class="exturl" data-url="aHR0cDovL2ptZXRlci5hcGFjaGUub3JnL2ltYWdlcy9zY3JlZW5zaG90cy9kaXN0cmlidXRlZC1uYW1lcy5zdmc=" title="http://jmeter.apache.org/images/screenshots/distributed-names.svg">http://jmeter.apache.org/images/screenshots/distributed-names.svg<i class="fa fa-external-link"></i></span> </p><p>地址：<span class="exturl" data-url="aHR0cDovL2ptZXRlci5hcGFjaGUub3JnL2ltYWdlcy9zY3JlZW5zaG90cy9kaXN0cmlidXRlZC1qbWV0ZXIuc3Zn" title="http://jmeter.apache.org/images/screenshots/distributed-jmeter.svg">http://jmeter.apache.org/images/screenshots/distributed-jmeter.svg<i class="fa fa-external-link"></i></span></p><h2 id="3、远程拷贝-内网地址-："><a href="#3、远程拷贝-内网地址-：" class="headerlink" title="3、远程拷贝(内网地址)："></a>3、远程拷贝(内网地址)：</h2><p>scp -r /usr/local/software/jdk-8u141-linux-x64.tar.gz <span class="exturl" data-url="aHR0cDovL21haWx0bzpyb290QDE3Mi4xOC4yMzAuMjMz" title="http://mailto:root@172.18.230.233">root@172.18.230.233<i class="fa fa-external-link"></i></span>:/usr/local/software</p><p>scp -r /usr/local/software/jmeter/apache-jmeter-4.0.tgz <span class="exturl" data-url="aHR0cDovL21haWx0bzpyb290QDE3Mi4xOC4yMzAuMjMz" title="http://mailto:root@172.18.230.233">root@172.18.230.233<i class="fa fa-external-link"></i></span>:/usr/local/software/jmeter</p><h2 id="4、启动"><a href="#4、启动" class="headerlink" title="4、启动"></a>4、启动</h2><p>./jmeter-server 或者 nohup ./jmeter-server &amp;</p><h2 id="5、检查启动是否成功"><a href="#5、检查启动是否成功" class="headerlink" title="5、检查启动是否成功"></a>5、检查启动是否成功</h2><p>ps -ef|grep jmeter-server</p><p>ps aux|grep jmeter-server</p><h1 id="17、Jmeter分布式压测"><a href="#17、Jmeter分布式压测" class="headerlink" title="17、Jmeter分布式压测"></a>17、Jmeter分布式压测</h1><h2 id="本地非GUI分布式压测-r"><a href="#本地非GUI分布式压测-r" class="headerlink" title="本地非GUI分布式压测 -r"></a>本地非GUI分布式压测 -r</h2><p>jmeter -n -t /Users/jack/Desktop/remote.jmx -r -l /Users/jack/Desktop/jtl/result.jtl -e -o /Users/jack/Desktop/result</p><h2 id="压测结果"><a href="#压测结果" class="headerlink" title="压测结果"></a>压测结果</h2><p>./jmeter -n -t /Users/jack/Desktop/remote.jmx -r -l /Users/jack/Desktop/jtl/result.jtl -e -o /Users/jack/Desktop/result</p><h2 id="压测报告"><a href="#压测报告" class="headerlink" title="压测报告"></a>压测报告</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Creating summariser &lt;summary&gt;</span><br><span class="line">Created the tree successfully using &#x2F;Users&#x2F;jack&#x2F;Desktop&#x2F;remote.jmx</span><br><span class="line">Configuring remote engine: 172.20.10.3:8899</span><br><span class="line">Using local port: 8899</span><br><span class="line">Configuring remote engine: 172.20.10.11:8899</span><br><span class="line">Starting remote engines</span><br><span class="line">Starting the test @ Thu Mar 29 23:21:13 CST 2018 (1522336873931)</span><br><span class="line">Remote engines have been started</span><br><span class="line">Waiting for possible Shutdown&#x2F;StopTestNow&#x2F;Heapdump message on port 4445</span><br><span class="line">summary &#x3D;      4 in 00:00:22 &#x3D;    0.2&#x2F;s Avg:  5582 Min:    94 Max: 21006 Err:     1 (25.00%)</span><br><span class="line">Tidying up remote @ Thu Mar 29 23:21:36 CST 2018 (1522336896842)</span><br><span class="line">... end of run</span><br></pre></td></tr></table></figure><h2 id="压测修改master节点信息"><a href="#压测修改master节点信息" class="headerlink" title="压测修改master节点信息"></a>压测修改master节点信息</h2><p>jemeter.properties 值是slave机器的ip+端口号，如果有多个，用逗号分隔 remote_hosts=192.168.0.102:8899,192.168.0.101:8899 server.rmi.ssl.disable=true (前面有说到)</p><h2 id="启动slave机器，注意要同个网段，ip地址用内网ip"><a href="#启动slave机器，注意要同个网段，ip地址用内网ip" class="headerlink" title="启动slave机器，注意要同个网段，ip地址用内网ip"></a>启动slave机器，注意要同个网段，ip地址用内网ip</h2><p>./jmeter-server Using local port: 8899 Created remote object: UnicastServerRef2 [liveRef: [endpoint:<span class="exturl" data-url="aHR0cDovL2xvY2Fs" title="http://local">192.168.0.102:8899<i class="fa fa-external-link"></i></span>,objID:[3a585a4d:162724586ab:-7fff, 3963132813614033916]]]</p><h2 id="相关资料："><a href="#相关资料：" class="headerlink" title="相关资料："></a>相关资料：</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vRmluZS1DaGFuL3AvNjIzMzgyMy5odG1s" title="https://www.cnblogs.com/Fine-Chan/p/6233823.html">https://www.cnblogs.com/Fine-Chan/p/6233823.html<i class="fa fa-external-link"></i></span> <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdWppbmdxaXUvYXJ0aWNsZS9kZXRhaWxzLzUyNjM1Mjg5aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vcHVyZXNvdWwvcC80ODQ0NTM5Lmh0bWw=" title="https://blog.csdn.net/liujingqiu/article/details/52635289https://www.cnblogs.com/puresoul/p/4844539.html">https://blog.csdn.net/liujingqiu/article/details/52635289https://www.cnblogs.com/puresoul/p/4844539.html<i class="fa fa-external-link"></i></span></p><h1 id="18-、测试基本内容"><a href="#18-、测试基本内容" class="headerlink" title="18.、测试基本内容"></a>18.、测试基本内容</h1><p><strong>配置元件=》前置处理器=》定时器=》采样器=》后置处理器=》断言=》监听器</strong></p><h1 id="19、安装常见问题"><a href="#19、安装常见问题" class="headerlink" title="19、安装常见问题"></a>19、安装常见问题</h1><h2 id="1、问题：无法解析"><a href="#1、问题：无法解析" class="headerlink" title="1、问题：无法解析"></a>1、问题：无法解析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz95j86y235aroi85ht0Z bin]# .&#x2F;jmeter-server</span><br><span class="line">Created remote object: UnicastServerRef2 [liveRef: [endpoint:[:39308](local),objID:[24e78a63:16243c70661:-7fff, 7492480871343944173]]]</span><br><span class="line">Server failed to start: java.rmi.RemoteException: Cannot start. Unable to get local host IP address.; nested exception is:</span><br><span class="line">java.net.UnknownHostException: iZwz95j86y235aroi85ht0Z: iZwz95j86y235aroi85ht0Z: Name or service not known</span><br><span class="line">An error occurred: Cannot start. Unable to get local host IP address.; nested exception is:</span><br><span class="line">java.net.UnknownHostException: iZwz95j86y235aroi85ht0Z: iZwz95j86y235aroi85ht0Z: Name or service not known</span><br></pre></td></tr></table></figure><h3 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hostname  命令获取机器名称，追加一个映射  iZwz95j86y235aroi85ht0Z</span><br><span class="line">vim &#x2F;etc&#x2F;hosts</span><br><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line">120.79.160.143 iZwz95j86y235aroi85ht0Z</span><br><span class="line"></span><br><span class="line">windows用户 修改c:\windows\system32\drivers\etc\hosts文件，增加一条域名 与IP的映射</span><br></pre></td></tr></table></figure><h2 id="2-问题：禁用了SSL"><a href="#2-问题：禁用了SSL" class="headerlink" title="2.问题：禁用了SSL"></a>2.问题：禁用了SSL</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz95j86y235aroi85ht0Z bin]# .&#x2F;jmeter-server</span><br><span class="line">Server failed to start: java.rmi.server.ExportException: Listen failed on port: 0; nested exception is:</span><br><span class="line">java.io.FileNotFoundException: rmi_keystore.jks (No such file or directory)</span><br><span class="line">An error occurred: Listen failed on port: 0; nested exception is:</span><br><span class="line">java.io.FileNotFoundException: rmi_keystore.jks (No such file or directory)</span><br></pre></td></tr></table></figure><h3 id="解决：-1"><a href="#解决：-1" class="headerlink" title="解决："></a>解决：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">拥有RMI over SSL的有效密钥库，或者禁用了SSL。</span><br><span class="line">1、禁用SSL</span><br><span class="line">  jmeter.property里面 server.rmi.ssl.disable 改为 true，表示禁用</span><br></pre></td></tr></table></figure><h2 id="3、问题："><a href="#3、问题：" class="headerlink" title="3、问题："></a>3、问题：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ949uw2xehZ bin]# .&#x2F;jmeter</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: INFO: os::commit_memory(0x00000000c0000000, 1073741824, 0) failed; error&#x3D;&#39;Cannot allocate memory&#39; (errno&#x3D;12)</span><br><span class="line">#</span><br><span class="line"># There is insufficient memory for the Java Runtime Environment to continue.</span><br><span class="line"># Native memory allocation (mmap) failed to map 1073741824 bytes for committing reserved memory.</span><br><span class="line"># An error report file with more information is saved as:</span><br><span class="line"># &#x2F;usr&#x2F;local&#x2F;jmeter&#x2F;apache-jmeter-4.0&#x2F;bin&#x2F;hs_err_pid5855.log</span><br></pre></td></tr></table></figure><h3 id="解决：-2"><a href="#解决：-2" class="headerlink" title="解决："></a>解决：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">编辑jmeter</span><br><span class="line">搜索 : &quot;$&#123;HEAP:&#x3D;&quot;-Xms1g -Xmx1g -XX:MaxMetaspaceSize&#x3D;256m&quot;&#125;&quot;</span><br><span class="line">改变初始堆内存和最大堆内存</span><br></pre></td></tr></table></figure><h2 id="4、仅修改-server-port-即可-下面两者一样"><a href="#4、仅修改-server-port-即可-下面两者一样" class="headerlink" title="4、仅修改 server_port 即可,下面两者一样"></a>4、仅修改 server_port 即可,下面两者一样</h2><p>server.rmi.localport=8899 表示slave server启动显示的端口</p><p>server_port=8899 表示master机器要远程连接的端口 即 remote_hosts=xxxx:8899</p><h2 id="5、—–"><a href="#5、—–" class="headerlink" title="5、—–"></a>5、—–</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- jmeter 分布式性能测试（多网卡配置） --&gt;</span><br><span class="line">我们要在多网卡的服务器上开启RMI服务的话必须指定IP，使他们能够在同一个网段内。 </span><br><span class="line"></span><br><span class="line">需要以下几步（假定所有机器都在10.120.11.*网段,agent服务器为linux,controller服务器为windows）：</span><br><span class="line"></span><br><span class="line">1、 修改agent服务器，指定agent机器的IP</span><br><span class="line">修改jmeter-server文件</span><br><span class="line"># vi jmeter-server</span><br><span class="line">修改RMI_HOST_DEF&#x3D;-Djava.rmi.server.hostname&#x3D;xxx.xxx.xxx.xxx(需要连接的IP)</span><br><span class="line"></span><br><span class="line">2、修改server服务器，指定server机器的IP</span><br><span class="line"></span><br><span class="line">修改jmeter.bat文件 </span><br><span class="line"></span><br><span class="line">新增set rmi_host&#x3D;-Djava.rmi.server.hostname&#x3D;10.120.11.214</span><br><span class="line"></span><br><span class="line">修改set ARGS&#x3D;%DUMP% %HEAP% %NEW% %SURVIVOR% %TENURING% %PERM% %DDRAW% %rmi_host%</span><br></pre></td></tr></table></figure><h2 id="6、确定在controller机器上安装jdk-版本和jmeter一致，配置环境变量：Java-home等"><a href="#6、确定在controller机器上安装jdk-版本和jmeter一致，配置环境变量：Java-home等" class="headerlink" title="6、确定在controller机器上安装jdk,版本和jmeter一致，配置环境变量：Java_home等"></a>6、确定在controller机器上安装jdk,版本和jmeter一致，配置环境变量：Java_home等</h2><ul><li>在Agent机器上安装jdk，配置环境变量：Java_home和JMeter_home</li><li>安装目录不要带空格，最好都是简短的英文路径</li></ul><h2 id="7、master机器启动后会拷贝jmx文件到slave机器，所以不需要在每台slave机器上也上传一份jmx，只需要在master机器上上传一份jmx脚本即可。"><a href="#7、master机器启动后会拷贝jmx文件到slave机器，所以不需要在每台slave机器上也上传一份jmx，只需要在master机器上上传一份jmx脚本即可。" class="headerlink" title="7、master机器启动后会拷贝jmx文件到slave机器，所以不需要在每台slave机器上也上传一份jmx，只需要在master机器上上传一份jmx脚本即可。"></a>7、master机器启动后会拷贝jmx文件到slave机器，所以不需要在每台slave机器上也上传一份jmx，只需要在master机器上上传一份jmx脚本即可。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果使用csv进行参数化，则需要把参数文件在每台slave上拷一份且路径需要设置成一样的。</span><br><span class="line"></span><br><span class="line">总样本数 &#x3D; 线程数 * 循环次数 * 执行机总数</span><br></pre></td></tr></table></figure><h2 id="8、连接失败原因排查"><a href="#8、连接失败原因排查" class="headerlink" title="8、连接失败原因排查"></a>8、连接失败原因排查</h2><h4 id="以下步骤进行排查："><a href="#以下步骤进行排查：" class="headerlink" title="以下步骤进行排查："></a>以下步骤进行排查：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. jmeter-server是否启动；</span><br><span class="line">2. 是否联网</span><br><span class="line">3. ping 服务器IP是否畅通.</span><br><span class="line">4. telnet 端口 192.168.3.10 1099</span><br><span class="line">5. 检查服务器的防火墙是否关闭。</span><br><span class="line">6. 阿里云安全策略是否正常</span><br></pre></td></tr></table></figure><h2 id="9、”could-not-find-ApacheJmeter-core-jar”"><a href="#9、”could-not-find-ApacheJmeter-core-jar”" class="headerlink" title="9、”could not find ApacheJmeter_core.jar”"></a>9、”could not find ApacheJmeter_core.jar”</h2><p>​    <strong>解决：在Agent机器安装jdk，并设置环境变量</strong></p><h2 id="10、”Bad-call-to-remote-host”"><a href="#10、”Bad-call-to-remote-host”" class="headerlink" title="10、”Bad call to remote host”"></a>10、”Bad call to remote host”</h2><p>解决：检查被控制机器上的jmeter-server有没有启动，或者remote_hosts的配置是否正确。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      学习如何使用jmeter压力测试
    
    </summary>
    
    
      <category term="压力测试" scheme="https://whitestore.top/categories/%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="jmeter" scheme="https://whitestore.top/tags/jmeter/"/>
    
  </entry>
  
  <entry>
    <title>《劝学篇》读书笔记</title>
    <link href="https://whitestore.top/2021/05/20/note/"/>
    <id>https://whitestore.top/2021/05/20/note/</id>
    <published>2021-05-20T15:04:51.000Z</published>
    <updated>2021-05-20T15:05:03.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《劝学篇》读书笔记"><a href="#《劝学篇》读书笔记" class="headerlink" title="《劝学篇》读书笔记"></a>《劝学篇》读书笔记</h1><h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>​    只能说不愧是日本“一万元”头像上的人物，在日本确实称得上伟人了。很难想象作为一个明治时期刚刚启蒙的日本会有如此超前的思想。这本书写了很多当时超前的内容，指出来很多的毛病到现在依然可以看到很多现实缩影。部分内容和观点甚至是永远受用…..</p><a id="more"></a><h1 id="资源地址"><a href="#资源地址" class="headerlink" title="资源地址"></a>资源地址</h1><p>​    偏门书，还好被我翻到了。这本书个人购买了实体书来进行阅读。</p><blockquote><p>链接：<span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMXhWNHZNVGhneVhGSFY5WWFzSWlDcHc=" title="https://pan.baidu.com/s/1xV4vMThgyXFHV9YasIiCpw">https://pan.baidu.com/s/1xV4vMThgyXFHV9YasIiCpw<i class="fa fa-external-link"></i></span><br>提取码：3i8d<br>复制这段内容后打开百度网盘手机App，操作更方便哦–来自百度网盘超级会员V6的分享</p></blockquote><h1 id="推荐指数"><a href="#推荐指数" class="headerlink" title="推荐指数"></a>推荐指数</h1><p>​    <strong>4.5星，满分5星。</strong>少0.5星是因为内容开头有一段非常鄙视当时的中国人。认为当时的中国人没有教养。（心理总归有些膈应）这本书不管带不带民族偏见，里面的大部分内容还是十分受用的。</p><h2 id="推荐语"><a href="#推荐语" class="headerlink" title="推荐语"></a>推荐语</h2><p>​    不要看到这本书的名字劝学就劝退了，一个明治时期的人用接近近代人的思想来教授你各种学问。三观非常正的一本书，看完正能量爆棚。非常有收获的一本书。干下这碗毒鸡汤吧。</p><h1 id="好句摘录"><a href="#好句摘录" class="headerlink" title="好句摘录"></a>好句摘录</h1><ul><li><strong>天不生人上之人，也不生人下之人</strong></li></ul><blockquote><p>人生来无贵无贱，只是贫富贵贱造就人上之人，但是贵能求学，穷也能求学。</p></blockquote><ul><li>倘若没有欲求，就不可能有劳动，没有劳动，就不可能享有快乐的幸福</li></ul><blockquote><p>人的价值来自于劳动（不是洗脑）</p></blockquote><ul><li><strong>学问的要诀，在于活用，不能活用的学问，便等于无学。</strong></li></ul><blockquote><p>学而不思则罔，思而不学则殆。</p><p>有道无术，术可求也，有术无道，止于术。</p></blockquote><ul><li>“我的学问放在东京了”</li></ul><blockquote><p>笔记要用手也要用心</p></blockquote><h1 id="内容摘要"><a href="#内容摘要" class="headerlink" title="内容摘要"></a>内容摘要</h1><h2 id="政府与人民的关系"><a href="#政府与人民的关系" class="headerlink" title="政府与人民的关系"></a>政府与人民的关系</h2><p>​    这一部分的内容在当时也受不少的争议。大致内容讲述了福泽谕吉认为政府为人民谋福利，建设平等社会，管理人民，人民也应该给予社会反馈，信任政府，全心全意为政府服务。</p><p>​    但是在政府出现腐败的时候，人民又应该怎么样看待政府呢？</p><ul><li><p>反抗政府，实施暴力。作者认为这是一种不负责任并且没有任何益处的事情。实施暴力不仅不能从根本上解决问题，更是容易造成社会动乱。</p></li><li><p>屈从社会，接受社会的教化。作者则认为这样的人没有独立精神，只是逃避自己的责任，历史上无数次的压迫也是人民爆发的根本。</p></li><li><p>坚持真理，保持独立精神。这是面对政府无脑和统治腐败的最好应对方式。</p></li></ul><p>​    真正良好的社会秩序是人具备独立精神，具备独立精神的人为政府培育优秀的人才，而优秀的人才又反过来促进社会的秩序和繁荣，这才是造就和谐社会，繁荣社会的根本路径。</p><h2 id="何为学问"><a href="#何为学问" class="headerlink" title="何为学问"></a>何为学问</h2><p>​    学问是一个非常宽泛的概念，在书中也没用具体的描述到底什么是学问，而是阐述了万物皆学问这一个观点，并且鼓励每一位国民全心全意的求学。</p><p>​    学问分为学和问，“学”是积累的过程，就好比文字是必须学习的东西，但是文字只是学问的工具，而“问”则是对于知识的自我理解和思考，只有学问结合，内化成自己的东西，才是真正的学有所用。</p><p>​    作者讽刺了当时的日本空有文明的外壳，却没有文明的实质。学士“学富五车”却不吸收消化和思考，甚至有的人的认为把学问抄写下来便是自己的学问。然而抄写的东西又有多少是自己可以内化的呢，作者讽刺说有的学者甚至出现“我的学问丢在东京”了这种非常奇葩但是真实的社会现象。</p><p>​    上面一段话放到现在貌似也没有什么错，泛滥的教育机构，大量“免费”的资料充斥互联网，<strong>我们一心求学，最终变成了一心求学习资料</strong>。我们将过多的时间去关注令我们眼花缭乱的东西。</p><h2 id="行与思的统一"><a href="#行与思的统一" class="headerlink" title="行与思的统一"></a>行与思的统一</h2><p>​    用白话来讲就是讽刺很多人<strong>说一套做的又是另一套</strong>。满嘴空话却不付诸于实际行动。在书本当中指的是当时的一些迂腐的守旧学士和学识浅薄自示狂妄之人。</p><p>​    为什么我们的行与思不统一呢？一方面是一种非常健忘的生物，同时自控力与专注力因人而异，当人的思考不马上付诸行动，那么人基本上是永远不会做这一件事情的。另一方面是人的<strong>72小时法则</strong>。这是来自于《小狗钱钱》的一个观点，如果一个决定或者一个事情不在72小时之内获得阶段性结果，那么90以上概率人基本不会再想这件事情。这也是为我们我们时常下定了决心改变之后，却又在短短几天的时间忘记自己的决定。</p><p>​    关于行与思的统一，我认为最基本的锻炼方法是：</p><ul><li>提高<strong>时间观念</strong>，正确把握时间，做好时间管理。</li><li>今日事，今日毕，做不到的事情绝对不逼自己完成</li><li>养成说到做到的习惯。</li><li><strong>劳逸结合。</strong></li></ul><blockquote><p>这里特别提一下为什么劳逸结合对于行与思的统一重要性。人的注意力是随着时间推移而减弱的，虽然不少人晚上的学习效率会高于白天的效率。但是从科学的角度来看，每一天时间越早人的注意力是越高的。特别是早上大脑放空的状态下人的学习效率出奇的高（当然有一个好的作息规律）</p></blockquote><h2 id="怀疑的取舍"><a href="#怀疑的取舍" class="headerlink" title="怀疑的取舍"></a>怀疑的取舍</h2><p>​    关于怀疑的取舍这一段，作者认为学者应该保持怀疑的精神，对于任何事情最好的状态是保持换位思考，当然对于一些经过了长时间考验的真理我们可以保持无条件的相信。</p><p>​    真理应该怀疑还是认可是是一个非常个人并且主观的问题，但是从一些小的论点来看，比如<strong>尽信书不如无书</strong>这些经过了时间考验的话是完全值得相信的真理。</p><h2 id="怨犹之害"><a href="#怨犹之害" class="headerlink" title="怨犹之害"></a>怨犹之害</h2><p>​    作者评判了一个重要的观点：<strong>冤冤相报何时了</strong>，强调人与人之间应该保持独立精神并且和谐相处，<strong>常常抱怨的人往往是没有学问的人</strong>，越是对自己的认知不够，越会把事情的过错推给外因，比如没有时间，时机不对，运气不好等等因素，等到机会真正来临的时候又抱怨没有抓住机会。</p><p>​    所以怨犹是自内而外的一种负面能量，我们需要摈弃之。为无意义或者没有到来的事情烦恼，是单纯的浪费时间和生命。</p><h2 id="民族资本主义"><a href="#民族资本主义" class="headerlink" title="民族资本主义"></a>民族资本主义</h2><p>​    作者鼓励人民创业和实业，并且赞扬为实业谋生而为国家繁荣富强，而又受到政府剥削的民族资本主义的坚持是值得鼓励的。在当时的背景下，这种观点是十分正确的，作者受到西方学术的先进思想的熏陶。能将眼光放得更高和更远，而民族资本主义是先进思想的发扬者和传播者。</p><h2 id="作者的不足之处"><a href="#作者的不足之处" class="headerlink" title="作者的不足之处"></a>作者的不足之处</h2><p>​    全书看完可以明显看出作者福泽谕吉是偏向政府这边，更多的是劝诫人民踏实做事情，而不是同政府作对，这种十分激进的压迫方式是不值得借鉴的。纵观大部分的国家历史，更多是推翻旧的政府和统治阶层而获得新生，虽然革命并不一定能带来光明的未来。但是从历史的进程来看，革命更多是推进历史的脚本。而作者的偏激思想在这时看来十分具有局限性。</p><h1 id="我所知的劝学"><a href="#我所知的劝学" class="headerlink" title="我所知的劝学"></a>我所知的劝学</h1><p>​    不知道有多少人看到这一部分，希望下面这段话能给读者一些感触。当然看不到这一部分也说明我对于写作的功底还不够深厚，还需要加以磨练。</p><p>​    单独拿一个大节再来深入谈谈关于这本书本身劝学这两个字。其实真心想要学习的人，根本不需要去劝。人会不喜欢学习，本质是因为 <strong>找不到目标</strong>。工作之后的我也逐渐讨厌学习，百分之百是因为缺少目标，因为大学的我目标是能进入IT这个行业。但其实不管进入的是任何行业，终身学习都是必须的，我们可以没有目标，但是我们不可以放弃对于知识的追求和探索。正所谓废掉一个人就是让他闲着。</p><p>​    非常感谢过去的我有一个好的读书习惯，这个社会需要的是自燃的人。所以为自己充电是十分重要的事情。经历过那么多读书笔记的编写和“熏陶”之后。明显感觉自己理解能力有了不小的提升。</p><p>​    </p><h1 id="个人感想"><a href="#个人感想" class="headerlink" title="个人感想"></a>个人感想</h1><p>​    从作者的角度出发，虽然作者是明治时期的人，并且是一个外国人，但是里面很多东西放到现在还受用，很难想象在当时比中国还要闭锁的日本能有如此超前的思想启蒙家。同时作者是一个三观极正的人，三观正到很难辩驳，能从事物的两面看待并且中立的评判一件事情。这在当时的封建思想是很难得的存在，在现在也是十分的少见。最后作者给出的许多比喻十分好理解并且恰到好处，能把十分难懂的理论用简单的比喻形象的概括，这是需要十分深厚的积累才能办得到的。</p><p>​    从内容出发，整本书让我印象最深的是作者赠与友人的一部序，讨论了当时日本学士的浮夸之风，会学习却不思考，并且急于求成就早早下判断，缺乏钻研和自己的理解，甚至要把学问带在身上。作者用各种比喻来形容。书本中的内容非常有意思。</p><p>​    现代社会越来越浮躁，在一个内卷化的时代，我们每一个人都在焦虑，却很少付出行动对抗焦虑和付诸行动。想要努力却又没有方向。我个人的选择是用读书来扩展自己的眼界，同时提高自己的表述能力，语言组织和沟通能力，在不断的读书和笔记摘录中，我对于书籍作者想要表达的思想可以越来越快的领悟。这也促使我可以看更多的书，如此形成一个良性循环。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>​    <strong>我始终认为，一个经受不住学问考验，不能积跬步的人，是无法去寻找自己真正想要的生活的。</strong>如果学习不能带给你名誉，金钱，荣誉等等，你还会继续学习么，答案是你肯定还会学习，因为这件事情我们做了10多年直至成年。我想作者想要并不是真正想要劝谁学习，作者想要看到的是一个拥有良好求学之风气的社会罢辽。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      请输入描述信息
    
    </summary>
    
    
      <category term="未分类" scheme="https://whitestore.top/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="无" scheme="https://whitestore.top/tags/%E6%97%A0/"/>
    
  </entry>
  
  <entry>
    <title>《这本书能帮助你戒烟》读书笔记</title>
    <link href="https://whitestore.top/2021/05/20/jieyan/"/>
    <id>https://whitestore.top/2021/05/20/jieyan/</id>
    <published>2021-05-20T15:02:54.000Z</published>
    <updated>2021-05-20T15:04:16.142Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《这本书能帮助你戒烟》读书笔记"><a href="#《这本书能帮助你戒烟》读书笔记" class="headerlink" title="《这本书能帮助你戒烟》读书笔记"></a>《这本书能帮助你戒烟》读书笔记</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    这本书是在论坛上一位小伙伴误以为我抽烟给我推荐的，然后其实我虽然会抽烟但是并不会吸烟（过嘴不过肺）。吸这玩意我也不能理解为什么会让人上瘾。这本书没有买实体书，甚至连笔记都没有做，因为我没有烟瘾也不喜欢吸烟。<strong>如果你真的有烟瘾，建议你坚持一下看完这本书</strong>。</p><p>​    这里也感谢一下这位陌生网友，对陌生人的共情心是十分美好的品质。</p><a id="more"></a><h1 id="推荐指数"><a href="#推荐指数" class="headerlink" title="推荐指数"></a>推荐指数</h1><p>​    <strong>3.5星</strong>（满分5星）。这本书如果是吸烟人群看看会比较有帮助，<strong>不建议没有烟瘾的人闲的没事看这本书</strong>。同时，坚持看完这本书，能大致让你认识烟瘾是怎么一回事。</p><h1 id="推荐语"><a href="#推荐语" class="headerlink" title="推荐语"></a>推荐语</h1><p>​    戒烟并不是让你“失去健康”，吸烟的本质是一种洗脑，吸烟的其实是就是躲避恐惧，逃避责任的表现。</p><h1 id="内容概要"><a href="#内容概要" class="headerlink" title="内容概要"></a>内容概要</h1><p>​    这本书的很多内容还是建议有真正有烟瘾的人去好好看看。提高对于吸烟的认知比戒烟本身重要。了解自己到底在“恐惧”什么，才是解决吸烟和戒烟这一个无解轮回的根本办法。</p><h2 id="吸烟误区"><a href="#吸烟误区" class="headerlink" title="吸烟误区"></a>吸烟误区</h2><p>​    吸烟的误区常常是误认为自己需要烟，但是更多的其实是烟带来的戒断反应。你所认为的吸烟让人更精神，其实本质就是尼古丁的作用。</p><p>​    吸烟误区另一种表现是想靠意志力去对付自己，其实根本没有必要，吸烟不吸烟并没有失去什么，戒烟会让得到的比失去的要多得多。或者说本来什么都不用失去，因为戒烟反而把失去的东西找回来了。</p><p>​    </p><h2 id="吸烟是一种洗脑"><a href="#吸烟是一种洗脑" class="headerlink" title="吸烟是一种洗脑"></a>吸烟是一种洗脑</h2><p>​    吸烟是如何给你洗脑的呢？首先是 <strong>在烟盒上印上“吸烟有害健康”</strong>。都知道这是最讽刺的，你不买烟永远不会看到这句话。这当然其实是一种心理暗示：有害健康是一个宽泛的概念，这十分容易欺骗吸烟者给自己洗脑。</p><p>​    吸烟会让人觉得“少了”什么东西，同时如果吸烟之后过了一段时间马上会出现戒断反应，会不由自主的吸下一根。</p><p>​    永远都有下一根，和所有的诱惑一样，吸烟永远没有最后一根，只会有下一根，吸烟者对此是完全没有概念的。</p><h2 id="为什么要想最坏处？"><a href="#为什么要想最坏处？" class="headerlink" title="为什么要想最坏处？"></a>为什么要想最坏处？</h2><p>​    吸烟者的脑海把自己逼到最坏处，通常会闭上眼睛，幻想自己某一天会戒烟，突然就不想吸烟了。抱持种想法是无法摆脱尼古丁的。</p><p>​    往最坏处想另一种表现是寻找替代品，电子烟或者口香糖，或者其他任何可以“吞云吐雾”的东西。这还是往最坏处想，</p><p>​    最后，做好最好的准备，想最坏的结果，做一个悲观的乐观主义者才是一个正确的观念。</p><h2 id="为什么戒烟那么难？"><a href="#为什么戒烟那么难？" class="headerlink" title="为什么戒烟那么难？"></a>为什么戒烟那么难？</h2><ol><li>最大的敌人是 <strong>恐惧</strong>。人越是恐惧，越是空虚，越容易染上烟瘾。</li><li>停止吸烟不是最重要的。因为停止了吸烟也会因为自控力缺失而放纵自己。</li><li>戒烟似乎是一种牺牲。从另一个角度来讲，几乎让我们改变自己习惯和行为的所有对手都是来源于“牺牲”，吸烟会让人认为不抽烟少了点什么，这种感觉类似<strong>自己家门口的下水道缺了井盖</strong>。</li><li>双重否定效应。吸烟的人通常自认为知道烟的危害，其实他们根本不知道，上面说了吸烟的洗脑，戒烟之所以这么难是因为吸烟的人在<strong>否定烟没有好处的同时，否定了烟对自己有影响</strong>。人会主观意识里面排斥，但是潜意识会认同。</li><li>最后，烟很容易买到，下个楼随便走个几百米都可以买到烟。很小商铺可能缺少一些生活必需品，但是烟是永远不会缺的。</li></ol><h2 id="一支烟值15000元"><a href="#一支烟值15000元" class="headerlink" title="一支烟值15000元"></a>一支烟值15000元</h2><p>​    或许只有这样，才会让有烟瘾的人知道一支烟到底让他花了多少钱在里面，实际上抽烟的人花的钱远比这个数值高。只要永远存在一支烟，那么就永远不要想可以戒烟。</p><h2 id="认识未来的自己"><a href="#认识未来的自己" class="headerlink" title="认识未来的自己"></a>认识未来的自己</h2><p>​    这个话题在《自控力》里面用了专门的一章节来讲，其实认识未来的自己是一件很重要的事情。这里提一下书中用模拟癌症的实验，实验内容为人们愿意花多少为退休后的自己投资，将两组人一组人“体验癌症”，另一组人正常生活，很显然“得过”癌症的实验者通常会花更多的钱来投资自己。因为他们“经历”过。投资未来对于一个普通人来说是很难办到的。吸烟也是一样的，你如果用现在不会出事来麻痹自己。那么戒烟看来是永远不可能的一件事。</p><p>​    不要试图用各种“吃喝嫖赌”却活了很长时间的人来安慰自己，当然也不要拿各种“案例”来恐吓自己，吸烟的人只需要了解 <strong>未来的自己和现在的自己没有什么区别（难道祈祷未来可以像赛博朋克一样给自己身体部位换零件?）</strong>。</p><h2 id="意志力戒烟为什么常常失败？"><a href="#意志力戒烟为什么常常失败？" class="headerlink" title="意志力戒烟为什么常常失败？"></a>意志力戒烟为什么常常失败？</h2><p>​    书中有不少案例是因为意志力戒烟跟自己作对的人是什么样的身体和心理状况，虽然他们可以和吸烟不吸烟之间打“拉锯战”，但是这种意志力早晚一天会崩塌。因为这是在“少了什么”的前提先构建的一种对立。</p><p>​    令人更加惊讶的是，一个看上去完全不会抽烟的人，甚至觉得抽烟没有任何趣味的人，最终因为经常吸二手烟而患上20年的烟瘾。起初看到这一段有点难以置信，看到后面从患上烟瘾的自白中似乎可以理解，在军队染上烟瘾。在退伍之后因为烟受尽折磨，甚至影响了家庭和个人情感，及时家庭的劝阻也依旧无法停止。作者会详细的描述这个案例，或许是因为作者曾经经历过这种心理煎熬。</p><h2 id="为什么贫穷不能阻止吸烟"><a href="#为什么贫穷不能阻止吸烟" class="headerlink" title="为什么贫穷不能阻止吸烟"></a>为什么贫穷不能阻止吸烟</h2><p>​    吸烟的经济开销是十分厉害的。经济紧张的人宁可抽便宜的烟也不会控制自己吸烟。更加讽刺的是，在大城市烟民嫌弃物价很贵，却从来不会犹豫的买各种“高档”点的二手烟。</p><p>​    吸烟的人宁可在吃饭上面节俭，也永远不会思考在吸烟这块节俭一些。</p><p>​    毫不夸张的说，即使身无分文，烟民口袋里永远都会有那么一两支烟作为“后备储备”。</p><h2 id="医院是吸烟重灾区"><a href="#医院是吸烟重灾区" class="headerlink" title="医院是吸烟重灾区"></a>医院是吸烟重灾区</h2><p>​    这个部分为个人的思考，医院到处可以看到各种烟头和烟灰。很难想象一个最不应该吸烟的地方全是烟头。最最讽刺的是，劝人吸烟的医生可能烟瘾是非常重的。所以吸烟这东西最只有可能自己让自己戒烟。</p><p>​    最后，作为医生这种高压职业的想要戒烟要难上不少。</p><h2 id="现时代的“控烟”"><a href="#现时代的“控烟”" class="headerlink" title="现时代的“控烟”"></a>现时代的“控烟”</h2><p>​    中国作为最大的烟草生产和“销售”国，近几年可以看到现在对于很多公众场合都已经禁烟。这对于烟民来说是一把双刃剑，因为还是有吸烟区，厕所这种地方让吸烟者来躲避恐惧。烟民在“失败”的时候，通常会用烟和酒来抑制失败，然而经历过的都知道，这其实只会让人更加堕落和无助，从总体来看，越来越多的地方禁烟还是一种好事。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>​    作为一个湖南人，我感觉比吸烟毒害更大的是<strong>槟榔</strong>。我身边的朋友几乎半数都着了道。希望看到这边笔记的烟民，最好看看这本书。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      不管你能不能成功,这本书都很有帮助
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://whitestore.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="励志" scheme="https://whitestore.top/tags/%E5%8A%B1%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>《为什么长大》读书笔记</title>
    <link href="https://whitestore.top/2021/05/20/zhangda/"/>
    <id>https://whitestore.top/2021/05/20/zhangda/</id>
    <published>2021-05-20T15:01:32.000Z</published>
    <updated>2021-05-20T15:02:27.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《为什么长大》读书笔记"><a href="#《为什么长大》读书笔记" class="headerlink" title="《为什么长大》读书笔记"></a>《为什么长大》读书笔记</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    我不太能看懂哲学类的书，看完之后我通常都会去看看书评，然后就是“哦”的一声，看完之后再回去看一遍书，但是看着书评和书友的感受之后重新看这本书，感觉我又似乎看懂了一点点作者想要表达什么，还是挺开心的。</p><a id="more"></a><h1 id="推荐语"><a href="#推荐语" class="headerlink" title="推荐语"></a>推荐语</h1><p>​    《为什么长大》属于一本系列书。这是一本需要用心去看的书，我们为什么成长？我们真的有必要成长么？成长到底应该是什么样子，看完这本书或许并不能收获什么，但是能让你最直观的感受什么是成长。</p><h1 id="推荐指数"><a href="#推荐指数" class="headerlink" title="推荐指数"></a>推荐指数</h1><p>​    满星5星，个人评价<strong>3星：</strong>还算不错的一本书，也是一本适合地铁上思考和阅读的书籍。这本书仔细看基本能告诉你到底什么才是成长？人为什么要成长？为什么人人都不想长大呢？3星另一个方面是因为这是一本哲学书，并不是十分看得懂。</p><h1 id="内容分析"><a href="#内容分析" class="headerlink" title="内容分析"></a>内容分析</h1><h2 id="成长意味着什么？"><a href="#成长意味着什么？" class="headerlink" title="成长意味着什么？"></a>成长意味着什么？</h2><p>​    成年意味着最坦诚的时候被骗了，谁能指责不想长大的人呢？</p><p>​    在我们最单纯的时候被骗，或许是人的第一次成长，特别是初入社会的人多少会经历类似的事情，当我们认为世界还存在美好的时候，世界却在我们最向往美好的时候给我们最重的一拳。</p><p>​    书里有一段话是这样写的：<strong>彻底放弃理想比希望彻底破灭要好太多，纸面腐朽的现实比沉甸甸的幻想要好太多</strong>。这大概就是《神话》里面多少人希望做易小川却逐渐活成了赵高。</p><p>​    第一次被骗：刚来大城市租房的时候押金被骗（高房租租烂房子），在人生地不熟的地方被房东耍的团团转。幸好住旅馆遇到好心人给我上的人生第一课：不要轻易相信任何人，包括我现在对你说的每一句话，你都不要百分之百相信。</p><p>​    第二次被骗：是在火车站的时候，被人拉着说没钱回家想借现金搭车回家。当时只有几十块钱没太在意，后面在车上突然醒悟，明白被骗了。然而并不是生气，而是觉得十分无奈。</p><p>​    事不过三，这之后我很少再被骗了。说实话，这样的成长很不是滋味，大概这就是社会的无可奈何。</p><h2 id="谁的玩具最多？"><a href="#谁的玩具最多？" class="headerlink" title="谁的玩具最多？"></a>谁的玩具最多？</h2><p>​    <strong>死的时候，谁的玩具最多，谁是赢家</strong>。对于物质的极度追求，我们总是想要在世界留下印记，但是我们制造出来的却是否定与损坏的玩物。如果我们没有判断力，世界将会逐渐瘫痪，我们就不能将理性的用于世界。我们越是失去的越多，我们越是渴望玩具，我们就越是想要得到更多。或许我们还是和小时候一样，想到得到更多的“玩具”，然而“玩具”本身的意义似乎也逐渐失去了。然而奇怪的是，我们最快乐的时候，却是我们没有任何玩具的时候。</p><p>​    </p><h2 id="失去惊奇"><a href="#失去惊奇" class="headerlink" title="失去惊奇"></a>失去惊奇</h2><p>​    最直观的成长大概是我们的惊奇越来越少，我们对世界的事务越发的感到稀松平常，我们失去了童心和幼稚心。世界本来就应该是这样的，当世界的改变不在令我们惊奇，我们主观认为自己不再是独特的存在的时候，我们是感到失落还是感到愤慨还是感到认同。</p><h2 id="成长到底意味着什么"><a href="#成长到底意味着什么" class="headerlink" title="成长到底意味着什么"></a>成长到底意味着什么</h2><p>​    为什么长大？为什么遵守规则？为什么接受教育？我怎么知道？我怎么找到活着的意义？怎么创造自己的生活？</p><p>​    回答上面这些问题，或许还是不能明白成长意味着什么。但是在我看来，当我们能看到自己的不足，当我们真正认识自己，当我们找到存在的意义和价值，当我们在世界上不再是扮演角色的演员，无论我们接到什么剧本，我们都能拥有自己的角色，<strong>我们是自己的导演，我们演绎好自己的人生</strong>。</p><p>​    </p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>​    这是一本只可意会不可言传的书，我更加推荐仔细阅读一下这本书。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      人为什么会成长
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://whitestore.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="励志" scheme="https://whitestore.top/tags/%E5%8A%B1%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>《炎拳》读书笔记</title>
    <link href="https://whitestore.top/2021/05/20/yanquan/"/>
    <id>https://whitestore.top/2021/05/20/yanquan/</id>
    <published>2021-05-20T14:57:38.000Z</published>
    <updated>2021-05-20T14:58:54.333Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《炎拳》读书笔记"><a href="#《炎拳》读书笔记" class="headerlink" title="《炎拳》读书笔记"></a>《炎拳》读书笔记</h1><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20210510114029.png" alt=""></p><h1 id="资源链接："><a href="#资源链接：" class="headerlink" title="资源链接："></a>资源链接：</h1><p>​    之前的笔记都没有记录链接，这次先把链接放出来，由于使用超高清的分辨率扫描，文件体积十分庞大，<strong>请用WIFI下载</strong>（好像有4、5个G）</p><blockquote><p>链接：<span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMUdUYXNrNU1UUFVqcllXeFVFSnNzVFE=" title="https://pan.baidu.com/s/1GTask5MTPUjrYWxUEJssTQ">https://pan.baidu.com/s/1GTask5MTPUjrYWxUEJssTQ<i class="fa fa-external-link"></i></span><br>提取码：kkn5<br>复制这段内容后打开百度网盘手机App，操作更方便哦–来自百度网盘超级会员V6的分享</p></blockquote><p>​    <a id="more"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    本来想取名观后感的，不过感觉和小学生作文一样，还是归入读书笔记吧。平时除了读书之外，个人也经常看看漫画，其实并不是不看专业书，而是因为专业书是一个长时间积累的过程，并不能像普通书籍那样马上产出…..扯远了，再回来说说这本漫画， 这本漫画我比较犹豫要不要给读者看，因为这本漫画非常<strong>邪道</strong>。我敢打赌第一次打开这边漫画，看到前几页就会直接“卧槽”（看了就会明白）。这本书虽然只有短短83话，但是里面的人生哲学基本都有暗示。</p><p>​    这篇 “读书笔记”涉及剧透，如果不想被剧透，请自行下载上方的资源链接。</p><p>​    本文包含剧透！！！</p><p>​    本文包含剧透！！！</p><p>​    本文包含剧透！！！</p><h2 id="推荐指数"><a href="#推荐指数" class="headerlink" title="推荐指数"></a>推荐指数</h2><p>​    <strong>5星，满分五星。</strong>非常有意思的漫画，让我认识了藤本树这个人，对于人物的刻画非常细致。漫画里面的每一个人都不是无用的角色，奇特的时间观，用类似电影的描绘手法进行叙述。同时也是一部富含哲学的漫画。</p><p>​    个人还是十分推荐这本漫画的，虽然看到不少人十分矛盾要不要推荐这部漫画。</p><h2 id="推荐语"><a href="#推荐语" class="headerlink" title="推荐语"></a>推荐语</h2><p>​    <strong>对他使用炎拳吧</strong>！看完绝对让人印象深刻的一部漫画。这部漫画最核心的内容是告诉你，你可以成为你想要成为的任何人。不论是成为“炎拳”，还是成为普通人。无论是成为好人还是成为坏人，最终的来源的只是个人的想法而已。</p><p>​    整个世界从个人来看近似一个乌托邦，大概也可以当反乌托邦的漫画？</p><p>——— 分割线 ——————-</p><h1 id="内容概括"><a href="#内容概括" class="headerlink" title="内容概括"></a>内容概括</h1><p>​    这里说一下作品的几个人名，男主叫阿格尼，英文叫agone（痛苦），女主叫做尤迪。最后男主化身为了萨恩（Sun，太阳），女主变成了露娜（Luna，月亮），作者玩梗玩的挺溜的。</p><p>​    之后的内容算是个人的一些漫画感想，完全主观，所以我所说明的内容只是我的个人理解层次：</p><h2 id="漫画内容概要"><a href="#漫画内容概要" class="headerlink" title="漫画内容概要"></a>漫画内容概要</h2><p>​    这部分还是留给读者自己去看吧，相信这部漫画能带来深刻的回忆。</p><p>​    我更推荐第一遍看这部漫画直接把他当成一部电影看待。</p><h2 id="导演和演员"><a href="#导演和演员" class="headerlink" title="导演和演员"></a>导演和演员</h2><p>​    看过评论有人说这部漫画可以当成一部电影来看待，最开始的电影描述的是阿格尼隐忍和寻找自己的仇人，中间为了拯救被囚禁的祝福者们和统治者进行斗争。导演在前半部分贯穿了主线的内容，在中场为了拯救阿格尼牺牲了自己，导演退出了舞台。演员完成了复仇之后，阿格尼发现自己找不到活着的意义，原本复仇的对象变成了一个一心为了孩子们的“好人”，当阿格尼自以为杀了仇人可以得到解脱之后，却因为妹妹让自己活下去无法完成死去的这个夙愿。从这一部分之后，整个故事就显得越来越神话化了……</p><p>​    所以可以想象自己在电影院看完一整部漫画，挺有意思的。</p><h2 id="成为炎拳"><a href="#成为炎拳" class="headerlink" title="成为炎拳"></a>成为炎拳</h2><p>​    让阿格尼成为炎拳根本原因是尤迪的计划，而直接原因是火焰祝福者永不熄灭的火焰。</p><p>​    最开始的炎拳是没有自我意识，是为了复仇可以做出任何事情的人。后面阿格尼自认为放下了仇恨，然而内心深处的仇恨却让他依然把复仇对象给烧死了，顺带烧死了他的孩子们。阿格尼失忆之后，由于自己“幻想”的妹妹被人掳走，最终还是没能抵住诱惑，还是被孩子变成了炎拳。阿格尼好几次想要放弃作为炎拳活下去，想作为阿格尼活下去，但是各种的想法和自我幻想不断让自己变成炎拳伤害了自己并不想伤害的人。</p><p>​    那么炎拳究竟代表了什么呢？是为了让自己更强大的“火焰祝福者”，还是因为找不到活着意义只能盲目”自燃”的自己，是我们讨厌的自己还是我们喜欢的自己。阿格尼知道最后也没有想明白这件事，作为读者的我也并没有完全想通，最后还是靠女主的拯救得以改变。</p><p>​    作者为什么要刻画炎拳呢？炎拳在被拯救的人来说是英雄，对于导演来说是好演员，对于教徒来说是敌人，对于萨恩来说是渴望被认可的神。阿格尼很明显通过给自己洗脑和粉饰自己来逃避自己内心的罪恶感，有意无意的犯下了永远无法挽回的罪行。</p><p>​    作为读者的我们其实也不自觉的代入炎拳本身，我们甚至代入了阿格尼连同阿格尼去思考，前面或许最开始可以比他看做英雄，但是最后却可能认为是单纯发泄自己欲望的恶魔，我们似乎比阿格尼更加矛盾。</p><p>​    为什么偏偏是阿格尼活了下去并且成为了炎拳？我们无法用单纯的善恶来评判阿格尼。炎拳并不是黑白分明，非好即坏的角色，这和人类一般，人类似乎永远看不透心中藏着的炎拳。</p><h2 id="祝福与诅咒"><a href="#祝福与诅咒" class="headerlink" title="祝福与诅咒"></a>祝福与诅咒</h2><p>​    这一块对个人冲击最大的是萨恩被拉去”集中营”当“材料”的那一部分，萨恩依靠着不断灌输给自己信仰活了下来。并且向同伴不断的传递信念，坚信自己一定会被拯救。然而萨恩后面也因为信仰陷入了疯狂，迷失了自己，可叹的是萨恩最后是被自己信仰的神给结束了生命的，十分讽刺。</p><p>​    这个世界祝福者本来是可以拯救世界的，但是却被人类利用作为了工具，祝福者们也把自己的祝福是看做一种诅咒，这是整个漫画最为明显的一个对立话题。另外，整个“集中营”类似奥斯维辛集中营的映射一个末日当中疯狂的世界。从整个漫画的设定和世界观来看，对立冲突和矛盾是整个漫画的一大核心。</p><p>​    我们从漫画可以发现宗教的力量是十分巨大的，人的信仰可以发挥无穷的力量。这可以想到早期的航海时代，就是依靠着信仰不断的支撑才得以最终发现了新大陆。</p><h2 id="活下去活下去活下去"><a href="#活下去活下去活下去" class="headerlink" title="活下去活下去活下去"></a>活下去活下去活下去</h2><p>​    <strong>活下去</strong>这三个字贯穿了整个漫画，整部漫画都是阿格尼为了活下去不断寻找活着的证明，寻找自己存活的意义。阿格尼一边受着永不熄灭的火焰不断的灼烧，一边要不断的活着寻找存在的理由。在这本漫画，有很多人给了男主存在的理由，比如兵团的“罪人”，被利用的祝福者，导演（看了漫画就会知道）、到后面被阿格尼幻想成自己妹妹的尤迪。</p><p>​    这部分个人认为更贴近《活着》这本书，不管生命命运如何，<strong>活着本身的意义就是为了活着，不为了其他任何事情。</strong></p><h2 id="末日中的人性"><a href="#末日中的人性" class="headerlink" title="末日中的人性"></a>末日中的人性</h2><p>​    这本书很好的表现了末日的世界观，一个冲突的世界，对立与冲突，利用与被利用。善良的人与邪恶的人。这里令人唏嘘的是当初被阿格尼救了的人最后却反过来想要杀了阿格尼，“罪犯”们认为是阿格尼让他们感到十分的痛苦，这大概就是令人悲哀的人性。当然这个话题也类似一个无解的铁轨命题，本质就是在说个人做出的任何选择都要付出相应的代价。</p><p>​    让阿格尼成为火焰祝福者的老人（后面变成的），因为后悔自己放火烧村恳求炎拳放弃复仇，知道世界的真相之后一心想要保持末日当中作为人的最后一点人性，我不太明白作者为什么要洗白老人，我认为作为末日当中抹去人性才是正确的选择，因为<strong>生存永远是第一需要</strong>，哪怕吃人也不足为奇，毕竟<strong>失去人性，失去一些，失去兽性，失去一切</strong>。</p><p>​    <strong>人只会相信自己相信的事物，只能看到自己想要看到的事物</strong>。阿格尼拯救了兵团了犯人，人们都把他当英雄。然而因为末日阿格尼瞒着人们割下自己的肉给人们当做食物，人们又反过来想要毁灭炎拳，<strong>他们忘记了过去，只考虑现在，并认为自己变得黑暗是因为炎拳</strong>。</p><p>​    这一段让我想起了《三体》当中人类不感谢拯救了地球的罗辑，人性当中的阴暗面或许就潜藏在我们的无意识或者潜意识当中，只有时刻保持自我约束。才能让压抑我们内心黑暗的想法。</p><p>​    还有一点很奇怪的是，当炎拳拯救了实际上是罪人的“祝福者”。我们甚至感同身受的认为炎拳是一个英雄，甚至忘了他无情的夺走了很多人的性命。</p><p>​    </p><h2 id="活出自己"><a href="#活出自己" class="headerlink" title="活出自己"></a>活出自己</h2><p>​    阿格尼最开始活着是为了复仇，然而复活对象死后，他在不断的自我惩罚而堕落当中寻找活着的意义，。炎拳个人认为最为温馨的一段是尤迪第一次变成大树的计划被炎拳破坏之后两人失忆的那一段时间。阿格尼找到了真心愿意让他过得更好的“家人”。</p><p>​    然而最后炎拳还是亲手杀了自己的“家人”。阿格尼还是没有战胜自己，或许这种遗憾是每一个人的心结。</p><p>​    </p><h2 id="自救和被拯救"><a href="#自救和被拯救" class="headerlink" title="自救和被拯救"></a>自救和被拯救</h2><p>​    接下来要说下对于结局的看法，最终男主还是“找到”了目标，当然是被尤迪赋予了活着的意义。阿格尼虽然并不是靠着自己的力量完成自救，并且找到活着的意义的</p><p>​    和《肖申克的救赎》有些类似，拯救了阿格尼牺牲自己的尤迪无疑是十分伟大的，阿格尼成功获得了救赎，并且忘记了自己作为炎拳以及自己的所有过去。作为人来说，要完全放下过去，重新做人基本上是不太可能的一件事情，因为漫画的主角阿格尼有着强韧的精神力却也依然没有做到，或许这也是人之本性吧。</p><p>​    我更想看到阿格尼成功自救，走出炎拳的束缚，但是结局没有如我所愿。</p><h2 id="关于结局"><a href="#关于结局" class="headerlink" title="关于结局"></a>关于结局</h2><p>​    接上一个小节的介绍，结局是作者被尤迪（女主）所拯救。另一方面，虽然尤迪变成大树给地球带来了生机。但是由于人类对资源的掠夺，最后的结局是人类自取灭亡。</p><p>​    另外最后人类的的咎由自取有点讽刺现在的大环境。地球资源的掠夺，人类注定会自取灭亡。</p><p>​    另外，我认为结局“Luna”和”Sun“相遇有点故事的神话化，当然画面的冲击感十分强烈，总的来说还是可以接受但是不是很满意的结局。</p><p>​    这个结局我个人<strong>不太满意</strong>，因为阿格尼结局是被拯救而不是自我拯救。有一点点高开低走，最后男主借用萨恩的身份活了下来，算是完成了找到活着的意义的目的，并且看了过去的“自己”拍的电影。而女主因为长时间的等待甚至忘记了当初拯救的人是谁。结局的几张画面还是刻画的十分有美感的。虽然这个结局不是十分喜欢，但是比起隔壁某温泉店老板的作品那可真是要好太多了（说的就是你，进击的巨人）。</p><p>​    </p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>​    唉，该来的还是来了，希望不要拍烂吧，而且国内应该播不出。</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20210427153330.png" alt=""></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>​    一部漫画只要听到名字就能想起某个画面，我想这部漫画就是十分成功的漫画，这部漫画的出生也有不少的波折。关于人生的所有哲学，都可以从这部漫画各种方面看到缩影。</p><p>​    <strong>或许每一个人都是炎拳</strong>。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      什么是炎拳,对他使用炎拳
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://whitestore.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="炎拳" scheme="https://whitestore.top/tags/%E7%82%8E%E6%8B%B3/"/>
    
  </entry>
  
  <entry>
    <title>《给未出世的你 致2025年的世界》读书笔记</title>
    <link href="https://whitestore.top/2021/05/20/weichushi/"/>
    <id>https://whitestore.top/2021/05/20/weichushi/</id>
    <published>2021-05-20T14:55:41.000Z</published>
    <updated>2021-05-20T14:56:58.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《给未出世的你-致2025年的世界》读书笔记"><a href="#《给未出世的你-致2025年的世界》读书笔记" class="headerlink" title="《给未出世的你 致2025年的世界》读书笔记"></a>《给未出世的你 致2025年的世界》读书笔记</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    这是一份送给“一零后”的成人礼。1999年世纪之交，七十四岁的雅卡尔写下这封信，期待未出世的重孙在自己百年诞辰的2025年，打开它。</p><p>​    令人惊讶的是，书中的预言到现在基本全然实现，并且当智能手机以惊人的速度普及的现代，这个预言似乎来得更早了。</p><p>​    这本书适合给青少年看，适合给每一个懵懂无知并且处在迷茫徘徊的年代的读物。然而作为一个成年人，依然可以从书中诚挚的语言感动。</p><a id="more"></a><h1 id="推荐语"><a href="#推荐语" class="headerlink" title="推荐语"></a>推荐语</h1><p>​    作者的语言用朴实的语言，写下这封“信”给自己的重孙，这本书适合每一个青少年和“10后”读一读。</p><h1 id="好句摘录"><a href="#好句摘录" class="headerlink" title="好句摘录"></a>好句摘录</h1><ul><li>你并不比遭到社会抛弃的人强多少，并不比所谓强大的有社会地位的人弱多少。</li><li>毫无作为的选择是无意义的，没有理解接踵而至而盲目的作为也同样苍白无力。</li><li>不为困难迈向山顶的人，每一步都很费力，但不会放弃，因为视野开阔之际，他将得到怎样的回报。</li></ul><h1 id="内容概要"><a href="#内容概要" class="headerlink" title="内容概要"></a>内容概要</h1><p>​    可能是过了适合读这本书的年纪，对于书本的内容似乎已经麻木而且习以为常，作者对于未来的担忧到现在基本已经成真，特别是疫情后的世界，前路更加迷茫。</p><h2 id="社会与未来"><a href="#社会与未来" class="headerlink" title="社会与未来"></a>社会与未来</h2><p>​    现代基础科学也正如作者一般并没有很大的变化，基础理论的发展缓慢，更多是社会资源朝着“极限”不断的发展和蔓延。作为未来的一代，是面临人口爆炸，社会资源枯竭，竞争压力也越发的巨大。</p><p>​    技术的进步将改变人的生产甚至改变生活方式。当时基础的社会生活依然和几十年前没有多大的改变。更多的是通货膨胀，物价飞涨，社会生活到现在依然是量的积累而不是质的飞跃。</p><h2 id="因为你终究死去"><a href="#因为你终究死去" class="headerlink" title="因为你终究死去"></a>因为你终究死去</h2><p>​    “你很幸运，因为你终将死去”。这是这本书背面唯一的一句话，似乎向自己的重孙说，也是在向自己说吧。</p><p>​    年轻的时候，“死亡”经常会认为是一个遥远的话题，虽然人的生命不过3万多天，但是即使是单纯的数字，依然可以让人感觉生命的“漫长”。然而，<strong>时间并不是装在宝箱的宝藏，你每花费一点就从宝藏里面拿出一点。时间是永远流动的泉水，只不过你终将离开泉眼</strong>。作者豁达的心态令人致敬。</p><p>​    别人的死亡只不过是一系列事件的一个篇章。但是我们自己却有完全不同的地位。我们永远可以看到其他人生命的终点，但是我们永远看不到自己生命的终点。正是由于此种的原因，我们自觉永远不会离开名为时间的泉眼</p><p>​    对于死亡的忧虑，正在促成个人的不断成长，在对不死进行斗争的时候，死亡的焦虑是永恒的朋友。</p><h2 id="关于人类这物种"><a href="#关于人类这物种" class="headerlink" title="关于人类这物种"></a>关于人类这物种</h2><p>​    在科技不断发展的现在，人类越发的自觉自己是世界的主宰。人们一边忧虑世界资源的掠夺和破坏，一边却又在不断的重蹈覆辙，似乎世界是永恒的。</p><p>​    这种死循环似乎存在于一种规则一般，让人担忧却无可奈何，人类未来也将在不断的忧虑和进步当中寻找新的可能。</p><h2 id="人的构成："><a href="#人的构成：" class="headerlink" title="人的构成："></a>人的构成：</h2><p>​    对人的看法似乎从出生的那一刻就进行的划分，并不是简单的男性和女性，而是阳性，中性，阴性。人文主义的进化与发展，促成了现代人性格的多样性和独立性。然而，不论生活在任何地区，都会对人进行划分，将男人和女人进行区别对待，这便是自古遗留下来的观念。</p><p>​    和人的两极一样，世界似乎处处也存在着两极，任何的事物都拥有他的对立面，我们对于宇宙和世界的认知却如同婴儿一般。</p><p>​    </p><h2 id="世界的变革"><a href="#世界的变革" class="headerlink" title="世界的变革"></a>世界的变革</h2><p>​    作者期望的发达国家“零增长”的世界似乎永远不会到来（但是人口零增长却已经实现了）。虽然世界已经脱离了冷战时期。资源掠夺依旧在继续，大国依旧在利用核武器互相危险，然后用蹒跚的脚步不断“减量”。爱因斯坦大概永远不会知道，促成世界和平的居然是人类灭亡的核武器，而爱因斯坦醒悟的时候已经没有的回头的路。</p><p>​    </p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>​    作为成年人，这本书似乎永远只适合作为地铁读物，所以这本书简单看看就差不多了。但是<strong>身处与他人相遇的联系中时，任何人都不只是“他自己”。</strong></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      《给未出世的你 致2025年的世界》读书笔记
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://whitestore.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="励志" scheme="https://whitestore.top/tags/%E5%8A%B1%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>《不努力好像也没关系》读书笔记</title>
    <link href="https://whitestore.top/2021/05/20/bunuli/"/>
    <id>https://whitestore.top/2021/05/20/bunuli/</id>
    <published>2021-05-20T14:51:42.000Z</published>
    <updated>2021-05-20T14:55:20.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《不努力好像也没关系》读书笔记"><a href="#《不努力好像也没关系》读书笔记" class="headerlink" title="《不努力好像也没关系》读书笔记"></a>《不努力好像也没关系》读书笔记</h1><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20210410191647.png" alt=""></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    这本书算是一本彻底的标题党的书，内容虽然和书名的意思差不多，但是由于作者是个日本人，很多东西只要看看就好。我从这本书中学到的内容并不算很多，更多的是一种感慨。这本书是那种口袋书，比较适合地铁上放松的时候看看。</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>​    《不努力好像也没关系》是“14岁懂社会”系列的第五本（前四本为《以书为友》，《你没那么笨》，《动物园的生死告白》，《女生的世界里总是硝烟弥漫》）。讲述了如何用“佛系”和达观的心态去看待社会和世界，用朴实和语重心长的语言以教育K君和U子两个孩子为线索，阐述了作者认为的世界观，人生观和价值观。</p><h1 id="推荐语"><a href="#推荐语" class="headerlink" title="推荐语"></a>推荐语</h1><p>​    <strong>地铁放松读物</strong>。这本书用非常“佛系”的心态让读者用释怀的角度去看待人生百态，比如避免竞争，要做有趣的人，不要做无趣的人，接纳自己的缺点，以及不要那么拼命的努力。但是并不是说真的放弃追求，而是要用活出自己的个性并且接纳自己的缺点，并且努力让自己成为“真正的人”。</p><h1 id="好句摘录"><a href="#好句摘录" class="headerlink" title="好句摘录"></a>好句摘录</h1><ul><li>人生既有风雨交加，也有晴空万里。<strong>请在悲伤的时候尽情悲伤，喜悦的时候尽情喜悦</strong>。悠闲舒畅地度过你们的人生，这就是我的希望。</li><li>K君，你一定要牢牢记住，每个人都是不同的，跟别人不一样完全没关系，也不要因为别人跟自己不一样就欺负对方，千万不要成为那样的人。这是我对你的希望。</li><li>U子，我希望你记住：人是孤独的，人的孤独是本质性的，无法消解的。在了解这个事实的前提下，你就可以尽情和世上的很多人交往。毕竟你了解到孤独是本质性的，与他人互发消息时就不会患得患失了。</li><li>我们每个人都有好奇心和求知欲，<strong>如果是为了满足自己的好奇心与求知欲而学习，肯定会很开心</strong>。</li></ul><h1 id="内容概要"><a href="#内容概要" class="headerlink" title="内容概要"></a>内容概要</h1><p>​    这本书讲述了人应该拥有自己的目标，应当关爱他人，讲述人的孤独是与生俱来的，没有人可以代替人死亡，同时批判日本社会，人际关系的冷漠以及隔阂。讲述人不应该存在竞争，同时批判社会制度的各种竞争。下面就作者的几个观点进行简述。</p><h2 id="脱离正轨"><a href="#脱离正轨" class="headerlink" title="脱离正轨"></a>脱离正轨</h2><p>​    本书讽刺了日本社会的生活用“成功“来衡量一个人，并且反对”人要于是有用”的说法，提出每一个人都是独一无二的，有缺点并不是什么坏事，相反，要在接纳自己缺点的同时，寻找自己的优点，寻找自己的热情，让自己脱离生活的正轨。</p><p>​    什么是无趣的人？什么是有趣的人呢？作者给出的答案是，无趣的人想着荣华与富贵并且为工作而活的人，而有趣的人则<strong>为自己而活</strong>。</p><p>​    这里讽刺了日本冷漠并且病态社会的社会，作者认为大家都“疯了”，社会让多数人变成无趣的人。这样病态的日本社会现实好像逐渐在映射到我们的国家。</p><h2 id="人是孤独的"><a href="#人是孤独的" class="headerlink" title="人是孤独的"></a>人是孤独的</h2><p>​    这里面作者提到了夏目漱石的《心》。这本书比较建议每一个人看看，讲了人的孤独是与生俱来的，每个人从出生到死去都是“孤独”的。所以孤独的自己更应该好好的活在这个世界上，更好的感受每一天人生。</p><p>​    对于孤独个人的理解是，觉得自己孤独的人都不是孤独的人，内心感受不到孤独的人才是真正孤独的人。</p><p>​    </p><h2 id="人的缺点"><a href="#人的缺点" class="headerlink" title="人的缺点"></a>人的缺点</h2><p>​    接纳自己的缺点，同时极力的发扬自己的长处才是正确的做法。取长补短固然是一种可行的办法，但是人生来就是不完美的，正是因为不完美每一个人才显得独立而富有个性，所以我们并不需要让自己成为完美的人，相反更应该反其道而行，极力的发挥自己的长处，因为完美的人是不存在的，完美的人是怪物。</p><p>​    对于人的缺点这一段的看法，个人认为每一个人更多的是厌恶别人的缺点，但是从来不反省自己的缺点，每个人似乎都能通过生活和细节了解和观察一个人，但是很少有人真正的了解自己。</p><h2 id="拼命工作是对的么？"><a href="#拼命工作是对的么？" class="headerlink" title="拼命工作是对的么？"></a>拼命工作是对的么？</h2><p>​    本书从蜜蜂和蚂蚁的案例，提出过多的花朵并不能让蜜蜂采到更多的蜂蜜，反而会让蜜蜂累死，而蚂蚁看起来很勤劳，但是实际上大部分的蚂蚁都在“偷懒”。最后质疑为什么一定要拼命工作，但是并不是说拼命工作是错的，而是质疑为什么一定要那样努力的工作，每个人更应该探究自己于社会的使命和活着的意义。</p><p>​    正是因为有懒惰的人，才能显得勤劳的人伟大， 社会精英永远都是少数人，即使出自同一个环境的人也会分出三六九等，我们并不需要为什么“成功“拼命的工作。</p><p>​    这种观点说的是日本压抑的社会环境，在个人看来更像是对日本阶级固化社会的一种反抗。至于对于这一个观点的看法，我个人保持保留意见，并不认可也并不反对。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>​    这本书最终个人定位还是认为是地铁上的轻松读物，看完可以让心中稍微释怀一些，但是像作者这样佛系的心态我想作为一个普通人来说还有很远的路要走。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      人生需要拼搏,也需要休息
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://whitestore.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="励志" scheme="https://whitestore.top/tags/%E5%8A%B1%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>《奇特的一生》读书笔记</title>
    <link href="https://whitestore.top/2021/05/20/qiteyisheng/"/>
    <id>https://whitestore.top/2021/05/20/qiteyisheng/</id>
    <published>2021-05-20T14:49:08.000Z</published>
    <updated>2021-05-20T14:51:13.803Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《奇特的一生》读书笔记"><a href="#《奇特的一生》读书笔记" class="headerlink" title="《奇特的一生》读书笔记"></a>《奇特的一生》读书笔记</h1><p>[TOC]</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20210408135045.png" alt=""></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    这本书个人认为是时间管理的一本“教材书”，需要注意的是这更像是对于一个人一生的评价和讨论。同时主人公并不是我们常见的“成功人物”。他的知名度远远不及列夫托尔斯泰，但是他是属于“不鸣则已，一鸣惊人”的典型案例。另外再说说作者，作者作为文学界“王者”用一整本书写一个人，可以看出他对柳比歇夫的尊敬态度。最后我想吐槽一句，其实这本书并不需要那么多内容，修订版凑篇幅的痕迹比较明显。</p><p>​    这本书算是自律和时间管理的教科书，用一个真实人物的案例告诉你一个自律+时间管理的人能产生多大的能量。</p><p>​    好像我看过印象比较深刻的书籍读书笔记的内容都比较长，所有这篇文章也非常长。后续根据具体情况反馈调整读书笔记的篇幅。</p><p>​    <a id="more"></a></p><h1 id="推荐指数"><a href="#推荐指数" class="headerlink" title="推荐指数"></a>推荐指数</h1><p>​    <strong>五星</strong>：我很少会认为一本书是完美的，但是这本书从个人角度来看无论是当做人物传记读一读还是学习时间管理，这都是对于个人成长十分有价值的。</p><p>​    比较遗憾看到没能早点看到这本书晚，不过还算年轻的时候看到这本书绝对是人生的一大宝藏。</p><p>​    这本书算是宝藏类型的书。是值得“浪费”人生来仔细阅读的一本书。</p><h1 id="推荐语"><a href="#推荐语" class="headerlink" title="推荐语"></a>推荐语</h1><p>​    <strong>你可以浪费时间，但是请不要浪费生命</strong>。柳比歇夫用一生贯彻自己的人生目标，他的时间统计法值得每一个人学习和借鉴，同时对于时间的感知越深，目标越伟大，越会感觉时间的短暂。</p><h1 id="好句摘录"><a href="#好句摘录" class="headerlink" title="好句摘录"></a>好句摘录</h1><ul><li><p>再伟大的人，终究不过是一个凡人，无论多么没有感情的方法，都阻挡不了幸福的冲击</p></li><li><p>一个心灵美好的人是很难遇到的，因为人不可能长进的超过善良与真诚</p></li><li><p>有些人把穿一套好衣服当做真正的乐趣，何必同这些人比赛竞争呢？</p></li><li><p>生活不会等待慢吞吞的人，人生是一场没有终点的旅行。</p></li><li><p>他拿着秒表检查自己，惩罚自己，一旦独树一帜，就不可能得到理解。</p></li><li><p>真正的时间管理是：<strong>你总是可以浪费时间做没有什么目的的事情，只要你开心，没有负罪感，你就是一个幸福的人</strong></p></li></ul><h1 id="看书之后总结几个问题"><a href="#看书之后总结几个问题" class="headerlink" title="看书之后总结几个问题"></a>看书之后总结几个问题</h1><h2 id="柳比歇夫是谁？"><a href="#柳比歇夫是谁？" class="headerlink" title="柳比歇夫是谁？"></a>柳比歇夫是谁？</h2><p>​    亚历山大·亚历山德罗维奇·柳比歇夫（1890年4月5日——1972年8月31日），前苏联的昆虫学家、<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/lk7LlrablrrYvMzk2OA==" title="https://baike.baidu.com/item/哲学家/3968">哲学家<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/mlbDlrablrrYvMTIxMDk5MQ==" title="https://baike.baidu.com/item/数学家/1210991">数学家<i class="fa fa-external-link"></i></span>。毕业于<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/lnKPlvbzlvpfloKHlm73nq4vlpKflraYvMjA2NDc2OA==" title="https://baike.baidu.com/item/圣彼得堡国立大学/2064768">圣彼得堡国立大学<i class="fa fa-external-link"></i></span>，一生发布了70余部学术著作，从分散分析、生物分类学到昆虫学等。</p><p>​    <strong>他在26岁时独创了一种“时间统计法”，通过记录每个事件的花销时间，通过统计和分析，进行月小结和年终总结，以此来改进工作方法、计划未来事务，从而提高对时间的利用效率。期间他不断完善这一统计方法，并一直沿用了56年直到逝世。</strong></p><p>​    – 摘自百度百科。</p><h2 id="这本书讲了什么？"><a href="#这本书讲了什么？" class="headerlink" title="这本书讲了什么？"></a>这本书讲了什么？</h2><p>​    时间是和生命同等重要的东西，而生命本质就是时间的积累和延长。但是认知和管理时间却恰恰是人所容易忽视的。</p><p>​    时间不属于任何人，同时时间是一种我们<strong>不得不花的消耗品</strong>。我们珍惜一分一秒，就是在珍惜我们的生命。</p><p>​    那么这本书到底讲了什么？这本书通过一整本书来介绍柳比歇夫，同时介绍这本书最核心的内容时间统计法也是对于时间管理思想启蒙，如果不知道如何规划自己，同时想要了解自己的时间是如何“浪费”的，可以借鉴书中的时间管理办法进行自我审视。</p><h2 id="时间统计法的具体内容？"><a href="#时间统计法的具体内容？" class="headerlink" title="时间统计法的具体内容？"></a>时间统计法的具体内容？</h2><p>​    看书吧，这本书不是说教，越看你越会发现柳比歇夫的个人魅力。</p><h3 id="柳比歇夫时间记录分析的4个步骤"><a href="#柳比歇夫时间记录分析的4个步骤" class="headerlink" title="柳比歇夫时间记录分析的4个步骤"></a>柳比歇夫时间记录分析的4个步骤</h3><p><strong>1.记录</strong>：忠实的记录自己的 <strong>完成目标相关的任务</strong>的时间开销，误差不超过15分钟。不记录吃喝拉撒的事情。了解自己的时间花在那些地方</p><p><strong>2.统计</strong>：每一个月对于自己这个月的时间开销进行归类统计，并且进行归档，严格的计算自己的时间开支s</p><p><strong>3.分析</strong>：分析那些方法是高效的，根据开销调整自己的工作方法，提高工作效率。</p><p><strong>4.反馈</strong>：反馈除了继续坚持，还意味着适当的放弃，同时，不要把所有的时间花在目标上面，<strong>人不是机器，需要适当休息，需要适当娱乐</strong>。</p><h3 id="柳比歇夫时间5个时间原则"><a href="#柳比歇夫时间5个时间原则" class="headerlink" title="柳比歇夫时间5个时间原则"></a>柳比歇夫时间5个时间原则</h3><ol><li><strong>不承担必须完成的任务</strong>：永远不接受自己无法完成的任务，只承担自己力所能及的事情</li><li><strong>不接受紧急任务</strong>：永远不接受紧急的任务，但是紧急的书信会第一时间回复。平常时间按照自己定时的三大类按部就班的完成</li><li><strong>充足的休息时间</strong>：每天睡够10个小时，柳比歇夫虽然看上去一分一刻都不浪费，但是他的睡眠时间甚至比现代绝大多数人的睡眠时间都要长。跟很多动辄每天4个小时睡眠时间的“超人”和“怪物”，柳比歇夫很注重充足的休息时间。</li><li><strong>一累了就马上休息</strong>：类似番茄工作法，劳逸结合的工作方式比长时间高强度的工作效率高很多。但是想要控制却非常难。</li><li><strong>把累人的工作同愉快的工作结合在一起</strong>：把时间分类之后，按照时间的重要程度和先后依次完成，保持乐观健康的心态进行工作。</li></ol><h2 id="柳比歇夫是普通人么？"><a href="#柳比歇夫是普通人么？" class="headerlink" title="柳比歇夫是普通人么？"></a>柳比歇夫是普通人么？</h2><p>​    先说结论：<strong>绝对不是普通人</strong>，在我看来如果人人可以做到像柳比歇夫这般，世界不但不会更精彩，只会显得无趣。但是柳比歇夫是普通人通过努力可以达到的。时间统计法适用于任何人，实际尝试就可以发现，这花不了多少时间，并且一天天的记录，通过积累可以清晰的认识到自己在干什么，因为 <strong>时间是不会骗人的</strong>。</p><p>​    </p><h2 id="为什么柳比歇夫可以如此自律？"><a href="#为什么柳比歇夫可以如此自律？" class="headerlink" title="为什么柳比歇夫可以如此自律？"></a>为什么柳比歇夫可以如此自律？</h2><p>​    <strong>他将自己的一生奉献给自己定下的目标。</strong>柳比歇夫是非常幸运的人，在年轻的时候找到了自己的使命，找到了自己真正目标和毕生的梦想，他也用行动来达成自己的目标，虽然从结果来说他可能<strong>依然还在成功的路上。</strong>但是他的成就绝对不比任何一个功成名就的人要差。</p><p>​    <strong>清楚自己浪费过时间，清楚浪费多少，怎么浪费，为什么浪费？</strong>人最容易看清的是别人，最难看清的是自己。但是柳比歇夫时刻知道自己离目标有多远，自己每一时每一刻的开销。</p><h2 id="如何像柳比歇夫一样精确感知时间？"><a href="#如何像柳比歇夫一样精确感知时间？" class="headerlink" title="如何像柳比歇夫一样精确感知时间？"></a>如何像柳比歇夫一样精确感知时间？</h2><p>​    老调重谈，还是需要<strong>坚持</strong>，只需要记住，任何具备真正价值的东西，通常都需要一个量变到质变的过程。</p><h2 id="什么是纯时间，什么是毛时间，为什么要计算纯时间？"><a href="#什么是纯时间，什么是毛时间，为什么要计算纯时间？" class="headerlink" title="什么是纯时间，什么是毛时间，为什么要计算纯时间？"></a>什么是纯时间，什么是毛时间，为什么要计算纯时间？</h2><p>​    纯时间：完成一个目标实际花费的时间，这是最能真实反映工作效率的时间。</p><p>​    毛时间：就是指从任务的开始到任务的结束总共花了多少时间，这个时间可以用来衡量。</p><p>​    多数人计算毛时间基本都可以进行大致估算，但是对于纯时间的把握是十分困难的，但是纯时间恰恰又是一个最能反映效率的时间，所以时间统计法的核心就是合理计划以及精准的估算自己花费的纯时间。尽量的减少毛时间的消耗，因为一件事情拖得越久越难完成。</p><p>​    </p><h2 id="时间统计法有什么作用？"><a href="#时间统计法有什么作用？" class="headerlink" title="时间统计法有什么作用？"></a>时间统计法有什么作用？</h2><ol><li><strong>抓住偷跑的时间</strong>。现代的科技发展让我们的生活越来越便利，大部分人基本不必担心温饱问题，不会居无定所，全球大多数人摆脱了生存的问题，到了未来甚至我们的一切衣食住行都可以由机器来帮助我们完成。但是我们却越发感到时间的不足。对于偷跑的时间，只要时刻牢记<strong>想要让你浪费时间的，多半要么是自己“想”浪费，要么是别人想从你身上赚钱</strong>，学习时间统计法就是想办法“留”更多的时间给自己成长。<ol start="2"><li><strong>有效并且高质量的利用时间。</strong>随便找一天记录一天的工作时间开销，都会发现自己其实一天真正有效的工作时间能有<strong>一半</strong>就算是非常不错了。而时间统计法可以帮助衡量时间的开销和调整计划。</li><li><strong>与时间做朋友，时间会给你回报</strong>。人人为我，我为人人，对待时间像对待自己最珍贵的朋友一样，时间迟早会给你该有的回报。</li><li><strong>学会感知时间。</strong>，用时间统计法就会发现，人类不仅工作低效，并且人对于时间这个看不见摸不着的东西 <strong>无法把握。</strong>就像我们在日常生活常觉得放假的时间太短，而上班的时间太过漫长。然而这两个时间对于一天来说都是一样的。所以用统计看看自己在那里浪费了时间，可以帮助自己更好的感知时间。</li></ol></li></ol><h2 id="紧张工作和享受生活有矛盾么？"><a href="#紧张工作和享受生活有矛盾么？" class="headerlink" title="紧张工作和享受生活有矛盾么？"></a>紧张工作和享受生活有矛盾么？</h2><p>​    从书中的内容来看，柳比歇夫拥有如此旺盛的意志力，一方面得益于有着伟大的梦想，另一方面是他非常懂得<strong>劳逸结合</strong>。他每天睡10个小时，累了就马上休息，从不拖泥带水。并且<strong>不接受任何必须完成的任务。不接受任何紧急任务。但是遇到紧急的事情会第一时间回复。</strong></p><p>​    这让我想起了<strong>《不努力也没关系》</strong>书中的一段内容：<strong>如果你想成为大师，努力训练5年就够了，但是如果每天拼命努力用所有时间来练习却要花费十年的时间</strong>。永远要相信人的意志力一种消耗品，科学也证明了人高强度工作<strong>90分钟</strong>之后效率会十分低下。所以紧张工作和生活完全可以分开，甚至可以在累了的时候马上休息，但是大多数时候我们会选择把所有的时间用来<strong>享受生活</strong>。</p><h2 id="如何更好的成长？"><a href="#如何更好的成长？" class="headerlink" title="如何更好的成长？"></a>如何更好的成长？</h2><p>​    <strong>立马行动，实践书中所有可以实践的内容。</strong>如果看完书丢到一边，那么这本书只是一个人物传记，对于读者个人的帮助微乎其微。</p><p>​    <strong>不要忘记自己的初衷</strong>。无论何时何地，遇到多少挫折，都不要忘记自己的初衷，个体的一切努力而是为了<strong>达成目标</strong>。</p><p>​    <strong>时间统计法最重要的是诚实</strong>。千万不要为了形式主义去做时间笔记，这样做没有任何帮助，也不要为了“凑数”让自己看上去很用功，努力了就是努力了，懈怠了就是懈怠了，人都会有想要放松的念头，但是如果借助时间统计法能更加精确的规划时间让自己成长，一时的浪费并不算什么大问题。</p><p>​    <strong>回想自己为目标付出了多少有效时间。</strong>学习就是一个输入和输出的过程，一直输入而不进行输出，那么知识是无法内化的，最好的状态是保持高效的同时平衡输入和输出。</p><p>​    <strong>制定大目标，小目标，年计划，月计划，周计划，时间耗费</strong>。如果你曾经依靠自律让自己获得一定的成就，相信可以理解柳比歇夫为什么要做到如此极端。根本原因是柳比歇夫的目标过于伟大，所以对于时间以及精力的管理有着异于常人的要求。<strong>其难度不亚于一个身体素质一般的普通人要去拿奥运冠军</strong>。</p><h2 id="其他建议"><a href="#其他建议" class="headerlink" title="其他建议:"></a>其他建议:</h2><p>​    个人买的奇特的一生实体书附带了一本小册子，主要讲一些读者的反馈以及自己如何实践时间统计法，下面记录一个方法摘要：</p><p>大道至简：</p><ul><li>你是看上去很努力而已</li><li>纯时间看到工作效率</li><li>柳比歇夫日程表</li><li>打造专属日程表</li></ul><p>他的要求：</p><ul><li>精确记录是第一原则</li><li>不要忘记初衷，不要忘记你的目的</li><li>适合自己的才是最好的。</li></ul><h1 id="阅读感受"><a href="#阅读感受" class="headerlink" title="阅读感受"></a>阅读感受</h1><p>​    看完整本书，我最大的感受一方面是惊叹时间统计法以及人的自律居然可以有如此强大的力量，另一方面从作者的笔墨中，也可以看到作者并不建议任何一个人效仿柳比歇夫，作者也直言不讳的表示自己也做不到柳比歇夫那样，甚至赞成一些对于柳比歇夫的极端工作的批判观点。同时可以看到，柳比歇夫并不是一个没有感情的机器人，柳比歇夫也拥有书信往来的朋友，也花时间陪家人，是一个十分具有个人魅力的人。</p><p>​    从柳比歇夫的另一个对于生活的态度，和很多的文豪作家不同富丽堂皇的家庭环境，柳比歇夫对于生活的要求标准极低，只要一个书桌，一盏灯，一把椅子，和一个安静的环境，柳比歇夫就满足了。这种务实和朴实的精神在奢靡风气横行的时代显得非常格格不入。如果用《小狗钱钱》当中的来比喻，<strong>柳比歇夫是拥有很大的圆孔，但是甜甜圈本身却很小的人</strong>。人人都有虚荣心，但是柳比歇夫的“虚荣”更像是用行动来证明自己，如果不是他自己公布自己的时间管理方法和自己成就，可能多数人认为柳比歇夫就是一个稍微有点成就的生物学家。这样的柳比歇夫，给我的感觉像是小隐隐于林，大隐隐于世的奇妙感觉。</p><p>​    柳比歇夫不但对于梦想有着极强的执念和行动力，并且拥有者独特的个人魅力。不了解这个人，可能看上去和普通人无异。但是作者越是解读柳比歇夫这个人，这个人给人的印象就越发的深刻。</p><h1 id="内容概要"><a href="#内容概要" class="headerlink" title="内容概要"></a>内容概要</h1><p>​    这本书实际去看会比看我这篇笔记有价值和有意义的多，同时内容是人物自传类型的读物，不适合作为内容概要，所以这部分内容根据个人看到的内容进行小结。这个小节的内容都是随便写写，比较自由，可以不看，不过我想没有多少人看到这里所以也就胡说八道了。</p><h2 id="柳比歇夫的读书观"><a href="#柳比歇夫的读书观" class="headerlink" title="柳比歇夫的读书观"></a>柳比歇夫的读书观</h2><p>​    “我在抄抄写写中不断积累，为我日后的发表留下材料。浮皮潦草，蜻蜓点水式的看书，是看不到深度内容的”。柳比歇夫非常擅长总结看到的内容，我想柳比歇夫是通过大量的可以练习的结果。是设定目标不断的抄写，造就了现在的柳比歇夫。</p><h2 id="碎片时间"><a href="#碎片时间" class="headerlink" title="碎片时间"></a>碎片时间</h2><p>​    碎片时间在书中被称为“时间脚下料”，个人在通勤过程中看完了很多小说，漫画，文学作品等等（也做了不少读书笔记），非常赞成好好利用“脚步上的时间”。</p><p>​    个人认知的碎片时间如下：</p><ul><li>通勤时间，上下班</li><li>旅游，出差的火车，高铁上</li><li>到店就餐或者等外卖</li><li>刷牙，洗漱</li><li>其他一切消耗时间没有价值但是必须做到事情</li></ul><p>当然，不建议吃饭的时候看书，不利于消化。</p><h2 id="人生目标的重要性"><a href="#人生目标的重要性" class="headerlink" title="人生目标的重要性"></a>人生目标的重要性</h2><p>​    26岁柳比歇夫定下了一生追求的梦想，时间统计法和他一生数不清的著作就是最有力的证据。所以任何时候定下目标都不晚，结果并不重要，重要的是享受追逐梦想的过程。</p><h2 id="把时间分类："><a href="#把时间分类：" class="headerlink" title="把时间分类："></a>把时间分类：</h2><p>​    柳比歇夫把时间分为三类：</p><pre><code>+ 工作，需要非常大精力的事情放在最重要的一类+ 把阅读和写作等并不是十分重要的事情规划为第二类+ 日常休息，娱乐等日常必需消耗的时间，则划分为第三类（也包含陪同家人的时间）。</code></pre><p>这种分类既不会让自己看上去充实，又具备明确的指向性和目的性，同时可以帮助个人培养时间观念，什么时间做什么，按部就班。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>​    你可以浪费时间，但是不能浪费人生。时间统计法是一种人人都可以做到非常简单的一种方法。目前个人结合自己的习惯定制了一套时间统计法进行实践。时间统计法在任何时候学习都不晚，只要立马行动真实的记录，对于时间的感知就会越来越强，对于目标的管理和自我管理也会越来越强。</p><p>​    另外，最近打算写个人的<strong>读书方法论（二）</strong>了，但是回顾一下发现好像该讲的都讲的差不多了（尴尬）。希望可以<strong>借用</strong>读者一些时间评论留下建议。</p><h1 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h1><p>有兴趣可以看看知乎的回答，写的比我这篇比较要简洁很多也概括的比较好。个人还需要多多练习写作技巧。（要看清自己真的是一件非常难得事情）</p><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMTUzODAyMTM=" title="https://zhuanlan.zhihu.com/p/115380213">知乎文章1<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzI4NjMwMzQz" title="https://www.zhihu.com/question/28630343">知乎文章2<i class="fa fa-external-link"></i></span></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      《奇特的一生》读书笔记
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://whitestore.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="时间管理" scheme="https://whitestore.top/tags/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>浅谈设计模式 - 迭代器模式（十一）</title>
    <link href="https://whitestore.top/2021/05/20/diedaiqi/"/>
    <id>https://whitestore.top/2021/05/20/diedaiqi/</id>
    <published>2021-05-20T14:45:06.000Z</published>
    <updated>2021-05-20T14:46:36.741Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浅谈设计模式-迭代器模式（十一）"><a href="#浅谈设计模式-迭代器模式（十一）" class="headerlink" title="浅谈设计模式 - 迭代器模式（十一）"></a>浅谈设计模式 - 迭代器模式（十一）</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>迭代器模式通常只需要知道该模式的实现原理和了解结构图即可，在设计模式当中自己实现的情况几乎是没有的，所以这个模式简单的过一遍。</p><a id="more"></a><h1 id="什么是迭代器模式"><a href="#什么是迭代器模式" class="headerlink" title="什么是迭代器模式"></a>什么是迭代器模式</h1><p>定义：<strong>提供顺序的方法访问一个聚合对象的各个元素，同时又不会暴露内部的功能</strong></p><p>迭代器模式通过接管遍历的细节，让提供方不必关心迭代的具体细节，只需要提供对应的聚合对象即可。</p><blockquote><p> 迭代器模式和增强的FOR循环:</p><p> Jdk1.5之后，将泛型和增强for循环加入到语言体系，可以直接对于集合的内容进行for循环查看，其实本质上还是调用了iterator方法，而java通过语法糖的形式为我们进行的遍历的隐藏。</p></blockquote><h1 id="迭代器模式结构图"><a href="#迭代器模式结构图" class="headerlink" title="迭代器模式结构图"></a>迭代器模式结构图</h1><pre><code>迭代器模式的结构图如下：![](https://gitee.com/lazyTimes/imageReposity/raw/master/img/20210310215705.png)</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Aggregate：聚合对象的共同接口，定义了具备遍历功能的聚合对象，通过定义创建迭代器的接口来建立与迭代器的组合</span><br><span class="line">ConcreateAggregate：具体的迭代器实现对象，通过接口方法返回具体的迭代器实现</span><br><span class="line">Iterator：迭代器接口，定义迭代器的统一规范，所以派生类都需要强制按照接口标准执行迭代器的实现。保证迭代器具备相似的行为。</span><br><span class="line">ConcreteIterator：具体的迭代器实现，内部聚合对象的同时，可以扩展迭代器的遍历方式，比如ListIterator。</span><br></pre></td></tr></table></figure><h1 id="迭代器模式特点"><a href="#迭代器模式特点" class="headerlink" title="迭代器模式特点"></a>迭代器模式特点</h1><ul><li>迭代器将遍历的细节进行了封装，<strong>聚合对象不需要在关心客户端如何操作内部的变量</strong>，而是通过委托给迭代器的形式交由迭代器去完成具体的遍历细节。</li><li>迭代器可以在<strong>不暴露内部结构的同时让外界可以访问到内部的聚合对象</strong>，所以即使是完全不同的对象也可以统一对待和处理。</li><li>迭代器是一种职责的转移，将遍历的工作从原本的聚合对象中进行独立，能在<strong>不改动数据结构的同时改变数据的操作方式</strong>。</li></ul><h1 id="迭代器的注意事项："><a href="#迭代器的注意事项：" class="headerlink" title="迭代器的注意事项："></a>迭代器的注意事项：</h1><ol><li>需要注意迭代器存在<strong>内部的迭代器</strong>和<strong>外部的迭代器</strong>，内部的迭代器供对象本身使用不对外开放，外部的迭代器通过方法返回给调用方使用。</li><li>每个责任对应一个区域，超过区域意味多了一个责任，遍历和数据操作实际上是两个操作，应该区分对待。</li><li>注意迭代器是如何体现单一职责的原则，他剥离了遍历对象的功能，将其封装到一个迭代器内部进行使用。</li><li>好的迭代器应当具备“快速失败机制”，目的是为了防止操作内部元素的指针越界，同时及时通知客户端遍历异常。</li><li><strong>如果想让方法不支持某些功能，最好使用异常机制提醒客户端我不支持某些操作。</strong></li></ol><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><pre><code>光有理论还是不够的，这里配合代码讲解迭代器是如何实现解耦聚合对象的遍历的。</code></pre><h2 id="模拟场景："><a href="#模拟场景：" class="headerlink" title="模拟场景："></a>模拟场景：</h2><pre><code>由于迭代器在实际工作中使用概率 **几乎为0**，这里设置的场景比较简单我们使用window最常见的文件系统来作为案例，我们通常进入不同的磁盘，首先就是对该磁盘下面的第一级目录进行遍历，同时我们根据遍历方式的不同，可以将页面展示为分组，按照时间排序，显示不同的详略信息.....这些功能的本质都是遍历，只不过遍历的形式不同，为了实现对于菜单的不同形式遍历，我们通过定义不同迭代器来完成这一个目标。接着，我们会发现迭代的种类丰富还不够，我们还需要迭代其他的内容，比如任务管理器需要迭代不同的进程，同样也包含了排序的或者隐藏部分进程等等一系列的功能，所以需要让不同的对象可以支撑相似的迭代操作，并且可以自由的替换迭代的方式，当然这部分功能不会放入案例部分，案例部分为简单的迭代器实现。</code></pre><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><pre><code>在进行具体的编码之前，先检查一下需要的基本构建类：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Travelsable：定义对象具备迭代的功能接口。</span><br><span class="line">MissionBoard：任务栏，贮存基本的任务信息，提供迭代器供外部展示。</span><br><span class="line">TaskItemlIterator：任务迭代器，用于任务的迭代操作</span><br><span class="line">ConcreteCatalogIterator：目录迭代器的实现具体子类，定义了不同的迭代种类。</span><br><span class="line">TaskItem 任务项，定义一个任务的内容</span><br><span class="line">Computer 电脑，只需要管理任务栏和文件管理器即可。</span><br><span class="line">FileManager 文件管理器，负责管理文件夹的内容</span><br><span class="line">FileIterator 文件迭代器，管理文件夹的迭代操作</span><br><span class="line">FileItem 文件项</span><br></pre></td></tr></table></figure><pre><code>下面直接按照结构图构建具体代码：</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 电脑，只需要管理任务栏和文件管理器即可。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> FileManager fileManager;</span><br><span class="line">    <span class="keyword">private</span> MissionBoard missionBoard;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">(FileManager fileManager, MissionBoard missionBoard)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fileManager = fileManager;</span><br><span class="line">        <span class="keyword">this</span>.missionBoard = missionBoard;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Iterator fileManagerIterator = fileManager.createIterator();</span><br><span class="line">        Iterator missionBoardIterator = missionBoard.createIterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fileManagerIterator.hasNext())&#123;</span><br><span class="line">            Object next = fileManagerIterator.next();</span><br><span class="line">            System.out.println(next);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (missionBoardIterator.hasNext())&#123;</span><br><span class="line">            Object next = missionBoardIterator.next();</span><br><span class="line">            System.out.println(next);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件项</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileItem</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String fileName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String editDate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String ceateDate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> size;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 省略部分内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务项</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskItem</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略部分内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器规范接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Travelsable</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Object</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建迭代器的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">createIterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务栏，管理任务项. 实现接口，支持迭代操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MissionBoard</span> <span class="keyword">implements</span> <span class="title">Travelsable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;TaskItem&gt; taskItems;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MissionBoard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        taskItems = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        taskItems.push(<span class="keyword">new</span> TaskItem(<span class="string">"任务1"</span>, <span class="number">10</span>));</span><br><span class="line">        taskItems.push(<span class="keyword">new</span> TaskItem(<span class="string">"任务2"</span>, <span class="number">1230</span>));</span><br><span class="line">        taskItems.push(<span class="keyword">new</span> TaskItem(<span class="string">"任务3"</span>, <span class="number">123</span>));</span><br><span class="line">        taskItems.push(<span class="keyword">new</span> TaskItem(<span class="string">"任务4"</span>, <span class="number">414</span>));</span><br><span class="line">        taskItems.push(<span class="keyword">new</span> TaskItem(<span class="string">"任务5"</span>, <span class="number">555</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">createIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TaskItemlIterator(taskItems);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件管理器，管理文件项，实现接口并且支持迭代操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileManager</span> <span class="keyword">implements</span> <span class="title">Travelsable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> FileItem[] fileItems;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fileItems = <span class="keyword">new</span> FileItem[<span class="number">10</span>];</span><br><span class="line">        Random random = <span class="keyword">new</span> Random(<span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fileItems.length; i++) &#123;</span><br><span class="line">            fileItems[i] = <span class="keyword">new</span> FileItem(<span class="string">"文件"</span>+i, random.nextInt(<span class="number">2000</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">createIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FileIterator(fileItems);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件迭代器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> FileItem[] fileItems;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileIterator</span><span class="params">(FileItem[] fileItems)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fileItems = fileItems;</span><br><span class="line">        <span class="keyword">this</span>.index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index++ &lt; fileItems.length - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fileItems[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object ele)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"数组不支持当前操作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务迭代器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskItemlIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;TaskItem&gt; taskItems;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TaskItemlIterator</span><span class="params">(Stack&lt;TaskItem&gt; taskItems)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.taskItems = taskItems;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(taskItems.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TaskItem peek = taskItems.peek();</span><br><span class="line">        <span class="keyword">return</span> peek != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> taskItems.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object ele)</span> </span>&#123;</span><br><span class="line">        taskItems.remove(ele);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是迭代的大致实现案例代码，现代编程基本不会自己去设计迭代器，所以了解概念和知道样板代码即可。</p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><pre><code>迭代器在JAVA语言中基本已经实现到集合当中，当我们遍历集合的时候，其实就是在使用迭代器，迭代器通过**封装遍历**解耦了一堆对象的遍历和创建工作，将迭代的细节封装到一个黑盒当中，外部只需要调用接口就可以操作集合的数据。</code></pre><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      迭代器模式
    
    </summary>
    
    
      <category term="设计模式" scheme="https://whitestore.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="迭代器" scheme="https://whitestore.top/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>《自控力》读书笔记</title>
    <link href="https://whitestore.top/2021/05/20/zikongli/"/>
    <id>https://whitestore.top/2021/05/20/zikongli/</id>
    <published>2021-05-20T14:43:13.000Z</published>
    <updated>2021-05-20T14:44:21.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《自控力》读书笔记"><a href="#《自控力》读书笔记" class="headerlink" title="《自控力》读书笔记"></a>《自控力》读书笔记</h1><p>[TOC]</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20210405152653.png" alt=""></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    这本书的封面比较有意思，一个大大的甜筒。还好这是书，如果是实物我肯定已经吃起来了。这本书大致就是告诉你如何让你在看到如同封面这般诱惑的情况下依然可以保持很好的自控力。</p><p>​    如果能把一遍文章仔细看完，静下心来认认真真的做做某件事，我相信都是对自控力的挑战，这本书如果看着费力或者想偷懒，个人建议阅读每一个章节最后的部分，然后根据总结选择自己感兴趣的内容即可。当然连打开书或者看书的兴趣都没有，那可以看看我的这篇笔记，希望可以让你了解到这本书讲了那些内容。</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>​    本书为读者提供了清晰的框架，讲述了<strong>什么是自控力</strong>，自控力如何发生作用，以及<strong>为何自控力如此重要</strong>。</p><p>​    – 以上引用自豆瓣的简介。</p><p>​    </p><h2 id="推荐指数："><a href="#推荐指数：" class="headerlink" title="推荐指数："></a>推荐指数：</h2><p>​    <strong>4星</strong>，个人评分，因为他确实让我更加了解到了自己对于意志力的错误认知，以及以前一些自控的方式更加科学的解释。更重要的是，了解意志力本身比去提高个人意志力更为重要。</p><p>​    这本书阅读更倾向于了解意志力和一些基础效应，避开陷阱，如果想要了解自控的方法，可以看看每一章节的“意志力实验”部分，依照案例对于方法进行解释。当然部分案例比较牵强，但是有意思的案例也不少，比如点击老鼠的实验，猩猩和人的自控力对比等等。</p><h2 id="推荐语"><a href="#推荐语" class="headerlink" title="推荐语"></a>推荐语</h2><p>​    了解自控力比自控更加重要，我们可能了解他人的想法，但是很难认识到自己，<strong>想从一本书学到一劳永逸的自控力提高方法是不可能的</strong>，人的自律完全依靠自身，但是认识自控力有多重要以及为什么自己会失控，这本书可以给你答案。</p><h1 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h1><h2 id="自控力为何如此重要？"><a href="#自控力为何如此重要？" class="headerlink" title="自控力为何如此重要？"></a>自控力为何如此重要？</h2><p>​    <strong>自律是一个人成功的开始</strong>，任何一个成功的人不管开端如何，多数都是对于个人意志力有着自己的管理方式。通常个人在意志力本身为何物都不知道情况下，都会选择拿自控和愧疚来对付自己，然而这却恰恰是很多人失控的根本愿意，用意志力来对付自己。</p><p>​    <strong>能够定制自己幸福的人往往过得更加幸福。</strong>定制目标往往和自控有关，当你不满足于现在自己的时候，通常需要通过学习来提高自身，而通过学习提高自身往往就是所谓的自控提升自己的一个过程。</p><p>​    <strong>我们的心中都有两个自我</strong>。自控力挑战往往是使用原始本能来对付心中的“两个自我”。一个自我告诉我们放松，冲动，及时满足自己。而另一个自我则告诉我们应该勤劳，努力，改变自己。这两个自我在大部分情况下都是“更坏”的自我占据主导，因为这包含了生物的本能反应。而自控就是让失控的自己能够在更短的时间内将自己的注意力拉回来的过程。</p><h2 id="为什么要看《自控力》这本书？"><a href="#为什么要看《自控力》这本书？" class="headerlink" title="为什么要看《自控力》这本书？"></a>为什么要看《自控力》这本书？</h2><pre><code>  1. 首先是我的自控力减弱了。当初在学校的时候，我只需要专心学习，所以能保持较强的学习动力和自控力，然而进入社会，各种杂七杂八的事情充斥我们的脑海，分散我们的注意。2. 自律是走上成功的第二步，定下目标是成功的第一步。我并不想把自己年初定的FLAG到了年底一个都没有完成。3. 认识到未来的自己需要“我”的帮助。过去的我因为努力自学让自己现在有了一份比较体面而稳定的工作，我希望现在的努力能给将来的自己留下更多财产。</code></pre><h2 id="我从《自控力》学到了什么？"><a href="#我从《自控力》学到了什么？" class="headerlink" title="我从《自控力》学到了什么？"></a>我从《自控力》学到了什么？</h2><ul><li>自控力就是驾驭“我不要”、“我想要”、“我要做”这三个事情</li><li>最让人遗憾的不是没有努力，也不是不想努力，而是重复想努力到不想努力这个过程。既浪费了时间，又没有任何意义。深陷“道德许可”的陷阱中给自己一个身份牌</li><li>焦虑，恐惧，自我批评，不仅不能让我们更加自控，反而更容易让我们冲动，失控，不想努力。面对自己的人生，不要把负面情绪加到自己身上</li><li>找到自己真正的目标，幻想自己的未来，想象的越来越真实，越能走向成功。</li><li>人的脑海中有两个自己，一个想要变好的自己和想要变坏的自己，我们要全力接受“好的自己”</li><li>微笑面对未来的自己，学会延迟满足为自己的未来投资。</li><li>学会“同情”自己，为自己的挫折毫不在意，只关注自己离目标还有多远。（可以参考《食戟之灵》）</li><li>成功可能带来退步，奖励效应让自己不断的重蹈覆辙</li><li>强烈的自控力可能会危害自己的身心。如果你无法合理驾驭自己的意志力，那就把<strong>最重要的事情</strong>放到最早的时候。</li></ul><h2 id="哪一个意志力实验对我最有帮助"><a href="#哪一个意志力实验对我最有帮助" class="headerlink" title="哪一个意志力实验对我最有帮助?"></a>哪一个意志力实验对我最有帮助?</h2><p>​    <strong>学会原谅自己，而不是自我厌恶和自我批评</strong>。在人的惯性思维当中，人们犯了错之后，一般都会情绪失落或者消沉，但是在这本书中却从反方向建议读者不要进行自我批评，因为自我批评容易让人更加堕落。所以学会原谅自己可能对我我这样带有一定自卑情结的人来说更有帮助。</p><h2 id="读到那一页最让我吃惊？"><a href="#读到那一页最让我吃惊？" class="headerlink" title="读到那一页最让我吃惊？"></a>读到那一页最让我吃惊？</h2><p>​    <strong>180页</strong>的内容讲了现在的自己和未来的自己。</p><p>在仔细思考之后，我对自己做了下面的这个选择，发现自己对于未来的自己不够重视。</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20210405161129.png" alt=""></p><h1 id="好句摘录"><a href="#好句摘录" class="headerlink" title="好句摘录"></a>好句摘录</h1><ol><li>省钱不是买到便宜的东西，而是在<strong>支付限额</strong>内买到便宜的东西。</li><li>想象一下过去的你为现在的你带来了什么，现在的你会为未来的你带来什么</li><li>我们经常会用“别人”的眼光评估自身，但是“我应该”的力量更能让自己坚持</li><li>梦想比任何网站都要值钱</li><li>导致堕落的并不是第一次放弃，而是第一次放弃之后的羞耻感，罪恶感和绝望感</li><li>比辱骂更为重要的是被人同情</li><li>想象冲动是海浪，虽然波涛汹涌，但是一定会遇到巨石</li><li>当你今天的决定会影响未来幸福的时候，也要想一想不这么做，以后一定会后悔。</li></ol><h1 id="内容分析"><a href="#内容分析" class="headerlink" title="内容分析"></a>内容分析</h1><h2 id="自控力的讨论"><a href="#自控力的讨论" class="headerlink" title="自控力的讨论"></a>自控力的讨论</h2><p>​    我们讨论的自控力其实就是人的意志力，人的意志力要比自己想象中的要弱的多的多，同时人是非常容易堕落和懒散的物种，稍加一不注意就会分心或者失去专注力。</p><h3 id="什么是自控力"><a href="#什么是自控力" class="headerlink" title="什么是自控力"></a>什么是自控力</h3><p>​    自控力简单理解就是驾驭<strong>我想要，我不要，我要做</strong>这三件事的能力。</p><h3 id="人为什么会失控"><a href="#人为什么会失控" class="headerlink" title="人为什么会失控"></a>人为什么会失控</h3><p>​    因为人做决定就像是自动档，不加任何约束人会变得堕落和懒散。</p><h3 id="失控的后果"><a href="#失控的后果" class="headerlink" title="失控的后果"></a>失控的后果</h3><p>​    自控力差的人很容易满足。失去欲望和奋斗的目标。</p><p>​    同时，自控力差的人通常易怒和暴躁。</p><h2 id="章节总结"><a href="#章节总结" class="headerlink" title="章节总结"></a>章节总结</h2><p>​    书中通过章节的形式，介绍了提高自控力或者如何更好管理自我的一些策略，部分策略甚至本身就存在一些冲突。下面是各个章节的个人小结（和书中的顺序不一致，同时存在合并）：</p><ul><li>第一章：我要做，我不要，我想要：什么是意志力？为什么意志力至关重要？<ul><li>自控力是把注意力不断发散和收回的过程<ul><li><strong>用冥想的方式锻炼意志力，让自己去做更加苦难的事情</strong></li><li>把注意力集中在，<strong>我不要，我想要，我要做</strong>。这三件事情上面</li><li>当你提高意志力的时候，能够学会利用自己的身体机能去调整状态</li><li>了解和认识两个自我<ul><li>意志力关键因素是正确的认识自己<ul><li>大部分人做决定就像是自动档，根本意识不到自己为什么会做决定<ul><li>如果你在自控的同时遇到其他事情，冲动会主导你的选择</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><ul><li><p>第二章：意志力存在能量</p><ul><li>利用各种运动来提高意志力</li><li>对比剑齿虎，我们更需小心奶油蛋糕的危险</li><li>自控力要合理以及适度，不要一味的压迫自己</li><li>提升意志力往往是从 <strong>我要做</strong>到 <strong>我不要</strong>。不建议直接思考“我想要”</li></ul></li><li><p>第三章：介绍意志力是存在极限的。面对意志力这种能量我们要如何合理安排</p><ul><li>自控力如同肌肉一般是存在极限的</li><li>意志力的强弱通常是从最早到最晚不断降低</li><li>意志力会消耗大量的糖，而我们可以使用低糖代替高糖</li></ul></li><li><p>第四章：为什么善行之后会有恶行，为什么我们总是在重蹈覆辙</p><ul><li>只要我们脑海中存在坏事与好事，我们行为总允许我们做一点坏事<ul><li>渴望补偿常常会使人堕落</li><li>任何可以让美德感到满足的东西，都会允许你冲动行事</li></ul></li><li>成功的陷阱<ul><li>进步有可能让人放弃为之奋斗的东西</li><li>多数情况下，我们总在寻找停下来的理由</li></ul></li><li>向明天赊账<ul><li>人们总是期望明天选择和今天不一样，然而想法本身就是错的</li><li>扪心自问，“今天赊账，明天改变”是否又开始了</li></ul></li></ul></li><li><p>第五章：来自名为多巴胺的诱惑</p><ul><li>多巴胺是大脑中含量最丰富的儿茶酚胺类神经递质<ul><li><strong>多巴胺并不会控制我们的行为，真正让我们失控的是寻求奖赏效应的大脑皮质</strong></li></ul></li><li>如何将欲望变为动力，同时不要把甜蜜陷阱当幸福</li><li>渴望让你感到快乐，同时让你感到压力<ul><li>购物的欲望与花钱的焦虑</li></ul></li><li>想要让你分泌更多多巴胺的人多半是商人<ul><li>买一送一</li><li>满减</li><li>打折</li><li>赠品</li></ul></li><li>多巴胺是虚假的幸福，但是把多巴胺用于让自己身心保持健康是非常有效的自控力武器<ul><li>跑步锻炼，强身健体</li><li>用于达成目标，“欺骗”自己</li></ul></li></ul></li><li><p>第六章：决心改善心情，改变自己而不是改变决心</p><ul><li>虚假希望综合征：当人们决心改变自己的心情实际却又无法满足自己决定的时候，人们往往会失落<ul><li>很多人乐于一次次放弃之后重新开始，而不是找到改变的真实想法</li><li>避免用改变承诺而不是改变来改善心情，回忆自己是否为压杠杆渴望点击的白鼠</li></ul></li><li>失败和堕落让人屈从诱惑，决心改变让自己更加强大<ul><li>做一个<strong>乐观的悲观主义者</strong></li><li>缓解压力最好的方式是<strong>自我同情</strong>而不是自我批评</li></ul></li></ul></li><li><p>第七章：意志力感染和未来的自己，意志力存在互相传染，未来和现在同样重要</p><ul><li>什么是意志力感染：<strong>近朱者赤，近墨者黑</strong></li><li>冷静的大脑需要在诱惑面前存在<strong>等待时间</strong></li><li>有形的奖励和无形的奖励巨大差距，根本在于一个会刺激多巴胺，而另一个会产生“延迟满足”</li><li>让未来更重要我们才能抵消“及时享乐”的行为</li><li>记住目标，时刻记住自己的承诺。</li></ul></li><li><p>第八章：”我不要”的局限性讽刺性反弹，为什么人们越是压抑想法越是失控</p><ul><li>为什么压抑想法如此艰难：操作与监控两者相辅相成<ul><li>我们精神全力操作大脑，而监控失灵</li></ul></li><li>人们越是摆脱某种意识，越是容易跑进脑海</li><li>如何规避讽刺性反弹<ul><li>学会把“我不要”变为“我想要”</li><li>接受不是放纵，抑制或者压抑，需要从根本上转变为对目标的执行。</li><li>接受自己的弱点和缺点，接受诱惑但是永远<strong>不行动</strong></li><li>想象冲动是海浪，虽然波涛汹涌，但是一定会遇到巨石</li></ul></li></ul></li></ul><p>以上是个人的总结部分，更多章节的总结可以上网查阅资料</p><h2 id="自控力实验"><a href="#自控力实验" class="headerlink" title="自控力实验"></a>自控力实验</h2><p>​    这本书的自控力实验比较多，个人挑选了以下一些印象比较深刻的实验：</p><ul><li>花一周的时间想想自己的目标，想象自己未来的生活</li><li>每天花5分钟锻炼，只需要5分钟即可，可以使走路，散步，慢跑</li><li>每天利用5分钟的时间完成冥想（除了互相不要有任何其他杂念）</li><li>找出自己自控力最薄弱的点，自己在什么情况下会失控，为什么会失控。这让你离你的目标更远还是更近？</li><li>尝试把最想要完成的事情放在早上，越早越好</li><li>良好的睡眠是意志力的有效储备</li></ul><blockquote><p>完成自控力的实验最大的阻碍是奖赏效应。</p></blockquote><h2 id="书中的几大效应"><a href="#书中的几大效应" class="headerlink" title="书中的几大效应"></a>书中的几大效应</h2><p>​    书中的对于人的行为提出了一些科学合理的解释，介绍一些人类本能所产生的一些效应。</p><h3 id="“那又如何”效应"><a href="#“那又如何”效应" class="headerlink" title="“那又如何”效应"></a>“那又如何”效应</h3><p>​    那又如何效应其实就是我们常说的一件事情做了第一次之后，就会有第二次和无数次。</p><h3 id="“道德许可”效应"><a href="#“道德许可”效应" class="headerlink" title="“道德许可”效应"></a>“道德许可”效应</h3><p>​    当自己对某事有一个明确的道德标准之后，在做出与这项道德标准相关的行为和判断时，反而更倾向于违背这项道德标准的行为。</p><h3 id="虚假希望综合征"><a href="#虚假希望综合征" class="headerlink" title="虚假希望综合征"></a>虚假希望综合征</h3><p>​    指定下目标之后却无法完成或当无法满足之后，过一段时间又产生希望，如此往复。</p><h3 id="奖赏效应"><a href="#奖赏效应" class="headerlink" title="奖赏效应"></a>奖赏效应</h3><p>​    奖赏效应是一种正性强化效应，与中脑边缘多巴胺系统密切相关。</p><p>​    当人们成功或者失落的时候，会寻找外在的事物逃避 <strong>失落的感觉</strong>。这时候人会以为奖励而失控。<strong>借酒消愁</strong>就是最简单的解释</p><h3 id="讽刺性反弹"><a href="#讽刺性反弹" class="headerlink" title="讽刺性反弹"></a>讽刺性反弹</h3><p>​    当人们试着不去想某件事时，反而会比没有控制自己的思维时想得更多,比自己有意去想的时候还要多。</p><h1 id="结语："><a href="#结语：" class="headerlink" title="结语："></a>结语：</h1><p>​    这本书看完不止从自控力方面我还从自己的过去中反思了自己，之前看评论以及 <strong>人生七年</strong> 很多人都认为阶级固化以及人的出身环境已经决定了他的一生，<strong>我不认为这是错的</strong>，这是约定俗成的规则，所以我们能做的就是不断朝着自己的目标前进。</p><p>​    自控力归根结底就是 <strong>想要过什么样的生活，想要过什么样的人生。</strong>。</p><p>​    最后，如果想对自控力进行补充，可以看看《意志力》这本书作为补充。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      关于自控力这本书的读书笔记
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://whitestore.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="自控力" scheme="https://whitestore.top/tags/%E8%87%AA%E6%8E%A7%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>postgresql 关于日期比较的一个小坑</title>
    <link href="https://whitestore.top/2021/05/20/postgresql-date/"/>
    <id>https://whitestore.top/2021/05/20/postgresql-date/</id>
    <published>2021-05-20T14:41:32.000Z</published>
    <updated>2021-05-20T14:42:39.878Z</updated>
    
    <content type="html"><![CDATA[<h1 id="postgresql-关于日期比较的一个小坑"><a href="#postgresql-关于日期比较的一个小坑" class="headerlink" title="postgresql 关于日期比较的一个小坑"></a>postgresql 关于日期比较的一个小坑</h1><p>关于日期方面的比较方面，由于多年JAVA写法的固定观念，导致卡了一点时间排查这个问题。</p><p>按照正常的逻辑，一般情况下我们都会想到 <code>yyyy-MM-dd HH:mm:ss</code>，这样写通常没有什么问题，但是在postgre当中是存在问题的。因为 <code>HH</code>默认是<strong>12小时制</strong>！！！这个坑会导致查找数据出现下面莫名其妙的问题：</p><p>首先按照下面的sql进行查询：</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20210331183239.png" alt=""></p><p>得到查询结果如下：</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20210331190301.png" alt=""></p><p>这个结果是出乎预料的，因为正常来说应该查出来是0点的数据：</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20210331190422.png" alt=""></p><p>将上面的<code>00:59:59</code> 时间点改为<code>01:59:59</code>，结果查出来是第一条居然是13点的数据：</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20210331190640.png" alt=""></p><p>于是我停了下来，我套入各种数据不断尝试，猜想这个1点和13点都代表1点，或许使用了12小时制，果不其然，正确的写法应该如下：</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20210331190839.png" alt=""></p><p>这一下结果就正确了</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20210331190856.png" alt=""></p><p>总结：</p><pre><code>这周问题是习惯性思维的问题，但是个人想要吐槽一下这个设计有点点坑人=-=</code></pre><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      关于日期格式化的一个坑
    
    </summary>
    
    
      <category term="数据库" scheme="https://whitestore.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="postgresql" scheme="https://whitestore.top/tags/postgresql/"/>
    
  </entry>
  
  <entry>
    <title>《小王子》读书笔记</title>
    <link href="https://whitestore.top/2021/03/28/xiaowangzi/"/>
    <id>https://whitestore.top/2021/03/28/xiaowangzi/</id>
    <published>2021-03-28T07:07:06.000Z</published>
    <updated>2021-03-28T07:08:59.540Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《小王子》读书笔记"><a href="#《小王子》读书笔记" class="headerlink" title="《小王子》读书笔记"></a>《小王子》读书笔记</h1><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20210328131426.png" alt=""></p><p>[TOC]</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    《小王子》这本书应该有不少人看过了，以前一直听说过他的名号，然而到了现在才来看，这本书也会我少有的看了两遍的的的书，每看一遍心理的感受都不相同。《小王子》个人阅读的版本是李继宏翻译的版本，个人认为翻译的非常棒，下面就来展开说一下这次读小王子这本书的感受。</p><a id="more"></a><h1 id="在读书之前"><a href="#在读书之前" class="headerlink" title="在读书之前"></a>在读书之前</h1><p>​    这本虽然只有短短100多页，去掉配图和前面的序并没有多少内容，在阅读正文之前，前面关于序的部分是值得仔细推敲的，了解作者的生平对于看懂这部作品比较有帮助，同时作者的经历也比较传奇，在他的作品走向巅峰的时候却突然离奇失踪，虽然已经被证实是被二战德国纳粹士兵击落，但是依然不减传奇的色彩。这个作者并不像很多伟人一般有很多名人事迹，而是通过自己当飞行员的经历和过往生活，写下来自己的作品，可能是许多名人里面经历最为“普通”的一个。</p><p>​    所以在读这本书之前，建议先了解一下作者的经历。</p><h1 id="推荐程度"><a href="#推荐程度" class="headerlink" title="推荐程度"></a>推荐程度</h1><p>​    <strong>5星</strong>：这本书是完全可以和《老人与海》媲美的一本书，将丰富的哲学和人生道理蕴含在小小的童话之中，不同的年龄段有不同的感触，每读一遍，都会有不同的想法。</p><p>​    这本书最关键的部分无非关乎狐狸和玫瑰，但是我更关注泉水和奇怪的人。</p><p>​    </p><h1 id="内容摘要"><a href="#内容摘要" class="headerlink" title="内容摘要"></a>内容摘要</h1><p>​    这本书让我印象深刻的部分有下面几个点：</p><pre><code>+ 我与小王子的相遇+ 玫瑰与庭院+ 小王子和奇怪的人+ 小王子和狐狸+ 沙漠中的泉水</code></pre><p>从整体上来看是一个非常质朴的故事，但是书中的每一段对话，每一幅画都有他深刻的含义。每看一遍都回味无穷。</p><h2 id="我与小王子的相遇"><a href="#我与小王子的相遇" class="headerlink" title="我与小王子的相遇"></a>我与小王子的相遇</h2><p>​    “我”在一次飞行任务当中出现飞行事故，迫降在非洲的沙哈拉沙漠，在沙漠当中遇到了小王子。小王子要求“我”画一只绵羊给他，我献给了“帽子”，然而却惊奇王子说不要“蛇吞象”。“我”很高兴有人可以看懂“我”的画。而我与小王子的见面引出了整个童话故事的前奏。</p><p>​    我与小王子相遇能互相理解，个人认为是作者“超我”的一种论述，用自己和自己对话的方式，用故事来讲述自己的“过去”。这种不着痕迹的隐喻是非常厉害的写作方式。</p><h2 id="玫瑰与庭院"><a href="#玫瑰与庭院" class="headerlink" title="玫瑰与庭院"></a>玫瑰与庭院</h2><p>​    在小王子懵懂无知的时候，遇到了玫瑰，玫瑰虽然美丽但是是带刺的，而玫瑰欺骗小王子说自己是世界上独一无二的花朵，虽然玫瑰欺骗了王子，但是玫瑰本意却是善良温柔的。就像小王子所说的：他为我散发芬芳，我却不懂背后的事情，在小王子不懂得爱的时候，他遇到了玫瑰，但是他和玫瑰之间是不合的，因为青涩与懵懂，小王子和玫瑰之前并不是互相理解。但是小王子和玫瑰</p><p>​    每个人在青春懵懂的时候，或明恋或暗恋都应该遇到自己的玫瑰，虽然都知道玫瑰非常美好，但是都很害怕被玫瑰的刺伤到。而玫瑰虽然和花园里万千的玫瑰并没有什么不同，但是因为为他浇过水，施过肥，除过虫，所以这朵玫瑰对于你来说就是独一无二的存在。但是当互相无法理解的感情硬扭在一起的时候，结果好像注定是分离，这样的事情在学生时代几乎是见怪不怪了。</p><p>​    但是，多少人遇到了对的玫瑰呢？</p><h2 id="小王子和奇怪的人"><a href="#小王子和奇怪的人" class="headerlink" title="小王子和奇怪的人"></a>小王子和奇怪的人</h2><p>​    小王子离开自己的星球，前往了6个星球并且拜访了下面的人：国王、虚荣的人、爱喝酒的人、做生意的人、地理学家和点灯的人。在所有人中小王子认为点灯的人是最不奇怪的，因为点灯的人照亮的是他人，也是默默奉献的人，而其他的人代表了拥有权利，荣耀，富贵，名声等形形色色的人。</p><p>​    小王子觉得星球上的人都很奇怪，并且感到无法理解。对于这一段的理解，作者批判了世俗的欲望，并且通过小王子指出这都是空虚的东西，同时也是`不重要的。但是点灯的人却不同，点灯的人默默奉献自己，是受到了作者正面肯定的。</p><p>​    </p><h2 id="小王子和狐狸"><a href="#小王子和狐狸" class="headerlink" title="小王子和狐狸"></a>小王子和狐狸</h2><p>​    小王子在看到遍地玫瑰的时候，认为自己的玫瑰欺骗了他，就在小王子迷茫无知的时候，他遇到了狐狸，狐狸希望小王子驯化他，并且作为交换分享自己的秘密，他告诉了小王子什么是爱，爱是责任和包容，爱是承担，既然选择爱上一朵玫瑰，就要为玫瑰一直负责。</p><p>​    “狐狸”曾经也是“玫瑰”，然而狐狸受过伤，害怕人类，狐狸需要隐藏和伪装自己，他是孤独和寂寞的，狐狸不被任何人需要，所以他想要朋友，想要人类驯化他，当有人驯化他，对于狐狸和驯化他的人来说，彼此都是需要的。</p><p>​    小王子和狐狸是许多人印象深刻的点。但是虽然我遇到过玫瑰，但是没有见到过狐狸，这里就不做论述的了。。。。</p><h2 id="沙漠中的泉水"><a href="#沙漠中的泉水" class="headerlink" title="沙漠中的泉水"></a>沙漠中的泉水</h2><p>​    在小王子给“我”讲述完他的故事之后，小王子打算离开回到自己的星球，在此之前，他们发现了沙漠的水井。他们一直在寻找的东西就在一汪清泉当中。他们需要的只不过是水而已。他们晚上一起看星星，并且企图找到自己的花朵所在的星星。</p><p>​    这一段富含哲理，沙漠中的泉水大致是指人类美好的心灵和纯真，然而沙漠当中要找到泉水是非常困难的，所以小王子和“我”都为找到泉水而十分的兴奋而高兴。</p><h1 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h1><p>​    可能我是单身狗并且是非常非常感性的人，我并没有非常看懂《小王子》，同时也对狐狸和玫瑰没有非常深的感触，所以我<strong>并没有读懂这本书</strong>。不知道这是一件好事还是坏事。在我看来，在高等教育不断普及并且个体的发展不断突出的现代，很难在找到纯粹的感情，当年龄不断增长，爱情也不断的变得物质，爱情的代价也不断的变大，很多人寻找“玫瑰”最后找到的却是“狐狸”。</p><p>​    对于作者来说，当飞行员飞上蓝天就是作者毕生的梦，所以他的经历也如同富有了传奇的色彩。无论如何，当你对某个东西付诸了心血，你既要对自己付诸心血的东西负责，时至今日，对于我们来说看不见的东西有回忆，有知识，有经历和成长。随着年龄的增长，每个人生命的厚度不断增长，每个人都在追寻生命的意义。</p><p>​    另外，书中通过沙漠的背景，以及奇怪的人，泉水等，讽刺了人类自以为很强大，但是在高空翱翔的视角来看，又是那样的渺小和脆弱，</p><p>​    <strong>看东西要用心才能看清楚，重要的东西是眼睛看不见的</strong>。爱是责任和担当，爱是成熟和稳重。</p><p>​    最后，这本书这也让我想起了小狗钱钱的甜甜圈。外在的圆圈是看的见得，每个人都应该充实外在的圆圈，但是真正重要的东西是内在的圆环，这决定了你能走多远。最重要的东西往往是看不见的。所以很多人只相信眼睛看见的东西。当然在拥有看不见的重要东西之前，我们依然需要追寻物质生活。这大概是成长的悲哀，也是人生世俗的规则。</p><p>​    </p><h1 id="精句摘录"><a href="#精句摘录" class="headerlink" title="精句摘录"></a>精句摘录</h1><pre><code>+ 看东西要用心才能看清楚，重要的东西是眼睛看不见的+ 人类自以为占据了很多空间，认为自己像猴面包树一般重要。+ 他们要寻找的东西或许就在一汪清泉当中。+ 当你爱上一朵在某颗星球上的花，当你抬头仰望星空的时候，你会很甜蜜，仿佛所有的星星都开满了鲜花。+ 如果美国是中午，那么法国就是黄昏，若果能在一分钟内达到法国，那么就可以看到日落+ 在看到第四十四次日落的时候，你是否会感到悲伤。+ **对我来说，你无非是个孩子，和其他成千上万的孩子没有区别，我不需要你，你不需要我，对你来说，我无法是只狐狸，但如果你驯化我，我们就会彼此需要。你对我来说是独一无二的，我对你来说也是独一无二的**</code></pre><h1 id="豆瓣精选书评"><a href="#豆瓣精选书评" class="headerlink" title="豆瓣精选书评"></a>豆瓣精选书评</h1><p>这里截取了一条个人十分有感触的豆瓣书评。</p><blockquote><p>小的时候有一阵心血来潮很爱读名著，于是买了这本。中英文对照版，有漂亮的插画，优雅的排版，可惜懵懵懂懂的看了一遍，并没有看懂，有点索然无味。<br>很多年后突然翻出这本书，突然发现自己能了解作者在说什么了。关于那座玫瑰花砌成的房子和那条吞了大象的蛇。还有小王子旅行的星球和那只狐狸。关于驯养和被驯养。一瞬间我看得泪流满面。<br>原来好像书的扉页所写的那样，献给曾经是孩子的大人。所有的大人都曾经是孩子，只是很少有人记得罢了。<br>可惜我也变成了那些大人中的一个。看着看着觉得自己是那样的可悲。<br>当你能读懂这样一本书的时候，你已经不再是个孩子了。现实的世界将你打磨的那么好，不管你心里究竟愿不愿意——<strong>你无可奈何的，毫无选择的被长大了。</strong><br>如今这本书是我心中的经典，没有别的可以取代。关于人生的一切哲理，你都可以在这本书里找到答案。但是我劝你不要去用它，只会让你在这个分外现实的世界里显得愈发格格不入。<br>大人还是要有大人的游戏规则。那些固执的游戏，早已过了可以任性的年纪。<br>想起李宗盛的歌：<strong>想得却不可得，你耐人生何。岁月你别催，该来的我不推。该还的还，该给的我给。</strong><br>我们就这样，一路跌跌撞撞，向前走着。<br>但愿我的孩子将来读这本书时，能像当时的我那样觉得—-这本书简直是莫名其妙</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​    童话就让他成为童话吧。或许得不到的才是最好的，想象永远要多于实际体验，我们不断的成长，终究看不到“蛇吞象”，终究只能看到一顶帽子。</p><p>​    重要的东西是眼睛看不见的。希望若干年后我再次捧起书能让我看懂。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      小王子的读书笔记
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://whitestore.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书" scheme="https://whitestore.top/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>《乌合之众》读书笔记</title>
    <link href="https://whitestore.top/2021/03/28/wuhezhizong/"/>
    <id>https://whitestore.top/2021/03/28/wuhezhizong/</id>
    <published>2021-03-28T07:05:52.000Z</published>
    <updated>2021-03-28T07:06:47.347Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《乌合之众》读书笔记"><a href="#《乌合之众》读书笔记" class="headerlink" title="《乌合之众》读书笔记"></a>《乌合之众》读书笔记</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    这本书是为了试验多多平台的书籍质量买的，也就5块钱，书本的内容大致也是扫读的，基本没有太过细看，《乌合之众》这本书是具有时代背景的局限性的，在法国大革命的背景下，作者的对于群众进行了一系列的批判，包括群众弱化个人贡献，群众降低个人能力，以及群众的盲目性等等。同时作者带有女性的各种歧视也可以从书本当中看到。我不太明白这本书为什么在国内如此推崇，所以这篇读书笔记将记录我的个人看法。</p><a id="more"></a><h1 id="推荐程度"><a href="#推荐程度" class="headerlink" title="推荐程度"></a>推荐程度</h1><p>​    <strong>2星</strong>：由于作者存在一定的<strong>精英主义</strong>和<strong>种族歧视</strong>，个人并不推荐看这本书，看这本书只要抱着提高自我认知和在群体中保持清醒认知就算是从书中多少学到点有用的东西了。</p><p>​    另外我是实在不懂为什么这本书如此被推崇，看完感到非常失望。</p><p>​    </p><h1 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h1><p>​    下面根据零碎的读书笔记进行阅读：</p><pre><code>+ 群体在智力上总是低于个人+ 群体因环境比个人更差或者更好</code></pre><ul><li>群体的情感和道德观<ul><li>冲动暴躁并且易怒<ul><li>自我控制力差</li><li>s容易受到轻信和暗示</li></ul></li></ul></li><li>个人崇拜：一个人把自己一切的思想资源，一切自愿服从行为，同时发自肺腑的进妄想。<ul><li>概括：不顾一切奉献一个事业或者个人的才是一个虔诚的人。</li><li>教育不会使人更道德，也不会使人更幸福</li><li>作者认为生活更能培养优秀的人，而不是理论化的学校教育</li><li>只要是人聚集的地方，必然会有一个头领</li><li>领袖使用不断重复的断言传染给其他人</li><li>名望可以产生多么无耻的陈词滥调</li></ul></li></ul><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>这里需要说明的一点是<strong>人以群分，物以类聚</strong>，如果你是什么样的人，通常你就会待在什么样的群体当中。这点基本算是毋庸置疑的，同时由于个人在群体中受到了平均化，群体容易受到风向的导向而失去理智。这些例子在生活中多的数不胜数。</p><p>​    二战的纳粹正是利用了群众的希望和盲从无知，并且说明了一个群体的领导对于一个群体会造成多大的改变！但是在现代的各种精英团队之下，群众又迸发出无与伦比的力量。</p><p>​    关于个人崇拜的部分，中国历史上也有不少，由于怕被请去喝茶这里就不一一列举了，可以自行查找资料（可以看看拿破仑的事迹，在他的带领下，士兵对于拿破仑英雄的个人崇拜），贝多芬曾经也因为个人崇拜而十分后悔。</p><p>​    一个好的团队可能会有好的领导，也有可能是一个坏的领导，这并没有很好的定式，但是作者更加倾向贬低群体当中的领导。在一个群体当中一定要有清晰的认知和定位，同时不要<strong>同流合污</strong>。众人皆浊我独清，众人皆醉我独醒的状态是最好不过的。</p><p>​    最后讲领袖是如何利用断言和情报传播流言的，集团通过不断释放良好的一面，所以在一个群体当中保持时刻保持清醒是十分难得的一件事情，如果集团不管灌输一个理念，那么群众或多或少都会有人相信。</p><p>​    最后还是需要强调一句这本书并不是完全一无是处，看完可以基本了解到为什么产品很烂却依然有很多的关注，明明看起来完全不能火的东西，却有很多人追捧。这一切都是乌合之众的影响。</p><h1 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h1><p>​    这本书无时不刻不在说明一些我们都会认同的道理，但是我并不认为多数人都认为正确的事情就一定是合理的。</p><p>​    从书本当中可以看出作者并不是完全中立的角度去看待的问题，在字里行间存在着一些“嘲讽”的意味，部分论断甚至不具备科学依据的解释，</p><p>​    这本书只要记住让独立思考保持自己的清醒，同时不要被他人的意见轻易左右，一定要有自己的观点和看法，这样才不容易被利用。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​    乌合之众在生活之中无处不在，我们需要避开乌合之众，寻找优秀的群体，即跟对人，做对事。</p><p>​    最后，多多的书如果没有过多要求还是可以买来看看的，当然纸质是那种复印纸，但是价钱十分的便宜。但是这本书真的没有吹嘘的那么厉害。</p><p>​    最后借用豆瓣的话：完这本书还可以去看看《群体的智慧》，从另一个角度来解释群体性的特性，正好跟这本书互相补充</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      如何看待乌合之众
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://whitestore.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书" scheme="https://whitestore.top/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>《如何有效读一本书》读书笔记</title>
    <link href="https://whitestore.top/2021/03/28/readbookok/"/>
    <id>https://whitestore.top/2021/03/28/readbookok/</id>
    <published>2021-03-28T07:04:26.000Z</published>
    <updated>2021-03-28T07:05:30.713Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《如何有效读一本书》读书笔记"><a href="#《如何有效读一本书》读书笔记" class="headerlink" title="《如何有效读一本书》读书笔记"></a>《如何有效读一本书》读书笔记</h1><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20210326094736.png" alt=""></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    这段时间由于搬家和布置家具，基本没怎么看书，安顿好之后，又重新开启了读书计划，这次看的一本书讲的是读书方法相关的内容，个人从中还是有不少的成长的，并且书中作者的某些做法竟然自己也在做，这本书是一本比较有意思的书。需要注意的是作者是个日本人，有些章节的参考价值不大，所以只挑选了符合“国情”的一些内容作为笔记。</p><a id="more"></a><h1 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h1><p>​    这本书是一本实用方面的书，主要讲作者的阅读习惯，以及读书笔记的记录方法，从挑选图书到读书，最后从书中提取笔记并且产出自己的思想，通过各种举证像读者“安利”自己的读书和学习方式，同时利用循序渐进的方式，像读者介绍了如何从零开始爱上编写读书笔记。在作者的观念当中，有效读书的核心就是 <strong>读书日记</strong>。通过日记不仅可以节省重读的时间，并且每看一遍笔记都会有新的收获。</p><h1 id="推荐指数"><a href="#推荐指数" class="headerlink" title="推荐指数"></a>推荐指数</h1><p><strong>3星</strong>：如果你喜欢纸质书，那这本书很值得参考，但是如果平时喜欢手机看书，或者只喜欢电子书，这本书的意义和价值不大，作者是个日本人，所以很多习惯和国人不一样，看书的时候请理解一下。</p><p>另外，如果你像我一样喜欢买二手书，也是不是特别推荐看的。因为这本书推荐的方式基本都是要对原来的书一样“动手脚”</p><h1 id="内容摘要"><a href="#内容摘要" class="headerlink" title="内容摘要"></a>内容摘要</h1><p>​    这本书个人的笔记方式：</p><pre><code>- 边看边使用便利贴的方式进行比较，记录自己感兴趣的话语- 第二遍回顾自己的便利贴，结合贴上的页码，回忆内容- 写下这篇文章，归档自己学习的内容和读书感想。形成自己的读书笔记</code></pre><p>经过了上面的步骤之后，就有了下面的思维导图笔记，下面是思维导图的部分笔记，讲真思维导图还是蛮香的，能快速构建自己的知识笔记的网络，虽然我并不讨厌码字，但是思维导图更加促进思考。</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20210325230246.png" alt=""></p><p>思维导图连接：<span class="exturl" data-url="aHR0cHM6Ly9zaGFyZS5tdWJ1LmNvbS9kb2MvSm5vMVp2MDFFbA==" title="https://share.mubu.com/doc/Jno1Zv01El">思维导图<i class="fa fa-external-link"></i></span></p><blockquote><p> 无法访问的试试直接访问URL：<span class="exturl" data-url="aHR0cHM6Ly9zaGFyZS5tdWJ1LmNvbS9kb2MvSm5vMVp2MDFFbA==" title="https://share.mubu.com/doc/Jno1Zv01El">https://share.mubu.com/doc/Jno1Zv01El<i class="fa fa-external-link"></i></span></p></blockquote><p>下面的部分是根据这本书的各个章节说下个人的感想</p><h2 id="有效读书"><a href="#有效读书" class="headerlink" title="有效读书"></a>有效读书</h2><p>​    在这本书的最开头，使用“有效读书”的话题，通过各种例证说明一个读书笔记的重要性，同时对于读书来说，最重要的不是看什么书和看书的收获，最重要的是<strong>看书的目标和想要从书中学到多少有用的内容</strong>。这样才是最重要的，同时重读读书笔记也是很重要的一件事，好好写好一份读书笔记就更加重要了。</p><p>​    对于书本当中提到的读书的五个步骤，个人大致归纳为：<code>选 -&gt; 购 -&gt; 读 -&gt; 记 -&gt; 活</code>。从最开始的选出一本适合自己的好书到最后活用书中的知识，形成自己的理解。</p><p>​    值得注意的是，人的大脑是一块不定时格式化的磁盘，所以对于重要的事情，个人非常推荐买一个小本子带在身上，在上面记录重要和紧急的事情非常有用。同时不需要注意格式，类似随身携带的草稿纸，写满一本之后，找一个鞋盒收进去，塞到床底下，等哪天想起来翻开看看，肯定会对当时记笔记的自己唏嘘不已。</p><h2 id="购书清单"><a href="#购书清单" class="headerlink" title="购书清单"></a>购书清单</h2><p>​    个人的购书清单通常在<strong>别人的博客推荐</strong>上，或者通过豆瓣上高评价的作品，这样大概率都不会踩坑。这里也要说一句一本书的起名太重要了，很多好书其实本身是由于一个不太“好听”的名字而没有知名度。个人还倾向于按照封面去选书，一个好看封面的实体书会增加我阅读的兴趣。</p><p>​    购书清单这部分个人建议跳读，因为基本上喜欢读书的人都有自己的一套购书习惯，没有必要去照着作者的思路去完成，个人对这一部分保持中立的态度，购书完全看自己。</p><p>​    同时这一个章节也是跳读的，这部分的内容个人认为更加适合日本的生活习惯。日本现在还有保留阅读报纸习惯，而国内现在读书却越来越趋近于网络看书，所以购书清单个人保持中立的意见，书中提到的冲动买书个人经常做，不过个人现在通常都是买的二手书，低价买入然后再卖回去，循环利用，这样我的书架永远都有很多书但是永远都只有那么多书，这里还是要说一句二手书还是很香的存在。</p><p>​    近几年来有些声音是讨论纸质书的必要性，我认为还是有必要的，这种情景总是让我想起《三体》最后部分罗辑把人类文明刻在石头上才得以流传，这真的是一个文明的悲哀！</p><blockquote><p>这里有一个值得学习的点就是学习报纸的排版方式，虽然报纸上密密麻麻的写满了文字，但是基本上没有多少人会反感报纸的排版方式，报纸的排版是一个十分值得学习的学问，对于喜欢纸质笔记的人来说，学习报纸的排版方式算是比较推崇的。</p></blockquote><h2 id="火锅式读书法"><a href="#火锅式读书法" class="headerlink" title="火锅式读书法"></a>火锅式读书法</h2><p>​    书中的火锅式是一个生僻字，懒得记忆的我直接叫了火锅式读书法。</p><p>​    关于火锅记忆法，简单理解就是形成自己的标记模式，创建自己的标记习惯，比如作者习惯一本书读三遍并且给书折角并且对于段落进行标记。<strong>我不太喜欢这种方式</strong>，我虽然不是特别爱惜书的人，但是我拿到的书基本不会让他脏乱，如果书出现折痕，我也会比较心疼。折角对于我来说，并不能形成强烈的提醒作用。因为有时候会出现误折角，所以在我的个人观点来看，作者的读书方式对我来说<strong>参考意义不大</strong>。关于火锅式读书法的另一个特点就是重读，重读可以是段落，笔记，也可以是全文，根据当时的心情重读也有可能，我是比较懒得，对于一本书能一遍看懂就一遍看懂，看不懂也之后很长时间之后偶尔翻一翻，所以我喜欢 <strong>一遍读懂一本书</strong>。这种想法或许会受到很多人的反对，但是长久的读书习惯。让我不再想起读一遍已经读过的书。（当然技术书籍和专业书籍除外，这类书籍我会反复去看）</p><p>​    火锅式读书法对于读者来说能吸收多少完全看个人，这本书在前言部分也说了，作者是个日本人，必然有日本人的思维习惯和生活习惯。很多读书方法在中国其实是走不通的。</p><h2 id="广告部分"><a href="#广告部分" class="headerlink" title="广告部分"></a>广告部分</h2><p>​    这本书让我比较在意的部分最后一个点就是作者的广告部分，作者居然用了十多种的笔来做笔记，在我看来不是很能理解。所以对于这部分的感受，个人在思维导图列举的部分是个人<strong>可能会有意向</strong>购买的辅助工具，也算是吃到了安利。</p><ul><li>便携阅读架：个人有一个nice202d 的阅读架，实际体验非常棒，架在桌子上加一个台灯很有读书的氛围。当然也比较贵。同时比较沉，适合放家里。买一个便携阅读架是看书之后才有的想法，因为有时候拿出书本记笔记的时候，书会自己合上非常恼火，一个夹书的工具对我来说很有必要</li><li>玻璃镇纸：压书神器</li><li>票夹：让书摊开最简单的工具，对于书本的伤害也是最大的</li><li>钢笔：虽然我字丑，但是我比较喜欢钢笔的外观以及写字的感受。</li><li>便利贴：便利贴挺好的，不过淘宝买的便利贴老是自己掉，下次买国誉的试一试</li><li>三菱彩色铅笔：做笔记感觉不错，各种颜色很醒目。当然也比较贵</li></ul><blockquote><p>不得不说，文具这一块日本完全是霸主的地位，国内还需要好好努力。</p></blockquote><h1 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h1><p>​    这本书准确来说就是作者的经验之谈，作者在反复强调调用兴趣和简单记录来让自己坚持写读书笔记，并且一次次的“安利”读书笔记的妙用。我的有效读书手段是无时无刻把书摆到离自己最近的位置。让自己可以随时碰到，同时只要是休息时间就拿出来翻一翻，这样可以激起我的兴趣。书中关于重读这部分是个人需要改进的部分，因为我发现自己很少去回顾以前的内容，总是在需要的时候着急找，这样挺不好的，后续会制定个人的复习计划，”重读”自己以前的记录。</p><p>​    个人比较认同的部分是作者对于为什么要写读书笔记，讲到了<strong>人连昨天吃的饭都会忘记，不要指望人可以融入多少知识</strong>，写的非常真实，因为很多人甚至连刚刚想起的事情都会马上忘记。另外个人还比较认同作者的信息一元化的观念，我的观念也是信息一元化，个人不擅长整理，同时比较自由放荡（家里很乱就可以看出）。所以我的方式基本也是按照时间轴的顺序记录，这种记录方式对我的作用一方面是可以很快的查找，因为一个月一个月翻，总能翻到想要的内容。这种简单快速的方式，不仅让我只需要关注每一个月该干什么，同时可以关注到每一个月干了什么。比如这个月搬家找房子浪费了很多时间，产出少了，从月份记录中明显就可以看出。</p><p>​    最后说下我对有效读书的看法，所谓有效读书最基本的还是要调动兴趣，个人观念认为很多人其实不适合看书，更适合有人讲书中的内容给他听，至于为什么有的人读书想睡觉，其实这其中有一定的科学依据，以前翻资料的时候有过了解，但是后来忘了，总之就是对于由于大脑的思考释放的休息信号。这里其实简单想象一下为什么很多人喜欢看各种网文和小说，一方面生活的压力之下很难集中精神，上班拥挤的公交地铁上，网文正好既可以补充这段空档，所以很多人喜欢看网文，但是遇到需要大脑思考的内容，大脑会因为保护机制释放休息信号，从而造成催眠的效果。</p><p>​    总之，不管形式如何，有效读书的最终法则还是形成个人记录和感悟。如果想要知道我的读书观念和习惯，可以看看往期读书方法论的文章，希望对你有帮助：</p><blockquote><p>文章链接：</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuNTJwb2ppZS5jbi90aHJlYWQtMTM2MjgzNC0xLTEuaHRtbA==" title="https://www.52pojie.cn/thread-1362834-1-1.html">读书方法论（一）<i class="fa fa-external-link"></i></span></p></blockquote><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>​    我的读书笔记比较自由，没有什么条条框框和格式，只要是记录本身就会让我很开心，虽然质量可能不如人意，哈哈，但是真心建议每一位读者好好思考下你的工作和人生经历留下了多少回忆，我个人喜欢用照片去回忆，喜欢每天记录自己的生活去回忆，可以看到过去那个“傻傻”的自己，后续打算看看小王子和时间管理方面的书籍，不知不觉21年过去4分之一，时间过得太快了，搬家之后，要多多读书和充实自己，今天的读书笔记分享就到这了。</p><blockquote><p>另外，这次搬家搬了20多本书，下决心买了一块大的墨水屏幕，Ireader smart2，为了防止有人说我安利，我这里直接截个图：</p><p>（不要问为什么要花1800大洋去买一个“电子垃圾”，买Ipad它不香么这种话。我只想说：谁用谁知道）</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/lADPBFDk-NZ-GifNBQDNA8A_960_1280.jpg" alt=""></p></blockquote><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      如何正确的对待读书笔记，如何有效读书
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://whitestore.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://whitestore.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>一次大数据文件处理日记</title>
    <link href="https://whitestore.top/2021/03/28/bigdatacompile/"/>
    <id>https://whitestore.top/2021/03/28/bigdatacompile/</id>
    <published>2021-03-28T07:02:44.000Z</published>
    <updated>2021-03-28T07:04:00.796Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一次大数据文件处理日记"><a href="#一次大数据文件处理日记" class="headerlink" title="一次大数据文件处理日记"></a>一次大数据文件处理日记</h1><h1 id="文章推荐"><a href="#文章推荐" class="headerlink" title="文章推荐"></a>文章推荐</h1><p><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvX0dTcS1VWG5EaGdHNmswcUhxTS02QQ==" title="https://mp.weixin.qq.com/s/_GSq-UXnDhgG6k0qHqM-6A">https://mp.weixin.qq.com/s/_GSq-UXnDhgG6k0qHqM-6A<i class="fa fa-external-link"></i></span></p><h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>​    最近在做业务功能的时候，拿到一个非常”简单”的需求，把一个 <strong>30万行</strong>的数据文件按照特定的格式进行入库，文件格式和字段的内容都有对应的规定。这种需求其实还算比较常见，通常这一类需求不管系统配置多么强悍，都不可能无脑的读取插入。趁着这个需求搜集了一下几种常见的做法。下面就来介绍一下解决这种大数据文件的常用套路。</p><a id="more"></a><h1 id="文章目的："><a href="#文章目的：" class="headerlink" title="文章目的："></a>文章目的：</h1><ol><li>在JAVA中如何安全的将一份超大文件进行安全入库处理方式。</li><li>大文件读写可能产生的性能问题和瓶颈分析</li><li>关于分析大文件读写的常见套路<ol><li>使用单线程还是多线程</li><li>多线程的相关问题讨论</li></ol></li></ol><h1 id="文件内容分析"><a href="#文件内容分析" class="headerlink" title="文件内容分析"></a>文件内容分析</h1><p>​    由于实际的情况复杂多变，在做具体的编码之前，需要先梳理有可能存在的情况，下面简单列举系统有可能的存在的问题，和一些常见的注意事项：</p><ul><li>系统硬件水平，服务器是否会因为读写大量的数据文件占用大量资源<ul><li>内存问题：加载大数据最容易出的问题那就是爆内存，建议至少使用<strong>缓冲流</strong>进行读写</li><li>硬盘问题：读写的限制另一种体现就是硬盘的好坏，固态优于机械的读写.</li></ul></li><li>文件的读写方式，JAVA的IO比较复杂，这里简化为三种也就是常见的BIO、NIO、和AIO（具体代表含义请自行百度）。<ul><li>异步IO虽然看起来很美，但是需要考虑顺序入库的问题。</li><li>多线程异步读写比较考验机器性能，请谨慎使用。</li><li>顺序读写永远是硬盘最快捷的一种方式</li></ul></li><li>完成一次完整的操作时间估量，既然是大文件，就必然需要考虑整个操作的执行时间，一份几十万的数据跑一轮下来不管如何优化肯定需要不少的时间，所以操作的时间消耗需要考虑在可接受的范围</li><li>大数据文件读写的时间选择<ul><li>通常比较重和累的活都放大半夜去干</li><li>估量整个任务的执行时间消耗</li></ul></li></ul><p>这些分析只是一些最基本的要求，不同的业务场景会有更多的细节考量，文章不可能面面俱到，这些分析更多的是帮助个人提高警惕性，只有考虑到所有可能想到的细节，这样的大文件读写才可能是安全可靠的，同时可以保证突发情况可以及时的反应。</p><p>最后，这类开销比较大的操作，对于<strong>日志打印和记录</strong>的计算需要额外小心，最好在一次较大操作中记录操作成功失败记录数，同时在整个记录完成之后通过日志持久化整个操作的结果。</p><h1 id="大文件读写的常见套路"><a href="#大文件读写的常见套路" class="headerlink" title="大文件读写的常见套路"></a>大文件读写的常见套路</h1><p>​    其实这些套路网上多看看资料基本都可以有自己的一套方案，下面给出的建议可能不是最好的方式，有些可能在实际业务场景下走不通。（完全有可能）但是借着这些套路希望可以给读者一些启发，下面我们直接进入主题。</p><h2 id="分批入库"><a href="#分批入库" class="headerlink" title="分批入库"></a>分批入库</h2><p>​    分批入库是最容易想到的方式，也是最保险最稳妥的方式，这里包含了一个隐式的条件，就是数据都是<strong>增量不改动</strong>数据，大致意思就是不会改动的固定数据库数据。</p><p>​    现在我们来看下分批入库是如何处理的，分批的意思就是说每N条进行一次操作，防止数据库突然收到一个巨量的Insert请求导致锁表并且影响业务（弱一点的服务器直接满载），下面根据一段案例代码来说明做法：</p><blockquote><p>个人公司的电脑是一块SATA的固态硬盘，在开启批量操作之后，经常100%读写占用系统假死，所以如果要进行试验，建议先设置一个很小的值慢慢加量，否则你的电脑可能会卡的动不了。</p></blockquote><ul><li>首先需要编写一个批量插入的sql语句，网上对应案例的语句如下（如果是mybatis，需要使用<foreach>标签标记需要循环的对象内容）：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO table ( &quot;clo1&quot;, &quot;col2&quot;, &quot;col3&quot;, &quot;col4&quot;, &quot;col5&quot; )</span><br><span class="line">VALUES</span><br><span class="line">( 1, 10, NULL, &#39;2019-12-19 13:38:35&#39;, &#39;新年活动16张卡券&#39;),</span><br><span class="line">( 2, 11, NULL, &#39;2019-12-19 15:05:13&#39;, &#39;圣诞活动11张卡券&#39;),</span><br><span class="line">( 3, 12, NULL, &#39;2019-12-19 15:05:13&#39;, &#39;圣诞活动12张卡券&#39;),</span><br><span class="line">( 4, 13, NULL, &#39;2019-12-19 15:05:13&#39;, &#39;圣诞活动13张卡券&#39;);</span><br></pre></td></tr></table></figure><ul><li>下面是分批操作的JAVA代码，大致逻辑是打开一个文件，然后将一行数据转为一个对象，同时塞入到一个集合当中，当集合的内容超过限制的时候，进行一次入库的操作。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private void insert2DbByBatchList(Config config, String line) throws IOException &#123;</span><br><span class="line">        List&lt;VisaNewBinVo&gt; insertList &#x3D; new ArrayList&lt;&gt;(1000);</span><br><span class="line">        Map configValue &#x3D; readConfigValue();</span><br><span class="line">        while (StringUtils.isNotEmpty(line)) &#123;</span><br><span class="line">            Timestamp timestamp &#x3D; new Timestamp(System.currentTimeMillis());</span><br><span class="line">            VisaNewBin visaNewBin &#x3D; new VisaNewBin();</span><br><span class="line">            configValue.forEach((key, value) -&gt; &#123;</span><br><span class="line">                Map&lt;String, Object&gt; visaBinField &#x3D; (Map&lt;String, Object&gt;) value;</span><br><span class="line">                Integer endInex &#x3D; (Integer) visaBinField.get(&quot;endInex&quot;);</span><br><span class="line">                Integer startIndex &#x3D; (Integer) visaBinField.get(&quot;startIndex&quot;);</span><br><span class="line">                if (startIndex &lt; line.length() &amp;&amp; endInex &lt; line.length()) &#123;</span><br><span class="line">                    String substring &#x3D; line.substring(startIndex, endInex);</span><br><span class="line">                    FieldReflectionUtil.setFieldValueByFieldName(visaNewBin, key.toString(), substring);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            VisaNewBinVo visaNewBinVo &#x3D; new VisaNewBinVo();</span><br><span class="line">            BeanUtils.copyProperties(visaNewBin, visaNewBinVo);</span><br><span class="line">            visaNewBinVo.setBinId(UUID.randomUUID().toString());</span><br><span class="line">            visaNewBinVo.setBatchNo(getVisaNewCardBinDecAfterFileName(config));</span><br><span class="line">            visaNewBinVo.setCreateTime(timestamp);</span><br><span class="line">            insertList.add(visaNewBinVo);</span><br><span class="line">            &#x2F;&#x2F; 限制部分</span><br><span class="line">            if (rechLimitValue(insertList)) &#123;</span><br><span class="line">                int count &#x3D; visaNewBinMapper.batchInsertNewBins(insertList);</span><br><span class="line">                logger.info(&quot;当前批次数据为：&#123;&#125; 条，成功入库: &#123;&#125; 条数据&quot;, insertList.size(), count);</span><br><span class="line">                insertList.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#x2F;&#x2F; 存在纰漏，在最后一批不足的情况下，需要把剩下的数据入库</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean rechLimitValue(List insertList) &#123;</span><br><span class="line">        return insertList.size() % 500 &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>小贴士：很多人可能会认为可以用<code>Thread.sleep(1000)</code>类似的线程休眠的方式让计算机“冷静”一下，给数据库一些缓冲时间，但是其实从大文件读写的角度来看，<strong>没有太大的意义</strong>，因为我们的文件读写要么需要开一条“河流”，要么就像新的方式直接开一条“矿道”（底层IO）。我们一旦打开流或者开通矿道就是在占用系统资源。用这种休眠的方式无非就是拉长了整个工作的时间，其实并没有太大的实际意义。</p><p>​    当然这种形式并不是完全没有任何作用，有些情况下比如之前个人曾经做过关于一个百度的分析接口存在<strong>QPS个位数限制</strong>的情况下，这种时候最简单的方法就是使用线程休眠来限制调用。</p><p>​    当然这种形式在编码里面比价丑陋，可以使用JDK的工具类<code>TimeUtil</code>来更加优雅的细粒度控制线程休眠时间控制。</p></blockquote><blockquote><p>这里有个八股文的面试题<code>Thread.sleep(0)</code>的含义。</p></blockquote><h3 id="分批入库存在的问题"><a href="#分批入库存在的问题" class="headerlink" title="分批入库存在的问题"></a>分批入库存在的问题</h3><p>​    分批入库虽然是最无脑的一种方式，但是这里其实是存在限制的，一般会存在下面这些问题：</p><ul><li>数据库对于preSql的占位符限制：<strong>比如postgreSql 的限制为Short类型的最大值</strong>，即<strong>32747</strong>，超过这个值就会抛出如下的异常：</li></ul><blockquote><p><strong>Tried to send an out-of-range integer as a 2-byte value</strong></p><p>github上面有人提过这个issue，里面还有一些老外的吐槽，挺有意思的，文章连接：</p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BnamRiYy9wZ2pkYmMvaXNzdWVzLzEzMTE=" title="https://github.com/pgjdbc/pgjdbc/issues/1311">https://github.com/pgjdbc/pgjdbc/issues/1311<i class="fa fa-external-link"></i></span> <code>如何解决&quot;尝试将超范围整数发送为 2 个按次值&quot;的错误#1311</code></p><p><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjc2MzkyMzkvcG9zdGdyZXNxbC1lcnJvci1pbnNlcnQtaGFzLW1vcmUtdGFyZ2V0LWNvbHVtbnMtdGhhbi1leHByZXNzaW9ucy13aGVuLWl0LWRvZXNu77yI6ZyA6KaB6Ieq5aSH5bel5YW377yJ" title="https://stackoverflow.com/questions/27639239/postgresql-error-insert-has-more-target-columns-than-expressions-when-it-doesn（需要自备工具）">https://stackoverflow.com/questions/27639239/postgresql-error-insert-has-more-target-columns-than-expressions-when-it-doesn（需要自备工具）<i class="fa fa-external-link"></i></span> <code>PostgreSQL ERROR: INSERT has more target columns than expressions, when it doesn&#39;t</code></p><p>如果想要绕开这个问题，可以自己手写一个实现类进行替换。还有一种办法就是减少占位符，增加批次然后减少每次批次的插入数据量。</p></blockquote><ul><li>硬件水平的限制：这里主要说的是硬盘上的限制，一块差点的硬盘即使是分批操作也会卡死，需要注意分批之后不是高枕无忧了</li></ul><blockquote><p>硬件问题不能完全作为无法解决问题的借口。</p></blockquote><ul><li>程序中断的影响：分批的方式比较常见的一个问题是处理入库过程中 <strong>程序异常</strong>，<strong>断电</strong>，<strong>系统故障（蓝屏）</strong>。</li></ul><blockquote><p>一种推荐的解决方式是数据库设置唯一校验字段，每次入库之前检查是否存在标记，可以使用redis进行辅助。（布隆过滤器）</p></blockquote><h2 id="多线程读写"><a href="#多线程读写" class="headerlink" title="多线程读写"></a>多线程读写</h2><p>多线程的处理方式也比较容易理解，既然一个人读写吃力，那就把文件“劈”成很多份，比如文件的第1条到1万条为线程1，第10001条到20000条为线程2， 依次类推，这种方式需要提前计算数据行的总量，然后开启线程将数据行分配给多个线程，由于个人处理的时候，被禁止使用多线程的处理方式，这里的代码为一些案例作用。</p><p>（建议PC端查看）</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIwMTQ5Mzk1" title="https://www.zhihu.com/question/20149395">java读取大文件，采用多线程处理对提高效率可有帮助？<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dpdGh1Yl8zNzM4MjMxOS9hcnRpY2xlL2RldGFpbHMvMTA0NzIzNDIx" title="https://blog.csdn.net/github_37382319/article/details/104723421">使用多线程会加快文件读取速度吗？<i class="fa fa-external-link"></i></span></p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>​    通过这次的小需求整理了一下大数据问题的处理经验，也算是对个人的一点提升。比较关键的是掌握多线程写入文件，需要考虑的内容还不少。不过网上的资料并不是特别多，还需要花更多的时间去研究。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      如何对于一个巨型文件进行分批处理
    
    </summary>
    
    
      <category term="日常" scheme="https://whitestore.top/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="实用" scheme="https://whitestore.top/tags/%E5%AE%9E%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>如何实现update select 语句</title>
    <link href="https://whitestore.top/2021/03/28/updateselect/"/>
    <id>https://whitestore.top/2021/03/28/updateselect/</id>
    <published>2021-03-28T07:01:30.000Z</published>
    <updated>2021-03-28T07:02:22.974Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何实现update-select-语句"><a href="#如何实现update-select-语句" class="headerlink" title="如何实现update select 语句"></a>如何实现update select 语句</h1><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>​    有些时候我们会遇到如下情况，我们需要依赖一张表的查询结果来更新另一张表，比如我们存在一张主表和一张关联表，我们需要把关联表的部分字段数据同步到主表的里面。</p><p>​    这次的文章出现也是因为这样一个类似的需求，个人需要把一个<strong>30万行</strong>（后续会发文介绍常见的处理手段）的数据文件入库，同时需要将部分字段迁移到另一张表，两个表之间通过<strong>两个字段</strong>进行and匹配。下面画一下结构图：</p><p>​    <img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20210315133417.png" alt=""></p><p>​    处理方式也比较简单，直接使用sql就可以完成，这篇文章针对这个小需求，总结一下update select 的几种实现方式。</p><a id="more"></a><h1 id="文章目的："><a href="#文章目的：" class="headerlink" title="文章目的："></a>文章目的：</h1><ol><li>实现update select 的几种常见方法<ol><li>join</li><li>merge</li><li>子查询</li></ol></li><li>merge的踩坑和问题</li></ol><h1 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h1><p>​    为了更好的进行实际操作，这里构建两张简单的表来模拟场景。直接复制下面的db即可，由于不同数据库sql不同，这里使用的是<strong>postgreSql</strong> 数据库。</p><h2 id="旧表"><a href="#旧表" class="headerlink" title="旧表"></a>旧表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">"public"</span>.<span class="string">"olddb"</span> (</span><br><span class="line">  <span class="string">"id"</span> int4 <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">"relevance1"</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> <span class="string">"pg_catalog"</span>.<span class="string">"default"</span>,</span><br><span class="line">  <span class="string">"relevance2"</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> <span class="string">"pg_catalog"</span>.<span class="string">"default"</span>,</span><br><span class="line">  <span class="string">"new_field"</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> <span class="string">"pg_catalog"</span>.<span class="string">"default"</span>,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> <span class="string">"olddb_pkey"</span> PRIMARY <span class="keyword">KEY</span> (<span class="string">"id"</span>)</span><br><span class="line">)</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">"public"</span>.<span class="string">"olddb"</span> </span><br><span class="line">  OWNER <span class="keyword">TO</span> <span class="string">"postgres"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMENT</span> <span class="keyword">ON</span> <span class="keyword">COLUMN</span> <span class="string">"public"</span>.<span class="string">"olddb"</span>.<span class="string">"id"</span> <span class="keyword">IS</span> <span class="string">'主键'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMENT</span> <span class="keyword">ON</span> <span class="keyword">COLUMN</span> <span class="string">"public"</span>.<span class="string">"olddb"</span>.<span class="string">"relevance1"</span> <span class="keyword">IS</span> <span class="string">'关联字段1'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMENT</span> <span class="keyword">ON</span> <span class="keyword">COLUMN</span> <span class="string">"public"</span>.<span class="string">"olddb"</span>.<span class="string">"relevance2"</span> <span class="keyword">IS</span> <span class="string">'关联字段2'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMENT</span> <span class="keyword">ON</span> <span class="keyword">COLUMN</span> <span class="string">"public"</span>.<span class="string">"olddb"</span>.<span class="string">"new_field"</span> <span class="keyword">IS</span> <span class="string">'新字段，需要由关联表同步'</span>;</span><br></pre></td></tr></table></figure><p>表成功创建之后，在内部加入一些简单的数据：</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20210315134419.png" alt=""></p><h2 id="新表"><a href="#新表" class="headerlink" title="新表"></a>新表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">"public"</span>.<span class="string">"newdb"</span> (</span><br><span class="line">  <span class="string">"id"</span> int4 <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">"relevance1"</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> <span class="string">"pg_catalog"</span>.<span class="string">"default"</span>,</span><br><span class="line">  <span class="string">"relevance2"</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> <span class="string">"pg_catalog"</span>.<span class="string">"default"</span>,</span><br><span class="line">  <span class="string">"new_field"</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> <span class="string">"pg_catalog"</span>.<span class="string">"default"</span>,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> <span class="string">"newdb_pkey"</span> PRIMARY <span class="keyword">KEY</span> (<span class="string">"id"</span>)</span><br><span class="line">)</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">"public"</span>.<span class="string">"newdb"</span> </span><br><span class="line">  OWNER <span class="keyword">TO</span> <span class="string">"postgres"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMENT</span> <span class="keyword">ON</span> <span class="keyword">COLUMN</span> <span class="string">"public"</span>.<span class="string">"newdb"</span>.<span class="string">"id"</span> <span class="keyword">IS</span> <span class="string">'主键'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMENT</span> <span class="keyword">ON</span> <span class="keyword">COLUMN</span> <span class="string">"public"</span>.<span class="string">"newdb"</span>.<span class="string">"relevance1"</span> <span class="keyword">IS</span> <span class="string">'关联字段1'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMENT</span> <span class="keyword">ON</span> <span class="keyword">COLUMN</span> <span class="string">"public"</span>.<span class="string">"newdb"</span>.<span class="string">"relevance2"</span> <span class="keyword">IS</span> <span class="string">'关联字段2'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMENT</span> <span class="keyword">ON</span> <span class="keyword">COLUMN</span> <span class="string">"public"</span>.<span class="string">"newdb"</span>.<span class="string">"new_field"</span> <span class="keyword">IS</span> <span class="string">'新字段，需要同步到旧表'</span>;</span><br></pre></td></tr></table></figure><blockquote><p>提醒：注意数据库是<strong>postgresql</strong>，其他数据库可能存在字段等差别而无法成功 </p></blockquote><p>表成功创建之后，在内部加入一些简单的数据：</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20210315134505.png" alt=""></p><h1 id="实现方式汇总"><a href="#实现方式汇总" class="headerlink" title="实现方式汇总"></a>实现方式汇总</h1><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p>​    第一种的连接方式使用的是连接表的<code>join</code>方法，我们通过关联字段查出对应的关联记录，同时在关联之后将关联新字段的数据更新到旧表，这样就实现了每关联一条记录就更新一条记录数据：</p><p>​    实现方式也比较简单，只需要使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UPDATE olddb aa</span><br><span class="line">SET new_field &#x3D; bb.new_field</span><br><span class="line">FROM</span><br><span class="line"> newdb bb where aa.relevance1 &#x3D; bb.relevance1 </span><br><span class="line">AND aa.relevance2 &#x3D; bb.relevance2</span><br></pre></td></tr></table></figure><p>他的执行结果如下：</p><p><img src="https://gitee.com/lazyTimes/imageReposity/raw/master/img/20210315143721.png" alt=""></p><blockquote><p>下面的下方是错的，这时候sql会抛出一个错误。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> olddb <span class="keyword">ALIAS</span> </span><br><span class="line"><span class="keyword">SET</span> ( new_field ) = (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">( bb.new_field ) </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">olddb aa</span><br><span class="line"><span class="keyword">JOIN</span> newdb bb <span class="keyword">ON</span> aa.relevance2 = bb.relevance2 </span><br><span class="line"><span class="keyword">AND</span> aa.relevance1 = bb.relevance1 </span><br><span class="line">)</span><br></pre></td></tr></table></figure></blockquote><h2 id="Merge（未验证）"><a href="#Merge（未验证）" class="headerlink" title="Merge（未验证）"></a>Merge（未验证）</h2><p>第二种方式可能比较陌生，因为<code>merge</code>算是对于insert以及update的一个统合，粗略了解了一下发现能干不少事情，下面说下。</p><p>注意下面的方法在postgresql <strong>报错</strong>，原因是是我的postgresql<strong>版本太低</strong>，但是个人在升级过后还不能支持使用merge方法 ，所以这里保存了sql，可以改动后尝试到其它的数据库语言进行使用。</p><blockquote><p>ERROR:  syntax error at or near “MERGE” </p><p>很头疼，在stackflow也没用找到答案。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">merge</span> <span class="keyword">into</span> olddb <span class="keyword">as</span> olds</span><br><span class="line"><span class="keyword">using</span> newdb news <span class="keyword">on</span> olds.new_field = news.new_field</span><br><span class="line"><span class="keyword">when</span> <span class="keyword">matched</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">set</span> </span><br><span class="line">olds.new_field = news.new_field</span><br></pre></td></tr></table></figure><p>需要注意的是不同的数据库对于merge的特性是不一致的，建议查看当前安装数据库的版本以及文档进行确认比较稳妥。</p><p>下面是 <strong>postgresql</strong> 的<code>merge</code>使用案例，注意一般建议版本为<code>11</code>以上再使用<code>merge</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MERGE INTO wines </span><br><span class="line">USING (VALUES(&#39;Chateau Lafite 2003&#39;, &#39;24&#39;)) v</span><br><span class="line">ON v.column1 &#x3D; w.winename</span><br><span class="line">WHEN NOT MATCHED </span><br><span class="line">  INSERT VALUES(v.column1, v.column2)</span><br><span class="line">WHEN MATCHED</span><br><span class="line">  UPDATE SET stock &#x3D; stock + v.column2;</span><br></pre></td></tr></table></figure><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>​    子查询是最简单也是最容易想到的一种方式，不过子查询有一个明显的缺点就是数据量较大的情况下通常性能都比较差， 这种操作通常适合数据量比较小的情况，下面是对应的案例语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> olddb </span><br><span class="line"><span class="keyword">SET</span> new_field = ( <span class="keyword">SELECT</span> newdb.new_field <span class="keyword">FROM</span> newdb <span class="keyword">WHERE</span> olddb.relevance1 = newdb.relevance1 <span class="keyword">AND</span> olddb.relevance2 = newdb.relevance2 )</span><br></pre></td></tr></table></figure><p>下面是子查询需要注意的点：</p><ul><li>如果子查询无法找到任何匹配的行，则更新后的值将被更改为NULL</li><li>如果子查询找到多个匹配的行，update查询将返回一个错误。</li></ul><blockquote><p>错误的信息如下：</p><p><code>&gt; ERROR:  more than one row returned by a subquery used as an expression</code></p><p>(&gt;错误:作为表达式使用的子查询返回多行)</p></blockquote><ul><li>多数情况下子查询的性能较差，尽量避免使用</li></ul><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>​    由于merge个人使用经验不足，花了较多时间依然没有解决，所以文章标题进行了标记，后续使用了其他的方式避开问题。</p><p>​    update select的实现实际情况复杂多变，这里只列举了最简单的使用情况。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      一个数据库的使用经验技巧
    
    </summary>
    
    
      <category term="数据库" scheme="https://whitestore.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="实用" scheme="https://whitestore.top/tags/%E5%AE%9E%E7%94%A8/"/>
    
  </entry>
  
</feed>
